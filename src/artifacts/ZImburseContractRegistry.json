{"noir_version":"0.34.0+02fea6abe8637b9fb8f9535d1709b367d5e1da5c","name":"ZImburseContractRegistry","functions":[{"name":"register_escrow","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"escrow_contract","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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qK95//toW08C1SdVxS4WLuYfUxs1cDdq4H7UwGXUwMOogcdRA0+jBp77Bf6y+9J198703f3na0Wpn/Aqyy94dabq3KiB+1EDl1EDD6MGHkcNPI0aeO4X+Nd7z8Y12703fXdv++7e9d2977t76bv70Hf3se/uU9fdy+cPzGkhQW72wH/swPXu4PN4ras/CW9dch87yL1HUDp3EFowyLfXGBZvYrx14Ht3IL07CL07iL07SA06SLf3CUr+2EHu3UHp3EE0vTuwvTtwvTvwvTtocCbfvgY9LbvYjx2E3h3E3h2k3h3k3h2Uzh0k07uDBmeyzXVVxZaPE6/kenfQe16UYu8OUu8OcucOsundge3dgevdge/dgXTtYPrDvWy6veSZ4nyNSXlHxYi9fVfI/vUsa7O94Kk/bDdm2H7MsGXMsMOYYccxw05jhp17hf313gJno50703Pnn64L9ZtzEj+WZOd67tz33Ln03Pmnr1f1UyNSVkBjz52nnjv/7Bka6sc4wuJzvu7BslKjnXvTc+e2584/eygGP/vo4Fc7jz13/lmgsX42N0bzYedieu5cOqZFPg20FtEQw8edx547Tz13nnvuvHTceTA9d2577ty123n6+FBW8D13/ukzNNQzNK92/ukzVNL9nceeO089d/7ZMzTaecYV7WrNrHTceTQ9d2577vyzZ2g09c1G+30rTK12Lj13HnruPPbceeq589xz56Xdzt3H4zyZnjv/9BlaP9YX/Wrnn66hRe7v3PfcufTc+afP0Afz8xR77jz13HnuufOeN1y55w1Xtj137rrtfPrDv2x45y275Rd2Y3zcycsPHM0bi/sopO684nSsg/pFait5Z2NV70OhjTJeYpTpEqPMlxhlucIonbnEKO0lRumUjPLr3XflzolFFMXy5Gqv6vU3tFGmS4wyX2KU5Qqj9OYSo7SXGKVTMsqvd9/QPCcWURSLlmr/9e6LoufEoqVyfr33UxknxaKlCn2997DJSbFouaJ/vfvCb7dYdl7ejaqiefLx+/jVi+A05SZ4VdE8/bj5gZeHz4omq4qmaIomGlXR2GdH8wNvR58VjVcVjaiKJqiKJqqKJqmK5tnX4h95sfykaJJRFY1VFY1TFY1XFY2oiubZ1+LHny2IqqJRdT+VjaporKpovKpoRFU0QVU0UVU0SU800x/ysun20xLO1mf1nM23RwJtsvcfPthr5H+kkfxIo/AjjeKPNEo/0ij/SKPyA422lwCnLWsj5/27RuuDKJT5ze3ls6Hb29oS6iOeZXnAlQe/Bn5eOE5XOF5XOKIrnKArnKgrnKQrnKwrnKIqHNF1VRZdV2XRdVUWXVdl0XVVFl1XZdF1VRZdV+Xw5BP94W/KBqcpmCcfNw9/Ny0kTcFkTcEURcHErlX86731zpYduN4dNKidscwbJxNWHUjvDkLvDhpceVL9Fk8q+yXC3EqEDR9LREy6wsm6winPDsfX9YIiq3qejK5wrK5w3LPDWUy+4urYSV5XOKIrnKArnHhiOOuJe0q6wsm6wmlwVc52numVkH9426/3lk3PCsZqCsZpCsZrCkY0BRM0BRM1BZM0BZM1BaPpClw0XYGLpitw0XQFLpquwEXTFbhougIXTVfgoukKXDRdga158oXmoU63xqmK5skn1ENtbE1UFU1SFU1WFU3Xac1LD9Z078F27yFpOtfts48ge/sqq19HUzRF44yqaKyqaJyqaPyzr4OlRiPraERVNEFVNFFVNElVNFlVNEVTNN5omul4qyoapyoaryoaURWNqjsrr+rOyqu6s/Kq7qx80RSNqLoWi6prsai6Fouqa7GouhaLqmuxPPm50cdWQJ794OjDu7tgVEVjVUXjVEXz5Jc/Ht8zBFEVTVAVTVQVTVIVTVYVTdEUTXz2tfhh1YxWVTROVTReVTSiKpqgKhpNb1PZqOl1Khs1vU9lo6YXqmxSdS1Oeq7F01/hZcvtXw+Lsf66alnetL0hPt4kHW+Sjzcph5tsr18+aDL9FV+23F5qFD83lOwWDdNrX+54E3+8iRxvEo43icebpONN8vEm5XCT7XWTEOa7uBDXTezxJu54E3+8ySb9EKvJSHHVJBxvEo83ScebbNIPpZ6bxqyalMNNtk3t4yb2eBO31ySvmvjjTeR4k+3rf307JsawahKPN0nHm+TjTbav/6kWwVQ+Ntn2Zo+b2ONN3PEmm/Rj/fHgZPyqiRxvEo43icebpJ0m1q6a5ONNyuEmd37ivn4OL8XV+XLnh+sfNnHHm/jjTTbpp/pzQWld+O78IPzDJvF4k3S8yfYPPpe5WGSzKhZ3fmj9UZM7P5/+sIk93sTtNLGyauKPN5HjTTbp5zhflHJcXZS232F93CQdb5KPN9mkn9N87ue8Gv72W5WPm9jjTdzxJpv0c5nP/WJWw99+2+9xk3C8STzeJO00sWnVJB9vUg432X6jq9RvKZeyqmLb7109buKON/EHm0x/pZcttyVQrGZhOcWI8bVdftnyzlw+1Tnj8iYjyoO5/P0m01/lta/tj9Wa+jUTa91yeOX+bcBeo/IDje78YtWjRn/99Poz9v++ZzjqfWdetowvLac//+/P//rl57//+s8/piYv//V/f/vHn7/8/tvbn3/+v//59l+mjf8/","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_nullifier_membership_witness","get_contract_instance_internal","get_public_keys_and_partial_address","unsafe_rand","notify_created_note","pack_arguments","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient"]},{"name":"get_managed_escrows","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"page_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"array","length":10,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"kind":"boolean"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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1K3c1H354pJt5XNTt3JTt3JTt3JTt3JTV7mpq9zUVW7qKjd1X75sY1v53NRVbuoqN3WVm7rKTV3jpq5xU9e4qWvc1DVu6ho3dY2busZNXeOmrnFT17mp69zUdW7qOjd1X74Yalv53NR1buo6N3Wdm7rOTd3GTV3ubqrK3U1VubupKnc3VeXupqrc3VSVu5uqcndTVe5uqsrdTVW5u6kqdzdV5e6mqtzdVJW7m6pyd1NV7m6qyt1NVbm7qZS7m0q5u6mUu5tKubupNFFTV7m7qZS7m0q5u6mUu5tKubuplLubSrm7qZS7m0q5u6mUu5tKubuplLubSrm7qZS7m0q5u6mUu5tKubuplLubSrm7qZS7m0q5u6mUu5tKubuplLubSsG6qR4kgfVNHSRh0fEgCYt4B0lYFDtIwiLTQRIWbQ6SsAhykIRFhQdJuzTyWD9LanYhaYfHW8tZktZ+IUnxJP3w43045VOn2tSp6xTuJ3Jb7/ni1D+UVYxOydSpPHWqTJ2qU6d06pRNnfKpU23q1NSzYVPPhk09Gzb1bNjUs2FTz4ZNPRs29WzY1LNhU8+GTT0bPvVs+NSz4VPPhk89Gz71bPjUs+FTz4ZPPRs+9Wz41LNxfUHCUzme8iWTXJ66+nfoOR3f59yz+OUpG54qV+7lM6eu/wCwJ6unubxfnipTp64+hy5yTCkupQ0jkPk5Ap3nefyq/frPRG56B3v2O/iz36E9+x36M9/Brv8I3aZ3kGe/Q372O5Rnv0N99jvos9/Bnv0O/ux3aM9+h+uf06mf+CJywReTNHVKpk7lqVNl6lSdOqVTp2zqlE+dalOnpp6NPPVs5KmPcp76KOepj3Ke+ijv8Q0TTen8D0RyfvX+JKnDSdrjmyAjSYInKeNJKniSKp4kxZNkeJIcTxKeexc896547l3x3Lviufcu373SryTZpSTDk+R4khqepA4naY96+5EkwZOU8SQVPEkVTxKeeyueeyueeyueeyueexueexueexueexueexueexueexueexueexueexueezueezueezueezueezueezueezueezueezueezueezc892547t3w3LvhuXfDc++G594Nz70bnns3PPdueO7d8dy747l3x3PvjufeHc+9O557dzz37nju3fHcu8O5tyc49/YE596e4NzbE5x7e4Jzb09w7u0Jzr09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","brillig_names":["get_managed_escrows"]},{"name":"check_and_register_participant","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"participant","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"participant_name","type":{"kind":"string","length":60},"visibility":"private"},{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"escrow","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{"1756802668388977958":{"error_kind":"fmtstring","length":17,"item_types":[]}}},"bytecode":"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","debug_symbols":"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rcXXqrX4WrUWX6vW4mvVWnytWouvVWvxtWprfK3aGl+rtsbXqq3xtWrrrcUvscYv0eOX2OKX2OOXiD/d8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3yt2hpfq7bG16qt8bVqa3ytWo+vVevxtWo9vlatx9eq9VuLX2KNX6LHL7HFL7HHLxF/uuNr1Xp8rVqPr1Xr8bVqPb5WrcfXqvX4WrUeX6vW42vVenytWo+vVevxtWo9vlatx9eq9fhatR5fq9bja9V6fK1aj69V6/G1aj2+Vq3H16r1+Fq1Hl+r1uNr1Xp8rVqPr1Xr8bVqPb5WrcfXqvX4WrUeX6vW42vVenytWo+vVevxtWo9vlatx9eq9fhatR5fq9bja9V6fK1aj69V6/G1aj2+Vq3H16r1+Fq1Hl+r1uNr1Xp8rVqPr1Xr8bVqPb5WrcfXqvX4WrUeX6vW42vVenytWo+vVevxtWo9vlatx9eq9fhatR5fq9bja9V6fK1aj69V6/G1aj2+Vq3H16r1+Fq1Hl+r1uNr1Xp8rVqPr1Xr8bVqPb5WrcfXqvX4WrUeX6vW42vVenytWo+vVevxtWo9vlatx9eq9fhatR5fq9bja9V6fK3aFl+rtsXXqm3xtWpbfK3admvxS6zxS/T4Jbb4Jfb4JeJPd3yt2hZfq7bF16pt8bVqW3yt2hZfq7bF16pt8bVqW3yt2hZfq7bF16pt8bVqW3yt2hZfq7bF16pt8bVqW3yt2hZfq7bF16pt8bVqW3yt2hZfq7bF16pt8bVqW3yt2hZfq7bF16pt8bVqW3yt2hZf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m+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Jr1ab4WrUpvlZtiq9Vm+Nr1eb4WrU5vlZtjq9Vm28tfok1fokev8QWv8Qev0T86Y6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZvja9Xm+Fq1Ob5WbY6vVZt/v1btx8fm5z62PPex9tzH1uc+1p/72Pbcx/bnPnY89TFVH7VvPz/Wbrf2tTtK1UeducQcv8QSv0SLX2KNX6LHL7HFL7HHL3GEL7HFn+4t/nRv8ad7iz/dW/zp3uJP9xZ/urffPt0/PrY/97HjqY/tt+c+Nj33sfm5jy3Pfaw997H1uY+Z+9Zu8/L+sdn62PHUx+x6jTbN+9vHpr4aH1ue+1h77mPrcx8TSJb3j91a//Sxxf6nev9j03Mfm5/72PLcx9pzH1uf+1h/7mPbcx/bn/vYc3fJ9NxdMj13l0zP3SXTc3fJ9NxdMokN2Pv7x45mfOx46mPz7bmPTc99bH7uY8tzH2vPfWx97mP9uY9tz33subtkfu4uWZ67S5bn7pLlubtkee4uWZ67S5bn7pLlubtkee4uWZ67S5bn7pL23F3SnrtL2nN3SXvuLmnP3SXtubukPXeXtOfukvbcXdKeu0vW5+6S9bm7ZH3uLlmfu0vW5+6S9bm7ZH3uLlmfu0vW5+6S9bm7pD93l/Tn7pL+3F3Sn7tL+nN3SX/uLunP3SX9ubukP3eX9Ofuku25u2R77i7ZnrtLtufuku25u2R77i7ZnrtLtufuku25u2R77i7Zn7tL9ufukv25u2R/7i7Zn7tL9ufukv25u2R/7i7Zn7tL9ufukuO5u+R47i45nrtLjufukuO5u+R47i45nrtLjufukuO5u+R46i5pt9tzH5ue+9j83MeW5z7WnvvY+tzH+nMf25772P7cx567S6bn7pLpubtkeu4umZ67S6bn7pLpubtkeu4umZ67S57Lvbbncq/tudxrey732p7Lvbbncq/Nz71O0/Q3H/v8L7r9mI+ff92PNr//9fZziTV+iR6/hLhTt+md775+cYn9hCX25X2Jfe2fljjCl1A56DOXmOKXmOOXWOKXaPFLrPFL9PgltvglTjndx+39ATJ9eoAsR/gS7Ra/xBS/xBy/xBK/RItfYo1foscvscUvEX+6W/zpXuNP9xp/utf4073Gn+41/nSv8ad7jT/da/zpXuNP9xp/unv86e7xp7vHn+4ef7p7/Onu8ae7x5/uHn+6e/zp7vGne4s/3Vv86d7iT/cWf7q3+NO9xZ/uLf50b/Gne4s/3Vv86d7jT/cef7r3+NO9x5/uPf507/Gne48/3Xv86d7jT/cef7qP+NN9xJ/uI/50H/Gn+4g/3Uf86T7iT/cRf7qP+NN9hJ/u9XaLX2KKX2KOX2KJX6LFL7HGL9Hjl9jil9jjl4g/3VP86Z7iT/cUf7qn+NM9xZ/uKf50T/Gne4o/3VP86Z7iT/ccf7rn+NM9x5/uOf50z/Gne44/3XP86Z7jT/ccf7rn+NO9xJ/uJf50L/Gne4k/3Uv86V7iT/cSf7qX+NMdX6u2xteqrfG1amt8rdoaX6u2xteqrfG1amt8rdoaX6u2xteqrfG1amt8rdoaX6u2xteqrfG1amt8rdoaX6u2xteqrfG1amt8rdoaX6u2xteqrfG1amt8rdoaX6u2xteqrfG1ausptWoPu6vWU2rVnCW2+CX2+CWO8CVOqVVzlpjil5jjl1jil7BP94Nxo//0W3/9Y5H164s87q9aRbXaqUts8Uvs8Usc4UuIarVTl5jOWOLhS2mf45dY4pdo8Uus8Uv0+CW2+CX2+CWO8CWOW/wS8af7iD/dR/zpPuJP93HG6X6sQY4ev8QWv8Qev8QRvUS/3eKXmOKXmOOXWOKXeMoKoN/6cx/bnvvYb9/2f73/V//jb+1/yppux9vclmmal18f3Y4/VrT/ccr70PHEh+x/QHr4oft/bX/8rV2a0t/dMPZt//XB/oPk7fc/Mv3+R+bf/8jy+x9pv/+R9fc/0n//I9vvf8S8347b/PMjxzz9zUc+n/Ll3fFm2X/dL/PU//z6I/Tr7RKH875+iv36Ofbrl9ivb7/39X98ZP39j/Tf/4h5Co717RQc2+zEPW9vfzsfn+PeY7/+CP16+6n/O1//4abY2t98/ee/PY43ATDdptvfb5RdX/BN1zJf6FqWkdcyt1+OZdun26Vd51LW61xKv86lbNe5lP06l3Jc5lLWoQ/ch8/+dbrOpczXuZQzn7afZdLaYr9+jf36Hvv1W+zX77Ffbz9l9Lv9d4WAXSdy5gJT9ALzlxd4+HS1C0RO/P4W/P1r8Pf34O/fgr9/D/7+rx/hhy+X7Rb8/VPk9//X/T//v//8v/7ln//7v/7P/7h/5I//6//7b//jP//l3//t53/+5//v//nxf7n/8f8f","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_notes_internal","get_collapse_hints","pack_arguments","call_private_function_internal","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"contract_class_id","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"get_participants","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"escrow","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"participant","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"page_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"array","length":10,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"kind":"array","length":10,"type":{"kind":"array","length":60,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"kind":"boolean"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"5Z3hbmPHsYTfZX/7x5np7ukev8rFRWAnTrCAsQ5s5wIXht89FCmScnTEybaHYpXmT7Abn9GpWtXpalLSp98+/e2H7//1j798/vL3n3759O3//Pbpx5/++t2vn3/6cvjbb79/8+n7nz//+OPnf/zl5f/9aXv6nyLleOCXf3735envv/z63c+/fvq2eNVvPv3w5W9PfxQ9fIi/f/7xh0/fipTfv3l1tXd5vjhKuVxbyrZzrVV7vtZsu17b5Pf//eagpv55NaHni6O1gRqV/nyttnitRiao6eX54r7ZQE3bzv82rbbXavTPq+n17LdrHamJ7fla33Y+U7anpm+XQ728yMKTmuOpljrlqVOROtUzp3RLnSqpUzV1SlKndjPXy+Wx6U95eHXKUqf2s1Hi/FD0usUw35enzV9MItnLd7Gz9dJfPPtd9j6uxXnE9fbyyem6e/Xlkdy268W1n3z6Ij5jEZ99DZ+2LeKzLOKzLuJTFvGpi/i0RXwusg/ZIvuQLbIP2SL7UJuwD5VN2/kWZZOB0y5xefVuo39Bqxej/cXHbSfthVh7JdYuxNqVWLsRa9/fA2q93KBqG9xBS/PzG50lrlf78Q4+ngbVh3dQud6h/MHFjuPQs57DH6//8v30VpBXNEGCJkjRBBmaoIYmyNEEBZqgDiYoNjRBaJM60CZ1oE3qQJvUgTapA21SB9qkjvef1F3j8tpXX3xlsO997Op6fg1++GP5j/UyOrP6vlGrL9TqK7V6oVav1OqNWn2jVu/U6qm7tjN3bd2Yu7ZuzF1bN+aurRtz19aNuWvrxty1dWPu2roxd+3hay7U6qm7tlB3baHu2kLdtYW6awt11xbqri3UXVuou7ZQd22h7tpK3bWVumsrdddW6q6t1F1bqbu2Undtpe7aSt21lbprhbprhbprhbprhbprhbprhbprhbprhbprhbprhbprlbprlbprlbprlbprlbprlbprlbprlbprlbprlbprjbprjbprjbprjbpr/wusCbJ66q416q416q416q416q5t1F3bqLu2UXdto+7a/wLxgayeumsbddc26q5t1F3bqLvWqbvWqbvWqbvWqbv2AQSfmeqpu9apu9apu9apu9apuzaouzaouzaouzaou/YBDKaZ6qm7Nqi7Nqi7lpobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRQs2NEmpulFBzo4SaGyUbc9cKNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cih5kYJNTdKqLlRQs2NEmpulFBzo4SaGyXU3Cil5kYpNTdKqblRSs2N0o25a5WaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRSs2NUmpulFJzo5SaG6XU3Cil5kYpNTdKqblRis6NEtHyfLV4adeP3XTP6+Zn3fXwUPzh6qNb8G6e7Ba8yye7Be/+uW7RuVeT3YLvFpPdgu8ik92C7y6T3epSbsF3o8lul9ql0Dlik90utUuhc8rmukXnmk12u9Quhc5Nm+x2qV0Kncs22e1SuxQ6922y26V2KXSu3GS3S+1S6Ny6yW6X2qXQuXiT3S61S6Fz9ya7XWqXQuf6TXa71C6Fzg2c7HalXcrQuYST3a60Sxk693Cy25V2Kdt0Kbcr7VKGzm2c7HalXcrQuZCT3S61S6FzJye7XWqXQudaTna71C6Fzs2c7HapXQqdyznZ7VK7FDr3c7LbpXYpdK7oZLdL7VLo3NLJbpfapdC5qJPdLrVLoXNXJ7tdapdC57pOdrvULoXOjZ3sdqldCp1LO9ntUrsUOvd2stuldil0ru5kt0vtUujc3slul9ql0LnAk90utUuhc4cnu11ql0LnGk92u9Quhc5Nnux2qV0Kncs82e1SuxQ693my26V2KXSu9GS3S+1S6NzqyW6X2qXQudiT3S61S6Fztye7XWqXQud6T3a71C6Fzg2f7HapXQqdSz7Z7VK71FLcc1uKe25Lcc9tKe65LcU9t6W457YU99yW4p7bUtxzW4p7bktxz20p7rktxT23pbjnthT33JbinttS3HNbintuS3HPbSnuuS3FPbeluOe2FPfcluKe21Lcc1uKe25Lcc9tKe65LcU9t6W457YU99yW4p7bUtxzW4p73pbinreluOdtKe55W4p73jZdyu1Ku1RbinveluKet6W4520p7nlbinveluKet6W4520p7nlbinveluKet6W4520p7nlbinveluKeN2bu+VE/8XZ01E+87xz1o28wLnHRr/5av5LrR98yRvrR94aX+k1f60ffBEb60bt9pB+9rWO76I/yOv/wrOyRfvT+HelH79+RfvT5H9Iu+nf2T3RyoB6+AnT+2Idh+Vo/VH8dFUE10lERVMccFb17axxkiF4l2SB2tbXLy7YWdrnYj/LfH2Q3V37hll+55Qu3fOWWb9zyG7d855Yf3PK5W7dxt27jbt3G3bqNu3XfHxs2Vz536zbu1m3crdu4W7dxt65zt65zt65zt65zt+77A6bmyuduXeduXeduXeduXedu3eBu3eBu3eBu3eBu3fdHEc2Vz926wd26wd26wd26wd26nbt1O3frdu7W7dyt+/7QmrnyuVu3c7du527dzt26nbp1faNuXd+oW9c36tb1jbp1faNuXd+oW9c36tb1jbp1faNuXd+4W7dwt27hbt3C3bqFu3XfH4QxVz536xbu1i3crVu4W7dwt27lbt3K3bqVu3Urd+u+P+phrnzu1q3crVu5W7dyt27lbl3hbl3hbl3hbl3hbl3hbl3hbl3hbl3hbl3hbl3hbl3lbl3lbl3lbl3lbl3lbl3lbl3lbl3lbl3lbl1uNpVzs6mcm03l3Gwq52ZTOTebyrnZVM7NpnJuNpVzs6mcm03l3Gwq52ZTOTebyrnZVM7NpnJuNpVzs6mcm03l3Gwq52ZTOTebyrnZVM7NpnJuNpVzs6mcm03l3Gwq52ZTOTebyrnZVM7NpnJuNpVzs6mcm03l3Gwq52ZTOTebyrnZVM7NpnJuNpVzs6mcm03l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","brillig_names":["get_participants"]},{"name":"register_participant","is_unconstrained":false,"custom_attributes":["private","interal"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"participant","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"participant_name","type":{"kind":"string","length":60},"visibility":"private"},{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"escrow","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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CGlHvR24R9pRbwdOk3ZU2zHjSmlHvR24UtpRbweulHbU24ErpR31dgTtoB3VduBKaUe9HbhS2lFvB66UdtTbgSulHfV24EppR7UdC66UdtTbgSulHfV24EppR70duFLaUW9H0A7aUW0HrpR21NuBK6Ud9XbgSmlHvR24UtpRbweulHZU27HiSmlHvR24UtpRbweulHbU24ErpR31dgTtoB3VduBKaUe9HbhS2lFvB66UdtTbgSulHfV24EppR7UdG66UdtTbgSulHfV24EppR70duFLaUW9H0A7aUW0HrpR21NuBK6Ud9XbgSmlHvR24UtpRbweulHZU27HjSmlHvR24UtpRbweulHbU24ErpR31dgTtoB3VduBKaUe9HbhS2lFvB66UdtTbgSulHfV24EppR60d24ArpR31duBKaUe9HbhS2lFvB66UdtTbEbSDdlTbgSulHfV24EppR70duFLaUW8HrpR21NuBK6Ud1XaMuFLaUW8HrpR21NuBK6Ud9XbgSmlHvR1BO2hHtR24UtpRbweulHbU24ErpR31duBKaUe9HbhS2lFtx4QrpR31duBKaUe9HbhS2lFvB66UdtTbEbSDdlTbgSulHfV24EppR70duFLaUW8HrpR21NuBK6Ud1XYUXCntqLcDV0o76u3AldKOejtwpbSj3o6gHbSj2g5cKe2otwNXSjvq7cCV0o56O3CltKPeDlwp7ai2I3CltKPeDlwp7ai3A1dKO+rtwJXSjno7gnbQjmo7cKW0o94OXCntqLcDV0o76u3AldKOejtwpX7tKPPZjm35hHxGgNohL+tx8ZvBjK8vLsN6vLcybB9febrKIcb5eHcxruXx4vcy4UspU7MyoVcpU7MyYWMpU7MyBWWiTK3KhOulTM3KhBqmTM3KhEmmTM3KhHimTM3KhKemTK3KtGDAKVOzMmHAKVOzMmHAKVOzMmHAKVOzMgVlokytyoQBp0zNyoQBp0zNyoQBp0zNyoQBp0zNyoQBp0ytyrRiwClTszJhwClTszJhwClTszJhwClTszIFZaJMrcqEAadMzcqEAadMzcqEAadMzcqEAadMzcqEAadMrcq0YcApU7MyYcApU7MyYcApU7MyYcApU7MyBWWiTK3KhAGnTM3KhAGnTM3KhAGnTM3KhAGnTM3KhAGnTK3KtGPAKVOzMmHAKVOzMmHAKVOz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","brillig_names":["get_public_keys_and_partial_address","unsafe_rand","decompose_hint","notify_created_note","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log","notify_created_note","build_msg_block_iter","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"set_contract_registered","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"escrow_contract","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/8VZz4vbRhQeryRbsldZ9xe00MNAD+0p2EkKDbRlQ9JAKGygOfTSErTW7EZgS0EeJ9nS0lt7bqGHUui1tH9lZ9h5609vx06ylsiA940033zvx7w3Gml7Yt16TkbsWngwh05OdmvTFrkmDSPDLU5QG3ow16B/4ORRpWVRFrrI5sUPKkf4O9D/0sn7q3Kmi6qUS6Ufz6pS19lMP67VabHUqla5nGWlrMr5mTxWpj+fm1tFaYZK0z9D9o+h/7mTj3RVZ6dKLufGqokszV8zrXqu8usSx5ZysVpqudRZreVJXS3k9Dpy34X+R8T9JDP2PVgsVjo7nitDXKssP9vk/HfQ/8DJO3Wd2Qm5eiGrlZbViTyuVmW+xIk59D90MtNaLZ5qqSuZ5bl8Xugnsnqm6hPjG87VV1X64w5Kf7mq0t9eU+lFLv7nZGJ+e65PeX3orie7tWkCxrXK/dmtW4lo1mDbdkfdcE8GhuNufM5F9pOu1PwC1ydM7H622c3gXiwabd/8xrTwzxYPn86qXN3J81otG4mybdO9Cl//Nfje53xHq/m8OClU/dULs2c1eAceXtvfE+s8RX/QFhzHxtfT4g7d9WS3Nu2B/tBxD5iNEWBoz3/bY+c+jF/E6pEyO0Dd5VIOXpFPgBuRWNuB7tL4u0763OyyvBKwR7TH+2kKvqEfcTd+3ORrEUKfdA5Fswzb3AJ7oIf08zJLXQzQpjHcw7xKGFfCuHBesGUetyERzWNWizG48ZbjJxtIT8R8TkQzN1rSP8EYRqCvD3oxVr0WdffA39BxD9j6RID5xMlN9d5mTd48vp3NsvP4BMBLOihOKdNLtnSVL9tqdghy0I3+Ka4Z6SddvpolLNYePqZoHO3l/EPGPwb8EHTiPOISjEt4uLgNqbh8bLI23wbeBDhDDz4R3a1BBPp/Bvu+cP0DsAfzcCSasQhZLCxmn2FGzC9cM44l3BBsons0fs9JXw1j3mDc74N9fWY/x+P54BQ4HoCOvkfH16AjZDr6Hh2EeQgcR65vYxYAhj/TcT+JQZdw/mCeHjo52a1NMbYCdL3pfSrpRr93n+LnARuTEbNpDPdwTUYd2kl1RHlF+YK1R5jvnfTVj69+uc++fYDm+PZlwlrMe66/fm04/1TzbV1oJVjD9yRM+KFnnDvBF44Mww01AKMRgwcowpBxmzYdPhc3hEA0D0OC2SYAJxi27QNbbj5k+R50HSbo1kLG4uloI5n6EpbnkI3JPrNpLC4ndgL3urAzdVxUyJQvWOCEWTm5qZDTl/jsK/YU/LTtQDQLmOSVC9m3+NsKmS+c760Nn5KIwd2PMD85+bLTwwg46fRwIC6fSgNxebenhsENGK8do68PPIjfmCLFosHCxNbz6OKYRKwXtYuEpX8UUIwpBpjIhPnVyU2xD+K1zSTDuBPbb1jaP0D3RYGBPvwnCD7lsIB4kV2Dvm1jwOA68i8GhMe8xhxEDJ5YCfO7k77Y4hsK+ZB6+PANxeZ638UigJgM4qbNhNkDmwjzJ/D+BXojxmvH//WMU9v2AAkhZ5JucuX8K0O89i8EXSH4T5gh2BHB9T/gzyhu+nOR+07a+MeuP4o3z4vYvDFgYpiXsHkJWze7Bn+7/lA066DNPQPX2ubu/4aymBN6HQAA","debug_symbols":"5ZzhbuIwDMffpZ/5EMexE+9VTqcT29iEhNi0sZNOE+9+hSOl0K7Rbe2drX5BFNz657TJPzEO79X96vbt8cd6+/D0Wt18e682T3fL3fppWx+97xfV7ct6s1k//mh/XLnDSzqavz4vt4ej193yZVfdQPRhUa2294e3GOoLPKw3q+oGEfaLjrVgPBkLxcYWCHtsg5N0Mg7gWtYQe6yZHZ+smb2/sP6+qOTr7OCgsXYt639AD26Epo+Ym15KTQ8+NFdG5wrwUUBO1lG4Cw9jwtdNf0l/8OAn94CTewiTe6CvewieIT/VnqX0VEfK3Z1j7D4YPALQqN0s/i3Q4aT0mZPkEyf53lEAE9PpJEytnv3BI+Lz/ZMI5/jR9Y0C5DKNpLOt9I0YQqkZXji0WlZCr/V5JHVnYy/HMGEeYfp5hInzCDPMI0yaR5g8jzDjPMJM8whTZhEmzmMWhPOYBeE8ZkE4j1kQhq+HCS7kNRrUy9hCoIJ5+SeBCldmyegR2g14XFwh2UVnu+jRLnqyiy5m0UNR/cWXHACkTAO+nSc7uYDpXfgRXPgIjQvhCxdda+KUFYGiazVrb56MQvDZOgTcX+XJAtrGD7bxyTY+28aPtvGTbXwxjU/ONj7YxretumRbdcm26pL6cZ+lwY/uGp/Vd91EDb5AB/8/dN3m2hSBC/h1ZqX56V0ucijH+T6jbfxgG3+MCTPiuSImyPWCjnl6F3FyF3GM6QlBHkaBMBXuMzuf18nsqFRoVCcqcz1J/TZdDxJxjPtMMbsAvkhrTI8v2vFTI5BJOsUzyWnH5ziED9rxm7QYietMT5K3jY+28YNtfPUD5zA+28aPtvGTbXz1qjuIL+pVdxjftuqKbdUV26ortlVXbKuuqFddwjN+KFgLNstWQeoGq16jPw72gK9eo4fx1Wv0ID449SJd4EfteaHBzAS4oJ1/MDUBjrTzDyoFODbOH43zJ+P8Ypsf1OfVC/xgnN8b51evvwV+9fpb4Deuv2Bcf8G4/oJx/QXj+uvV6++IqQrw6tV6eLXp1at1gV+9Whf41at1gd92pR547SXa5JtsC2E3W+G112iTi0P8qL5I+6x2hFhSC++a3Z0euRut7cJQQPVF3QV+9VXdBf5gnF/9bqoCv/rtVAV+9Wpd4Fe/oarAr35H1TB/UK/WBX7j+qt/K3OB37j+6t/MXOA3rr/6tzMP8O/rw5/Ll/XydrM6/f3vw9v2rvVvwLtfz3++qY1/Aw==","brillig_names":["set_contract_registered"]},{"name":"get_participant_escrows","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"participant","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"page_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"array","length":10,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"kind":"boolean"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_participant_escrows"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"12265343917440897559":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"ZImburseContractRegistry::register_participant_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZImburseContractRegistry::register_participant_parameters","fields":[{"name":"participant","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"participant_name","type":{"kind":"string","length":60}},{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"escrow","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"ZImburseContractRegistry::register_escrow_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZImburseContractRegistry::register_escrow_parameters","fields":[{"name":"escrow_contract","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"ZImburseContractRegistry::set_contract_registered_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZImburseContractRegistry::set_contract_registered_parameters","fields":[{"name":"escrow_contract","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"ZImburseContractRegistry::check_and_register_participant_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZImburseContractRegistry::check_and_register_participant_parameters","fields":[{"name":"participant","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"participant_name","type":{"kind":"string","length":60}},{"name":"admin","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"escrow","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"ZImburseContractRegistry::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZImburseContractRegistry::constructor_parameters","fields":[{"name":"contract_class_id","type":{"kind":"field"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000b3dd3286"},{"kind":"string","value":"ParticipantNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"escrow_contract_id","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"managed_escrows","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"participants","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"participant_escrows","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"contract_registration","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array/mod.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"35":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    crate::sha256::digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u64, msg_start: u32) -> ([u8; 64], u64) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            msg_block[msg_byte_ptr] = msg[k];\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u64,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u64 {\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    let mut extra_bytes = 0;\n    if msg_end > N {\n        msg_end = N;\n        extra_bytes = msg_end - N;\n    }\n\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if msg_byte_ptr == 64 {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE as u64 {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64) -> ([u8; 64], u64) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        if msg_byte_ptr < 64 {\n            for _ in 57..64 {\n                if msg_byte_ptr <= 63 {\n                    msg_block[msg_byte_ptr] = 0;\n                    msg_byte_ptr += 1;\n                }\n            }\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64, message_size: u64) -> [u8; 64] {\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for _i in 0..64 {\n        // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n        if msg_byte_ptr < 56 {\n            msg_block[msg_byte_ptr] = 0;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        } else if msg_byte_ptr < 64 {\n            for j in 0..8 {\n                msg_block[msg_byte_ptr + j] = len_bytes[j];\n            }\n            msg_byte_ptr += 8;\n        }\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; 64], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"std/hash/sha256.nr"},"58":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"71":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/home/jpag/Workground/aztec/zimburse/z-imburse/contracts/address_note/src/address_note.nr"},"85":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"86":{"source":"use std::option::Option;\nuse dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::ToField};\nuse crate::note::note_interface::NoteInterface;\n\npub struct PropertySelector {\n    index: u8, // index of the field in the serialized note array\n    offset: u8, // offset in the byte representation of the field (selected with index above) from which to reading\n    length: u8, // number of bytes to read after the offset\n}\n\npub struct Select {\n    property_selector: PropertySelector,\n    comparator: u8,\n    value: Field,\n}\n\nimpl Select {\n    // The selected property will be the left hand side and value the right hand side of the operation, so e.g. the\n    // object created by new(property, Comparator.GT, value) represents 'property > value'.\n    pub fn new(property_selector: PropertySelector, comparator: u8, value: Field) -> Self {\n        Select { property_selector, comparator, value }\n    }\n}\n\npub struct SortOrderEnum {\n    DESC: u8,\n    ASC: u8,\n}\n\nglobal SortOrder = SortOrderEnum {\n    DESC: 1,\n    ASC: 2,\n};\n\npub struct Sort {\n    property_selector: PropertySelector,\n    order: u8,\n}\n\nimpl Sort {\n    pub fn new(property_selector: PropertySelector, order: u8) -> Self {\n        Sort { property_selector, order }\n    }\n}\n\npub struct NoteStatusEnum {\n    ACTIVE: u8,\n    ACTIVE_OR_NULLIFIED: u8,\n}\n\nglobal NoteStatus = NoteStatusEnum {\n    ACTIVE: 1,\n    ACTIVE_OR_NULLIFIED: 2,\n    // TODO 4217: add 'NULLIFIED'\n};\n\n// This is the default filter and preprocessor, which does nothing\nfn return_all_notes<Note>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    _p: Field\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    notes\n}\n\n// docs:start:NoteGetterOptions\npub struct NoteGetterOptions<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS> {\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n    limit: u32,\n    offset: u32,\n    // Preprocessor and filter functions are used to filter notes. The preprocessor is applied before the filter and\n    // unlike filter it is applied in an unconstrained context.\n    preprocessor: fn ([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n    filter: fn ([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], FILTER_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    filter_args: FILTER_ARGS,\n    status: u8,\n}\n// docs:end:NoteGetterOptions\n\n// When retrieving notes using the NoteGetterOptions, the configurations are applied in a specific sequence to ensure\n// precise and controlled data retrieval.\n// The database-level configurations are applied first:\n// `selects` to specify fields, `sorts` to establish sorting criteria, `offset` to skip items, and `limit` to cap\n// the result size.\n// And finally, a custom preprocessor and filter to refine the outcome further.\nimpl<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS> NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS> {\n    // This method adds a `Select` criterion to the options.\n    // It takes a property_selector indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from `utils::comparison`)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T\n    ) -> Self where T: ToField {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    // This method adds a `Sort` criterion to the options.\n    // It takes a field_index indicating which field to sort by and an order (SortOrder) to determine the sorting direction.\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    // This method lets you set a limit for the maximum number of notes to be retrieved in a single query result.\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        assert_constant(limit);\n\n        self.limit = limit;\n        *self\n    }\n\n    // This method sets the offset value, which determines where to start retrieving notes in the query results.\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n\nimpl<Note, let N: u32> NoteGetterOptions<Note, N, Field, Field> where Note: NoteInterface<N> {\n    // This function initializes a NoteGetterOptions that simply returns the maximum number of notes allowed in a call.\n    pub fn new() -> Self {\n        Self {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32,\n            offset: 0,\n            preprocessor: return_all_notes,\n            preprocessor_args: 0,\n            filter: return_all_notes,\n            filter_args: 0,\n            status: NoteStatus.ACTIVE\n        }\n    }\n}\n\nimpl<Note, let N: u32, PREPROCESSOR_ARGS> NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, Field> where Note: NoteInterface<N> {\n    // This function initializes a NoteGetterOptions with a preprocessor, which takes the notes returned from\n    // the database and preprocessor_args as its parameters.\n    // `preprocessor_args` allows you to provide additional data or context to the custom preprocessor.\n    pub fn with_preprocessor(\n        preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n        preprocessor_args: PREPROCESSOR_ARGS\n    ) -> Self {\n        Self {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32,\n            offset: 0,\n            preprocessor,\n            preprocessor_args,\n            filter: return_all_notes,\n            filter_args: 0,\n            status: NoteStatus.ACTIVE\n        }\n    }\n}\n\nimpl<Note, let N: u32, FILTER_ARGS> NoteGetterOptions<Note, N, Field, FILTER_ARGS> where Note: NoteInterface<N> {\n    // This function initializes a NoteGetterOptions with a filter, which takes\n    // the notes returned from the database and filter_args as its parameters.\n    // `filter_args` allows you to provide additional data or context to the custom filter.\n    pub fn with_filter(\n        filter: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], FILTER_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n        filter_args: FILTER_ARGS\n    ) -> Self {\n        Self {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32,\n            offset: 0,\n            preprocessor: return_all_notes,\n            preprocessor_args: 0,\n            filter,\n            filter_args,\n            status: NoteStatus.ACTIVE\n        }\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_getter_options.nr"},"87":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"88":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"91":{"source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"93":{"source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"},"95":{"source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"97":{"source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"100":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let N: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> [u8; M] where Note: NoteInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    encrypted_bytes[64] = num_public_values; // TODO(#8558): This can be just a single bit if we store info about partial fields in ABI\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[65 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[97 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[145 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[193 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 337;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[337 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // num_public_values (1 byte)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 0;\n\n        let log: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        assert_eq(encrypted_note_log_from_typescript, log);\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_of_finalized_partial_note_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note_public_value1 = 0x14172339287e8d281545c177313f02b6aa2fedfd628cfd8b7f11a136fd0d6557;\n        let note_public_value2 = 0x0834d81e3f73c7e2809b08ae38600ffc76a2554473eeab6de7bff4b33a84feac;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 2;\n\n        // First we compute the encrypted log without the public values\n        let log_without_public_values: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // Then we \"append\" the public values to the log by copying both the original log and the current log into a new byte array\n        let mut log: [u8; 513] = [0; 513];\n        for i in 0..449 {\n            log[i] = log_without_public_values[i];\n        }\n        let note_public_value1_bytes: [u8; 32] = note_public_value1.to_be_bytes();\n        let note_public_value2_bytes: [u8; 32] = note_public_value2.to_be_bytes();\n        for i in 0..32 {\n            log[449 + i] = note_public_value1_bytes[i];\n            log[481 + i] = note_public_value2_bytes[i];\n        }\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_of_finalized_partial_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38, 20, 23, 35, 57, 40, 126, 141, 40, 21, 69, 193, 119, 49, 63, 2, 182, 170, 47, 237, 253, 98, 140, 253, 139, 127, 17, 161, 54, 253, 13, 101, 87, 8, 52, 216, 30, 63, 115, 199, 226, 128, 155, 8, 174, 56, 96, 15, 252, 118, 162, 85, 68, 115, 238, 171, 109, 231, 191, 244, 179, 58, 132, 254, 172\n        ];\n        assert_eq(encrypted_note_log_of_finalized_partial_from_typescript, log);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"101":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\npub struct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{address::AztecAddress, scalar::Scalar};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    #[test]\n    unconstrained fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr"},"104":{"source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\npub struct EncryptedLogIncomingBody<let N: u32> {\n    plaintext: [u8; N * 32 + 64]\n}\n\nimpl<let N: u32> EncryptedLogIncomingBody<N> {\n    pub fn from_note<T>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T>(event: T, randomness: Field) -> Self where T: EventInterface<N> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: u32 = 3;\n\n    impl NullifiableNote for AddressNote {\n        fn compute_nullifier(\n            _self: Self,\n            _context: &mut PrivateContext,\n            _note_hash_for_nullify: Field\n        ) -> Field {\n            1\n        }\n\n        unconstrained fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n    }\n\n    struct AddressNoteHidingPoint {\n        inner: Point\n    }\n\n    impl NoteInterface<ADDRESS_NOTE_LEN> for AddressNote {\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader {\n            self.header\n        }\n\n        fn set_header(&mut self, header: NoteHeader) {\n            self.header = header;\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] {\n            [self.address.to_field(), self.owner.to_field(), self.randomness]\n        }\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote {\n                address: AztecAddress::from_field(fields[0]),\n                owner: AztecAddress::from_field(fields[1]),\n                randomness: fields[2],\n                header: NoteHeader::empty()\n            }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_LEN * 32 + 64] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_LEN * 32 + 64] = [0; ADDRESS_NOTE_LEN * 32 + 64];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n\n        fn compute_note_hash(_self: Self) -> Field {\n            crate::generators::Ga1.x\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: u32 = 3;\n\n    impl EventInterface<TEST_EVENT_LEN> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime\n            {\n                EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n            }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_LEN * 32 + 64] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 64] = [0; TEST_EVENT_LEN * 32 + 64];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_LEN * 32 + 32] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 32] = [0; TEST_EVENT_LEN * 32 + 32];\n\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 201, 247, 40, 80, 60, 188, 158, 251, 242, 103, 197, 79, 165, 195, 10, 160, 255, 35, 167, 152, 25, 233, 77, 145, 214, 243, 210, 119, 0, 20, 29, 95, 15, 63, 33, 190, 184, 67, 254, 96, 128, 243, 220, 228, 201, 130, 86, 163, 52, 127, 111, 10, 212, 7, 160, 16, 87, 13, 39, 11, 5, 1, 164, 65, 8, 56, 82, 245, 13, 68, 176, 90, 100, 69, 243, 78, 117, 188, 221, 34, 178, 31, 155, 89, 143, 176, 129, 118, 36, 236, 64, 179, 52, 239, 184, 51, 51, 199, 221, 49, 81, 197, 17, 199, 192, 99, 49, 168, 157, 164, 190, 33, 240, 182, 214, 173, 7, 156, 102, 95, 65, 217, 225, 123, 42, 21, 124, 144\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr"},"105":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::{get_public_keys, get_ovsk_app}, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note,\n        num_public_values\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient, num_public_values)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, iv, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Note: We could save a lot of gates by obtaining the following keys in an unconstrained context but this\n        // function is currently not used anywhere so we are not optimizing it.\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        // See the comment in `encode_and_encrypt_note_with_keys_unconstrained` for why having note hash counter\n        // and log hash unconstrained here is fine.\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, iv, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Number of public values is always 0 here because `encode_and_encrypt_note_with_keys_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"106":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"109":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"110":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"112":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"113":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"117":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"130":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"131":{"source":"use crate::{context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"136":{"source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"137":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"145":{"source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, hash::compute_siloed_nullifier,\n    constants::DEPLOYER_CONTRACT_ADDRESS\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for Header {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier = compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for Header {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier = compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for Header {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for Header {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr"},"147":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"151":{"source":"use dep::protocol_types::merkle_tree::root::root_from_sibling_path;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::{NoteInterface, NullifiableNote}}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n\n        // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n        // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n        // care about is showing that the tree contains an entry with the expected nullifier.\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(\n        self,\n        note: Note,\n        context: &mut PrivateContext\n    ) where Note: NoteInterface<N> + NullifiableNote {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"153":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"156":{"source":"struct ComparatorEnum {\n    EQ: u8,\n    NEQ: u8,\n    LT: u8,\n    LTE: u8,\n    GT: u8,\n    GTE: u8,\n}\n\nglobal Comparator = ComparatorEnum {\n    EQ: 1,\n    NEQ: 2,\n    LT: 3,\n    LTE: 4,\n    GT: 5,\n    GTE: 6,\n};\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::compare;\n    use super::Comparator;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GTE, rhs), \"Expected lhs to be greater than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GTE, rhs), \"Expected lhs to be greater than or equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LTE, rhs), \"Expected lhs to not be less than or equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.GTE, rhs), \"Expected lhs to not be greater than or equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.GTE, rhs), \"Expected lhs to not be greater than or equal to rhs\");\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr"},"157":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"158":{"source":"// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr"},"162":{"source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"163":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"164":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"166":{"source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr"},"168":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"169":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"170":{"source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"171":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 24;\n\npub struct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"174":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"177":{"source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"178":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"179":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call.\n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments\n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call.\n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments\n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"191":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"193":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"194":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"203":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"209":{"source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"210":{"source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"211":{"source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"213":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"214":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"216":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"236":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"238":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"241":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"267":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"288":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"292":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\npub struct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"311":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"331":{"source":"use dep::aztec::macros::aztec;\n\nmod types;\n\n#[aztec]\ncontract ZImburseContractRegistry {\n    use dep::aztec::prelude::{AztecAddress, PrivateImmutable, PrivateSet, SharedImmutable, Map};\n    use dep::aztec::macros::{storage::storage, functions::{private, public, view, initializer}};\n    use dep::aztec::note::{note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions, note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE};\n    use dep::aztec::oracle::{get_contract_instance::get_contract_instance, header::get_header_at_oracle};\n    use dep::aztec::keys::getters::get_public_keys;\n    use dep::aztec::utils::comparison::Comparator;\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::address_note::address_note::AddressNote;\n    use crate::types::participant_note::{ParticipantNote, NAME_LENGTH};\n    // use dep::z_imburse_escrow::ZImburseEscrow;\n\n    #[storage]\n    struct Storage<Context> {\n        escrow_contract_id: SharedImmutable<Field, Context>,\n        managed_escrows: PrivateSet<AddressNote, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: PrivateSet<AddressNote, Context>,\n        contract_registration: Map<AztecAddress, SharedImmutable<bool, Context>, Context>\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract by setting the class ID of the escrow contract\n     *\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     */\n    #[public]\n    #[initializer]\n    fn constructor(contract_class_id: Field) {\n        storage.escrow_contract_id.initialize(contract_class_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check that the contract has not already been registered\n        let registration_status = storage.contract_registration.at(escrow_contract).read_private();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        // check that the contract admin is the sender of the message\n        // let escrow_admin = ZImburseEscrow::at(escrow_contract).get_admin().call(&mut context);\n        // assert(escrow_admin == context.msg_sender(), \"Escrow contract admin does not match sender of message\");\n\n        // check that the contract has been deployed\n        let header = context.historical_header;\n        header.prove_contract_initialization(escrow_contract);\n\n        // check the contract class ID\n        let contract_class_id = get_contract_instance(escrow_contract).contract_class_id.to_field();\n        let expected_class_id = storage.escrow_contract_id.read_private();\n        assert(\n            contract_class_id == expected_class_id, \"Escrow contract class ID does not match expected class ID\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let npk_m_hash = get_public_keys(context.msg_sender()).npk_m.hash();\n        let mut escrow_note = AddressNote::new(escrow_contract, npk_m_hash);\n        storage.managed_escrows.insert(&mut escrow_note);\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseContractRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.contract_registration.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n   fn check_and_register_participant(\n        participant: AztecAddress,\n        participant_name: str<60>,\n        admin: AztecAddress,\n        escrow: AztecAddress\n    ) {\n        // check that the escrow address is registered\n        let registration_status = storage.contract_registration.at(escrow).read_private();\n        assert(registration_status, \"Escrow contract has not been registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new()\n            .select(AddressNote::properties().address, Comparator.EQ, participant)\n            .set_limit(1);\n        let participant_exists = storage.participants.at(escrow).get_notes(options).len() == 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        if participant_exists {\n            ZImburseContractRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, context.msg_sender()).call(&mut context);\n        }\n    }\n\n       #[private]\n       #[interal]\n       fn register_participant(\n            participant: AztecAddress,\n            participant_name: str<60>,\n            admin: AztecAddress,\n            escrow: AztecAddress\n        ) {\n            // add escrow to the participant's set of escrows\n            let mut escrow_note = AddressNote::new(escrow, get_public_keys(participant).npk_m.hash());\n            storage.participant_escrows.insert(&mut escrow_note).emit(\n                encode_and_encrypt_note(&mut context, admin, participant)\n            );\n            // add the participant to the admin set of participants\n            let mut participant_note = ParticipantNote::new(participant, participant_name, get_public_keys(participant).npk_m.hash());\n            storage.participants.at(escrow).insert(&mut participant_note).emit(\n                encode_and_encrypt_note(&mut context, admin, admin)\n            )\n       }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param page_index - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_managed_escrows(\n        admin: AztecAddress,\n        page_index: u32\n    ) -> pub ([AztecAddress; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.managed_escrows.view_notes(options.set_offset(offset));\n        let mut managed_escrows: [AztecAddress; MAX_NOTES_PER_PAGE] = [AztecAddress::from_field(0); MAX_NOTES_PER_PAGE];\n        for i in 0..notes.len() {\n            if i < notes.len() {\n                managed_escrows[i] = notes.get_unchecked(i).address;\n            }\n        }\n        let page_limit_reached = notes.len() == options.limit;\n        (managed_escrows, page_limit_reached)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param admin - the address of the participant\n     * @param page_index - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participant_escrows(\n        participant: AztecAddress,\n        page_index: u32\n    ) -> pub ([AztecAddress; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.managed_escrows.view_notes(options.set_offset(offset));\n        let mut participant_escrows: [AztecAddress; MAX_NOTES_PER_PAGE] = [AztecAddress::from_field(0); MAX_NOTES_PER_PAGE];\n        for i in 0..notes.len() {\n            if i < notes.len() {\n                participant_escrows[i] = notes.get_unchecked(i).address;\n            }\n        }\n        let page_limit_reached = notes.len() == options.limit;\n        (participant_escrows, page_limit_reached)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param page_index - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        participant: AztecAddress,\n        page_index: u32\n    ) -> pub ([AztecAddress; MAX_NOTES_PER_PAGE], [[u8; NAME_LENGTH]; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.participants.at(escrow).view_notes(options.set_offset(offset));\n        let mut participants: [AztecAddress; MAX_NOTES_PER_PAGE] = [AztecAddress::from_field(0); MAX_NOTES_PER_PAGE];\n        let mut participant_names: [[u8; NAME_LENGTH]; MAX_NOTES_PER_PAGE] = [[0; NAME_LENGTH]; MAX_NOTES_PER_PAGE];\n        for i in 0..notes.len() {\n            if i < notes.len() {\n                let participant_note = notes.get_unchecked(i);\n                participants[i] = participant_note.address;\n                participant_names[i] = participant_note.get_name();\n            }\n        }\n        let page_limit_reached = notes.len() == options.limit;\n        (participants, participant_names, page_limit_reached)\n    }\n}\n\n","path":"/home/jpag/Workground/aztec/zimburse/z-imburse/contracts/z_imburse_contract_registry/src/main.nr"},"333":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    \n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n","path":"/home/jpag/Workground/aztec/zimburse/z-imburse/contracts/z_imburse_contract_registry/src/types/participant_note.nr"},"336":{"source":"use dep::aztec::protocol_types::{utils::field::field_from_bytes, traits::{Serialize, Deserialize}};\n\n// The general Compressed String.\n// Compresses M bytes into N fields.\n// Can be used for longer strings that don't fit in a single field.\n// Each field can store 31 characters, so N should be M/31 rounded up.\npub struct CompressedString<let N: u32, let M: u32> {\n  value: [Field; N]\n}\n\nimpl<let N: u32, let M: u32> CompressedString<N, M> {\n    pub fn from_string(input_string: str<M>) -> Self {\n        let mut fields = [0; N];\n        let byts = input_string.as_bytes();\n\n        let mut r_index = 0 as u32;\n\n        for i in 0..N {\n            let mut temp = [0 as u8; 31];\n            for j in 0..31 {\n                if r_index < M {\n                    temp[j] = byts[r_index];\n                    r_index += 1;\n                }\n            }\n\n            fields[i] = field_from_bytes(temp, true);\n        }\n\n        Self { value: fields }\n    }\n\n    pub fn to_bytes(self) -> [u8; M] {\n        let mut result = [0; M];\n        let mut w_index = 0 as u32;\n        for i in 0..N {\n            let bytes: [u8; 31] = self.value[i].to_be_bytes();\n            for j in 0..31 {\n                if w_index < M {\n                    result[w_index] = bytes[j];\n                    w_index += 1;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let M: u32> Eq for CompressedString<N, M> {\n    fn eq(self, other: CompressedString<N, M>) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Serialize<N> for CompressedString<N, M> {\n    fn serialize(self) -> [Field; N] {\n        self.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Deserialize<N> for CompressedString<N, M> {\n    fn deserialize(input: [Field; N]) -> Self {\n        Self { value: input }\n    }\n}\n\n#[test]\nunconstrained fn test_short_string() {\n    let i = \"Hello world\";\n    let b = i.as_bytes();\n    let name: CompressedString<1,11> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<4,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string_work_with_too_many_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<5,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_serde() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let name: CompressedString<5,118> = CompressedString::from_string(i);\n\n    assert_eq(name, CompressedString::deserialize(name.serialize()));\n}\n\n#[test(should_fail)]\nunconstrained fn test_long_string_fail_with_too_few_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<3,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n","path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/compressed-string/src/compressed_string.nr"}}}