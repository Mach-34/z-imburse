{"transpiled":true,"noir_version":"0.34.0+02fea6abe8637b9fb8f9535d1709b367d5e1da5c","name":"ZImburseContractRegistry","functions":[{"name":"get_contract_registration_status","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"escrow_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRQAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAkrAAADCEQ6AAAACEQAAAABHgAAAAUeAAAABjEAAAAABQAAAAYAAAAHJAACAQYKAAIHBgUhAAAQAAU7AQAAHgALAAYkAAcBBwoABwYHBSEAABUABTsBAAAkAAcFByoAAAYkAAQDBQAABAAFACQBBAEGAAAEBgIFKgAFCCoCBwgAAAQIAggqAgMIJAAEAAUAAAQGAgkkAAQCCkIEAAAABQAAAAgAAAAJAAAACiQABwAGCgAHCAYHJAABAAMKAAEHAwohAAApAAo7AQAAKgAAByQABAIDAAAEAAMAJAEEAQcAAAQHAgMqAAMKKgIGCioBBwMAAAQDAgMqAgMHKgAAAwAABAACACoCBwMqAAUEIAA4CgAEBAUHIQAAQwAHIAA7KgEDBAAABAQCBgAABAYFByoBBwMcAAEDBBwABwQFHAABBQMjKgEDBxwABwQGAAAHCAYJLQAAAAAJAAAABiQABAEKDAAEBAoLIQAASwALOwEAACsAAAcIAyUABAACCAQiAAAAWisACAUACQAABAkCCwAABAsECioCBgokAAQBBgAABAQGBw4ABAQHCyEAAFcACzsBAAAqAgkDKgAHBCAAOCsBCAMIBgsABAgGAAIIByEAAF4IByAAYCsACAMIBSAAbisAAAAIBQEABAAACAQAACUABAAACAkNAAQICQgECAoXAAgKCAohAABsCAoBAAQIAwgJCAsrAQgLCAgBAAQIBQgJCAsrAggICAsBAAQICQACCAkgAGMlAQQAAQgFIABuIysAGMoYyg==","debug_symbols":"5ZvhbuIwDMffpZ/54MSxE/Mqp9MEG0yVEEzATjoh3v1ajobuWqXaOKZY+YJa+Cf52TS2a7Wn6mW1fH99qrfr3aGa/zhVm93z4ljvts3Z6Tyrlvt6s6lfn/pfV9B+yEV+eFts27PDcbE/VnPjrZtVq+1Le4iumWBdb1bV3MN5NhAL+qtWyEepIR7ROpBwFTsDPbUdm5kZ+KpmtvaD+uesMnA3uwETxdATfwe9ud/zHjvPy5TnjXVxYgSYYPdi5Kr2wkN2+x/ZG8d/hG8XwEcv4B69AD16Ab57AULoxIR28pogge6aYIODa8J/kqcdE74wRj4/xsIXxozuTyaMm5o4TPyB1nT705ubvxDH9id1zjVym9bI2F4WCnHjs+vtzjYKjKhvIQ5uYisXK20RVmIRVroirKQirOQirPRFWBmKsFJKsBKhCCuLqH2wiNoHi6h90BVh5f21jwHXiU1zWzlhp2DX8BBH6YlZOnBv+u5zF3DWCu61gget4KIU3IFW8Ols32svjoNzsLGV0u+Mtm2VgbrxQxc+yYOZ6DuRc93czeGg7+SsanpUTe9U05NqelZN71XTB9X0opmeQDW96lxLqnMtqc61lHu8Z4n0Hgb0ucecQJFezL/0/P0xhyOPNzxFb7snMBqiXn/hUt2zUcxuFbOjFnbnBuxOMTspZs+9Kk7GeM68KiYb8yvh4JkmzjxDEfgEvc+9Ko4NqIYeJ9RiIXbMLfLA1txr6GQt4XOvodP0udfQaXqnmj73flWaPvf7lzR97pk5TZ97vypNr/reMeSemdP0qnNtUJ1rg+pcG1Tn2qA61wbVuTYozrXn5vTXYl8vlpvV9d2r9fv2ufcq1vH3299fGvEf","brillig_names":["get_contract_registration_status"],"assert_messages":{"40":"Storage slot 0 not allowed. Storage slots must start from 1.","74":"Array index out of bounds","15":"Not initialized","20":"Function get_contract_registration_status can only be called statically","86":"attempt to add with overflow"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"contract_class_id","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"128":"Array index out of bounds","573":"attempt to add with overflow","378":"Initializer address is not the contract deployer","439":"attempt to add with overflow","372":"Initialization hash does not match","497":"Array index out of bounds","829":"Array index out of bounds","747":"attempt to add with overflow","680":"Array index out of bounds","668":"attempt to add with overflow","473":"Array index out of bounds","842":"attempt to add with overflow","135":"Array index out of bounds","455":"Array index out of bounds","513":"Array index out of bounds","647":"Array index out of bounds","696":"Array index out of bounds","821":"Array index out of bounds","431":"Array index out of bounds","559":"Array index out of bounds","541":"Array index out of bounds","90":"attempt to add with overflow","733":"Array index out of bounds","404":"SharedImmutable already initialized","526":"attempt to add with overflow","715":"Array index out of bounds","709":"attempt to add with overflow","639":"Array index out of bounds","124":"attempt to add with overflow","505":"Array index out of bounds","627":"attempt to add with overflow","688":"Array index out of bounds","813":"Array index out of bounds","484":"attempt to add with overflow","801":"attempt to add with overflow","146":"attempt to add with overflow","463":"attempt to add with overflow","655":"Array index out of bounds"}},{"name":"get_participants","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"escrow","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"page_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"kind":"array","length":10,"type":{"kind":"array","length":60,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"kind":"boolean"}],"kind":"tuple"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_participants"]},{"name":"set_contract_registered","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"escrow_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg6AAAACEQAAAAAHgAAAAUeAAAABjEAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY7AQAAHgACAAUeAAAABwoABwUHBiEAABQABjsBAAAkAAQABSQABwUHKgAABiQABAMIAAAEAAgAJAEEAQYAAAQGAggqAAgJKgIHCQAABAkCCSoCAwkAAAQGAgkkAAQCCkIEAAAABQAAAAgAAAAJAAAACiQABwAGCgAHCAYHJAABAAMKAAEHAwohAAAoAAo7AQAAJgAHO5rKAAAHAAAHBwgDKgAAByQABAIKAAAEAAoAJAEEAQcAAAQHAgoqAAoJKgIGCSoBBwoAAAQKAgoqAgoHKgAACgAABAACACoCBwoqAAUEIAA5CgAEBAUJJAAEAQchAAB/AAkgAD0qAQoEAAAEBAILAAAECwUMKgEMCgoABwoGBCEAAEQABDsBAAAqAAUJIABGCgAECQUGIQAAZwAGIABJKgAFBiAASwoABAYFBCEAAE8ABCAATiMcAAcGBAAABwgEAyQABwEEKgAACSQABAIKAAAEAAoAJAEEAQkAAAQJAgoqAAoLKgIECyQABAELDAAEBgsMIQAAXQAMOwEAAAAABAkCDAAABAwGCyoBCwouAAAAAAoAAAADAAAEBgcKDgAEBgoDIQAAZQADOwEAACoACgYgAEscAAcJBgAABwMGBCUAB96tAAYqAAAKJAAEAgsAAAQACwAkAQQBCgAABAoCCyoACwwqAgYMJAAEAQwMAAQJDA0hAAB1AA07AQAAAAAECgINAAAEDQkMKgEMCy4AAAAACwAAAAQAAAQJBwsOAAQJCwQhAAB9AAQ7AQAAKgALCSAARioBCgkcAAcECwAABwMLDC0AAAAADAAAAAskAAQBDQwABAQNDiEAAIcADjsBAAArAAAJCAMlAAQAAggEIgAAAJUrAAgFAAwAAAQMAg4AAAQOBA0qAgsNAAAEBAcJDgAEBAkLIQAAkgALOwEAACoCDAoqAAkEIAA5KwEIAwgGCwAECAYAAggHIQAAmQgHIACbKwAIAwgFIACpKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAKcICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAniUBBAABCAUgAKkjKwAYyhjK","debug_symbols":"5ZzhbuIwDMffpZ/5EMexE+9VTqeJbWxCQmza2EknxLtfy5FSaK/RDphs9ctENzf+OW3yTzyHbfW0ePh8uV+un18/qrsf22r1+jjfLF/X9dV2N6se3per1fLlvvvryjU/0t78422+bq4+NvP3TXUH0YdZtVg/NR8x1A08L1eL6i663axnLBgPtkKxNQXiAdvgJB2MA7iOtR9qmdnxwZrZ+xPrn7NKLkYHB62x6xh/Azy4yzs+Yu54KXU8+NA2jM4V2KOAHKyjcJ8drshed/wpfOPA39oB3tpBuLUDuthB8Az5ffYspfc5Uh7nHGP/neDLea46vuIXeZp70n/cI1+/xw+OfUxMh3swdQb08Mvh86OTCMfYEYfGPrnMIuloK0PzhFBqJxUOnV5tgAasj9OnOxp72UcJk4jSTyJKnESUYRJR0iSi5ElEGScRZZpElDKFKHESax+cxNoHJ7H2wUmsfTBcHCW4kHdkUG9ZC3EK5s2eBBpvmCWDR+h2X9iDk1VwtgoerYInq+BiFDwU1V58oX2AlFnAd/NgBw9wcw/+cg8+Quuhmck7HvrWxClLAEXX6dPBPBiF4LN1CLg7y4MFNE0fTNOTaXo2TR9N0yfT9GKZnpxpejBNb1prybTWkmmtJe3zPUtLH905PWsftYlaeoEe/feP2rZpisAFehBs/5MuJ1mS/fqe0TR9ME1/hRUy4rGyJcj57o355h7irT3EK6xICPLsCYSp8IzZ+bwjZkelaqE6CZkrQ+qP6Xx2iFd4xhSzB+CT5MXt6UU5fWpVMUmvCiY55fQcx+hBOX2b+iJxvRVJ8qbp0TR9ME2vfcYcp2fT9NE0fTJNr11rR+lFu9aO05vWWjGttWJaa8W01opprRXtWkt4pA8Fa8F2jypI/Vi1K/O/Y23otSvzOL12ZR6lB6ddmgv4qDz/M5qDABeU448mIcCRcvxRhQDHtvGjbfxkG19M44P2xHkBH2zje9v42lW3gK9ddQv4tlUXbKsu2FZdsK26YFt1vXbVvWJSArx2jR7fWnrtGl3A167RBXztGl3AN11zB155kTX5Nq1C2M9LeOVV1uTiGD5qL7M+ihwhllTCu/YgpkfuB2u6vhNQe1l2AV97XXYBP9jG134KqoCv/RhUAV+7RhfwtR+EKuBrPwk1jh+0a3QB37bqqj94XMC3rbrqjx4X8G2rrvrDxyP4u/ry1/x9OX9YLQ7fv/v8uX7sfB3v5vfb37/Uxn8A","brillig_names":["set_contract_registered"],"assert_messages":{"67":"SharedImmutable already initialized","39":"Storage slot 0 not allowed. Storage slots must start from 1.","116":"Array index out of bounds","100":"attempt to add with overflow","14":"Not initialized","145":"attempt to add with overflow","92":"Array index out of bounds","124":"attempt to add with overflow","134":"Array index out of bounds","19":"Function set_contract_registered can only be called internally"}},{"name":"get_managed_escrows","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"page_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"kind":"boolean"}],"kind":"tuple"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_managed_escrows"]},{"name":"check_and_register_participant","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"1756802668388977958":{"error_kind":"fmtstring","item_types":[],"length":17}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"participant","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"participant_name","type":{"kind":"string","length":60},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"escrow","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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FbXTXdHpntn76Z7Z++me2fvZntnb5WzP7O1ytmf2djnbM3u7+D6zf65RJ6zRJqxxwJPy+k+272vUIdYYE9bYJqyxH7tGq7drHFDRaa9RJqxxwFPhuqlva2xF7McBRZ32GnXCGgecj23t72uoZ+IBFZHmGkcUE/ZLffsx3pdNrPG799XPT61Pfao+9Sn51L7+6fun1qU/nZK4/eNSy+XXH1//58f1bPuv6+knu55xrus5oA5vvf71+8nYL7d37RElbKW9rVHLJk7GETVs5hptwhp9whpjwhrbhDV2/zWOqGQz1ygT1jggp17W+niNdcIadcIabcIaB5zzpbyvsaxCkRxR0GausU1YY/df44iaNnONMmGNZcIaB5zz5f2P67KrNeqENdqENfqENY4456N8rCF+0R5R22ausfuvcUR1m7lGmbDGMmGNdcIa9dA11ksRa7QJa/QJaxxwzmt/y2LUuqk1tglr7P5rHFHnZq5xwDmva/tYY/nPx7n/try9mNun7NBYfl3Ocq7LWc91OfVcl9POdTn9XJczznU527kuZz/V5RxRdHjk5Zzrqbyd66m8neupvJ3rqbyd66m8neupvJ3rqbyd66m8neupvJ/rqbyf66m8T3/uvP8bWbv+09vb3y7l10+JffbR6pe3fxbsly6uZzvZ9eynup79cjnZ9fger59rLBPWWCesccDZb+U9VdPa+pVH0X7E0MIjL6ef63LGuS5nO9fl7Ke6nCMGMh55OeVcl7Oc63LWc13OuZ7K5VxP5XKup3I511O5nOupXM71VF7O9VRezvVUXs71VF7O9VRezvVUXs71VF7O9VRezvVUXs71VF7O9VRez/VUXn2fyj/XWCassU5Y44iHYn+v121m8mfd6vLrr9etf1TRLPXXBbWzXVA/2wWNs13QdrYL2k92QUdU3h97QeVsF7Sc7YJW1wv6ucYBD9++vj/ge92NoK2mvP2IdoGDr6if7orG6a5oO90V7We7oiOaIh5c0c81yoQ1lglrHPDsM/ejTlijTVijT1hjTFhjm7DG7r/GEU0R5hplwhrLhDUmnPM+4Zz3Cee8TzjnfcI57xPOeZ9wzseEcz4mnPMx4ZyPCed8TDjnY8I5HxPO+ZhwzseEcz4mnPNtwjnfJpzzbcI53yac823COd8mnPNtwjnfJpzzbcI53yac833COd8nnPN9wjnf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tWrFv1at+NeqFf9ateJfq1b8a9WKf63a4l+rtvjXqi3+tWqLf63acqn+SzT/Jbr/EsN/ic1/Cf/T7V+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvjXqi3+tWqLf63a4l+rtvx+rdrPjy3PfWx97mP1uY+15z7Wn/vYeO5j23Mf25/62L36qG38+li9XOrX7qh79VFHLrH4L7H6L1H9l2j+S3T/JYb/Epv/Erv7EsP/dA//0z38T/fwP93D/3QP/9M9/E/3+O3T/fNj23Mf25/62HZ57mPluY8tz31sfe5j9bmPtec+JvetXpb1/WOL+tj+1Md0vUYty/b2sdKb+Nj63Mfqcx9rz33sDpL1/WOX2m8+tup/qrc/Vp772PLcx9bnPlaf+1h77mP9uY+N5z62Pfex5+6S8txdUp67S8pzd0l57i4pz90l5c4GbP39Y3sVH9uf+thyee5j5bmPLc99bH3uY/W5j7XnPtaf+9h47mPP3SXLc3fJ+txdsj53l6zP3SXrc3fJ+txdsj53l6zP3SXrc3fJ+txdsj53l9Tn7pL63F1Sn7tL6nN3SX3uLqnP3SX1ubukPneX1OfukvrcXdKeu0vac3dJe+4uac/dJe25u6Q9d5e05+6S9txd0p67S9pzd0l/7i7pz90l/bm7pD93l/Tn7pL+3F3Sn7tL+nN3SX/uLunP3SXjubtkPHeXjOfukvHcXTKeu0vGc3fJeO4uGc/dJeO5u2Q8d5dsz90l23N3yfbcXbI9d5dsz90l23N3yfbcXbI9d5dsz90l23N3yf7cXbI/d5fsz90l+3N3yf7cXbI/d5fsz90l+3N3yf7cXbI/dZfUy+W5j5XnPrY897H1uY/V5z7WnvtYf+5j47mPbc997Lm7pDx3l5Tn7pLy3F1SnrtLynN3SXnuLinP3SXlubvkudxrfS73Wp/Lvdbncq/1udxrfS73Wu3caynlDx+7/Rfdvi/7r7/ue13e/3r8WqL5L9H9l7hzp47yzndrX1xiO2CJbX1fYmv9ZondfYl7Oegjlyj+Syz+S6z+S1T/JZr/Et1/ieG/xCGne7+8P0DKzQNk3d2XqBf/JYr/Eov/Eqv/EtV/iea/RPdfYvgv4X+6q//pbv6nu/mf7uZ/upv/6W7+p7v5n+7mf7qb/+lu/qe7+Z/u7n+6u//p7v6nu/uf7u5/urv/6e7+p7v7n+7uf7q7/+ke/qd7+J/u4X+6h//pHv6ne/if7uF/uof/6R7+p3v4n+7N/3Rv/qd78z/dm//p3vxP9+Z/ujf/0735n+7N/3Rv/qd79z/du//p3v1P9+5/unf/0737n+7d/3Tv/qd79z/du/vpbpeL/xLFf4nFf4nVf4nqv0TzX6L7LzH8l9j8l/A/3cX/dBf/0138T3fxP93F/3QX/9Nd/E938T/dxf90F//Tvfif7sX/dC/+p3vxP92L/+le/E/34n+6F//Tvfif7sX/dK/+p3v1P92r/+le/U/36n+6V//Tvfqf7tX/dPvXqjX/WrXmX6vW/GvVmn+tWvOvVWv+tWrNv1at+deqNf9ateZfq9b8a9Waf61a869Va/61as2/Vq3516o1/1q15l+r1vxr1Zp/rVrzr1Vr/rVqzb9WrfnXqjX/WrXmX6vWDqlVe9hd1Q6pVTOWGP5LbP5L7O5LHFKrZixR/JdY/JdY/ZfQp/vBuNF/+K2//rlI+/oij/ur2p1qtUOXGP5LbP5L7O5L3KlWO3SJcsQSD19K2+K/xOq/RPVfovkv0f2XGP5LbP5L7O5L7Bf/JfxP9+5/unf/0737n+79iNP9WIPs3X+J4b/E5r/E7r1Ev1z8lyj+Syz+S6z+SzxlBdAv/bmPjec+9tu3/Z+v/9V//K3+p6xy2d/mtpSyrB8f3ZYfK+p/nLI+tD/xIf0PSA8/dP2v8eNvdWlKf3fD2MYnO67xk+Tl9z9Sfv8jy+9/ZP39j9Tf/0j7/Y/03//I+P2PyPttvyy/PrIv5Q8fuT3l67vjzbp93C9L2f/69bvr1+sSh+O+vvh+/eL79avv19ff+/ofH2m//5H++x+Rp2Bvb6dgH4sR9zLe/nbZb+PefL9+d/16/dT/na//dFOM+oevv/3bfX8TAOVSLn+7Ubq+4JuuZTnRtawzr2WpH45l4+Z2qee5lHaeS+nnuZRxnkvZznMp+2kupU194D589rdynktZznMpRz5tb2VSq75f33y/vvt+/fD9+s336/VT5v67/XeFgK4TOXKB4r3A8uUFHj5ddYHIgd9fnb+/OX9/d/7+4fz9m/P3f/0IP3y5jIvz9xfP7//P63/+v//4f/7yj//tn//p364f+fF//b//8t///S//+i+//vPf/7///fP/cv3j/x8=","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_notes_internal","get_collapse_hints","pack_arguments","call_private_function_internal","directive_invert","directive_integer_quotient"]},{"name":"register_participant","is_unconstrained":false,"custom_attributes":["private","interal"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"participant","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"participant_name","type":{"kind":"string","length":60},"visibility":"private"},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"escrow","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+ydB5xTRdfGF3ZZlo5YsFKUIv1Okk2h9957h2yyAcTeFREUFRGx995777137L1iV0RAFGwo+J0rd2WII8uSZ0Ke7735/Z43s0ff8X/mTDm5M/feSnkbPoE2eXmnBTaUK4nyve/KokZptrJvvVxgsBUa/r81DbbaBltdg62ewVZf1DXN1tDw7zUy2BobbHsabM0Mtr1FRWm2FgZbS4OtlcHW2mBrY7C1NdjaGWyOwaYMtoDBFjTYQgZbscEWNtgiBlvUYIsZbO0Ntg4GW0eDrZPB1tlg62KwdTXYuhls3Q22HgZbT4Otl8HW22DrY7D1Ndj6GWz9DbYBBttAg22QwTbYYBtisA012IYZbMMNthEG20iDbZTBNtpgG2OwjTXYxhls4w22CQbbRINtksE22WCbYrBNNdjiBluJwZbwbPqnkvfd1fsOOuFQqDQSKFVBFXcCsZJosRMqLglHVVQVR4uTgWgwWBoNRSOxkljEialQsFSlimPBlLPhc1LljXU5GX0CCZuc87eaM/Qvi8u2U96Gta6M1W2H9V65ed7G8t5aeb7375T9/06WvxeIThEtrLzRXvbJT2sDJ7OPagGs6+TKuNicCutDjmOz/VoC61oAbL9FJO3XCljXKcD2Ow3Yfqa54VRtbliklU/TygvT5obT5e8zRGeKzsrC3NAaWNfpwNicTdK32wDrOgPYfueQtF9bYF1nAtvvXMtzw9naHHCOVj5XK5+VNjecJ3+fL7pAdGEW5oZ2wLrOA8bmIpK+7QDrOh/YfheTtJ8C1nUBsP0usTw3XKTNARdr5Uu08oVpc8Ol8vdlostFV2RhbggA67oUGJsrSfp2EFjXZcD2u4qk/ULAui4Htt/VlueGK7U54CqtfLVWviJtbrhG/r5WdJ3o+izMDcXAuq4BxuYGkr4dBtZ1LbD9biRpvwiwruuA7XeT5bnhBm0OuFEr36SVr0+bG26Wv28R3Sq6LQtzQxRY183A2NxO0rdjwLpuAbbfHSTt1x5Y163A9rvT8txwuzYH3KGV79TKt6XNDXfJ33eL7hHdm4W5oQOwrruAsbmPpG93BNZ1N7D97idpv07Auu4Btt8DlueG+7Q54H6t/IBWvjdtbnhQ/n5I9LDokSzMDZ2BdT0IjM2jJH27C7Cuh4Dt9xhJ+3UF1vUwsP0etzw3PKrNAY9p5ce18iNpc8MT8veToqdET2dhbugGrOsJYGyeIenb3YF1PQlsv2dJ2q8HsK6ngO33nOW54RltDnhWKz+nlZ9Omxuel79fEL0oeikLc0NPYF3PA2OzmKRv9wLW9QKw/V4mab/ewLpeBLbfK5bnhsXaHPCyVn5FK7+UNje8Kn+/Jnpd9EYW5oY+wLpeBcbmTZK+3RdY12vA9nuLpP36Aet6Hdh+b1ueG97U5oC3tPLbWvmNtLnhHfn7XdF7ovezMDf0B9b1DjA2H5D07QHAut4Ftt+HJO03EFjXe8D2+8jy3PCBNgd8qJU/0srvp80NH8vfn4iWiD7NwtwwCFjXx8DYfEbStwcD6/oE2H6fk7TfEGBdS4Dt94XlueEzbQ74XCt/oZU/TZsbvpS/vxJ9LfomC3PDUGBdXwJj8y1J3x4GrOsrYPstJWm/4cC6vga233eW54ZvtTlgqVb+Tit/kzY3LJO/vxctF63IwtwwAljXMmBsVpL07ZHAur4Htt8PJO03CljXcmD7rbI8N6zU5oAftPIqrbwibW74Uf7+SbRatCYLc8NoYF0/AmPzM0nfHgOs6ydg+/1C0n5jgXWtBrbfr5bnhp+1OeAXrfyrVl6TNjf8Jn//Llor+iMLc8M4YF2/AWPzJ0nfHg+s63dg+60jab8JwLrWAttvveW54U9tDlinlddr5T/S5oa/Km8IQCVR5Xz7c8NEYF1/AWOTn8/RtycB68rLx7VfAUn7TQbWVQnYflXy7c4Nbv8umwMKtHIVrVw5f9O5oVD+rioqElXLwtwwBVhXITA21Un69lRgXVWB7VeDpP3iwLqKgO1X0/LcUF2bA2po5ZpauVra3FBL/q4tqiOqm4W5oQRYVy1gbLYj6dsJYF21ge1Xj6T9ksC66gDbb3vLc8N22hxQTytvr5Xrps0NO8jfO4p2EtXPwtxQCqxrB2BsdrYcm521GOyolXfSyvXTYrOL/L2raDfR7obYVAbHplkerj33wLWn0p8/69bbyHI77AHsVw0stUMDrx2qaH0s/VMJ3C7NcXU5tTTOht4k08j7bux97+l97+V9N/G+m3rfzbzv5t733t53C++7pffdqqzRyr7d/0ClNFsTg625wdbSs7kNXycvOw3fEDw5lX1a51sEbp2Pr7cNcGTa8rtN/sYGBtXrZLOzNbLU2drmWwRua6Gztcvxzub63c5CZzOxZup/Y29goJdq5ITg5HMO2D0tDViVbxFYWRiwgRwfsK7fAfLVYS9LnS2YbxE4aKGzhXK8s7l+h0hWhybewECvDsgJoTjfbhs6mX3+zlacfHxswjnut9vHiy34HSHNBppamqCj+RaBoxYm6FiOT9Cu3zHybKCZpc7WPt8icHsLna1Djnc21+8OJNlAc29goLMB5ITQMcdXRXfVjlhYFTvluN9uH+9owe/OpNnA3pYm6C75FoG7WJigu+b4BP13oMizgRaWOlu3fIvA3Sx0tu453tlcv7uTZAMtvYGBzgaQE0KPHF8V3VW7s4VVsWeO++328R4W/O4F9rvsg+bsDeMMhmxy9tl6zmS6wXT4prd2yKahVm6klfvkb3r4pq/83U/UXzQg3/7BqMa4PqX6Aue2gZb6Orr9gLtgqh+w/QaRtB9wY0f1B7bfYHBSmT43DNTmgEFaebBWHpA2NwyRv4eKhomGZ2FuaAKMzRBgbEaQ9G3gNXE1FNh+I0naD3iZVw0Dtt8oy3PDCG0OGKmVR2nl4Wlzw2j5e4xorGhcFuaG5sDYjAbGZjxJ3wZeIVNjgO03gaT9gBd91Fhg+020PDeM1+aACVp5olYelzY3TJK/J4umiKZmYW5oCYzNJGBs4pZjE9diMFkrT9HKU9NiUyJ/J0RJUWn+pvXpMUFcM+ll4ZpEChjrPO2D5pyG40yZ+JzMPsrtBykL8ZlOcs1oxtZzBtMNprE5TRuD07VyK608I21s7iN/zxTtK9ov3/6NUM2B7bmP5bnuv65nNd5Me+4vfx8gOlB0kNeeVfI23STSywfne/9C5bzs7CQB7xJ0Kmuch3gr7KH5aQ6gV95SYA86ZMtX3kQ5dalDgb0xmx1i/3w7HeIwL/CH2+4Q+wPTp8OAHeJw0g5xsKUOcYQX+CNtd4iDgR3iCGCHOBK8XtUQ1dTacSNnKBAuDYfipaVBpzQWiyZUMBFNlJYmkvFgPBKJOpFkSWk8WRwoSQRSwZKUUxovjRarklBJRDkJtT6tPiX+FofjTjiaCksmEggGQk4iFi4JJePFoUgoHJbqgiXRiFKJ4oBKRELRgArEVXFJQja3SuPh9dj4OukdPhANFCcisUQiHC9OlJSUlqYiyXA8mlIl4bgKlAQFJh4MRkMhJ16aKi0JBWNhFYomohKhSMIJxf7lr4Q2lVSudyURJxxIhkuK3cCXBsMlMScSDAeLnVQ4VRJ3VCAQTYTE5YATixU7sVRxRBYo2/46pckSVRqIBRPBRGlMlaTEiVIpxuPFTjKQKA6pVDyWlA4oXOKuEyxNlahEKh5IlASDxZHUv/wNhlQyHClOxSW6pYnSoARcekcwEQ+GpB2CJSpWEi6NRcIBJxSOiC0kzRcIJULSysnSYLF1f0PSzkEJlgw1R8ZcMhENlEbjxcXxWHEgGUqmAk6gOJwqdWSsJWOhmJglJnH5FePES1Lq33zxqNsyYdnhlP9JFSejMoxDsWQompKhE0o60j2ckli0NBlRkXispDgYiKfCQRkZxUEnElM2/C3y6nLLh2j55aFa+TCtfLhWPkIrH+mVgXwhtL9ufUcJ59GiWfkb0t+yNPi/PihfbNQtXbKkJBhKVsrbuJblafEE8kPTd1uMyIzSFuPBFhhtcB5FwtkgHz//u59jbA+oYyw1MPrCSQNgUjsbeEGzbNJzv916G+Vl98kpwCdSbfLklGO9jjfH+57rfR/nfR/vfc/zvk/wvk/0vk/yvud73yd73wu871PKGq3se27+v5+IMs9gO8lgW5Cf/SenHGtpxC/Mtwi8MB9f76nAkWnL71O1aRRUb1bPv8+x1NkW5VsEXmShs52W453N9fs0C53NxJqp/3O9gYFeqpETwun5nAP2OEsD9ox8i8BnWBiwZ+b4gHX9PpN8dTjeUmc7K98i8FkWOtvZOd7ZXL/PJlkd5nkDA706ICeEc/LttqGT2efvbOV0Cyc+zs1xv90+fo4Fv88jzQZOsDRBn59vEfh8CxP0BTk+Qbt+X0CeDZxoqbNdmG8R+EILne2iHO9srt8XkWQDJ3kDA50NICeEi3N8VXRX7fMsrIqX5Ljfbh+/2ILfl5JmA/MtTdCX5VsEvszCBH15jk/Qrt+Xk2cDJ1vqbFfkWwS+wkJnuzLHO5vr95Uk2cACb2CgswHkhHBVjq+K7qp9qYVV8eoc99vt41dZ8Psa8ES3uSd9HKuV5+T/95M+rpW/rxNdL7oh3/5deXOBBxuuBY7FG8F90lb7AXdt1HXA9ruJpP2AGxHqemD73Wx5brhRmwNu0so3a+Ub0uaGW+TvW0W3iW7PwtwwDxibW4CxuYOkbwOv4apbge13J0n7AS9LqtuA7XeX5bnhDm0OuFMr36WVb0+bG+6Wv+8R3Su6Lwtzw0nA2NwNjM39JH0beEVH3QNsvwdI2g94kULdC2y/By3PDfdrc8ADWvlBrXxf2tzwkPz9sOgR0aNZmBsWAGPzEDA2j1mOzWNaDB7Wyo9o5UfTYvO4/P2E6EnRU/n2nvTh/sa/xsJv6KeBsTb57WT2UW77Pm3B72cs9yX9yRTPaOVT8v/7SQrPyt/PiZ4XvZBv/8kUSWB7PgvemdH7kv5B9y9br6F90ZuUX/K+F3vfL3vfr3jfr3rfr3nfr3vfb3jfb3rfb3nfb3vf7+TnbXpDxOL8f98k8YbB9nZ+9m+ceBE82Mo+7+ZbBH43H1/ve8DV0Jbf7+VvbGBQvVnd/nrJUmd7P98i8PsWOtsHOd7ZXL8/sNDZTKyZ+r/YGxjoJRg5IXyYzzlgX7Y0YD/Ktwj8kYUB+3GOD1jX74/JV4dXLHW2T/ItAn9iobMtyfHO5vq9hGR1eNUbGOjVATkhfJpvtw2dzD5/ZysfWvih/1mO++328U8t+P05aTbwmqUJ+ot8i8BfWJigv8zxCdr1+0vybOB1S53tq3yLwF9Z6Gxf53hnc/3+miQbeMMbGOhsADkhfJPjq6K7an9uYVX8Nsf9dvv4Nxb8XkqaDbxpaYL+Lt8i8HcWJuhlOT5Bu34vI88G3rLU2b7Ptwj8vYXOtjzHO5vr93KSbOBtb2CgswHkhLAix1dFd9VeamFVXJnjfrt9fIUFv3+wfPhBv3HiRa38Uv5/3zixSv7+UfSTaHW+/UNOi3FtoFYBx+IacJ+01X7AXRv1I7D9fiZpP+BGhPoJ2H6/WJ4b1mhzwM9a+RetvDptbvhV/v5N9LtobRbmhleBsfkVGJs/SPo28Bqu+g3Yfn+StB/wsqT6Hdh+6yzPDX9oc8CfWnmdVl6bNjesl7//yt9gqFRgf254Axib9cDYVC7g6NvAKzrqL2D75ZO0H/AihcorwLVfQYHducHt32VzQL5WLtDKlQo2nRuqSKFQVFVUlIW54W1gbKoAY1PNcmyqaTEo1MpVtXJRWmyqS6GGqKaoVoG9Gyfc3/g/WPgNXbsAOA7z8NcO3PZ1GdF+17Hcl/QbJ+po/eed/P++caKuFLYT1RNtX8D1Ss+6ltvzBK3dTtTKJ22mPXeQwo6inUT1s9CeOwDnup319gw74XAsFXJKg05KOQFHhWKxElUcjKvS4oQKx6LJcGlC/juJYLQ4Fi9ORpPRUCiuoiWJYHEyFM3m5sPO4H5Q9tmlwCLwLgX4encFdgZbfu+qjQhQvX/vdLnVVs6z39l2sJTsgtskoE88u3l/7O597+F9N9D6IHy12xW4yut3Ye1RsPHOrPQZezdt1dtdK+9R8N8zdkMpNBI1Fu25mWzKyezzd8fZ1UJW8XiT3N7Fc31uaMHvJ5rYGYgFYE7ghKEaAusC9hv1hOU+6GT2Ue7CYGPs7QXOPMrmOLfeRl69aOaytkBnopWBjE0stWsTrV3LPugrGcA+oZoAE7qmltq06Wb6qpPZRxXm2Rm3zSy1RTOL47bQ0rgtBDI2t9SuzbMwboF9QjUHjtu9LbXp3hbHbc08O+O2haW2aGFx3Na0NG5rAhlbWmrXllkYt8A+oVoCx20rS23ayuK4rZ1nZ9y2ttQWrS2O29qWxm1tIGMbS+3aJgvjFtgnVBvguG1rqU3bWhy3dfPsjNt2ltqincVxW9fSuK0LZHQstauThXEL7BPKAY5bZalNlcVxWy/PzrgNWGqLgMVxW8/SuK0HZAxaatdgFsYtsE+oIHDchiy1acjiuK2fZ2fcFltqC71eNHN9S+O2PpAxbKld9XrzLI1bYJ9QYeC4jVhq08hm+qqT2Uc1zLMzbqOW2iJqcb1taGncNgQyxiy1aywL6y2wT6gYcNy2t9Sm7S2ut43y7IzbDpbaooPFcVvWFuhx2wjI2NFSu3bMwrgF9gnVEThuO1lq004Wx23jPDvjtrOltuhscdyWtQV63DYGMnax1K5dsjBugX1CdQGO266W2rSrxXG7Z56dcdvNUlt0szhu97Q0bvcEMna31K7dszBugX1CdQeO2x6W2rSHxXHbLM/OuO1pqS16Why3zSyN22ZAxl6W2rVXFsYtsE+oXsBx29tSm/a2OG5n59sZt30stUUfi+O2rC3Q43Y28I73vpbatW8Wxi2wT6i+wHHbz1Kb9vPaNJt3JDYAP+2j7NO/wCJw/wJ8vQOAHcSW3wMKNjYwqN6/70isZOhg7mdggdcbK+dlpzcOBI6syhrnIK/hBhekOYCesgYCe9GgLa8rUU5dajB4yqqhtR2y/dZvvr5AIqWCxaWRYiccDxUnw8FAMhBxkqHilJKGCMRC0gypRCiajAaCqUAkkFiP5fvb98pa53djVHa75mCvPES+h4qGFWwYPHXzsnO/7zBgjA24qLoDelsM9wbkiAKvQcrWQvcfrEsDQA/WYYDBWpra8BkOHPgjLAUSnacifR6p1aWiwUAgEnT/vWjSUaGkTG+BQLIk5CSceCJQGgupWCoUCAUTyUSJ1BlXKScVT8RS0Q1c2cyfRoIn1rLPqAKLwKMs5E+jczx/cv0ebSF/MrEiJoDRFn5kj7H0w2VMwcYUUc8M3L9f1h5B84pWftV7XFN5q+lY+R4nGp/l1XQ84Wo6wevfE9NX0wlZWE3HA1fTCcDJZCLJaor0eRLpajrJ0mo6ucAi8GQLq+mUHF9NXb+nkKymEz1WdL1TLa2mUwv+vcKh44ecFG2zjgWyNvLqiUudJaKEKCkqFaVE00TTRTNE+4hmivYV7SfaX3SA6EDRQaKDRYeIDhUdJjpcdIToSNFRoqNFs0THiGaLjhXNEc31Vmc95i5PUd6mthKDLWGwJQ22UoMtZbBNM9imG2wzDLZ9DLaZBtu+Btt+Btv+BtsBBtuBBttBBtvBBtshBtuhBtthBtvhBtsRBtuRBttRBtvRBtssg+0Yg222wXaswTbHYJvr2fRP2VTe1ft2MvtsMmYznWfjsMTSUSVArqeb2Eks02ORic9uLBKQ9tsQ12TmdQXKrkmXAmPxTC7HIrTxOnwqM58d/Zr+tEzqCmy6PzAdGItnczMWTvqeyIyt9Dmc+vf+yj5bV1fUtFczExiL53ItFlHz/tS+Ffc58l97XftVtK7If++b7Q+MxfO5E4vA5vYKD6iIz5HN7zseuOV1lbuHeRAwFi/kQiwi5XKqg7fMZ2cLfFaHbEldzha1nzoUGIsXt20sireQUx1Wns+hLfZZHb7ZukKpCrSfOgIYi5e2VSwiFeJUR/63z9EK+qyO+o+6YqkKt586GhiLxdmPhbMVnGqWyWdnq3xWx/y7LrWV7admA2PxcjZjkdxqTnXspj4HM/BZzdHqCqQyaj81FxiLV7IUCyezjwJeH1DA37dK/32WaSxeJYkF8HeQAubx6gVgLF4jiQUw31PAfEUtBsbidZJYANc1BZyX1avAWLxhKRboAxTA8auA/U8h28/tv+3yNt46MtfbEzvW2yM7xtszO9rbQ3PzfPf3jft7yf395f7udH/Hur+L3esB7vUF93qFe53Gve7jXkdyr5+51+Pc63vudU33Oql73dW93uxev3avh7v7APGCvH990g91ZNr3xgHznuMKYIc6nGwe6tC5nQw/Ou/xBRaB3crR9c4DdgZbfs/TBgWo3r87W9ldJLY727gCO5N9eptkOgD1jnyC1tfgp1Tm4Rpkk5db6dAVZE6Ud+TMZXbrr+gRu/Ia/QTgADwRPKuVtatb79yt7AvK3e1VTsqJBeRKTiQRjpTEkoGSaDwVTBUHk8GtbdfyOjuyXU+y1K4nbX27/r/or/Mttev8//H+erKldj3Za9ds3n6JXDz1xX6Bl1Sc4q4ZNha4EyxkayeAMwlbfld0cDgV8DtTxoWW29DJ7KPcjrmwAB+bUy1NCqduZrJ1MvuoUyy1xSJLbbHIYluMs9QWnzfJ7TnF1nj4Ytv6Xe7RElt9/0uSS4/AfqmAsVbI9nMTKfcNgqarEHkVbM/y+pNep401C9UmelJ52uauQjiZfdRCS4vAaZu5ClFONaq8/47LfJqFSeFbS5NCQQVjVpHkLVOfTy/IzQkGGQu9X56uJSdbG5/y2hwZnzP0vYVgUMZGMqJSyVSwOBILlKhwMBxOhVKRcDSUTBWH4slIqQrFg4FYacRJqWhpaaQ4mIiEU7FkIpzSJ22VDAZDyVhJQhUHwvESJ5oMxp1UKBKUH/zJYCSZDEbD4XgwmAxHU9GY/EiXn/5RpzgSiTnhQDAWsBWfM7Rf16hFobyrOXqdLIvCmYyLwpmWF4UzLSwK3+XIovCfnTiy4c585KRzVo4uCt9ZmnTOAiwK5V3aRMbn7BxdFGzF5+z/R5dcz/E61rmmS65OZp//3O9A7lVmWhfw8q2yEfiyNswnacNM6zovx+PhDpjzLCzs51tKcs63ePnzXEttcYGltrjA8qVgG23xfY5fCrY1Hpbn+KVgW31/BcmlYGC/VMBYK2T7/X+5FHyOpV/9F9r81X+epUXgQou/+l3mCy1MCj+SXAo+D5gIXlSQmxMMMhZ6v7woC5eCkfG5GPirfwXwV7+t+FxsiE9Fz9SUd+kXGZ9LLM2flwDaobyrU8h2uNRSO1xK1h8us9QOl5H1h8sttcPlW7BVlMuJnQEX1o/1pPEKxqTxCstJ4xUWksbVWUoaMzwVD53krgTWhUwakbHQ++WVW5A0Znq6HhmfqwpwiR4yabQVn6sAi2M5H+gzM66GzZ9RKwex53lX3dA7Ssg+fk2O72C4Mb7GwnpzraW11603/Tm0aPbrgOwud7u8f39Q9f9XGziZfRSyDWwxXo9mZBlcP+f4NpDr8/UW/P4lR658lvPZpGNm6vMNwAUE2G8UMhaWJ8l/tlP+FyfJG/5XJ8kbC+xOkk5mH+X6fKMFv2+ylHndpGVeNm5LNWXyTmYfhczkb87x/uT+8rvZQn+6hWAc3WLB71stjaNbNzOOnMw+1uaU35v8b/aBtVk6f5Mp523AJBEYa4VsP30M3eaNIf/XtT3G220njohfmbdbGPTrSH5l3k4w6DONxXqSCfgOYCyA/U8h28//lW5vsr2jwE4/h0+OdwI7OuvqfSdBh7qLpUPdjQMNsHaouwk61D0sHepeHGiQtUPdS9Ch7mPpUPfjQEOsHep+gg71AEuHehAHWszaoR4k6FAPsXSoh3GgYdYO9TBBh3qEpUM9igONsHaoRwk61GMsHepxHGiUtUM9TtChnmDpUE/iQGOsHepJgg71FEuHehoHGmftUE8TdKhnWDrUszjQEtYO9SxBh3qOpUM9jwNNsHao5wk61AssHepFHGiStUO9SNChXmLpUItxoKWsHWoxQYd6GcnIGqhp+bnP+ArLyH8VBqpob5l8lWDkv8bSoV7HdSjac0avE3SoN1g61Ju4DkV7zuhNgg71FkuHehvXoWjPGb1N0KHeYelQ7+I6FO05o3cJOtR7LB3qfVyHoj1n9D5Bh/qApUN9iOtQtOeMPiToUB+xdKiPcR2K9pzRxwQd6hOWDrUE16FozxktIehQn7J0qM9wHYr2nNFnBB3qc5YO9QWuQ9GeM/qCoEN9ydKhvsJ1KNpzRl8RdKivWTrUN7gORXvO6BuCDvUtS4daiutQtOeMlhJ0qO9YOtQyXIeiPWe0jKBDfc/SoZbjOlSKtUMtJ+hQK5CM7rt5quZtfBaUC9s4LWiVwQ4AH0qrbiEI2F0EjPcQMN5HwPgAAeNDBIyPEDA+RsD4BAHjUwSMzxAwPkfA+AIB40sEjC8TML5CwPgaAeMbBIxvETC+Q8D4HgHjBwSMHxEwfkLA+CkB4+cEjF8SMH5NwPgtAeN3BIzfEzCusMCYB2UMRvIMH0zdAWWvbseprMWsrM6V0t4/iFaJfhT9JFotWiP6WfSL6FfRb6LfRWtFf4j+FK0TrRf9JXIvKlcSVRbliwpEVUSFoqqiIlE1UXVRDVFNUS1RbVEdUV3RdqJ6ou1FO4h2FO0kqi/aWbSLaFfRbqLdRXuIGogaihqJGov2FO0laiJqKmomai7aW9RC1FLUStRa1KbKhjZoW8VrlLK3rLiNUpRm+8FgW2Ww/Wiw/WSwrTbY1hhsPxtsvxhsvxpsvxlsvxtsaw22Pwy2Pw22dQbbeoPtL4PN7TTptkoGW2WDLd9gKzDYqhhshQZbVYOtyGCrZrBVN9hqGGw1DbZaBlsdg62uwbadwVbPYNveYNvBYNvRYNvJYKtvsO1ssO1isO1qsO1msO1usO1hsDUw2BoabI0MtsYG254G214GWxODranB1sxga26w7W2wtTDYWhpsrQy21gZbG4PNnfy65m36Qb8kRt/8y6G38qmVlpKNyuD2A24mqh9IfAZuTqpVJD4DNzvVjyQ+AzdP1U8kPgM3Y9VqEp+Bm7tqDYnPwM1i9TOJz8DNZ/ULic/AzWz1K4nPwM1x9RuJz8DNdvU7ic/AzXu1lsRn4GEA9QeJz8DDBepPEp+BhxXUOhKfgYcf1HoSn4GHKdRfJD4DD2eovCocPgMPe6hKJD4DD4+oyiQ+Aw+jqHwSn4GHW1QBic/AwzKqConPwMM3qpDEZ+BhHlWVxGfg4SBVROIz8LCRqkbiM/DwkqpO4jPwMJSqQeIz8HCVqkniM/CwlqplyedKaT47mX1U7SqZt19pyv0k4u65oyItLpU0Tlv8Nva80Yz+zbMYRv/mWQyjf/MshtG/eRbD6N88i2H0b57FMPo3z2IY/ZtnMYz+zbMYRv/mWQyjf/MshtG/eRbD6N88i2H0b57FMPo3z2IYGW+exdQbtdamdavkfty3I2CsR8C4PQHjDgSMOxIw7kTAWJ+AcWcCxl0IGHclYNyNgHF3AsY9CBgbEDA2JGBsRMDYmIBxTwLGvQgYmxAwNiVgbEbA2JyAcW8CxhYEjC0JGFsRMLYmYGxj6axkHpQzEDCda2wn7I5IiQKioCgkKhaFRRFRVBQTtRd1EHUUdRJ1FnVxfRd1E3UX9RD1FPUS9Rb1EfUV9RP1Fw0QDRQNEg0WDRENFQ0TDReNEI0UjRKNFo0RjRWNE40XTRBNFE0STRZNEU0VuYc3S0QJUVJUKkqJpommi2aI9hHNFO0r2k+0f5UNbXBAlbxNH8LUzvBgJsdgUwZbwGALGmwhg63YYAsbbBGDLWqwxQy29gZbB4Oto8HWyWDrbLB1Mdi6GmzdDLbuBlsPg62nwdbLYOttsPUx2PoabP0Mtv4G2wCDbaDBNshgG2ywDTPYhhtsIwy2kQbbKINttME2xmAba7CNM9jGG2wTDLaJBtskg22ywTbFYJtqsMUNthKDLWGwJQ22UoMtZbBNM9imG2wzDLZ9DLaZBtu+Btt+Btv+BtsB2kJV9ilbFMrsmd6EADzQrtpVsbOwon1GPhDOIfEZ+UA4ReIz8oFwARKfkQ+EC5L4jHwgXIjEZ+QD4YpJfEY+EC5M4jPygXAREp+RD4SLkviMfCBcjMRn5APh2pP4jHwgXAcSn5EPhOtI4jPygXCdSHxGPhCuM4nPyAfCdSHxGflAuK4kPiMfCNeNxGfkA+G6k/iMfCBcDxKfkQ+E60niM/KBcL1IfEY+EK43ic/IB8L1IfEZ+UC4viQ+Ix8I14/EZ+QD4fqT+Ix8INwAEp+RD4QbSOIz8oFwg0h8Rj4QbrAlnyul+exk9lFDqmTefmUPhLPJORTGGVU2+xDwhks1jGTcAG/gVMNJfAbeEKpGkPgMvMFUjSTxGXjDqhpF4jPwBlg1msRn4A21agyJz8AbdNVYEp+BN/yqcSQ+A28gVuNJfAbekKwmkPgMvMFZTSTxGXjDtJpE4jPwBmw1mcRn4A3dagqJz8AbxNVUEp+BN5yrOInPwBvYVQmJz8Ab4lWCxGfgDfYqSeIz8IZ9VUriM/ABACpF4jPwgQJqGonPwAcUqOkkPgMfeKBmkPgMfICC2ofEZ+ADGdRMEp+BD3hQ+5L4DHxghNqPxGfgAyjU/kCfpaq8ankb7j92P5U0n/M0m94WTmYf/4VaIEb/hVoYRv+FWhhG/4VaGEb/hVoYRv+FWhhG/4VaGEb/hVoYRv+FWhhG/4VaGEb/hVoYRv+FWhhG/4VaGEb/hVoYRv+FWhhG/4VaiHr9F2rZYPRfqIVh9F+ohWH0X6iFYfRfqIVh9F+ohWH0X6iFYfRfqIVh9F+ohWH0X6iFYfRfqIVh9F+ohWH0X6iFYfRfqIVh9F+ohWFkeaGWxbpVJa1ty+o8UNrlINHBokNEh4oOEx0uOkJ0pOgo0dGiWaJjRLNFx4rmiOaKjhMdL5onOkF0ougk0XzRyaIFolNEC0WnihaJThOdLjpDdKboLNHZonNE54rOE50vukB0oegi0cWiS0SXii4TXS66QnSl6CrR1aJrRNeKrhNdL7pBdKPoJtHNoltEt4puE91eJW/Tl9m4jZH+gpuDDLaDDbZDDLZDDbbDDLbDDbYjDLYjDbajDLajDbZZBtsxBttsg+1Yg22OwTbXYDvOYDveYJtnsJ1gsJ1osJ1ksM032E422BYYbKcYbAsNtlMNtkUG22kG2+kG2w0G240G200G280G2y0G260G220G2+2eTf9U9r67et+59GKnAy1N8GifkS92OojEZ+SLnQ4m8Rn5YqdDSHxGvtjpUBKfkS92OozEZ+SLnQ4n8Rn5YqcjSHxGvtjpSBKfkS92OorEZ+SLnY4m8Rn5YqdZJD4jX+x0DInPyBc7zSbxGflip2NJfEa+2GkOic/IFzvNJfEZ+WKn40h8Rr7Y6XgSn5EvdppH4jPyxU4nkPiMfLHTiSQ+I1/sdBKJz8gXO80n8Rn5YqeTSXxGvthpAYnPyBc7nULiM/LFTgtJfEa+2OlUEp+RL3ZaROIz8sVOp5H4jHyx0+mWfEYfCjqjSubtl40XO50J49z0xU5ozrNI4n42Cec5JJznknCeR8J5PgnnBSScF5JwXkTCeTEJ5yUknJeScF5Gwnk5CecVJJxXknBeRcJ5NQnnNSSc15JwXkfCeb0lzoJMOdWmf96QGecmtd2Yqc9abTcBfq+XXZep1DRHY+Fs6vXNiD7j1XYLpv/9XdutwFhUzu1YOGVe34Ybv+p2YF3Avqz0WGR0Taw0FXPvA6ubt/GaqpXYWO7bTiaf3O0zNm62/GfO0uN9R5UN33em3xTo/oMlaTb3X2qU53eUTCfUKgwTalqH3kqfA57P6g5g+90JHLS2YlEZHAtk+91lqKvESSSLVUk4GVGl8eJoIhELKhWIh+PhkkA0VVpSrKLFUakzEQ9E5T8XiCdUqRMPuy/ey6uTtzEZ1z/oBP0u4ASr895dxSKwWzm63nuAncGW3/dU2djAoHqNrIjJxGVFDdh/7v4ExuhecMcvW9DdehvLdzYzwRuAC/yNwAX+JuCicnMVO4sKaDwZM8H7vPF6f3omeJ8hE7zfZiboQd4MzD7uAw7G+7W6AsniUicWLYkGSuLBSEkoWBKLxaXesFLRVDLgJEOBVLEKhxOx0lhKBVMlxaXxcHE8Fk7+vXomK5FkH8j2e4A0+3jAUvbxYBWLwA9ayD4eyvHsw/X7IZLs436PFZ19IGP0sKXs4+FtkH2AzrL+XRvsjKjCnr20+XB/QCyM2ccj3nh9ND37eMSQfTyahetQDB0l04FdleQ61IoCXCb4CHBifBT4k6EqSSaIbL/HSDPBxyxlgo9XsQj8uIVM8IkczwRdv58gyQQf9VjRmSAyRk9aygSf3AaZ4KfABf5z4AKPvKvua8JM8ClvvD6dngk+ZcgEn85CJsjQUTId2NVIMsGvgZngU8CJ8WlgJliNJBNEtt8zpJngM5YywWerWAR+1kIm+FyOZ4Ku38+RZIJPe6zoTBAZo+ctZYLPb4NM8D3gAv8BcIFHPi/lE8JM8AVvvL6Yngm+YMgEX8xCJsjQUTId2DVIMsFPgJngC8CJ8UVgJliDJBNEtt9LpJngS5YywcVVLAIvtpAJvpzjmaDr98skmeCLHis6E0TG6BVLmeAr2yATfA24wL8BXOCRT8J8hzATfNUbr6+lZ4KvGjLB17KQCTJ0lEwHdi2STPAdYCb4KnBifA2YCdYiyQSR7fc6aSb4uqVM8I0qFoHfsJAJvpnjmaDr95skmeBrHis6E0TG6C1LmeBb2yATfAG4wL8EXOCR7zh4hTATfNsbr++kZ4JvGzLBd7KQCTJ0lEwHdh2STPAVYCb4NnBifAeYCdYhyQSR7fcuaSb4rqVM8L0qFoHfs5AJvp/jmaDr9/skmeA7His6E0TG6ANLmeAH2yATfAK4wD8FXOCRb697jjAT/NAbrx+lZ4IfGjLBj7KQCTJ0lEwH9nYkmeBzwEzwQ+DE+BEwE9yOJBNEtt/HpJngx5YywU+qWAT+xEImuCTHM0HX7yUkmeBHHis6E0TG6FNLmeCn2yATfAC4wD8EXOCR7yV/jDAT/Mwbr5+nZ4KfGTLBz7OQCTJ0lEwH9vYkmeBjwEzwM+DE+DkwE9yeJBNEtt8XpJngF5YywS+rWAT+0kIm+FWOZ4Ku31+RZIKfe6zoTBAZo68tZYJfZzMT9Bblu4CL8j3A7O2+AlwSs5IwE/zGG6/fpmeC3xgywW9tZoJEHSXTgb1jrmeChg6daSb4DXBi/BaYCe5Ikgki228paSa41FIm+F0Vi8DfWcgEl+V4Juj6vYwkE/zWY0VngsgYfW8pE/zeywT1D7p9lwPYg5Ho3982OVcAOMNxJ1YaDkdscq4EcJaUhCPx0mixTc4fEHFPhEtTwUjAJucqAGe8OJRKFQfjNjl/BHAWK6e0OBBJ2eT8CcAZK3GKw9FowibnagCnSkWDyVi8xCbnGkTcS0olvVMxl61+3qY/5vRL/PrBD/04sH6TmP7oAP2BUm75Ua28XCtfV7D15fu1eu7Uyiu08kqt/INWXqWVf9TKP2nl1Vp5jVf+Wb5/Ef0q+k30u2it6A/Rn1X+fcUEnT/9CVzvy34UrpM614v+cvOywg3Qei7g/vOivE1t6w22vww2t76itDZBb0v8Ccyn1gHq+vudYClHrQdy1W9q58doflosMvHZjcVfkPbbEFe376D6CLL9bI/xPyyM8UrSlpVF+aICwxivVPjvsVvZYMs32AqyMMb/AI6lSoW4MV65EMe1C8kYzy/EjfEC4BjfhWiMr7UwxqtIWxaKqrrj0TDGqxjGbqHBVtVgK8rCGF8LHONVgGO8EDjGdyMZ41WBY7wIOMZ3Ixrjv1sY49WkLauLaohqGsZ4NcPYrW6w1TDYamZhjP8OHOPVgGO8OnCM70EyxmsAx3hN4Bjfg2iM/2ZhjNeStqwtqiOqaxjjtQxjt7bBVsdgq5uFMf4bcIzXAo7x2sAx3pBkjNcBjvG6wDHekGiM/2phjG8nbVlPtL1oB8MY384wdusZbNsbbDtkYYz/Chzj2wHHeD3gGG9MMsa3B47xHYBjvDHRGP/FwhjfUdpyJ1F90c6GMb6jYezuZLDVN9h2zsIY/wU4xncEjvGdgGN8L5IxXh84xncGjvG9iMb4zxbG+C7SlruKdhPtbhjjuxjG7q4G224G2+5ZGOM/A8f4LsAxvitwjDclGeO7Acf47sAx3pRojFfC1eU08urZQ9qygaihqJGosWhP0V6iJqKmomai5qK9RS1ELUWtRK1FbURtRe1EjkiJAqKgKCQqFoVFEVFUFBO1F3UQdTTMKXsY5ooGBltDg62RwdbYYNvTYNvLYGtisDU12JoZbM0Ntr0NthYGW0uDrZXB1tpga2OwtTXY2hlsjsGmDLaAwRY02EIGW7HBFjbYIgZb1GCLGWztDbYOBlvHLKxB+pjN+NorcA1qAFyDmmfpxo5M16CGwDWoUeZ1/XOTSGNgLPbO5ViE/uFUe2bms6P5rPbKpK7AJu2nmgBj0SI3Y+GkcaqmW+lzOPUvn1Wzrasramg/1RwYi5a5FouokVPtXXGfI//hs2pR0boi/9l+qiUwFq1yJxaBzXCqVhXxObJZn1XrLa8rUU77qTbAWLTOhVhEyuVUbbfMZ2cLfFbttqQuZ4vaTznAWLTZtrEo3kJOpcrzObTFPqvAZusKpSrQfioIjEXbbRWLSIU4Vei/fY5W0GdV/B91xVIVbj8VBsaiXfZj4WwFp4qYfHa2ymcV/XddaivbT8WAsXCyGYvkVnOq9pv6HMzAZ9VBqyuQyqj9VEdgLFSuP1DBwwReH1DA37dK/32WaSwCJLEA/g5SwDxetQbGIkgSC2C+p4D5imoHjEWIJBbAdU0B52UVAMaiOEt7hU5mHwUcvwrY/xSy/cr2Bht53/p+RPp+hb6foe936Psh+n6Jvp+i77fo+zH6fo2+n6Pv9+j7Qfp+kb6fpO836ftR+n6Vvp+l73fp+2H6fpm+n6bvt+n7cfp+nb6fp+/36fuB+n6hvp+o7zfW1Mr6PQT6PQb6PQhFWlm/r0i/70i/L6lA34PSyvq9iPq9inlaWb//WL8/Wb9/eXft39fPXOhnMvQzGztrZf0cln5OSz/HtYNW1s9m6mc39bOddbWyfl5bP89ddt67bELpJH93FnVx82RRN1F3UQ9RT1EvUW9RH1FfUT9Rf9EA0UDRINFg0RDRUNEw0XDRCNFI0SjRaNEY0VjRONF40QTRRNEk0WTRFNFUUVxUIkqIkqJSUUo0TTRdNEO0j2imaN9Cr+/kbZwT3b9PkD/We+UTtfJJ+V78tX93UMHGfz7YK+8n9e4vOqBw808vLJtTunrfTmYfdUChnfUiD8sZ0NviwMIN3wcV5m262ev+g3VpAOiF6wDAj7sNG7Sp1IHAH4oHWQpkZXD7IX0+WKtLyYV+uUDv/nvRpOQESbnEHggkS0JOwoknAqWxkFzjCgVCwUQyIRcdo3GVclLxRCy14flLKptPezu4EJ9kuJ9DCi0CH1KIr/dQYGew5fehhRsbGFSvlae9HeSxous9DNxZyyZrt17bp+mQk6Jt1v2ArI28eg6XOo8QHSk6SnS0aJboGNFs0bGiOaK5ouNEx4vmiU4QnSg6STRfdLJogegU0ULRqaJFotNEp4vOEJ0pOkt0tugc0bne6qzH/PDCf5/QOsJgO9JgO8pgO9pgm2WwHWOwzTbYjjXY5hhscw224wy24w22eQbbCQbbiQbbSQbbfIPtZINtgcF2isG20GA71WBbZLCdZrCdbrCdYbCdabCdZbCdbbCdY7CdW2j/5N9+wPXrcFhi6agjgFy9SE7+HQlpvw1xPSrzuv45+Xc0MBa9SU7+zcrM501O/h2TSV1pJ/9mA2PRh+Tk37Fb6bPp5N+cravLePJvLjAWfUlO/h1XcZ//8+Tf8RWtazMn/+YBY9GP5OTfCRXxuZyTfydueV3lnvw7CRiL/iQn/+Zvmc9bdPLv5C2pawtP/i0AxmIAycm/U8rzuQIn/xYW4k7+nQqMxUCSk3+LCnEn/04rxJ38Ox0Yi0EkJ//OKMSd/DuzEHfy7yxgLAaTnPw7uxB38u+cQtzJv3OBsRhCcqoGeH1AAX/fqj7AUzVDSWIB/B2kgHm86g+MxTCSWADzPQXMV9QgYCyGk8QCuK4p4LyshgJjMYLk5B9w/Cpg/1PI9nP7bxdRI6++c709sbO9PbIzvT2z0709tEXentpCb49tgbfnNt/bgzvR25Ob5+3RHeft2c3x9vBme3t6s7w9vqO8PT93H8DdV0j/pB/qyLTv7Q/Me84rhB3qcLJ5qEPndjL86LznF1oEditH13sBsDPY8vsCbVCA6v27s7mqnGe/s+1faGeyT2+TTAeg3pEv1Poa/JTKBbgGUfousg5dQeZEeUfOXGa3/ooesSuv0S8EDsCLwLNaWbu69c7dyr6gpO0Sykk5sYBcyYkkwpGSWDJQEo2ngqniYDK4te1aXmdHtuvFltr14q1v1/8X/fUSS+16yf94f73UUrte6rVr2cKZjUwNuXjqi/1lXlJxubtm2FjgLrSQrV0IziRs+V3RweFUwO9MGa+w3IZOZh/ldswrCvGxudLSpHDlZiZbJ7OPutxSW1xlqS2ustgW+1tqi0TT3J5TbI2H5Lb1u9yjJbb6finJpUdgv1TAWCtk+5W9A9d0FSKvgu1ZXn/S67SxZqHaRE8qr97cVQgns4+6wtIicPVmrkKUU40q77/jMl9tYVKYkSN7QxVJ3jL1+ZrC3JxgkLHQ++U1WnKytfEpr82R8blW31sIBmVsJCMqlUwFiyOxQIkKB8PhVCgVCUdDyVRxKJ6MlKpQPBiIlUaclIqWlkaKg4lIOBVLJsIpfdJWyWAwlIyVJFRxIBwvcaLJYNxJhSJB+cGfDEaSyWA0HI4Hg8lwNBWNyY90+ekfdYojkZgTDgRjAVvxuVb7dY1aFMq7mqPXybIoXMe4KFxneVG4zsKiMDNHFoX/7MSRDXfmIyed63N0UZhpadK5HrAolHdpExmfG3J0UbAVnxv+H11yvdG75HqT6ZKrk9nnP/c7kHuVmdYFvHyrbAS+rA1R7xqy3YaZ1nVzjsfDHTA3W1jYb7GU5Nxi8fLnTZba4lZLbXGr5UvBNtpivxy/FGxrPOyf45eCbfX9A0guBQP7pQLGWh3gXwpO//y9ZqHaRE92b7P5q/9mS4vAbRZ/9bvMt1mYFA4huRR8MzARvL0wNyeYQyz9qrw9C5eCkfG5A/ir/wDgr35b8bnDEJ+Knqkp79IvMj53Wpo/7wS0Q3lXp5DtcJeldriLrD/cbakd7ibrD/dYaod7tmCrKJcTOwMurB/rSeO9jEnjvZaTxnstJI2H5cZzhBLZnOTuA9aFTBoPs5SU3LcFSWOmp+uR8bm/EJfoIZNGW/G5H7A4lvOBPjPjAdj8GbVyEPsC76obekcJ2ccfzPEdDDfGD1pYbx6ytPa69RZ5f3fJ+/cH9d8sqw/d3tcV5D7jw+hEkqXTHpHj2yuuzw9b8PtIkgePPAycmB8BTszAfqOQsbA8Sf6zTfG/OEk+8r86ST5aaHeSdDL7KNfnRy34/ZiljOaxwo1P1rdxu6cpQ3Yy+yhkhvx4jvcn9xfV4xb60xME4+gJC34/aWkcPbmZceRk9rE2p8xq+r/ZB47J0rmWTDmfAiaJwFirYyxdoXrK/3VtnfFp24kj4lfm0xYG/RySX5lPEwz6TGMxl2QCfgYYC2D/U3P9X+kUk+0zyMmWdVW8kyBQz/qBctTdBIF6zg+Uo+4lCNTzfqAcdT9BoF7wAyVXGggC9aIfKNmDIwjUS36gHPUoQaAW+4Fy1OMEgXrZD5SjniQI1Ct+oOQKHkGgXvUDJb/6CQL1mh8o+TFJEKjX/UDJbxSCQL3hB0pSX4JAvekHylHT8nOf8S0/UJJREYyot/1AyUJNEKh3/EDJ/E8QqHf9QMm0QhCo9/xASW8lCNT7fqCkEQgC9YEfKEd9SBCoD/1AOepjgkB95AfKUUsIAvWxHyhHfUYQqE/8QDnqC4JALfED5aivCAL1qR8oR31DEKjP/EA5ailBoD73A+WoZQSB+sIPlKOWEwTqS2Sg3GdoVs3beG+ZC9s4LWiVwQ4AH3Kh0Df62wjYswSMzxEwPk/A+AIB44sEjC8RMC4mYHyZgPEVAsZXCRhfI2B8nYDxDQLGNwkY3yJgfJuA8R0CxncJGN8jYHyfgPEDAsYPCRg/ImD8mIDxEwLGJQSMnxIwfkbA+DkB4xcEjF9aYMyDMgYjeYYPpu6Aslf3xjeTV9Lq/Era+2vRN6JvRUtF34mWib4XLRetEK0U/SBaJfpR9JNotWiN6GfRL6JfRb+JfhetFf0h+lO0TrRe9JfIvfBcSVRZlC8qEFURFYqqiopE1UTVRTVENUW1RLVFdUR1RduJ6om2F+0g2lG0k6i+aGfRLqJdRbuJdhftIWogaihqJGos2lO0V9UNbdCkqtcoZU9t/Mp7aqNu+9pg+8Zg+9ZgW2qwfWewLTPYvjfYlhtsKwy2lQbbDwbbKoPtR4PtJ4NttcG2xmD72WD7xWD71WD7zWD73WBba7D9YbD9abCtM9jWG2x/GWxup063VTLYKhts+QZbFYOt0GCrarAVGWzVDLbqBlsNg62mwVbLYKttsNUx2OoabNsZbPUMtu0Nth0Mth0Ntp0MtvoG284G2y4G264G224G2+4G2x4GWwODraHB1shga2yw7Wmw7WWwuZNf17xNP+iHTuqbfzn0lG/1laVkozK4/YCbieprEp+Bm5PqGxKfgZud6lsSn4Gbp2opic/AzVj1HYnPwM1dtYzEZ+BmsfqexGfg5rNaTuIzcDNbrSDxGbg5rlaS+AzcbFc/kPgM3LxXq0h8Bh4GUD+S+Aw8XKB+IvEZeFhBrSbxGXj4Qa0h8Rl4mEL9TOIz8HCG+oXEZ+BhD/Uric/AwyPqNxKfgYdR1O8kPgMPt6i1JD4DD8uoP0h8Bh6+UX+S+Aw8zKPWkfgMPByk1pP4DDxspP4i8Rl4eEnlVeXwGXgYSlUi8Rl4uEpVJvEZeFhL5VvyuVKaz05mH1VQNfP2K025n0TcvRG3SItLJY3TFr+NPW80o3/zLIbRv3kWw+jfPIth9G+exTD6N89iGP2bZzGM/s2zGEb/5lkMo3/zLIbRv3kWw+jfPIth9G+exTD6N89iGP2bZzGM/s2zGEbGm2cx9UattWlh1dyPe1UCxiICxmoEjNUJGGsQMNYkYKxFwFibgLEOAWNdAsbtCBjrETBuT8C4AwHjjgSMOxEw1idg3JmAcRcCxl0JGHcjYNydgHEPAsYGBIwNCRgbETA2JmDck4BxL0tnJfOgnIGA6VxjU2FvJmou2lvUQtRS1ErUWtRG1FbUTuSIlCggCopComJRWBQRRUUxUXtRB1FHUSdRZ1EXt41E3UTdRT1EPUW9RL1FfUR9Rf1E/UUDRANFg0SDRUNEQ0XDRMNFI0QjRaNEo0VjRGNF40TjRRNEE0WTRJNFU0RTRXFRiSghSlbd0AalVfM2fQhTU8ODmZoZbM0Ntr0NthYGW0uDrZXB1tpga2OwtTXY2hlsjsGmDLaAwRY02EIGW7HBFjbYIgZb1GCLGWztDbYOBltHg62TwdbZYOtisHU12LoZbN0Nth4GW0+DrY/B1tdg62ew9TfYBhhsAw22QQbbYINtiME21GAbZrANN9hGGGwjDbZRBttog22MwTbWYBtnsI032CYYbBMNtkkG22SDbYrBNtVgixtsJQZbwmBLGmyl2kJV9ilbFMrsmd6EADzQrppWtbOwon1GPhCuGYnPyAfCNSfxGflAuL1JfEY+EK4Fic/IB8K1JPEZ+UC4ViQ+Ix8I15rEZ+QD4dqQ+Ix8IFxbEp+RD4RrR+Iz8oFwDonPyAfCKRKfkQ+EC5D4jHwgXJDEZ+QD4UIkPiMfCFdM4jPygXBhEp+RD4SLkPiMfCBclMRn5APhYiQ+Ix8I157EZ+QD4TqQ+Ix8IFxHEp+RD4TrROIz8oFwnUl8Rj4QrguJz8gHwnUl8Rn5QLhuJD4jHwjXncRn5APhepD4jHwgXE9LPldK89nJ7KN6Vc28/coeCGeTszeMM6ps9iHgDZeqD8m4Ad7AqfqS+Ay8IVT1I/EZeIOp6k/iM/CGVTWAxGfgDbBqIInPwBtq1SASn4E36KrBJD4Db/hVQ0h8Bt5ArIaS+Ay8IVkNI/EZeIOzGk7iM/CGaTWCxGfgDdhqJInPwBu61SgSn4E3iKvRJD4DbzhXY0h8Bt7ArsaS+Ay8IV6NI/EZeIO9Gk/iM/CGfTWBxGfgAwDURBKfgQ8UUJNIfAY+oEBNJvEZ+MADNYXEZ+ADFNRUEp+BD2RQcRKfgQ94UCUkPgMfGKESJD4DH0ChkkCf3RdqVcvbcP+x+6mk+Zyn2fS2cDL7+C/UAjH6L9TCMPov1MIw+i/UwjD6L9TCMPov1MIw+i/UwjD6L9TCMPov1MIw+i/UwjD6L9TCMPov1MIw+i/UwjD6L9TCMPov1MIw+i/UQtTrv1DLBqP/Qi0Mo/9CLQyj/0ItDKP/Qi0Mo/9CLQyj/0ItDKP/Qi0Mo/9CLQyj/0ItDKP/Qi0Mo/9CLQyj/0ItDKP/Qi0Mo/9CLQwjywu1LNatKmltW1ZnStplmmi6aIZoH9FM0b6i/UT7iw4QHSg6SHSw6BDRoaLDRIeLjhAdKTpKdLRolugY0WzRsaI5ormi40THi+aJThCdKDpJNF90smiB6BTRQtGpokWi00Sni84QnSk6S3S26BzRuaLzROeLLhBdKLpIdLHoEtGlostEl4uuEF0pukp0tega0bVV8zZ9mY3bGOkvuJlmsE032GYYbPsYbDMNtn0Ntv0Mtv0NtgMMtgMNtoMMtoMNtkMMtkMNtsMMtsMNtiMMtiMNtqMMtqMNtlkG2zEG22yD7ViDbY7BNtdgO85gO95gm2ewnWCwnWiwXWawXW6wXWGwXWmwXWWwXW2wXWOwXevZ9E9l77ur951LL3ZKWZrg0T4jX+w0jcRn5IudppP4jHyx0wwSn5EvdtqHxGfki51mkviMfLHTviQ+I1/stB+Jz8gXO+1P4jPyxU4HkPiMfLHTgSQ+I1/sdBCJz8gXOx1M4jPyxU6HkPiMfLHToSQ+I1/sdBiJz8gXOx1O4jPyxU5HkPiMfLHTkSQ+I1/sdBSJz8gXOx1N4jPyxU6zSHxGvtjpGBKfkS92mk3iM/LFTseS+Ix8sdMcEp+RL3aaS+Iz8sVOx5H4jHyx0/EkPiNf7DSPxGfki51OIPEZ+WKnEy35jD4UdFLVzNsvGy92mg/j3PTFTmjOk0nivoCE8xQSzoUknKeScC4i4TyNhPN0Es4zSDjPJOE8i4TzbBLOc0g4zyXhPI+E83wSzgtIOC8k4byIhPNiEs5LSDgvtcRZkCmn2vTPyzLj3KS2yzP1WavtCsDv9bLrMvOa5mgsnE29vhLRZ7zarsL0v79ruxoYixNyOxZOmdfX4MavuhZYF7AvKz0WGV0TK03F3JcK1M3beE3VSmws920nk0/u9hkbN1v+M2fp8b6u6obv69NvCnT/wZI0m/svNcrzO0qmE+p8hgk1rUNvpc8Bz2d1HbD9rgcOWluxqAyOBbL9bjDUVeIkksWqJJyMqNJ4cTSRiAWVCsTD8XBJIJoqLSlW0eKo1JmIB6LynwvEE6rUiYdL3UWkTt7GZFz/oBP0G4ATrM57Y1WLwG7l6HpvAnYGW37fVHVjA4PqNbIiJhOXFTVgy+pFxuhmcMcvW9DdehvLdzYzwcuAC/zlwAX+CuCicmVVO4sKaDwZM8FbvPF6a3omeIshE7zVZiboQV4JzD5uAQ7GW7W6AsniUicWLYkGSuLBSEkoWBKLxaXesFLRVDLgJEOBVLEKhxOx0lhKBVMlxaXxcHE8Fk7+vXom55FkH8j2u400+7jNUvZxe1WLwLdbyD7uyPHsw/X7DpLs41aPFZ19IGN0p6Xs485tkH2AzrL+XRvsjKjCnr20+XB/QCyM2cdd3ni9Oz37uMuQfdydhetQDB0l04G9gOQ61JeFuEzwLuDEeDfwJ8MCkkwQ2X73kGaC91jKBO+tahH4XguZ4H05ngm6ft9Hkgne7bGiM0FkjO63lAnevw0ywY+BC/wnwAUeeVfdp4SZ4APeeH0wPRN8wJAJPpiFTJCho2Q6sBeSZIKfAjPBB4AT44PATHAhSSaIbL+HSDPBhyxlgg9XtQj8sIVM8JEczwRdvx8hyQQf9FjRmSAyRo9aygQf3QaZ4PvABf4D4AKPfF7KR4SZ4GPeeH08PRN8zJAJPp6FTJCho2Q6sBeRZIIfATPBx4AT4+PATHARSSaIbL8nSDPBJyxlgk9WtQj8pIVM8KkczwRdv58iyQQf91jRmSAyRk9bygSf3gaZ4NvABf4d4AKPfBLme4SZ4DPeeH02PRN8xpAJPpuFTJCho2Q6sE8nyQTfA2aCzwAnxmeBmeDpJJkgsv2eI80En7OUCT5f1SLw8xYywRdyPBN0/X6BJBN81mNFZ4LIGL1oKRN8cRtkgq8DF/g3gAs88h0HbxFmgi9543Vxeib4kiETXJyFTJCho2Q6sM8kyQTfAmaCLwEnxsXATPBMkkwQ2X4vk2aCL1vKBF+pahH4FQuZ4Ks5ngm6fr9Kkgku9ljRmSAyRq9ZygRf2waZ4MvABf4V4AKPfHvda4SZ4OveeH0jPRN83ZAJvpGFTJCho2Q6sM8myQRfA2aCrwMnxjeAmeDZJJkgsv3eJM0E37SUCb5V1SLwWxYywbdzPBN0/X6bJBN8w2NFZ4LIGL1jKRN8Zxtkgi8AF/gXgQs88r3kiwkzwXe98fpeeib4riETfC8LmSBDR8l0YJ9LkgkuBmaC7wInxveAmeC5JJkgsv3eJ80E37eUCX5Q1SLwBxYywQ9zPBN0/f6QJBN8z2NFZ4LIGH1kKRP8KJuZoLcoPwtclJ8DZm/PF+KSmK8IM8GPvfH6SXom+LEhE/zEZiZI1FEyHdjn53omaOjQmWaCHwMnxk+AmeD5JJkgsv2WkGaCSyxlgp9WtQj8qYVM8LMczwRdvz8jyQQ/8VjRmSAyRp9bygQ/9zJBt1w/b9NFXr/0o28I6sfE9JsH9FtK9QeNuOW7tfLyKhvL1xVsfflWrc7rtfIKrf6VWvkHrbxKK/+olX/Syqu18hqv/IX8d74UfSX6WvSN6FvRUtF3Vf+dSaPH1XfAflCWLCyTOr8XLRet8LJAvY+4/7wob1Pb9wbbcoNthWfTP+jLVd8Bx9kyQF0b3p/sqO+BXBdaSlLy02KRic9uLJZD2m9DXFcAkzxk+9ke40stjPGVUucPolWiHw1jfKVh7P5gsK0y2H7MwhhfChxLK4Fj/Acg18UkY3wVcIz/CBzjFxON8W8tjPGfpM7VojWinw1j/CfD2F1tsK0x2H7Owhj/FjiWfgKO8dVArktJxvga4Bj/GTjGLyUa499YGOO/SJ2/in4T/W4Y478Yxu6vBttvBtvvWRjj3wDH0i/AMf4rkOtykjH+G3CM/w4c45cTjfGvLYzxtVLnH6I/ResMY3ytYez+YbD9abCty8IY/xo4ltYCx/gfQK4rScb4n8Axvg44xq8kGuNfWRjj66XOv9yxLYOxkjdI9XG63jB2/zLYXEO6rVKR/TH+FXAsrQeO8b+AXFeTjHE32JnXtSGulYpwfeRqojH+pYUxXlnaMl9UIKpiGOOVDWM332ArMNiqZGGMfwkcS5WLcGM8vwjHdS3JGC8AjvEqwDF+LdEY/8LCGC+UtqzqjkVRNcMYLzSM3aoGW5HBVi0LY/wL4BgvBI7xqsAxfj3JGC8CjvFqwDF+PdEYr4Sry2nk1VNd2rKGqKaolqi2qI6ormg7UT3R9qIdRDuKdhLVF+0s2kW0q2g30e6iPUQNRA1FjUSNRXuK9hI1ETUVNRM1F+0tamGYU6ob5ooaBltNg62WwVbbYKtjsNU12LYz2OoZbNsbbDsYbDsabDsZbPUNtp0Ntl0Mtl0Ntt0Mtt0Ntj0MtgYGW0ODrZHB1thg29Ng28tga2KwNTXYmhlszQ22vQ22FkX21yB9zGY611cHrkE1gGvQjVk68JvpGlQTuAbVyryufw4P1wbG4qZcjkXoH05VJzOfHc1nVTeTugKbtJ/aDhiLm3MzFk4ap6q3lT6HU//yWW2/dXVFDe2ndgDG4pZci0XUyKl2rLjPkf/wWe1U0boi/9l+qj4wFrfmTiwCm+FUO1fE58hmfVa7bHldiXLaT+0KjMVtuRCLSLmcarct89nZAp/V7ltSl7NF7af2AMbi9m0bi+It5FQNyvM5tMU+q4abrSuUqkD7qUbAWNyxrWIRqRCnavzfPkcr6LPa8z/qiqUq3H5qL2As7sx+LJyt4FRNTD47W+WzavrvutRWtp9qBozFXdmMRXKrOVXzTX0OZuCz2lurK5DKqP1UC2As7iZ55Arw+oAC/r5V+u+zTGNxD0ksgL+DFDCPV7cBY3EvSSyA+Z4C5ivqTmAs7iOJBXBdU8B5Wd0DjMX9WdordDL7KOD4VcD+p5DtV7Y32Mj71vcj0vcr9P0Mfb9D3w/R90v0/RR9v0Xfj9H3a/T9HH2/R98P0veL9P0kfb9J34/S96v0/Sx9v0vfD9P3y/T9NH2/Td+P0/fr9P08fb9P3w/U9wv1/UR9v/F37Qyifg+Bfo+Bfg/Cz1pZv69Iv+9Ivy/pR62s32uo34uo36u4Qivr9x/r9yfr9y9X03zRz1zoZzL0MxtVtPIm57C0sn6Oq5JW1s9m6mc39bOd67Syfl5bP89ddt67bEJpKX+0ErUWtRG1FbUTOSIlCoiCopCoWBQWRURRUUzUXtRB1FHUSdRZ1EXUVdRN1F3UQ9RT1EvUW9RH1FfUT9RfNEA0UDRINFg0RDRUNEw0XDRCNFI0SjRaNEY0VjSuyP498qW4uv45AzBeuCeIJoomiSaLpoimiuKiElFClBSVilKiaaLpohmifUQzRfuK9hPtLzpAdKDoINHBokNEh4oOEx0uOkJ0pOgoryPo+7Lji/69VzvBYJtosE0y2CYbbFMMtqkGW9xgKzHYEgZb0mArNdhSBts0g226wTbDYNvHYJtpsO1rsO1nsO1vsB1gsB1osB1ksB1ssB1isB1qsB1msB1usB1hsB1psB1VZP8MgD5mM83h3LGRaV1lZwAmFOG4nic5AzAR0n4b4jop87r+OQMwGRiLF0jOAEzJzOdNzgBMzaSutDMAcWAsXiQ5A1CylT6bzgAktq4u4xmAJDAWL5GcASituM//eQYgVdG6NnMGYBowFotJzgBMr4jP5ZwBmLHldZV7BmAfYCxeJjkDMHPLfN6iMwD7bkldW3gGYD9gLF4hOQOwf3k+V+AMwAFFuDMABwJj8SrJGYCDinBnAA4uwp0BOAQYi9dIzgAcWoQ7A3BYEe4MwOHAWLxOcgbgiCLcGYAji3BnAI4CxuINkv014PUBBfx9q14E7q+9SRIL4O8gBczj1cvAWLxFEgtgvqeA+Yp6DRiLt0liAVzXFHBeVm8CY/EOyRkA4PhVwP6nkO1ne69w/3z8XuHRkrvMEh0jmi06VjRHNFd0nOh40TzRCaITRSeJ5otOFi0QnSJaKDpVtEh0muh00RmiM0Vnic4WnSM6V3Se6HzRBaILvc0bff/maMOeziyD7RiDbbbBdqzBNsdgm2uwHWewHW+wzTPYTjDYTjTYTjLY5htsJxtsCwy2Uwy2hQbbqQbbIoPtNIPtdIPtDIPtTIPtLIPtbIPtHIPtXIPtPIPtfIPtAoPtwiL7e4X6mM10rj8aste1Ya9wFvA3y9cke4XHQNpvQ1xnZ17XP3uFxwJj8Q3JXuGczHzeZK9wbiZ1pe0VHgeMxbcke4XHb6XPpr3CeVtXl3Gv8ARgLJaS7BWeWHGf/3Ov8KSK1rWZvcL5wFh8R7JXeHJFfC5nr3DBltdV7l7hKcBYLCPZK1y4ZT5v0V7hqVtS1xbuFS4CxuJ7kr3C08rzuQJ7hacX4fYKzwDGYjnJXuGZRbi9wrOKcHuFZwNjsYJkr/CcItxe4blFuL3C84CxWEmyV3h+EW6v8IIi3F7hhcBY/EByHR54fUABf9+qb4HX4VeRxAL4O0gB83i1DBiLH0liAcz3FDBfUSuAsfiJJBbAdU0B52W1ChiL1SR7hcDxq4D9T60m2is82MJe4UWSu1wsukR0qegy0eWiK0RXiq4SXS26RnSt6DrR9aIbRDeKbhLdLLpFdKvoNtHtojtEd4ruEt0tukd0r+g+0f2iB0QPeps3+v7NRYY9nYsNtksMtksNtssMtssNtisMtisNtqsMtqsNtmsMtmsNtusMtusNthsMthsNtpsMtpsNtlsMtlsNttsMttsNtjsMtjsNtrsMtrsNtnsMtnsNtvsMtvsNtgcMtgeL7O8VHgzcK7wIste1Ya/wYuBvlvxmHHuFl0Dab0NcL828rn/2Ci8DxqIgl2Oh7RVenpnPm+wVXpFJXWl7hVcCY1ElN2Pxr73Cq7bSZ9Ne4dVbV5dxr/AaYCwKcy0W/7FXeG3Fff7PvcLrKlrXZvYKrwfGomruxGKze4U3VMTncvYKb9zyusrdK7wJGIuiXIjFFuwV3rxlPm/RXuEtW1LXFu4V3gqMRbVtG4st3iu8rTyfK7BXeHsRbq/wDmAsqm+rWFRwr/DOItxe4V1FuL3Cu4GxqJH9WGzVXuE9Rbi9wnuLcHuF9wFjUTObschgr/D+Itxe4QNFuL3CB4GxqJWlWDiZfRTw+oAC/r5V+u+zTGNRmyQWwN9BCpjHqyJgLOqQxAKY7ylgvqJqAGNRlyQWwHVNAedlVRsYi+0sxQK9VwgcvwrY/xSy/dz9hxpa27l/vyx/rPfKr2jlV/M3fFfW/t1BBRv/+WCv/JDkFg+LHhFVkb/r5v37Wadl/39kvB4pstOv8rCcAb0tHvU2fh5L3xRy/8G6NAB0B38EtpGTSj0KTCgfsxTIyuD2Q/r8uFaXkguCciHP/feiSUeFknIpLhBIloSchBNPBEpjIfktHAqEgolkQi5OROMq5aTiiVgquoHLHXR18jYOMP2DHnSPF2Eno7LPE0UWgd3K0fU+CewMtvx+smhjA4PqNbIiJoAni/D1PgXurGWTtVuv7VM3yEnRNutDQNZGXj1PS53PiJ4VPSd6XvSC6EXRS6LFopdFr4heFb0mel30huhN0Vuit0XviN4VvSd6X/SB6EPRR6KPRZ+Ilog+FX0m+lz0hbc66zF/2nCS4xmD7VmD7TmD7XmD7QWD7UWD7SWDbbHB9rLB9orB9qrB9prB9rrB9obB9qbB9pbB9rbB9o7B9q7B9p7B9r7B9oHB9qHB9pHB9rHB9onBtsRg+9Rg+8xg+9xg+6LI/gmhh4Dr19OwxNJRzwC5GpOcEHoW0n4b4vpc5nX9c0LoeWAs9iQ5IfRCZj5vckLoxUzqSjsh9BIwFnuRnBBavJU+m04Ivbx1dRlPCL0CjEUTkhNCr1bc5/88IfRaRevazAmh14GxaEpyQuiNivhczgmhN7e8rnJPCL0FjEUzkhNCb2+Zz1t0QuidLalrC08IvQuMRXOSE0LvledzBU4IvV+EOyH0ATAWe5OcEPqwCHdC6KMi3Amhj4GxaEFyQuiTItwJoSVFuBNCnwJj0ZLkhNBnRbgTQp8X4U4IfQGMRSuS3Xfg9QEF/H2r9gLuvrcmiQXwd5AC5vGqGTAWbUhiAcz3FDBfUS2AsWhLEgvguqaA87JqDYxFO5ITQsDxq4D9TyHbz+2/w0WNvPq+8PbEPvP2yJZ4e2Yfe3toH3p7au97e2zventub3t7cO71Bfd6hXudxr3u415Hcq+fudfj3Ot77nVN9zqpe93Vvd7sXr92r4e7+wBPp2+C5P37UEemfe9hYN7zZRHsUIeTzUMdOreT4Ufn/arIIrBbObrer4GdwZbfX2uDAlTv353NVeU8+53t4SI7k316m2Q6APWO/I3W1+CnVL7GNYjSd5F16AoyJ8o7cuYyu/VX9IhdeY3+DXAAfgue1cra1a137lb2BSVtl1BOyokF5EpOJBGOlMSSgZJoPBVMFQeTwa1t1/I6O7Jdl1pq16Vb367/L/rrd5ba9bv/8f66zFK7LvPatWzhzEamhlw89cX+ey+pWO6uGTYWuG8sZGvfgDMJW35XdHA4FfA74wciW25DJ7OPcjvmiiJ8bFZamhRWbmaydTL7qOWW2uIHS23xg8W2eNhSW3Rplttziq3x0HXb+l3u0RJbfb8byaVHYL9UwFgrZPu5iVRhnvkqRF4F27O8/qTXaWPNQrWJnlSu2txVCCezj1phaRFYtZmrEOVUo8r777jMqyxMCr1yZG+oIslbxk86L8rNCQYZC71f/qglJ1sbn/LaHBmfn/S9hWBQxkYyolLJVLA4EguUqHAwHE6FUpFwNJRMFYfiyUipCsWDgVhpxEmpaGlppDiYiIRTsWQinNInbZUMBkPJWElCFQfC8RInmgzGnVQoEpQf/MlgJJkMRsPheDCYDEdT0Zj8SJef/lGnOBKJOeFAMBawFZ+ftF/XqEWhvKs5ep0si8JqxkVhteVFYbWFRaFPjiwK/9mJIxvuzEdOOmtydFHoY2nSWQNYFMq7tImMz885uijYis/P/48uuf7iXXL91XTJ1cns85/7Hci9ykzrAl6+VTYCX9aG+SRtmGldv+V4PNwB85uFhf13S0nO7xYvf/5qqS3WWmqLtZYvBdtoi345finY1njon+OXgm31/QEkl4KB/VIBY60G+JeC0z9/r1moNtGT3T9s/ur/zdIi8IfFX/0u8x8WJoUhJJeCfwMmgn8W5eYEM8TSr8o/s3ApGBmfdcBf/QOAv/ptxWedIT4VPVNT3qVfZHzWW5o/1wPaobyrU8h2+MtSO/xF1h/yqtlpB7feTNshm/2hkqV2qFSt/K2iXE7sDLiwfqwnjZWrESaNOrSNpFGvv6zeTDv6sNx4jlAim5NcfrWcvAKhhllKSvKrlZ80Znq6Hhmfgmq4RA+ZNNqKTwFgcSznA31mRhXY4hi1chD7a++qG3pHCdnHC3EJhpUdDDfGhRbWm6qWEiu33iLv7+F5//6g/ptl9aHb+7qC3GcsqgZmZOm0I3J8e8X1uciC3yNJHjxSBEzoqgEnZmC/UchYWJ4k/9mm+F+cJKv9r06S1avZnSSdzD7K9bm6Bb9rWMpoalTb+GR9G7d7/mbhdk9khlwzx/uT+4uqpoX+VItgHNWy4HdtS+Oo9mbGkZPZx9qcMqbZ/2YfGJulcy0Zvz8VmCQCY63GWrpCVcf/dW2dsa7txBHxK7OuhUE/geRXZl2CQZ9pLCaSTMDbAWMB7H9qov8rnWKy3Q452bKuincSBKqeHyhH3U0QqO39QDnqXoJA7eAHylH3EwRqRz9QjnqQIFA7+YFy1MMEgarvB8pRjxIEamc/UI56nCBQu/iBctSTBIHa1Q+Uo54mCNRufqAc9SxBoHb3A+Wo5wkCtYcfKEe9SBCoBn6gHLWYIFAN/UA5alp+7jM28gPlqFcJRlRjP1COep0gUHv6gXLUmwSB2ssPlKPeJghUEz9QjnqXIFBN/UA56n2CQDXzA+WoDwkC1dwPlKM+JgjU3n6gHLWEIFAt/EA56jOCQLX0A+WoLwgC1coPlKO+IghUaz9QjvqGIFBt/EA5ailBoNr6gXLUMoJAtfMD5ajlBIFykIFyn6FZNW/jvWUubOO0oFUGOwB8yIVC3+hvI2D1CBi3J2DcgYBxRwLGnQgY6xMw7kzAuAsB464EjLsRMO5OwLgHAWMDAsaGBIyNCBgbEzDuScC4FwFjEwLGpgSMzQgYmxMw7k3A2IKAsSUBYysCxtYEjG0IGNsSMLYjYHQsMOZBGYORPMMHU3dA2at745vJK2l1KmnvgCgoComKRWFRRBQVxUTtRR1EHUWdRJ1FXdw4ibqJuot6iHqKeol6i/qI+or6ifqLBogGigaJBouGiIaKhomGi0aIRopGiUaLxojGisaJxosmiCaKJokmi6aIporiohJRQpQUlYpSommi6aIZon1EM0X7ivYT7S86QHRgtQ1tcFA1r1HKntroNkpRmi1gsAUNtpDBVmywhQ22iMEWNdhiBlt7g62DwdbRYOtksHU22LoYbF0Ntm4GW3eDrYfB1tNg62Ww9TbY+hhsfQ22fgZbf4NtgME20GAbZLANNtiGGGxDDbbhBtsIg22kwTbKYBttsI0x2MYabOMMtvEG2wSDbaLBNslgm2ywTTHYphpscYOtxGBLGGxJg63UYEsZbNMMtukG2wyDbR+DbabBtq/Btp/Btr/BdoDBdqDBdpC24JZ90A+d1Df/cugp30pVs5NsVAa3H3AzUQVIfAZuTqogic/AzU4VIvEZuHmqikl8Bm7GqjCJz8DNXRUh8Rm4WayiJD4DN59VjMRn4Ga2ak/iM3BzXHUg8Rm42a46kvgM3LxXnUh8Bh4GUJ1JfAYeLlBdSHwGHlZQXUl8Bh5+UN1IfAYeplDdSXwGHs5QPUh8Bh72UD1JfAYeHlG9SHwGHkZRvUl8Bh5uUX1IfAYellF9SXwGHr5R/Uh8Bh7mUf1JfAYeDlIDSHwGHjZSA0l8Bh5eUoNIfAYehlKDSXwGHq5SQ0h8Bh7WUkMt+VwpzWcns48aBtjLLk25n0TcvRG3SItLJY3TFr+NPW80o3/zLIbRv3kWw+jfPIth9G+exTD6N89iGP2bZzGM/s2zGEb/5lkMo3/zLIbRv3kWw+jfPIth9G+exTD6N89iGP2bZzGM/s2zGEbGm2cx9UattekIgriPJGAcRcA4moBxDAHjWALGcQSM4wkYJxAwTiRgnETAOJmAcQoB41QCxjgBYwkBY4KAMUnAWErAmCJgnEbAOJ2AcQYB4z4EjDMJGPclYNyPgHF/AsYDCBgPtHidD8cZCJjONR4s7IeIDhUdJjpcdIToSNFRoqNFs0THiGaLjhXNEc0VHSc6XjRPdILoRNFJovmik0ULRKeIFopOFS0SnSY6XXSG6EzRWaKzReeIzhWdJzpfdIHoQtFFootFl4guFV0mulx0hehK0VWiq0XXiK4VXSe6XnSD6EbRTaKbRbeIbhXdJrpddIfozmob2uCuanmbPoTJbZT0BzMdYrAdarAdZrAdbrAdYbAdabAdZbAdbbDNMtiOMdhmG2zHGmxzDLa5BttxBtvxBts8g+0Eg+1Eg+0kg22+wXaywbbAYDvFYFtosJ1qsC0y2E4z2E432M4w2M402M4x2M412M4z2M432C4w2C402C4y2C422C4x2C412C4z2C432K4w2K402K4y2K422K4x2K412K4z2K432G4w2G402G4y2G422G4x2G412G4z2G432O4w2O402O6q9u8D7WWLQpk905sQgAfa1cHV7CysaJ+RD4Q7hMRn5APhDiXxGflAuMNIfEY+EO5wEp+RD4Q7gsRn5APhjiTxGflAuKNIfEY+EO5oEp+RD4SbReIz8oFwx5D4jHwg3GwSn5EPhDuWxGfkA+HmkPiMfCDcXBKfkQ+EO47EZ+QD4Y4n8Rn5QLh5JD4jHwh3AonPyAfCnUjiM/KBcCeR+Ix8INx8Ep+RD4Q7mcRn5APhFpD4jHwg3CkkPiMfCLeQxGfkA+FOJfEZ+UC4RSQ+Ix8IdxqJz8gHwp1O4jPygXBnkPiMfCDcmZZ8rpTms5PZR51VLfP2K3sgnE3Os2GcUWWzDwFvuFTnkIwb4A2c6lwSn4E3hKrzSHwG3mCqzifxGXjDqrqAxGfgDbDqQhKfgTfUqotIfAbeoKsuJvEZeMOvuoTEZ+ANxOpSEp+BNySry0h8Bt7grC4n8Rl4w7S6gsRn4A3Y6koSn4E3dKurSHwG3iCuribxGXjDubqGxGfgDezqWhKfgTfEq+tIfAbeYK+uJ/EZeMO+uoHEZ+ADANSNJD4DHyigbiLxGfiAAnUzic/ABx6oW0h8Bj5AQd1K4jPwgQzqNhKfgQ94ULeT+Ax8YIS6g8Rn4AMo1J1An90Xakl1f99/7H4qaT7naTa9LZzMPv4LtUCM/gu1MIz+C7UwjP4LtTCM/gu1MIz+C7UwjP4LtTCM/gu1MIz+C7UwjP4LtTCM/gu1MIz+C7UwjP4LtTCM/gu1MIz+C7UwjP4LtRD1+i/UssHov1ALw+i/UAvD6L9QC8Pov1ALw+i/UAvD6L9QC8Pov1ALw+i/UAvD6L9QC8Pov1ALw+i/UAvD6L9QC8Pov1ALw+i/UAvDyPJCLYt1q0pa25bVebe0yz2ie0X3ie4XPSB6UPSQ6GHRI6JHRY+JHhc9IXpS9JToadEzomdFz4meF70gelH0kmix6GXRK6JXRa+JXhe9IXpT9JbobdE7ondF74neF30g+lD0kehj0SeiJaJPRZ+JPhd9IfpS9JXoa9E3om9FS0XfiZaJvhctF60QrRT9IFol+lH0U7W8TV9m4zZG+gtu7jHY7jXY7jPY7jfYHjDYHjTYHjLYHjbYHjHYHjXYHjPYHjfYnjDYnjTYnjLYnjbYnjHYnjXYnjPYnjfYXjDYXjTYXjLYFhtsLxtsrxhsrxpsrxlsrxtsbxhsbxps3xtsyw22FQbbSoPtB4NtlcH2o8H2k2fTP5W9767edy692OluSxM82mfki53uIfEZ+WKne0l8Rr7Y6T4Sn5EvdrqfxGfki50eIPEZ+WKnB0l8Rr7Y6SESn5EvdnqYxGfki50eIfEZ+WKnR0l8Rr7Y6TESn5EvdnqcxGfki52eIPEZ+WKnJ0l8Rr7Y6SkSn5EvdnqaxGfki52eIfEZ+WKnZ0l8Rr7Y6TkSn5EvdnqexGfki51eIPEZ+WKnF0l8Rr7Y6SUSn5EvdlpM4jPyxU4vk/iMfLHTKyQ+I1/s9CqJz8gXO71G4jPyxU6vk/iMfLHTGyQ+I1/s9KYln9GHgt6qlnn7ZePFTm/DODd9sROa8x2SuL9LwvkeCef7JJwfkHB+SML5EQnnxyScn5BwLiHh/JSE8zMSzs9JOL8g4fyShPMrEs6vSTi/IeH8loRzKQnndyScyyxxFmTKqTb98/vMODepbXmmPmu1rQD8Xv/n5W3NcjQWzqZer0T0Ga+2HzD97+/aVgFjMTW3Y+GUef0j8FreT8C6gH1Z6bHI6JpYaSrmvlSgbt7Ga6pWYmO5bzuZfHK3z9i42fKfOUuP9+pqG77XuN/6jVDuP1iSZnP/pUZ5fkfJ+E2GDBNqWofeSp8Dns9qNbD91gAHra1YVAbHAtl+PxvqKnESyWJVEk5GVGm8OJpIxIJKBeLheLgkEE2VlhSraHFU6kzEA1H5zwXiCVXqxMOl7iJSJ29jMq5/0An6z8AJVuf9pZpFYLdydL2/AjuDLb9/rbaxgUH1GlkRk4nLihqwZfUiY/QbuOOXLehuvY3lO5uZ4PfABX45cIFfAVxUVlazs6iAxpMxE/zdG69r0zPB3w2Z4FqbmaAHuRKYffwOHIxrtboCyeJSJxYtiQZK4sFISShYEovFpd6wUtFUMuAkQ4FUsQqHE7HSWEoFUyXFpfFwcTwWTv69eiankGQfyPb7gzT7+MNS9vFnNYvAf1rIPtblePbh+r2OJPtY67Gisw9kjNZbyj7Wb4Psow0w+2gLzD6QZy8dwuzjr7LxWj1v00zjL0P24f5LjfL8jpLpwC4luQ7lADPBv5CLV3Wcj6UkmSCy/SpV58wEK1XHLoj/xKq6RWC3cnS9+dVzOxN0/c6vvrGBQfVayQTzPFZ0JoiMUUF1O5mgW2+2M8EWwAW+JXCBR95V15owE6zijdfC9EzQ/QfpmWBhFjJBho6S6cCeRpIJtgZmglWAE2MhMBOcRpIJItuvKmkmWNVSJlhU3SJwkYVMsFqOZ4Ku39VIMsFCjxWdCSJjVN1SJlh9G2SCTYELfDPgAo98XsrehJlgDW+81kzPBGsYMsGaWcgEGTpKpgN7BkkmuDcwE6wBnBhrAjPBGSSZILL9apFmgrUsZYK1q1sErm0hE6yT45mg63cdkkywpseKzgSRMaprKROsuw0ywcbABX5P4AKPfBJmE8JMcDtvvNZLzwS3M2SC9bKQCTJ0lEwH9kySTLAJMBPcDjgx1gNmgjNJMkFk+21PmglubykT3KG6ReAdLGSCO+Z4Juj6vSNJJljPY0VngsgY7WQpE9xpG2SCewAX+AbABR75joNGhJlgfW+87pyeCdY3ZII7ZyETZOgomQ7s/UgywUbATLA+cGLcGZgJ7keSCSLbbxfSTHAXS5ngrtUtAu9qIRPcLcczQdfv3UgywZ09VnQmiIzR7pYywd23QSa4C3CB3xW4wCPfXrc7YSa4hzdeG6RngnsYMsEGWcgEGTpKpgP7AJJMcHdgJrgHcGJsAMwEDyDJBJHt15A0E2xoKRNsVN0icCMLmWDjHM8EXb8bk2SCDTxWdCaIjNGeljLBPbdBJrgjcIHfCbjAI99LvjNhJriXN16bpGeCexkywSZZyAQZOkqmA/sgkkxwZ2AmuBdwYmwCzAQPIskEke3XlDQTbGopE2xW3SJwMwuZYPMczwRdv5uTZIJNPFZ0JoiM0d6WMsG9s5kJeotyPeCivD0we9sB+DRyRZgJtvDGa8v0TLCFIRNsaTMTJOoomQ7sQ3I9EzR06EwzwRbAibElMBM8hCQTRLZfK9JMsJWlTLB1dYvArS1kgm1yPBN0/W5Dkgm29FjRmSAyRm0tZYJtvUzw7+NgeZsu8vqlH31DUD8mpt88oN9Sqj9o5O94aeXlVTaWryvY+nLZA3Xd8hqtvEKrf6VW/kErr9LKP2rln7Tyaq28xiu3Ez8ckRIFREFRSFQsClf/dyaNHldhYD8oSxYiUmdUFBO197JAvY+4/7wob1Nb1GCLGWztPZv+QV+uCgPHWQRQ14b3JzsqCuQ6zFKSkp8Wi0x8dmMRg7Tfhri2ByZ5yPazPcaLLYzxDlJnR1EnUWfDGO9gGLsdDbZOBlvnLIzxYuBY6gAc4x2BXEeQjPFOwDHeGTjGjyAa4yELY7yLW6eom6i7YYx3MYzdrgZbN4OtexbGeAg4lroAx3hXINdRJGO8G3CMdweO8aOIxnjQwhjvIXX2FPUS9TaM8R6GsdvTYOtlsPXOwhgPAsdSD+AY7wnkmkUyxnsBx3hv4BifRTTGAxbGeB+ps6+on6i/YYz3MYzdvgZbP4OtfxbGeAA4lvoAx3hfINdskjHeDzjG+wPH+GyiMa4sjPEBUudA0SDRYMMYH2AYuwMNtkEG2+AsjHEFHEsDgGN8IJBrDskYHwQc44OBY3wO0Rh3LIzxIVLnUNEw0XDDGB9iGLtDDbZhBtvwLIxxBziWhgDH+FAg13EkY3wYcIwPB47x44jGeDsLY3yE1DlSNEo02jDGRxjG7kiDbZTBNjoLY7wdcCyNAI7xkUCueSRjfBRwjI8GjnFk+5WN6Su0dkTVXeTX59fn1+fX59fn1+fX59fn15fL9YX89vPr8+vz6/Pr8+vz6/Pr+9+uL1oM5ivB1lcSxNYXSpZd7z6qaOO17yO18hFa+XCtfJhWPlQrH6KVD9bKB2nlA7XyAVp5f628n1beVyvP1Mr7aOUZWnm6Vp6mlVNauVQrJ7VyQiuXaOW4Vp6qlado5claeZJWnqiVJ2jl8Vr5Qq18gVY+Xyufp5XP1crnaOWztfJZWvlMrXyGVj5dK5+mlRdp5VO18kKtfIpWXqCVT9bK87XySVr5RK18glaep5WP18rHaeW5WnmOVj5WK8/Wysdo5Vla+Wit/KBWfkAr36+V79PK92rle7Ty3Vr5Lq18p1a+QyvfrpVv08q3auVbtPLNWvkmrXyjVr5BK1+vla/Tytdq5Wu08tVa+SqtfKVWvkIrX66VL9PKl2rlS7TyxVr5Iq3cW9t708/F6udm9XO13bWyflZeP0uvn7XvrJX1+2f0+2v0+2/aa2X9njr9njv9nrzRWlnfR9T3GfV9yOFaWT9boJ890M8mDNbK+nkj/TySfl6pv1bWzyDqZxTLzjDekbfhM0b+HisaJxovmiCaKJokmiyaIpoqiotKRAlRUlQqSommiaaLZoj2Ec0U7SvaT7S/6ADRgaKDRAeLDhEdKjpMdLjoCNGRoqNER4tmiY4RzRYdK5ojmis6TnS8aJ7oBNGJopNE80UnixaIThEtFJ0qWiQ6TXS66AzRmaKzRGeLzhGdKzpPdL7oAtGFootEF4suEV0qukx0uegK0ZWiq0RXi64RXSu6TnS96AbRjaKbRDeLbhHdKrpNdLvoDtGdortEd4vuEd0ruk90v+gB0YOih0QPix4RPSp6TPS46AnRk6KnRE+LnhE9K3pO9LzoBdGLopdEi0Uvi14RvSp6TfS66A3Rm6K3RG+L3hG9K3pP9L7oA9GHoo9EH4s+ES0RfSr6TPS56AvRl6KvRF+LvhF9K1oq+k60TPS9aLlohWil6AfRKtGPop9Eq0VrRD+LfhH9KvpN9LtoregP0Z+idaL1or9EeTWk74oqi/JFBaIqosIaG56kU9nr22WfsnJX7zvTfexdZfO/QcG/63Uy+yi3TlBdm5zhqFpjw3dRDa8xyg42uP9gbpqtyLPZbLh8iw2XKaPbJltYV6KculRRDVxA3Y5dmGd+RFReBduzPG69TnQnrwpsE32QV0vv3K6hUloDoU6KmDpLOayqPGeq1cBxVa8B6wybvuFemxxstWkRsB2QbVqjAm1a3n9Lb9MaXpvaPnU3GLi6NPLqqSnstUS1RXVEdUXbieqJthftINpRtJOovmhn0S6iXUW7iXYX7SFqIGooaiRqLNpTtJeoiaipqJmouWhvUQtRS1Erb8DrbenylGW2ZbZaBlttg62OwVbXYNvOYKtnsG1vsO1gsO1osO1ksNU32HY22HYx2HY12HYz2HY32PYw2BoYbA0NtkYGW2ODbU+DbS+DrYnB1tRga2awNTfY9jbYWhhsLQ22Vp5N/6BPhQ4GJjY1AXNh2anQWsB59cQsPYIv01OhtSHttyGudTKv65/H+dUFxuKkXI5FaGOCul1mPjt6slsvk7oCmybO2wNjMT83Y+Gk/1jYYSt9Dqf+/cNjx62rK2r6EbMTMBYn51osouYfbvUr7nPkv34E7lzRuiL//YNyF2AsFuROLAKb+xG9a0V8jmz+B/luwIsSuwNjcUouxCJSLqfaY8t8drbAZ9VgS+pytqj9VENgLBZu21gUbyGnalSez6Et9lk13mxdoVQF2k/tCYzFqdsqFpEKcaq9/tvnaAV9Vk3+o65YqsLtp5oCY7Eo+7FwtoJTNTP57GyVz6r5v+tSW9l+am9gLE7LZiySW82pWmzqczADn1VLra5AKqP2U62AsTid5CVIwOsDCvj7Vum/zzKNxRkksQD+DlLAPF6dAozFmSSxAOZ7CpivqEXAWJxFEgvguqaA87I6AxiLs7N0976T2UcBx68C9j91NtETOgZZ2CtsLblLG1FbUTuRI1KigCgoComKRWFRRBQVxUTtRR1EHUWdRJ1FXdw8SNRN1F3UQ9RT1EvUW9RH1FfUT9RfNMCwV9jasKfTxmBra7C1M9gcg00ZbAGDLWiwhQy2YoMtbLBFDLaowRYz2NobbB0Mto4GWyeDrbPB1sVg62qwdTPYuhtsPQy2ngZbL4Ott8HWx2Dra7D1M9j6G2wDatjfKxwE3CtsDdwrbAP8zXI1yV5hW+BeYTvgXqEDjMU1JHuFCrhXGADuFQaBsbiWZK8wBNwrLAbuFYaBsbiOZK8wAtwrjAL3CmPAWFxPslfYHrhX2AG4V9gRGIsbSPYKOwH3CjsD9wq7AGNxI8leYVfgXmE34F5hd2AsbiLZK+wB3CvsCdwr7AWMxc0ke4W9gXuFfYB7hX2BsbiFZK+wH3CvsD9wr3AAMBa3klyHB14fUMDft+pa4HX420hiAfwdpIB5vLoBGIvbSWIBzPcUMF9RNwNjcQdJLIDrmgLOy+o2YCzuJNkrBI5fBex/6k6ivcLmuLr+2SscKLnLINFg0RDRUNEw0XDRCNFI0SjRaNEY0VjRONF40QTRRNEk0WTRFNFUUVxUIkqIkqJSUUo0TTRdNEO0j2imYa9woGFPZ5DBNthgG2KwDTXYhhlsww22EQbbSINtlME22mAbY7CNNdjGGWzjDbYJBttEg22SwTbZYJtisE012OIGW4nBljDYkgZbqcGWMtimGWzTDbYZBts+BtvMGvb3CvUxm+lcPxC4VzgI+JvlSZK9wsHAvcIhwL3CocBYPEWyVzgMuFc4HLhXOAIYi6dJ9gpHAvcKRwH3CkcDY/EMyV7hGOBe4VjgXuE4YCyeJdkrHA/cK5wA3CucCIzFcyR7hZOAe4WTgXuFU4CxeJ5kr3AqcK8wDtwrLAHG4gWSvcIEcK8wCdwrLAXG4kWSvcIUcK9wGnCvcDowFi+R7BXOAO4V7gPcK5wJjMVikuvwwOsDCvj7Vj0NvA7/MkksgL+DFDCPV88BY/EKSSyA+Z4C5ivqRWAsXiWJBXBdU8B5Wb0MjMVrJHuFwPGrgP1P2Wo/9D7hq/k8e5ovA1kbefXsKznWfqL9RQeIDhQdJDpYdIjoUNFhosNFR4iOFB0lOlo0S3SMaLboWNEc0VzRcaLjRfNEJ4hOFJ0kmi86WbRAdIpooWFPc1/D3tN+Btv+BtsBBtuBBttBBtvBBtshBtuhBtthBtvhBtsRBtuRBttRBtvRBtssg+0Yg222wXaswTbHYJtrsB1nsB1vsM0z2E4w2E402E4y2OYbbCcbbAsMtlMMtoU17O9p6mM20zVpX+Ce5n7A31afkuxp7g/c0zwAuKd5IDAWn5HsaR4E3NM8GLineQgwFp+T7GkeCtzTPAy4p3k4MBZfkOxpHgHc0zwSuKd5FDAWX5LsaR4N3NOcBdzTPAYYi69I9jRnA/c0jwXuac4BxuJrkj3NucA9zeOAe5rHA2PxDcme5jzgnuYJwD3NE4Gx+JZkT/Mk4J7mfOCe5snAWCwl2dNcANzTPAW4p7kQGIvvSPYLgNcHFPD3rfocuF+wjCQWwN9BCpjHq6+AsfieJBbAfE8B8xX1LTAWy0liAVzXFHBeVsuAsVhBsqcJHL8K2P8Usv3c/psQNfLqW+jtiS3w9sjme3tmJ3p7aPO8PbXjvD22Od6e22xvD26Wtyd3lLdHd4S3Z3eYt4d3iLend5C3x3eAt+fn7gO4+wrpn8ppMc34nAlwH+RULYdScg1Hrr24/1406ahQUq6eBALJkpCTcOKJQGksJD9fQoFQMJFMyO/JaFylnFQ8EUtFN9TlvsC2Tt7GvVr9g96/1bmdDD8676IaFoHdytH1ngZMgm35fZo2KED1/t3Zyl4FbruzvZJvZ7JPb5NMB6DekU/X+tq/GiTTjnIabvQpfRdZh64gc6Kcxvl7oLj1p8/G5QGW1+inAwfgGeBZraxd3XrnbmVfUO5pf+WknFhAruREEuFISSwZKInGU8FUcTAZ3Np2La+zI9v1TEvteubWt+v/i/56lqV2Pet/vL+ebaldz/batWzhzEamhlw89cX+HC+pONddM2wscKdbyNZOr4HNJGz5XdHB4VTA70wZz7Pchk5mH+V2zPNq4GNzvqVJ4fzNTLZOZh91rqW2uMBSW1xgsS3cidBGW6xrlttziq3xsH7b+l3u0RJbff8vkkuPwH6pgLFWyPZzE6nCPPNViLwKtmd5/Umv08aahWoTPam8cHNXIZzMPuo8S4vAhZu5ClFONaq8/47LfKGFSSG/eW7sDVUkecvU54tq5OYEg4yF3i8v0pKTrY1PeW2OjM/F+t5CMChjIxlRqWQqWByJBUpUOBgOp0KpSDgaSqaKQ/FkpFSF4sFArDTipFS0tDRSHExEwqlYMhFO6ZO2SgaDoWSsJKGKA+F4iRNNBuNOKhQJyg/+ZDCSTAaj4XA8GEyGo6loTH6ky0//qFMcicSccCAYC9iKz8Xar2vUolDe1Ry9TpZF4RLGReESy4vCJRYWhSo5sij8ZyeO/H0HVQo56Vyao4tCFUuTzqWARaG8S5vI+FyWo4uCrfhc9v/okuvl3iXXK0yXXJ3MPv+534Hcq8y0LuDlW2Uj8GVtmE/ShpnWdWWOx8MdMFdaWNivspTkXGXx8ucVltriakttcbXlS8E22qIqOOFD89kaD0Xb1u9yLwXb6vvVLCX46EvBwH6pgLFWyPb7/3Ip+HJLv/qvsfmr/0pLi8A1Fn/1u8zXWJgUapFcCr4SmAheWyM3J5haln5VXpuFS8HI+FwH/NWvT9qZ/uq3FZ/rDPGp6Jma8i79IuNzvaX583pAO5R3dQrZDjdYaocbyPrDjZba4Uay/nCTpXa4aQu2inI5sTPgwvqxnjTezJg03mw5abzZQtJYJ0tJY4an4qGT3C3AupBJYx1LScktW5A0Znq6HhmfW2vgEj1k0mgrPrcCFsdyPtBnZtwGmz+jVg5in+ZddUPvKCH7+O05voPhxvh2C+vNHZbWXrfeIu/vRN6/P6j/Zll96Pa+riD3Ge9EJ5IsnXa7HN9ecX2+04Lf9XLkimI5n006ZqY+3wWcmIH9RiFjYXmS/Geb4n9xkrzrf3WSvDvHb89zfb7bgt/3WMpo7qmx8cn6Nm73NGXITmYfhcyQ783x/uT+orrXQn+6j2Ac3WfB7/stjaP7NzOOnMw+1uaUHZv/b/aBnbJ0riVTzgeASSIw1monS1eoHvB/XVtnfNB24oj4lfmghUG/C8mvzAcJBn2msdiVZAJ+CBgLYP9Tu/q/0ikm24eQky3rqngnQaAe9gPlqLsJAvWIHyhH3UsQqEf9QDnqfoJAPeYHSpJugkA97gdKFmqCQD3hB0rmf4JAPekHSqYVgkA95QdKeitBoJ72AyWNQBCoZ/xAOepZgkA96wfKUc8TBOo5P1COepEgUM/7gXLUYoJAveAHylHT8glGvR8oR71KMKJe8gPlqNcJArXYD5Sj3iQI1Mt+oBz1NkGgXvED5ah3CQL1qh8oR71PEKjX/EA56kOCQL3uB8pRHxME6g0/UI5aQhCoN/1AOeozgkC95QfKUV8QBOptP1CO+oogUO/4gXLUNwSBetcPlKOWEgTqPT9QjlpGEKj3/UA5ajlBoD6w9ShK9D2JH8JAgxGbnB9tPWdxusFl2ylv432T7t9uO6z3ykVauapW/sgrl/3/Ppa/PxEtEX1aY6O97IN+ycAQXMdXHwMfYPGZpc6Obr+hwPb7BNh+n4MfCJHetz/T+vDnWnmJVv40rW9/IX9/KfpK9LXXtyvnbfqB/0oEtkMjr55vpM5vRUtF34mWib4XLRetEK0U/SBaJfpR9JNotWiN6GfRL6JfRb+JfhetFf0h+lO0zm0z0V+ivJrSHqLKonxRgahKzQ2NpD9g4BvvAQO67VuDbanB9p3Btsxg+95gW26wrTDYVhpsPxhsqwy2Hw22nwy21QbbGoPtZ4PtF4PtV4PtN4Ptd4NtrcH2h8H2p8G2zmBbb7D9ZbC5/SXdVslgq2yw5RtsBQZblZobHwhT9kE/K+AL4Dz4DaCu0r/ft+mob4Fce+TGo6M367Mbi6WQ9tsQ1+8yrytQ9jKfZcBYNMjlWIQ2vsDo+8x8dvSXIS3PpK7Api9WWgGMRcPcjIWT/jKplVvpczj17xdT/bB1dUVNL7laBYxFo1yLRdT8Yq8fK+5z5L9eEvZTReuK/PcLx1YDY9E4d2IR2NxL1tZUxOfI5l/Y9vOW11XuywR/AcZiz1yIRaRcTvXrlvnsbIHP6rctqcvZovZTvwNjsde2jUXxFnKqteX5HNpin9Ufm60rlKpA+6k/gbFosq1iEakQp1r33z5HK+izWv8fdcVSFW4/9RcwFk2zHwtnKziV+5v1X3U5W+WzqvTvutRWtp+qXBMXi2bZjEVyqzlV/qY+BzPwWRVodQVSGbWfqgKMRXOS5yUCrw8o4O9b1RD4vMS9SWIB/B2kgHm82hMYixYksQDmewqYr6imwFi0JIkFcF1TwHlZ7Q2MRSuSl8UDx68C9j/F0n7AF3Co+4B5fGFN7D6u+5nrfbt/t9L2kVpq5RZaeW+t3FwrN9PKTbVyE628l1beUys31sqNtHJDrdxAK++hlXfXyrtp5V218i5aeWetXF8r76SVd9TKO2jl7bVyPa28nVauq5XraOXaWrmWVq6plQdo5f5auZ9W7quV+2jl3lq5l1buqZV7aOXuWrmbVu6qlbto5c5auZNW7qiVO2jl9lo5ppWjWjmilcNauVgrh7RyUCsHtLLSyo5WbqeV22rlNlq5tVaeqZX30coztPJ0rTxNK6e0cqlWTmrlhFYu0cpxrTxVK0/RypO18iStPFErT9DK47XyOK08ViuP0cqjtfIorTxSK4/QysO18jCtPFQrD9HKg7XyIK08UCsXanvMD2v2R7Tyo1r5Ma38uFZ+Qis/qZWf0spPa+VntPKzWvk5rfy8Vn5BK7+olV/Syou18sta+RWt/KpWfk0rv66V39DKb2rlt7Ty21r5Ha38rlZ+Tyu/r5U/0Mr6eQj9vIR+nkI/b6Gfx9DPa+jnOfTzHvp5EP28iH6eRD9vop9H0c+r6OdZ9PMuVbT+s8l5Ba2sn3fQz0Po5yX08xT6eQv9PIZ+XkM/z6Gf99DPg+jnRfTzJGXnTc7I2/Cp6nKIqomqi2qIaopqiWqL6ojqirYT1RNtL9pBtKNoJ1F90c6iXUS7inYT7S7aQ9RA1FDUSNRYtKdoL1ETUVNRM1Fz0d6iFqKWolai1qI2oraidiJHpEQBUVAUEhWLwqKIKCqKidqLOog6ijqJOou6uDmMqJuou6iHqKeol6i3qI+or6ifqL9ogGigaJBosGiIaKhomGi4aIRopGiUaLRojGisaJxovGiCaKJokmiyaIpoqiguKhElRElRqSglmiaaLpoh2kc0U7SvaD/R/qIDRAeKDhIdLDpEdKjoMNHhoiNER4qOEh0tmiU6RjRbdKxojmiu6DjR8aJ5ohNEJ4pOEs0XnSxaIDpFtFB0qmiR6DTR6aIzRGeKzhKdLTpHdK7ovJp5m3wqed9dvW8ns48aATwYbfusH/As6z9n/c6X9r1AdKHoItHFoktEl4ouE10uukJ0pegq0dWia0TXiq4TXS+6QXSj6CbRzaJbRLeKbhPdLrpDdKfoLtHdontE94ruq7mhkf6ez7z2cnn+meO87wsMtgsNtosMtosNtksMtksNtssMtssNtisMtisNtqsMtqsNtmsMtmsNtusMtusNthsMthsNtpsMtpsNtlsMtlsNttsMttsNtjsMtjsNtrsMtrsNtnsMtnsNtvs8m/5BX0PSx2ymv5XdsZFpXWVn/S6oiePqQHLW70JI+22I60WZ1/XPWb+LgbHoSHLW75LMfN7krN+lmdSVdtbvMmAsOpGc9bt8K302nfW7YuvqMp71uxIYi84kZ/2uqrjP/3nW7+qK1rWZs37XAGPRheSs37UV8bmcs37XbXld5Z71ux4Yi64kZ/1u2DKft+is341bUtcWnvW7CRiLbiRn/W4uz+cKnPW7pSburN+twFh0Jznrd1tN3Fm/22vizvrdAYxFD5KzfnfWxJ31u6sm7qzf3cBY9CQ563dPTdxZv3tr4s763QeMRS+SczTA6wMK+PtWdQKeo+lNEgvg7yAFzONVV2As+pDEApjvKWC+onoAY9GXJBbAdU0B52XVGxiLfiRn1YDjVwH7n0K2n9t/p4saefXd5+2J3ePtkd3l7Znd4e2h3ebtqd3i7bHd5O253eDtwV3n7cld4+3RXeXt2V3h7eFd5u3pXeLt8V3k7fm5+wDnp+2xup/KaTHNtO8NBe6D3K/lUEqu4ci1F/ffiyYdFUrK1ZNAIFkSchJOPBEojYXk50soEAomkgn5PRmNq5STiidiqeiGuqpIHXXyNu7V6h/0/q3O7WT40XkfqGkR2K0cXe+DwCTYlt8PaoMCVO/fnc1V5Tz7nQ344CbHgAsbgHpHfkjra/9qkEw7yoO40af0XWQduoLMiXIa5++B4tafPhuXB1heoz8EHIAPg2e1snZ16527lX1BSdsllJNyYgG5khNJhCMlsWSgJBpPBVPFwWRwa9u1vM6ObNdHLLXrI1vfrv8v+uujltr10f/x/vqYpXZ9zGvXsoUzG5naUEunAh/3koon3DXDxgL3kIVs7aGa2EzClt8VHRxOBfzOlPFJy23oZPZRbsd8siY+Nk9ZmhSe2sxk62T2UU9YaounLbXF0xbbwp0IbbTFuOa5PafYGg/jt63f5R4tsdX3J5BcegT2SwWMtUK2n5tIFeaZr0LkVbA9y338jfaxsWah2kRPKp/Z3FUIJ7OPetLSIvDMZq5ClFONKu+/4zI/Y2FSmJIje0MVSd4y9fnZmrk5wSBjoffLZ7XkZGvjU16bI+PznL63EAzK2EhGVCqZChZHYoESFQ6Gw6lQKhKOhpKp4lA8GSlVoXgwECuNOCkVLS2NFAcTkXAqlkyEU/qkrZLBYCgZK0mo4kA4XuJEk8G4kwpFgvKDPxmMJJPBaDgcDwaT4WgqGpMf6fLTP+oURyIxJxwIxgK24vOc9usatSiUdzVHr5NlUXiecVF43vKi8LyFRSGeI4vCf3biyN93UKWQk84LObooxC1NOi8AFoXyLm0i4/Niji4KtuLz4v+jS64veZdcF5suuTqZff5zvwO5V5lpXcDLt8pG4MvaMJ+kDTOt6+Ucj4c7YF62sLC/YinJecXi5c/FltriVUtt8arlS8E22iKR45eCbY2HZI5fCrbV90tJLgUD+6UCxlqV+peC0z9/r1moNtGT3dds/up/2dIi8JrFX/0u82sWJoUZJJeCXwYmgq/XzM0JZoalX5WvZ+FSMDI+bwB/9ZcCf/Xbis8bhvhU9ExNeZd+kfF509L8+SagHcq7OoVsh7cstcNbZP3hbUvt8DZZf3jHUju8swVbRbmc2BlwYf1YTxrfZUwa37WcNL5rIWmcmRvPEUpkc5J7D1gXMmmcaSkpeW8LksZMT9cj4/N+TVyih0wabcXnfcDiWM4H+syMD2DzZ9TKQewHvatu6B0lZB//MMd3MNwYf2hhvfnI0trr1lvk/T09798f1H+zrD50e19XkPuMH6MTSZZOu1+Ob6+4Pn9swe/9SR488jFwYv4EODED+41CxsLyJPnPNsX/4iT5yf/qJLkkx2/Pc31eYsHvTy1lNJ/W3PhkfRu3e5oyZCezj0JmyJ/leH9yf1F9ZqE/fU4wjj634PcXlsbRF5sZR05mH2tzykHN/zf7wMFZOteSKeeXwCQRGGt1sKUrVF/6v66tM35lO3FE/Mr8ysKgP4zkV+ZXBIM+01gcTjIBfw2MBbD/qcP9X+kUk+3XyMmWdVW8kyBQ3/iBctTdBIH61g+Uo+4lCNRSP1COup8gUN/5gZK9fIJALfMD5aiHCQL1vR8oRz1KEKjlfqAc9ThBoFb4gXLUkwSBWukHylFPEwTqBz9QjnqWIFCr/EA56nmCQP3oB8pRLxIE6ic/UI5aTBCo1X6gHDUtP/cZ1/iBctSrBCPqZz9QjnqdIFC/+IFy1JsEgfrVD5Sj3iYI1G9+oBz1LkGgfvcD5aj3CQK11g+Uoz4kCNQffqAc9TFBoP70A+WoJQSBWucHylGfEQRqvR8oR31BEKi//EA56iuCQOXV8gOlviEIVCU/UI5aShCoyn6gHLWMIFD5fqActZwgUAXIQLnP0Kyet/HeMhe2UuU84wf2H/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/1/XW9lbL0K+PBkhX6ArPvJ6cc6WWL8loBxKQHjdwSMywgYvydgXE7AuIKAcSUB4w8EjKsIGH8kYPyJgHE1AeMaAsafCRh/IWD8lYDxNwLG3wkY1xIw/kHA+CcB4zoCxvUEjH8RMEIP1VtirETAWJmAMZ+AsYCAsVNh7jN2JmDsQsDYlYCxGwFjdwLGHgSMPQkYexEw9iZg7EPA2JeAsR8BY38CxgEEjAMJGAcRMA4mYBxCwDiUgHEYAeNwAsYRBIwjCRhHETCOJmAcQ8A4loBxHAHjeALGCQSMEwkYJxEwTiZgnELAOJWAMU7AWELAmCBgTBIwlhIwpggYpxEwTidgnEHAuA8B40wCxn0JGFsW5T5jKwLG1gSMbQgY2xIwtiNgdAgYFQFjgIAxSMAYImAsJmAMEzBGCBijBIwxAsb2BIwdCBg7EjB2ImDsTMDYhYCxKwFjNwLG7gSMPQgYexIw9iJg7E3A2IeAsS8BYz8Cxv4EjAMIGAcSMA4iYBxMwDiEgHEoAeMwAsbhBIwjCBhHEjCOImAcTcA4hoBxLAHjOALGqgTPVSgiYKxGwFidgLEGAWNNAsZaBIy1CRjrEDDWJWDcjoCxHgHj9gSMOxAw7kjAuBMBY30Cxp0JGHchYNyVgHE3AsbdCRj3IGBsQMDYkICxEQFjYwLGPQkY9yJgbELA2JSAsRkBY3MCxr0JGFsQMLYkYGxFwNiagLENAWNbAsZ2BIwOAaMiYAwQMAYJGEMEjMUEjGECxggBY5SAMUbA2J6AsQMBY0cCxk4EjJ0JGLsQMHYlYOxGwNidgLEHAWNPAsZeBIy9CRj7EDD2JWDsR8DYn4BxAAHjQALGQQSMgwkYhxAwDiVgHEbAOJyAcQQB40gCxlEEjKMJGMcQMI4lYBxHwDiegHECAeNEAsZJBIyTCRinEDBOJWCMEzCWEDAmCBiTBIylBIwpAsZpBIzTCRhnEDDuQ8A4k4BxXwLG/QgY9ydgPICA8UACxoMIGA8mYDyEgPFQAsbDCBgPJ2A8goDxSALGowgYjyZgnEXAeAwB42wCxmMJGOcQMM4lYDyOgPF4AsZ5BIwnEDCeSMB4EgHjfALGkwkYFxAwnkLAuJCA8VQCxkUEjKcRMJ5OwHgGAeOZBIxnETCeTcB4DgHjuQSM5zGcf6ye+4xjCRjHETCOJ2CcQMA4kYBxEgHjZALGKQSMUwkY4wSMJQSMCQLGJAFjKQFjioBxGgHjdALGGQSM+xAwziRg3JeAcT8Cxv0JGA8gYDyQgPEgAsaDCRgPIWA8lIDxMALGwwkYjyBgPJKA8SgCxqMJGGcRMB5DwDibgPFYAsY5BIxzCRiPI2A8noBxHgHjCQSMJxIwnkTAOJ+A8WQCxgUEjKcQMC4kYDyVgHERAeNpBIynEzCeQcB4JgHjWQSMZxMwnkPAeC4B43kEjOcTMF5AwHghAeNFBIwXEzBeQsB4KQHjZQSMlxMwXkHAeCUB41UEjFcTMF5DwHgtAeN1BIzXEzDeQMB4IwHjTQSMNxMw3kLAeCsB420EjLcTMN5BwHgnAeNdBIx3EzDeQ8B4LwHjfQSM9xMwPkDA+CAB40MEjA8TMD5CwPgoAeNjBIyPEzA+QcD4JAHjUwSMTxMwPkPA+CwB43MEjM8TML5AwPgiAeNLBIyLCRhfJmB8hYDxVQLG1wgYXydgfIOA8U0CxrcIGN8mYHyHgPFdAsb3CBjfJ2D8gIDxQwLGjwgYPyZg/ISAcQkB46cEjJ8RMH5OwPgFAeOXBIxfETB+TcD4DQHjtwSMSwkYvyNgXEbA+D0B43ICxhUEjCsJGH8gYFxFwPgjAeNPBIyrCRjXEDD+TMD4CwHjrwSMvxEw/k7AuJaA8Q8Cxj8JGNcRMK4nYPyLgDGvRu4zViJgrEzAmE/AWEDAWIWAsdACo/6B1B2Q+cdW3fKprLVtWZ1VauXlFYqqiopE1UTVRTVENUW1RLVFdUR1RduJ6om2F+0g2lG0k6i+aGfRLqJdRbuJdhftIWogaihqJGos2lO0l6iJqKmomai5aG9RC1FLUStRa1EbUVtRO5EjUqKAKCgKiYpFYVFEFBXFRO1FHUQdRZ1EnUVdRF1F3UTdRT1EPWttaINetbxGyfe+XUPXtCDAB00tOx0SPnBIOKuScBaRcFYj4axOwlmDhLMmCWctEs7aJJx1SDjrknBuR8JZj4RzexLOHUg4dyTh3ImEsz4J584knLuQcO5KwrkbCefuJJx7kHA2IOFsSMLZiISzMQnnniSce5FwNiHhbErC2YyEszkJ594knC1IOFuScLYi4WxNwtmGhLMtCWc7Ek6HhFORcAZIOIMknCESzmISzjAJZ4SEM0rCGSPhbE/C2YGEsyMJZycSzs4knF1IOLuScHYj4exOwtmDhLMnkNNlq+8xXleQl9eIuLyiysbySq38g1ZepZV/1Mo/aeXVWnmNV+4tbd5H1FfUT9RfNEA0UDRIJP9aXvW8Dedry2JeqXKe8dMVFDu/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev97/3/VWxtarltTE1fV5Tby/6P2UbwgYvyVgXErA+B0B4zICxu8JGJcTMK4gYFxJwPgDAeMqAsYfCRh/ImBcTcC4hoDxZwLGXwgYfyVg/I2A8XcCxrUEjH8QMP5JwLiOgHE9AeNfBIx5tXKfsRIBY2UCxnwCxgICxk6Fuc/YmYCxCwFjVwLGbgSM3QkYexAw9iRg7EXA2JuAsQ8BY18Cxn4EjP0JGAcQMA4kYBxEwDiYgHEIAeNQAsZhBIzDCRhHEDCOJGAcRcA4moBxDAHjWALGcQSM4wkYJxAwTiRgnETAOJmAcQoB41QCxjgBYwkBY4KAMUnAWErAmCJgnEbAOJ2AcQYB4z4EjDMJGPclYGxZlPuMrQgYWxMwtiFgbEvA2I6A0SFgVASMAQLGIAFjiICxmIAxTMAYIWCMEjDGCBjbEzB2IGDsSMDYiYCxMwFjFwLGrgSM3QgYuxMw9iBg7EnA2IuAsTcBYx8Cxr4EjP0IGPsTMA4gYBxIwDiIgHEwAeMQAsahBIzDCBiHEzCOIGAcScA4ioBxNAHjGALGsQSM4wgYqxI8V6GIgLEaAWN1AsYaBIw1CRhrETDWJmCsQ8BYl4BxOwLGegSM2xMw7kDAuCMB404EjPUJGHcmYNyFgHFXAsbdCBh3J2Dcg4CxAQFjQwLGRgSMjQkY9yRg3IuAsQkBY1MCxmYEjM0JGPcmYGxBwNiSgLEVAWNrAsY2BIxtCRjbETA6BIyKgDFAwBgkYAwRMBYTMIYJGCMEjFECxhgBY3sCxg4EjB0JGDsRMHYmYOxCwNiVgLEbAWN3AsYeBIw9CRh7ETD2JmDsQ8DYl4CxHwFjfwLGAQSMAwkYBxEwDiZgHELAOJSAcRgB43ACxhEEjCMJGEcRMI4mYBxDwDiWgHEcAeN4AsYJBIwTCRgnETBOJmCcQsA4lYAxTsBYQsCYIGBMEjCWEjCmCBinETBOJ2CcQcC4DwHjTALGfQkY9yNg3J+A8QACxgMJGA8iYDyYgPEQAsZDCRgPI2A8nIDxCALGIwkYjyJgPJqAcRYB4zEEjLMJGI8lYJxDwDiXgPE4AsbjCRjnETCeQMB4IgHjSQSM8wkYTyZgXEDAeAoB40ICxlMJGBcRMJ5GwHg6AeMZBIxnEjCeRcB4NgHjOQSM5xIwnsdw/rF67jOOJWAcR8A4noBxAgHjRALGSQSMkwkYpxAwTiVgjBMwlhAwJggYkwSMpQSMKQLGaQSM0wkYZxAw7kPAOJOAcV8Cxv0IGPcnYDyAgPFAAsaDCBgPJmA8hIDxUALGwwgYDydgPIKA8UgCxqMIGI8mYJxFwHgMAeNsAsZjCRjnEDDOJWA8joDxeALGeQSMJxAwnkjAeBIB43wCxpMJGBcQMJ5CwLiQgPFUAsZFBIynETCeTsB4BgHjmQSMZxEwnk3AeA4B47kEjOcRMJ5PwHgBAeOFBIwXETBeTMB4CQHjpQSMlxEwXk7AeAUB45UEjFcRMF5NwHgNAeO1BIzXETBeT8B4AwHjjQSMNxEw3kzAeAsB460EjLcRMN5OwHgHAeOdBIx3ETDeTcB4DwHjvQSM9xEw3k/A+AAB44MEjA8RMD5MwPgIAeOjBIyPETA+TsD4BAHjkwSMTxEwPk3A+AwB47MEjM8RMD5PwPgCAeOLBIwvETAuJmB8mYDxFQLGVwkYXyNgfJ2A8Q0CxjcJGN8iYHybgPEdAsZ3CRjfI2B8n4DxAwLGDwkYPyJg/JiA8RMCxiUEjJ8SMH5GwPg5AeMXBIxfEjB+RcD4NQHjNwSM3xIwLiVg/I6AcRkB4/cEjMsJGFcQMK4kYPyBgHEVAeOPBIw/ETCuJmBcQ8D4MwHjLwSMvxIw/kbA+DsB41oCxj8IGP8kYFxHwLiegPEvAsa8GrnPWImAsTIBYz4BYwEBYxUCxkILjPoHUndA5h9bdTshp7LWtmV1Dq6VlzdENFQ0TDRcNEI0UjRKNFo0RjRWNE40XjRBNFE0STRZNEU0VRQXlYgSoqSoVJQSTRNNF80Q7SOaKdpXtJ9of9EBogNFB4kOFh0iOlR0mOhw0RGiI0VHiY4WzRIdI5otOlY0RzRXdJzoeNE80QmiE0UnieaLThYtEJ0iWig6VbSo1oY2OK2W1yj53rfbIEVptqEG2zCDbbjBNsJgG2mwjTLYRhtsYwy2sQbbOINtvME2wWCbaLBNMtgmG2xTDLapBlvcYCsx2BIGW9JgKzXYUgbbNINtusE2w2Dbx2CbabDta7DtZ7Dtb7AdYLAdaLAdZLAdbLAdYrAdarAdZrAdbrAdYbAdabAdZbAdbbDNMtiOMdhmG2zHGmxzDLa5BttxBtvxBts8g+0Eg+1Eg+0kg22+wXaywbbAYDvFYFtosJ1qsC0y2NzJr2vepp9K3neZ3cnsowbXsrP45qdxBp1wKFQaCZSqoIo7gVhJtNgJFZeEoyqqiqPFyUA0GCyNhqKRWEks4sRUKFiqUsWxYMqre0lNXF2f416YrIZYar/K4Pb7BujzUBKfvwX6PIzE56VAn4eT+Pwd0OcRJD4vA/o8ksTn74E+jyLxeTnQ59EkPq8A+jyGxOeVQJ/Hkvj8A9DncSQ+rwL6PJ7E5x+BPk8g8fknoM8TSXxeDfR5EonPa4A+Tybx+Wegz1NIfP4F6PNUEp9/BfocJ/H5N6DPJSQ+/w70OUHi81qgz0kSn/8A+lxK4vOfQJ9TJD6vA/o8jcTn9UCfp5P4/BfQ5xkkPufhONU+JD5XAvo8k8TnykCf9yXxOR/o834kPhcAfd6fxOdOhTifDyDxuTPQ5wNJfO4C9PkgEp+7An0+mMTnbkCfDyHxuTvQ50NJfO4B9PkwEp97An0+nMTnXkCfjyDxuTfQ5yNJfO4D9PkoEp/7An0+msTnfkCfZ5H43B/o8zEkPg8A+jybxOeBQJ+PJfF5ENDnOSQ+Dwb6PJfE5yFAn48j8Xko0OfjSXweBvR5HonPw4E+n0Di8wigzyeS+DwS6PNJJD6PAvo8n8Tn0UCfTybxeQzQ5wUkPo8F+nwKic/jgD4vJPF5PNDnU0l8ngD0eRHQ5ypSR13NX/1TkNYGztZ+1IYv0Pj+uzbYuFHY/giMs40Hrqiygh7v02tt+D7D/dZvknf/wZI0m/svNcrzO0qmE8JRze10FFgsNnw26dBb6XPA81mdXgvXfmcAD7fYikVlcCyQ7Xemoa4SJ5EsViXhZESVxoujiUQsqFQgHo6HSwLRVGlJsYoWR6XORDwQlf9cIJ5QpU48XOouInXyNj5AQ/+gH6pxJnDx03nPqmUR2K0cXe/ZwM5gy++za21sYFC9RlbEZOKyogZsWb3IGJ0D7vhlC7pbb2P5zmYmOBK4wI8CLvDIKw1jCDPBc73xel56JniuIRM8LwuZIENHyXRgzyLJBMcAM8FzgRPjecBMcBZJJohsv/NJM8HzLWWCF9SyCHyBhUzwwhzPBF2/LyTJBM/zWNGZIDJGF1nKBC/aBpngUOACPwy4wCP3kEcQZoIXe+P1kvRM8GJDJnhJFjJBho6S6cCeTZIJjgBmghcDJ8ZLgJngbJJMENl+l5JmgpdaygQvq2UR+DILmeDlOZ4Jun5fTpIJXuKxojNBZIyusJQJXrENMsGBwAV+EHCBR54OHkKYCV7pjder0jPBKw2Z4FVZyAQZOkqmA3sOSSY4BJgJXgmcGK8CZoJzSDJBZPtdTZoJXm0pE7ymlkXgayxkgtfmeCbo+n0tSSZ4lceKzgSRMbrOUiZ43TbIBPsCF/h+wAUeed/nAMJM8HpvvN6Qngleb8gEb8hCJsjQUTId2MeRZIIDgJng9cCJ8QZgJngcSSaIbL8bSTPBGy1lgjfVsgh8k4VM8OYczwRdv28myQRv8FjRmSAyRrdYygRv2QaZYE/gAt8LuMAjn+jThzATvNUbr7elZ4K3GjLB27KQCTJ0lEwH9jySTLAPMBO8FTgx3gbMBOeRZILI9rudNBO83VImeEcti8B3WMgE78zxTND1+06STPA2jxWdCSJjdJelTPCubZAJdgUu8N2ACzzyWa09CDPBu73xek96Jni3IRO8JwuZIENHyXRgn0iSCfYAZoJ3AyfGe4CZ4IkkmSCy/e4lzQTvtZQJ3lfLIvB9FjLB+3M8E3T9vp8kE7zHY0VngsgYPWApE3wgm5mgtyh3Ai7KyDdnQN5I4SUxwDe3ZC0TfNAbrw+lZ4IPGjLBh2xmgkQdJdOBPT/XM0FDh840E3wQODE+BMwE55Nkgsj2e5g0E3zYUib4SC2LwI9YyAQfzfFM0PX7UZJM8CGPFZ0JImP0mKVM8LFtcE0Q9L7Kv2uDvQdSYd+vmE+YCT7ujdcn0jPBxw2Z4BNZuCbI0FEyHdgLSK4J5gMzwceB7fcEcNAuIMkEke33JGkm+KSlTPCpWhaBn7KQCT6d45mg6/fTJJngEx4rOhNExugZS5ngM9sgE/yzJm6BX1cTt8CvB75FHvhG+qxlgs964/W59EzwWUMm+FwWMkGGjpLpwF5Ikgn+VROXCT4LnBifA2aCC0kyQWT7PU+aCT5vKRN8oZZF4BcsZIIv5ngm6Pr9Ikkm+JzHis4EkTF6yVIm+NI2yAR/Ay7wvwMX+LXATPAPwkxwsTdeX07PBBcbMsGXs5AJMnSUTAf2IpJM8A9gJrgYODG+DMwEF5Fkgsj2e4U0E3zFUib4ai2LwK9ayARfy/FM0PX7NZJM8GWPFZ0JImP0uqVM8PVtkAmuAS7wPwMX+F+AmeCvhJngG954fTM9E3zDkAm+mYVMkKGjZDqwTyfJBH8FZoJvACfGN4GZ4OkkmSCy/d4izQTfspQJvl3LIvDbFjLBd3I8E3T9fockE3zTY0VngsgYvWspE3x3G2SCq4AL/I/ABf4nYCa4mjATfM8br++nZ4LvGTLB97OQCTJ0lIzf+0qSCa4GZoLvASfG94GZ4JkkmSCy/T4gzQQ/sJQJfljLIvCHFjLBj3I8E3T9/ogkE3zfY0VngsgYfWwpE/x4G2SCy4EL/ArgAr8SmAn+QJgJfuKN1yXpmeAnhkxwSRYyQYaOkunAPpskE/wBmAl+ApwYlwAzwbNJMkFk+31Kmgl+aikT/KyWReDPLGSCn+d4Juj6/TlJJrjEY0VngsgYfWEpE/xiG2SCS4EL/HfABX4ZMBP8njAT/NIbr1+lZ4JfGjLBr7KQCTJ0lEwH9rkkmeD3wEzwS+DE+BUwEzyXJBNEtt/XpJng15YywW9qWQT+xkIm+G2OZ4Ku39+SZIJfeazoTBAZo6WWMsGlW5AJ5iNjKAvpN8CM61tgsjCklp2FADQGjNnbd94YW5aevX1nyN6W2czePESG4GY6GM+3lDGkD7RMM67vgD4vA2Zc55NkXMj2+5404/reUsa1vJZF4OUWMq4VOZ5xuX6vIMm4lnms6IwLGaOVljKulV7G5Zbr5226MOuXWPSNN/04ln5IX791U3+gh1t+Qis/pJXv0cq3aeUbtPJVWvkSrXyeVj5DK/fWyn20cl+t3E8r99fKA7TyQK08yCv/IN+rRD+KfhKtFq0R/Sz6pdaGzLV63sbF0/3/VjKlsXn2sju/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev97/X/Wi93BsnEBAM35TM/cZvyVgXErA+B0B4zICxu8JGJcTMK4gYFxJwPgDAeMqAsYfCRh/ImBcTcC4hoDxZwLGXwgYfyVg/I2A8XcCxrUEjH8QMP5JwLiOgHE9AeNfBIx5BNdSKhEwViZgzCdgLCBg7FSY+4ydCRi7EDB2JWDsRsDYnYCxBwFjTwLGXgSMvQkY+xAw9iVg7EfA2J+AcQAB40ACxkEEjIMJGIcQMA4lYBxGwDicgHEEAeNIAsZRBIyjCRjHEDCOJWAcR8A4noBxAgHjRALGSQSMkwkYpxAwTiVgjBMwlhAwJggYkwSMpQSMKQLGaQSM0wkYZxAw7kPAOJOAcV8CxpZFuc/YioCxNQFjGwLGtgSM7QgYHQJGRcAYIGAMEjCGCBiLCRjDBIwRAsYoAWOMgLE9AWMHAsaOBIydCBg7EzB2IWDsSsDYjYCxOwFjDwLGngSMvQgYexMw9iFg7EvA2I+AsT8B4wACxoEEjIMIGAcTMA4hYBxKwDiMgHE4AeMIAsaRBIyjCBhHEzCOIWAcS8A4joCxKsFzFYoIGKsRMFYnYKxBwFiTgLEWAWNtAsY6BIx1CRi3I2CsR8C4PQHjDgSMOxIw7kTAWJ+AcWcCxl0IGHclYNyNgHF3AsY9CBgbEDA2JGBsRMDYmIBxTwLGvQgYmxAwNiVgbEbA2JyAcW8CxhYEjC0JGFsRMLYmYGxDwNiWgLEdAaNDwKgIGAMEjEECxhABYzEBY5iAMULAGCVgjBEwtidg7EDA2JGAsRMBY2cCxi4EjF0JGLsRMHYnYOxBwNiTgLEXAWNvAsY+BIx9CRj7ETD2J2AcQMA4kIBxEAHjYALGIQSMQwkYhxEwDidgHEHAOJKAcRQB42gCxjEEjGMJGMcRMI4nYJxAwDiRgHESAeNkAsYpBIxTCRjjBIwlBIwJAsYkAWMpAWOKgHEaAeN0AsYZBIz7EDDOJGDcl4BxPwLG/QkYDyBgPJCA8SACxoMJGA8hYDyUgPEwAsbDCRiPIGA8koDxKALGowkYZxEwHkPAOJuA8VgCxjkEjHMJGI8jYDyegHEeAeMJBIwnEjCeRMA4n4DxZALGBQSMpxAwLiRgPJWAcREB42kEjKcTMJ5BwHgmAeNZBIxnEzCeQ8B4LgHjeQznH6vnPuNYAsZxBIzjCRgnEDBOJGCcRMA4mYBxCgHjVALGOAFjCQFjgoAxScBYSsCYImCcRsA4nYBxBgHjPgSMMwkY9yVg3I+AcX8CxgMIGA8kYDyIgPFgAsZDCBgPJWA8jIDxcALGIwgYjyRgPIqA8WgCxlkEjMcQMM4mYDyWgHEOAeNcAsbjCBiPJ2CcR8B4AgHjiQSMJxEwzidgPJmAcQEB4ykEjAsJGE8lYFxEwHgaAePpBIxnEDCeScB4FgHj2QSM5xAwnkvAeB4B4/kEjBcQMF5IwHgRAePFBIyXEDBeSsB4GQHj5QSMVxAwXknAeBUB49UEjNcQMF5LwHgdAeP1BIw3EDDeSMB4EwHjzQSMtxAw3krAeBsB4+0EjHcQMN5JwHgXAePdBIz3EDDeS8B4HwHj/QSMDxAwPkjA+BAB48MEjI8QMD5KwPgYAePjBIxPEDA+ScD4FAHj0wSMzxAwPkvA+BwB4/MEjC8QML5IwPgSAeNiAsaXCRhfIWB8lYDxNQLG1wkY3yBgfJOA8S0CxrcJGN8hYHyXgPE9Asb3CRg/IGD8kIDxIwLGjwkYPyFgXELA+CkB42cEjJ8TMH5BwPglAeNXBIxfEzB+Q8D4LQHjUgLG7wgYlxEwfk/AuJyAcQUB40oCxh8IGFcRMP5IwPgTAeNqAsY1BIw/EzD+QsD4KwHjbwSMvxMwriVg/IOA8U8CxnUEjOsJGP8iYMyrkfuMlQgYKxMw5hMwFhAwViFgLLTAqH8gdQdk/rFVtxN1KmttW1bnr7Xy8n4T/S5aK/pD9KdonWi96C9RXm35/4gqi/JFBaIqokJRVVGRqJqouqiGqKaolqi2qI6ormg7UT3R9qIdRDuKdhLVF+0s2kW0q2g30e6iPUQNRA1FjUSNRXuK9hI1ETUVNRM1F+0taiFqKWolai1qI2oraidyREoUEAVFIVGxKFx7QxtEanuNku99u41SlGb7zWD73WBba7D9YbD9abCtM9jWG2x/GWxukNJtlQy2ygZbvsFWYLBVMdgKDbaqBluRwVbNYKtusNUw2GoabLUMttoGWx2Dra7Btp3BVs9g295g28Fg29Fg28lgq2+w7Wyw7WKw7Wqw7Waw7W6w7WGwNTDYGhpsjQy2xgbbngbbXgZbE4OtqcHWzGBrbrDtbbC1MNhaGmytDLbWBlsbg62twdbOYHMMNmWwBQy2oMEWMtiKDbawweZOiF3zNv2ULR5l9qATDoVKI4FSFVRxJxAriRY7oeKScFRFVXG0OBmIBoOl0VA0EiuJRZyYCgVLVao4Fkx5y9HEQuCFl1p2Fne0z5OAPv9G4vNkoM+/k/g8BejzWhKfpwJ9/oPE5zjQ5z9JfC4B+ryOxOcE0Of1JD4ngT7/ReJzKdDnvNocPqeAPlci8Xka0OfKJD5PB/qcT+LzDKDPBSQ+7wP0uQqJzzOBPheS+Lwv0OeqJD63LML5XETicyugz9VIfG4N9Lk6ic9tgD7XIPG5LdDnmiQ+twP6XIvEZwfoc20SnxXQ5zokPgeAPtcl8TkI9Hk7Ep9DQJ/rkfhcDPR5exKfw0CfdyDxOQL0eUcSn6NAn3ci8TkG9Lk+ic/tgT7vTOJzB6DPu5D43BHo864kPncC+rwbic+dgT7vTuJzF6DPe5D43BXocwMSn7sBfW5I4nN3oM+NSHzuAfS5MYnPPYE+70nicy+gz3uR+Nwb6HMTEp/7AH1uSuJzX6DPzUh87gf0uTmJz/2BPu9N4vMAoM8tSHweCPS5JYnPg4A+tyLxeTDQ59YkPg8B+tyGxOehQJ/bkvg8DOhzOxKfhwN9dkh8HgH0WZH4PBLoc4DE51FAn4MkPo8G+hwi8XkM0OdiEp/HAn0OA32uInXU1fzVPwVpbeBs7Udt+AKN779rg40bhe2PwDjbeAiLKivo8Y56DwmJpT8kxP0HS9Js7r/UKM/vKJlOCBc2t9NRYLHY8NmkQ2+lzwHPZxWtjWu/GG4SVLZiURkcC2T7tTfUVeIkksWqJJyMqNJ4cTSRiAWVCsTD8XBJIJoqLSlW0eKo1JmIB6LynwvEE6rUiYdL3UWkTp73kJ60TyVwG7QHLn46b4faFoHdytH1dgR2Blt+d6y9sYFB9RpZEZOJy4oasP+cUgLGqBO445ct6G69jeU7m5ngMOACPxy4wCOvNIwkzAQ7e+O1S3om2NmQCXbJQibI0FEyHdgXk2SCI4GZYGfgxNgFmAleTJIJItuvK2km2NVSJtittkXgbhYywe45ngm6fncnyQS7eKzoTBAZox6WMsEe2yATHARc4AcDF3jkHvJQwkywpzdee6Vngj0NmWCvLGSCDB0l04F9KUkmOBSYCfYEToy9gJngpSSZILL9epNmgr0tZYJ9alsE7mMhE+yb45mg63dfkkywl8eKzgSRMepnKRPstw0ywX7ABb4/cIFHng4eSJgJ9vfG64D0TLC/IRMckIVMkKGjZDqwLyfJBAcCM8H+wIlxADATvJwkE0S230DSTHCgpUxwUG2LwIMsZIKDczwTdP0eTJIJDvBY0ZkgMkZDLGWCQ7ZBJtgLuMD3Bi7wyPs++xJmgkO98TosPRMcasgEh2UhE2ToKJkO7CtJMsG+wExwKHBiHAbMBK8kyQSR7TecNBMcbikTHFHbIvAIC5ngyBzPBF2/R5JkgsM8VnQmiIzRKEuZ4KhtkAl2Ay7w3YELPPKJPj0JM8HR3ngdk54JjjZkgmOykAkydJRMB/bVJJlgT2AmOBo4MY4BZoJXk2SCyPYbS5oJjrWUCY6rbRF4nIVMcHyOZ4Ku3+NJMsExHis6E0TGaIKlTHDCNsgEOwEX+M7ABR75rNauhJngRG+8TkrPBCcaMsFJWcgEGTpKpgP7WpJMsCswE5wInBgnATPBa0kyQWT7TSbNBCdbygSn1LYIPMVCJjg1xzNB1++pJJngJI8VnQkiYxS3lAnGt0EmGAMu8O2BCzzyLRwdCTPBEm+8JtIzwRJDJpjIQibI0FEyHdjXk2SCHYGZYAlwYkwAM8HrSTJBZPslSTPBpKVMsLS2ReBSC5lgKsczQdfvFEkmmPBY0ZkgMkbTLGWC07ZBJlgMXODDwAUe+X7FKGEmON0brzPSM8HphkxwRhYyQYaOkunAvpEkE4wCM8HpwIlxBjATvJEkE0S23z6kmeA+ljLBmbUtAs+0kAnum+OZoOv3viSZ4AyPFZ0JImO0n6VMcL9tkAkq4AIfAC7wQeTT3Qkzwf298XpAeia4vyETPCALmSBDR8l0YN9MkgmGgJng/sCJ8QBgJngzSSaIbL8DSTPBAy1lggfVtgh8kIVM8OAczwRdvw8myQQP8FjRmSAyRodYygQP2QaZYBvgAt8WuMC3Q763izATPNQbr4elZ4KHGjLBw7KQCTJ0lEwH9q0kmaADzAQPBU6MhwEzwVtJMkFk+x1OmgkebikTPKK2ReAjLGSCR+Z4Juj6fSRJJniYx4rOBJExOspSJnjUNsgE9y3ELfAtgQt8K+QbmQkzwaO98TorPRM82pAJzspCJsjQUTId2LeTZIKtgZng0cCJcRYwE7ydJBNEtt8xpJngMZYywdm1LQLPtpAJHpvjmaDr97EkmeAsjxWdCSJjNMdSJjhnG2SC04EL/IxC3AK/TyGu/88stLOogMaTMROc643X49IzwbmGTPC4LGSCDB0l04F9J0kmOLMQlwnOBU6MxwEzwTtJMkFk+x1PmgkebykTnFfbIvA8C5ngCTmeCbp+n0CSCR7nsaIzQWSMTrSUCZ64DTLBJHCBLwUu8ClgJjiNMBM8yRuv89MzwZMMmeD8LGSCDB0l04F9N0kmOA2YCZ4EnBjnAzPBu0kyQWT7nUyaCZ5sKRNcUNsi8AILmeApOZ4Jun6fQpIJzvdY0ZkgMkYLLWWCC7dBJjgVuMDHgQt8CTATTBBmgqd643VReiZ4qiETXJSFTJCho2Q6sO8lyQQTwEzwVODEuAiYCd5Lkgki2+800kzwNEuZ4Om1LQKfbiETPCPHM0HX7zNIMsFFHis6E0TG6ExLmeCZ2yATnAhc4CcBF/jJwExwCmEmeJY3Xs9OzwTPMmSCZ2chE2ToKJkO7PtJMsEpwEzwLODEeDYwE7yfJBNEtt85pJngOZYywXNrWwQ+10ImeF6OZ4Ku3+eRZIJne6zoTBAZo/MtZYLne5mgW66ft+kir1/60TcE9WNi+s0D+i2l+oNG3PIMrZzQypO08hitPEwrD9DKvbRyF60c08o/1NpYXqWVf9TKP2nl1Vp5jVb+WSv/4pUvkP/OhaKLRBeLLhFdKrpMdHntDRl1da99y/pqJVN6nWcvU/Tr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/3/VS96D2dIrdxn/KZm7jN+S8C4lIDxOwLGZQSM3xMwLidgXEHAuJKA8QcCxlUEjD8SMP5EwLiagHENAePPBIy/EDD+SsD4GwHj7wSMawkY/yBg/JOAcR0B43oCxr8IGPMIrqVUImCsTMCYT8BYQMDYqTD3GTsTMHYhYOxKwNiNgLE7AWMPAsaeBIy9CBh7EzD2IWDsS8DYj4CxPwHjAALGgQSMgwgYBxMwDiFgHErAOIyAcTgB4wgCxpEEjKMIGEcTMI4hYBxLwDiOgHE8AeMEAsaJBIyTCBgnEzBOIWCcSsAYJ2AsIWBMEDAmCRhLCRhTBIzTCBinEzDOIGDch4BxJgHjvgSMLYtyn7EVAWNrAsY2BIxtCRjbETA6BIyKgDFAwBgkYAwRMBYTMIYJGCMEjFECxhgBY3sCxg4EjB0JGDsRMHYmYOxCwNiVgLEbAWN3AsYeBIw9CRh7ETD2JmDsQ8DYl4CxHwFjfwLGAQSMAwkYBxEwDiZgHELAOJSAcRgB43ACxhEEjCMJGEcRMI4mYBxDwDiWgHEcAWNVgucqFBEwViNgrE7AWIOAsSYBYy0CxtoEjHUIGOsSMG5HwFiPgHF7AsYdCBh3JGDciYCxPgHjzgSMuxAw7krAuBsB4+4EjHsQMDYgYGxIwNiIgLExAeOeBIx7ETA2IWBsSsDYjICxOQHj3gSMLQgYWxIwtiJgbE3A2IaAsS0BYzsCRoeAUREwBggYgwSMIQLGYgLGMAFjhIAxSsAYI2BsT8DYgYCxIwFjJwLGzgSMXQgYuxIwdiNg7E7A2IOAsScBYy8Cxt4EjH0IGPsSMPYjYOxPwDiAgHEgAeMgAsbBBIxDCBiHEjAOI2AcTsA4goBxJAHjKALG0QSMYwgYxxIwjiNgHE/AOIGAcSIB4yQCxskEjFMIGKcSMMYJGEsIGBMEjEkCxlICxhQB4zQCxukEjDMIGPchYJxJwLgvAeN+BIz7EzAeQMB4IAHjQQSMBxMwHkLAeCgB42EEjIcTMB5BwHgkAeNRBIxHEzDOImA8hoBxNgHjsQSMcwgY5xIwHkfAeDwB4zwCxhMIGE8kYDyJgHE+AePJBIwLCBhPIWBcSMB4KgHjIgLG0wgYTydgPIOA8UwCxrMIGM8mYDyHgPFcAsbzGM4/Vs99xrEEjOMIGMcTME4gYJxIwDiJgHEyAeMUAsapBIxxAsYSAsYEAWOSgLGUgDFFwDiNgHE6AeMMAsZ9CBhnEjDuS8C4HwHj/gSMBxAwHkjAeBAB48EEjIcQMB5KwHgYAePhBIxHEDAeScB4FAHj0QSMswgYjyFgnE3AeCwB4xwCxrkEjMcRMB5PwDiPgPEEAsYTCRhPImCcT8B4MgHjAgLGUwgYFxIwnkrAuIiA8TQCxtMJGM8gYDyTgPEsAsazCRjPIWA8l4DxPALG8wkYLyBgvJCA8SICxosJGC8hYLyUgPEyAsbLCRivIGC8koDxKgLGqwkYryFgvJaA8ToCxusJGG8gYLyRgPEmAsabCRhvIWC8lYDxNgLG2wkY7yBgvJOA8S4CxrsJGO8hYLyXgPE+Asb7CRgfIGB8kIDxIQLGhwkYHyFgfJSA8TECxscJGJ8gYHySgPEpAsanCRifIWB8loDxOQLG5wkYXyBgfJGA8SUCxsUEjC8TML5CwPgqAeNrBIyvEzC+QcD4JgHjWwSMbxMwvkPA+C4B43sEjO8TMH5AwPghAeNHBIwfEzB+QsC4hIDxUwLGzwgYPydg/IKA8UsCxq8IGL8mYPyGgPFbAsalBIzfETAuI2D8noBxOQHjCgLGlQSMPxAwriJg/JGA8ScCxtUEjGsIGH8mYPyFgPFXAsbfCBh/J2BcS8D4BwHjnwSM6wgY1xMw/kXAmFcj9xkrETBWJmDMJ2AsIGCsQsBYaIFR/0DqDsj8Y6tuJ+FU1tq2rM4rauflXSm6SnS16BrRtaLrRNeLbhDdKLpJdLPoFtGtottEt4vuEN0pukt0t+ge0b2i+0T3ix4QPSh6SPSw6BHRo6LHRI+LnhA9KXpK9LToGdGzoudEz4teEL0oekm0WPSy6BXRq6LXRK+L3hC9KXpL9LboHdG7ovdE74s+EH0o+kj0segT0RLRp7U3tMFntb1Gyfe+3UYpSrNdabBdZbBdbbBdY7Bda7BdZ7Bdb7DdYLDdaLDdZLDdbLDdYrDdarDdZrDdbrDdYbDdabDdZbDdbbDdY7Dda7DdZ7Ddb7A9YLA9aLA9ZLA9bLA9YrA9arA9ZrA9brA9YbA9abA9ZbA9bbA9Y7A9a7A9Z7A9b7C9YLC9aLC9ZLAtNtheNtheMdheNdheM9heN9jeMNjeNNjeMtjeNtjeMdjeNdjeM9jeN9g+MNg+NNg+Mtg+Ntg+MdiWGGyfGmzuhNg1b9NP2eJRZg864VCoNBIoVUEVdwKxkmixEyouCUdVVBVHi5OBaDBYGg1FI7GSWMSJqVCwVKWKY8GUtxyNK8It7lfUtrO4o32uinuJsrqSxOcioM9XkfhcDejz1SQ+Vwf6fA2JzzWAPl9L4nNNoM/XkfhcC+jz9SQ+1wb6fAOJz3WAPt9I4nNdoM83kfi8HdDnm0l8rgf0+RYSn7cH+nwric87AH2+jcTnHYE+307i805An+8g8bk+0Oc7SXzeGejzXSQ+7wL0+W4Sn3cF+nwPic+7AX2+l8Tn3YE+30fi8x5An+8n8bkB0OcHSHxuCPT5QRKfGwF9fojE58ZAnx8m8XlPoM+PkPi8F9DnR0l8bgL0+TESn5sCfX6cxOdmQJ+fIPG5OdDnJ0l83hvo81MkPrcA+vw0ic8tgT4/Q+JzK6DPz5L43Bro83MkPrcB+vw8ic9tgT6/QOJzO6DPL5L47AB9fonEZwX0eTGJzwGgzy+T+BwE+vwKic8hoM+vkvhcDPT5NRKfw0CfXyfxOQL0+Q0Sn6NAn98k8TkG9PktEp/bA31+m8TnDkCf3yHxuSPQ53dJfO4E9Pk9Ep87A31+n8TnLkCfPyDxuSvQ5w9JfO4G9PkjEp+7A33+mMTnHkCfPyHxuSfQ5yUkPvcC+vwp0OcqUkddzV/9U5DWBs7WftSGL9D4/rs22LhR2P4IjLONh7CosoIe789rb/j+wv3Wb5J3/8GSNJv7LzXK8ztKphPCg83tdBRYLDZ8NunQW+lzwPNZfV4b135f4CZBZSsWlcGxQLbfl4a6SpxEsliVhJMRVRovjiYSsaBSgXg4Hi4JRFOlJcUqWhyVOhPxQFT+c4F4QpU68XCpu4jUydswP6R/KoHb4Evg4qfzflXbIrBbObrer4GdwZbfX9fe2MCgeo2siMnEZUUN2LJ6kTH6BtzxyxZ0t97G8p3NTLAzcIHvAlzgkVcauhFmgt9643Vpeib4rSETXJqFTJCho2Q6sB8myQS7ATPBb4ET41JgJvgwSSaIbL/vSDPB7yxlgstqWwReZiET/D7HM0HX7+9JMsGlHis6E0TGaLmlTHD5NsgE2wMX+A7ABR65h9yJMBNc4Y3XlemZ4ApDJrgyC5kgQ0fJdGA/SpIJdgJmgiuAE+NKYCb4KEkmiGy/H0gzwR8sZYKralsEXmUhE/wxxzNB1+8fSTLBlR4rOhNExugnS5ngT9sgEwwDF/gIcIFHng6OEWaCq73xuiY9E1xtyATXZCETZOgomQ7sx0kywRgwE1wNnBjXADPBx0kyQWT7/UyaCf5sKRP8pbZF4F8sZIK/5ngm6Pr9K0kmuMZjRWeCyBj9ZikT/G0bZIIB4AIfBC7wyPs+iwkzwd+98bo2PRP83ZAJrs1CJsjQUTId2E+SZILFwEzwd+DEuBaYCT5Jkgki2+8P0kzwD0uZ4J+1LQL/aSETXJfjmaDr9zqSTHCtx4rOBJExWm8pE1y/DTLBtsAFvh1wgUc+0UcRZoJ/lY3Xstm8rJP8ZcgE3X+pUZ7fUTId2E+TZIIKmAn+hVy86uB8fJokE0S2X6U6nJlgpTrYBfGfWNWxCOxWjq43v05uZ4Ku3/l1NjYwqF4rmWCex4rOBJExKqhjJxN06812JtgSuMC3Ai7wyGe1tiHMBKt447UwPRN0/0F6JliYhUyQoaNkOrCfJckE2wAzwSrAibEQmAk+S5IJItuvKmkmWNVSJlhUxyJwkYVMsFqOZ4Ku39VIMsFCjxWdCSJjVN1SJlh9G2SCzYALfHPgAo98C0cLwkywhjdea6ZngjUMmWDNLGSCDB0l04H9PEkm2AKYCdYATow1gZng8ySZILL9apFmgrUsZYK161gErm0hE6yT45mg63cdkkywpseKzgSRMaprKROsuw0ywT2BC/xewAUe+X7FpoSZ4HbeeK2XngluZ8gE62UhE2ToKJkO7BdJMsGmwExwO+DEWA+YCb5Ikgki22970kxwe0uZ4A51LALvYCET3DHHM0HX7x1JMsF6His6E0TGaCdLmeBO2yATbABc4BsCF/hGwEywMWEmWN8brzunZ4L1DZngzlnIBBk6SqYDezFJJtgYmAnWB06MOwMzwcUkmSCy/XYhzQR3sZQJ7lrHIvCuFjLB3XI8E3T93o0kE9zZY0VngsgY7W4pE9x9G2SCuwIX+N2AC/zuwExwD8JMcA9vvDZIzwT3MGSCDbKQCTJ0lEwH9iskmeAewExwD+DE2ACYCb5Ckgki268haSbY0FIm2KiOReBGFjLBxjmeCbp+NybJBBt4rOhMEBmjPS1lgntug0xwJ+ACXx+4wO8MzAR3IcwE9/LGa5P0THAvQybYJAuZIENHyXRgv0aSCe4CzAT3Ak6MTYCZ4GskmSCy/ZqSZoJNLWWCzepYBG5mIRNsnuOZoOt3c5JMsInHis4EkTHa21ImuPc2yATrARf47YEL/A7ATHBHwkywhTdeW6Zngi0MmWDLLGSCDB0l04H9BkkmuCMwE2wBnBhbAjPBN0gyQWT7tSLNBFtZygRb17EI3NpCJtgmxzNB1+82JJlgS48VnQkiY9TWUibYdhtkgrWBC3wd4AJfF5gJbkeYCbbzxquTngm2M2SCThYyQYaOkunAfoskE9wOmAm2A06MDjATfIskE0S2nyLNBJWlTDBQxyJwwEImGMzxTND1O0iSCToeKzoTRMYoZCkTDG2DTLA6cIGvAVzgawIzwVqEmWCxN17D6ZlgsSETDGchE2ToKJkO7HdIMsFawEywGDgxhoGZ4DskmSCy/SKkmWDEUiYYrWMROGohE4zleCbo+h0jyQTDHis6E0TGqL2lTLD9NsgExxXhFviqwAW+CJgJViPMBDt447VjeibYwZAJdsxCJsjQUTId2O+RZILVgJlgB+DE2BGYCb5Hkgki268TaSbYyVIm2LmOReDOFjLBLjmeCbp+dyHJBDt6rOhMEBmjrpYywa5eJvj3w0LyNl3k9Us/+oagfkxMv3lAv6VUf9CIW66nlWtq5UKtnKeVy15r65bXaOWVWnmpVv5CK1+glS/Uyhdp5Yu18iVa+VKtfJlWvtwrdxPG7qIeop6iXqLeoj6ivnU2ZNTVvfYt66uVTOl1nr1M0a/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev16/Xr9ev9/9Xveg9nCG1cp/xm5q5z/gtAeNSAsbvCBiXETB+T8C4nIBxBQHjSgLGHwgYVxEw/kjA+BMB42oCxjUEjD8TMP5CwPgrAeNvBIy/EzCuJWD8g4DxTwLGdQSM6wkY/yJgzCO4llKJgLEyAWM+AWMBAWOnwtxn7EzA2IWAsSsBYzcCxu4EjD0IGHsSMPYiYOxNwNiHgLEvAWM/Asb+BIwDCBgHEjAOImAcTMA4hIBxKAHjMALG4QSMIwgYRxIwjiJgHE3AOIaAcSwB4zgCxvEEjBMIGCcSME4iYJxMwDiFgHEqAWOcgLGEgDFBwJgkYCwlYEwRME4jYJxOwDiDgHEfAsaZBIz7EjC2LMp9xlYEjK0JGNsQMLYlYGxHwOgQMCoCxgABY5CAMUTAWEzAGCZgjBAwRgkYYwSM7QkYOxAwdiRg7ETA2JmAsQsBY1cCxm4EjN0JGHsQMPYkYOxFwNibgLEPAWNfAsZ+BIz9CRgHEDAOJGAcRMA4mIBxCAHjUALGYQSMwwkYRxAwjiRgHEXAOJqAcQwB41gCxnEEjFUJnqtQRMBYjYCxOgFjDQLGmgSMtQgYaxMw1iFgrEvAuB0BYz0Cxu0JGHcgYNyRgHEnAsb6BIw7EzDuQsC4KwHjbgSMuxMw7kHA2ICAsSEB4/+xdxZwchTdFt8ogRAiG8cS3OmaWZkFQtzdXWZ3duLurkSIQBwLbsEtuLu7S3BICBAChBAC5N0mvV86w4XInNrMefT8fuftcPle8b91q7rOdLXUIGCsScB4FAHj0QSMxxAwHkvAeBwB4/EEjCcQMJ5IwHgSAePJBIynEDCeSsB4GgHj6QSMDgGjIWAMETCGCRgzCBgzCRizCBizCRgjBIw5BIxnEDCeScB4FgFjLQLGswkYaxMw1iFgrEvAWI+AsT4BYwMCxoYEjI0IGBsTMDYhYGxKwNiMgLE5AWMLAsaWBIytCBhbEzC2IWBsS8DYjoCxPQFjBwLGjgSMnQgYOxMwdiFg7ErA2I2AsTsBYw8Cxp4EjL0IGHsTMPYhYIwSMOYSMOYRMMYIGPMJGOMEjH0JGPsRMPYnYBxAwDiQgHEQAeNgAsYhBIxDCRiHETAOJ2AcQcA4koBxFAHjaALGMQSMYwkYxxEwjidgnEDAOJGAcRIB42QCxikEjFMJGKcRME4nYJxBwDiTgHEWAeM5BIyzCRjnEDDOJWCcR8B4LgHjfALGBQSMCwkYFxEwnkfAeD4B42ICxiUEjEsJGJcRMC4nYFzBcP3jQanP2IWAsSsBYzcCxu4EjD0IGHsSMPYiYOxNwNiHgDFKwJhLwJhHwBgjYMwnYIwTMPYlYOxHwNifgHEAAeNAAsZBBIyDCRiHEDAOJWAcRsA4nIBxBAHjSALGUQSMowkYxxAwjiVgHEfAOJ6AcQIB40QCxkkEjJMJGKcQME4lYJxGwDidgHEGAeNMAsZZBIznEDDOJmCcQ8A4l4BxHgHjuQSM8wkYFxAwLiRgXETAeB4B4/kEjIsJGJcQMC4lYFxGwLicgHEFAeNKAsYLCBgvJGC8iIDxYgLGSwgYVxEwXkrAeBkB4+UEjFcQMF5JwHgVAePVBIzXEDBeS8B4HQHj9QSMqwkYbyBgvJGA8SYCxpsJGG8hYLyVgPE2AsbbCRjvIGC8k4DxLgLGNQSMdxMw3kPAeC8B430EjPcTMD5AwPggAeNDBIwPEzA+QsD4KAHjYwSMjxMwPkHA+CQB41MEjE8TMD5DwPgsAeNzBIzPEzC+QMD4IgHjSwSMLxMwvkLA+CoB42sEjK8TML5BwPgmAeNbBIxvEzC+Q8D4LgHjewSM7xMwfkDA+CEB40cEjGsJGD8mYPyEgPFTAsbPCBg/J2D8goDxSwLGrwgYvyZgXEfAuJ6A8RsCxg0EjN8SMH5HwPg9AeNGAsYfCBg3ETD+SMD4EwHjzwSMmwkYfyFg3ELA+CsB41YCxt8IGLcRMP5OwPgHAeOfBIzbCRjTSqc+YxECxqIEjMUIGIsTMJYgYCxpgdH/gbQdkuOPrbaN4xT19W1Bm03LpqU1EzUXtRC1FLUStRa1EbUVtRO1F3UQdRR1EnUWdRF1FXUTdRf1EPUU9RL1FvURRUW5ojxRTJQviov6ivqJ+osGiAaKBokGi4aIhoqGiYaLRohGikaJRovGiMaKxonGiyaIJoomiSaLpoimiqaJpotmiGaKZonOEc0WzRHNLbujD+aV9TqlmPfX7ZRSCbFmSqy5EmuhxFoqsVZKrLUSa6PE2iqxdkqsvRLroMQ6KrFOSqyzEuuixLoqsW5KrLsS66HEeiqxXkqstxLro8SiSixXieUpsZgSy1dicSXWV4n1U2L9ldgAJTZQiQ1SYoOV2BAlNlSJDVNiw5XYCCU2UomNUmKjldgYJTZWiY1TYuOV2AQlNlGJTVJik5XYFCU2VYlNU2LTldgMJTZTic1SYucosdlKbI4Sm6vE3ANinbRdPwWLR0E87GRlZORnh/JN2ESdUE5uJNPJyMzNipiIyYxkxkKRcDg/khHJzsnNyXZyTEY438Qzc8Jxbz1qhHuhsGla1s7ijs65MTDnZiQ5NwHm3Jwk56bAnFuQ5NwMmHNLkpybA3NuRZJzC2DOrUlybgnMuQ1Jzq2AObclybk1MOd2JDm3AebcniTntsCcO5Dk3A6Yc0eSnNsDc+5EknMHYM6dSXLuCMy5C0nOnYA5dyXJuTMw524kOXcB5tydJOeuwJx7kOTcDZhzT5KcuwNz7kWScw9gzr1Jcu4JzLkPSc69gDlHSXLuDcw5lyTnPsCc80hyjgJzjpHknAvMOZ8k5zxgznGSnGPAnPuS5JwPzLkfSc5xYM79SXLuC8x5AEnO/YA5DyTJuT8w50EkOQ8A5jyYJOeBwJyHkOQ8CJjzUJKcBwNzHkaS8xBgzsNJch4KzHkESc7DgDmPJMl5ODDnUSQ5jwDmPJok55HAnMeQ5DwKmPNYkpxHA3MeR5LzGGDO40lyHgvMeQJJzuOAOU8kyXk8MOdJJDlPAOY8mSTnicCcp5DkPAmY81SSnCcDc55GkvMUYM7TSXKeCsx5BknO04A5zyTJeTow51kkOc8A5nwOSc4zgTnPJsl5FjDnOSQ5nwPMeS4w5xLSRjlfvv5P8YQ+cPb1Y3b8Ac3vv1qDzRuDHY/AOtt4CIsp+OKv97lld/yd7/713yTv/ou1CTH3f1QjLRgoyR4Q3jvezkCB1WLHZ5cBvY85h7yczbllcf03H3cQNLZqURRcC2T/LVDaynXyYpkmNyuWbfKjmZG8vJywMaFoVjQrNxSJ5+dmmkhmRNrMi4Yi8p8LRfNMvhPNyncXkYJjR+KnCLgPFgAXPz/vwrIWgd3G0e0uAg4GW3kvKruzg0HtqqyIg4nLipqwBe0ia3QeeOAXLOhuuzXlb2E6wSnABX4qcIFHnmmYTugEz/fm6+JEJ3i+4gQXF4ITZBgoyU7sD0ic4HSgEzwfeGBcDHSCH5A4QWT/LSF1gkssOcGlZS0CL7XgBJeluBN0815G4gQXe6xoJ4is0XJLTnD5fnCCE4AL/ETgAo/cQ55M6ARXePN1ZaITXKE4wZWF4AQZBkqyE/sjEic4GegEVwAPjCuBTvAjEieI7L8LSJ3gBZac4IVlLQJfaMEJXpTiTtDN+yISJ7jSY0U7QWSNLrbkBC/eD05wDHCBHwtc4JFXB48ndIKXePN1VaITvERxgqsKwQkyDJRkJ/bHJE5wPNAJXgI8MK4COsGPSZwgsv8uJXWCl1pygpeVtQh8mQUneHmKO0E378tJnOAqjxXtBJE1usKSE7xiPzjBEcAFfiRwgUfe9zma0Ale6c3XqxKd4JWKE7yqEJwgw0BJdmJ/SuIERwOd4JXAA+NVQCf4KYkTRPbf1aRO8GpLTvCashaBr7HgBK9NcSfo5n0tiRO8ymNFO0Fkja6z5ASv2w9OcAhwgR8KXOCRT/QZTugEr/fm6+pEJ3i94gRXF4ITZBgoyU7sz0mc4HCgE7weeGBcDXSCn5M4QWT/3UDqBG+w5ARvLGsR+EYLTvCmFHeCbt43kTjB1R4r2gkia3SzJSd4835wggOAC/xA4AKPfFbrYEIneIs3X29NdIK3KE7w1kJwggwDJdmJ/SWJExwMdIK3AA+MtwKd4JckThDZf7eROsHbLDnB28taBL7dghO8I8WdoJv3HSRO8FaPFe0EkTW605ITvHM/OME4cIHvC1zgkW/h6E/oBO/y5uuaRCd4l+IE1xSCE2QYKMlO7K9JnGB/oBO8C3hgXAN0gl+TOEFk/91N6gTvtuQE7ylrEfgeC07w3hR3gm7e95I4wTUeK9oJImt0nyUneN9+cIK5wAU+D7jAI9+vmE/oBO/35usDiU7wfsUJPlAITpBhoCQ7sdeTOMF8oBO8H3hgfADoBNeTOEFk/z1I6gQftOQEHyprEfghC07w4RR3gm7eD5M4wQc8VrQTRNboEUtO8JH94AR7ARf43sAFvg/QCUYJneCj3nx9LNEJPqo4wccKwQkyDJRkJ/YGEicYBTrBR4EHxseATnADiRNE9t/jpE7wcUtO8ImyFoGfsOAEn0xxJ+jm/SSJE3zMY0U7QWSNnrLkBJ/aD06wG3CB7w5c4HsAnWBPQif4tDdfn0l0gk8rTvCZQnCCDAMl2Yn9HYkT7Al0gk8DD4zPAJ3gdyROENl/z5I6wWctOcHnyloEfs6CE3w+xZ2gm/fzJE7wGY8V7QSRNXrBkhN8YT84wU7ABb4zcIHvAnSCXQmd4IvefH0p0Qm+qDjBlwrBCTIMlGQn9kYSJ9gV6ARfBB4YXwI6wY0kThDZfy+TOsGXLTnBV8paBH7FghN8NcWdoJv3qyRO8CWPFe0EkTV6zZITfG0/OMF2wAW+PXCB7wB0gh0JneDr3nx9I9EJvq44wTcKwQkyDJRkJ/YmEifYEegEXwceGN8AOsFNJE4Q2X9vkjrBNy05wbfKWgR+y4ITfDvFnaCb99skTvANjxXtBJE1eseSE3xnPzjBVsAFvjVwgW8DdIJtCZ3gu958fS/RCb6rOMH3CsEJMgyUZCf2TyROsC3QCb4LPDC+B3SCP5E4QWT/vU/qBN+35AQ/KGsR+AMLTvDDFHeCbt4fkjjB9zxWtBNE1ugjS07wo/3gBJsBF/jmwAW+BdAJtiR0gmu9+fpxohNcqzjBjwvBCTIMlGQn9mYSJ9gS6ATXAg+MHwOd4GYSJ4jsv09IneAnlpzgp2UtAn9qwQl+luJO0M37MxIn+LHHinaCyBp9bskJfr4fnGAj4ALfGLjANwE6waaETvALb75+megEv1Cc4JeF4AQZBkqyE3sLiRNsCnSCXwAPjF8CneAWEieI7L+vSJ3gV5ac4NdlLQJ/bcEJrktxJ+jmvY7ECX7psaKdILJG6y05wfWeE3S/V0nbdZH3n/rxbwj6LxPz3zzgv6XU/6AR9/sDvu9rfN9v9X1f7ft+le/7Kt/3lb7vi33f5/u+1/V9r+f7Xt/3vYHve0Pf90a+741935t437+RvxtE34q+E30v2ij6QbSp7A5HfZDXvwVjtYhmr9PsOcWg3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN3/X+2i93Bal0l9xq8OTn3GrwkY1xEwridg/IaAcQMB47cEjN8RMH5PwLiRgPEHAsZNBIw/EjD+RMD4MwHjZgLGXwgYtxAw/krAuJWA8TcCxm0EjL8TMP5BwPgnAeN2AsY0gnMpRQgYixIwFiNgLE7AWKtk6jOeTcBYm4CxDgFjXQLGegSM9QkYGxAwNiRgbETA2JiAsQkBY1MCxmYEjM0JGFsQMLYkYGxFwNiagLENAWNbAsZ2BIztCRg7EDB2JGDsRMDYmYCxCwFjVwLGbgSM3QkYexAw9iRg7EXA2JuAsQ8BY5SAMZeAMY+AMUbAmE/AGCdg7EvA2I+AsT8B4wACxoEEjIMIGE8qlfqMJxMwnkLAeCoB42kEjKcTMDoEjIaAMUTAGCZgzCBgzCRgzCJgzCZgjBAw5hAwnkHAeCYB41kEjLUIGM8mYKxNwFiHgLEuAWM9Asb6BIwNCBgbEjA2ImBsTMDYhICxKQFjMwLG5gSMLQgYWxIwtiJgbE3A2IaAsS0BYzsCxvYEjB0IGDsSMHYiYOxMwNiFgLErAeMBBM9VKEXAeCAB40EEjKUJGA8mYCxDwHgIAWNZAsZyBIzlCRgrEDCmEzBWJGCsRMBYmYCxCgFjVQLGagSM1QkYDyVgPIyA8XACxiMIGI8kYKxBwFiTgPEoAsajCRiPIWA8loDxOALG4wkYTyBgPJGA8SQCxpMJGE8hYDyVgPE0AsbTCRgdAkZDwBgiYAwTMGYQMGYSMGYRMGYTMEYIGHMIGM8gYDyTgPEsAsZaBIxnEzDWJmCsQ8BYl4CxHgFjfQLGBgSMDQkYGxEwNiZgbELA2JSAsRkBY3MCxhYEjC0JGFsRMLYmYGxDwNiWgLEdAWN7AsYOBIwdCRg7ETB2JmDsQsDYlYCxGwFjdwLGHgSMPQkYexEw9iZg7EPAGCVgzCVgzCNgjBEw5hMwxgkY+xIw9iNg7E/AOICAcSAB4yACxsEEjEMIGIcSMA4jYBxOwDiCgHEkAeMoAsbRBIxjCBjHEjCOI2AcT8A4gYBxIgHjJALGyQSMUwgYpxIwTiNgnE7AOIOAcSYB4ywCxnMIGGcTMM4hYJxLwDiPgPFcAsb5BIwLCBgXEjAuImA8j4DxfALGxQSMSwgYlxIwLiNgXE7AuILh+seDUp+xCwFjVwLGbgSM3QkYexAw9iRg7EXA2JuAsQ8BY5SAMZeAMY+AMUbAmE/AGCdg7EvA2I+AsT8B4wACxoEEjIMIGAcTMA4hYBxKwDiMgHE4AeMIAsaRBIyjCBhHEzCOIWAcS8A4joBxPAHjBALGiQSMkwgYJxMwTiFgnErAOI2AcToB4wwCxpkEjLMIGM8hYJxNwDiHgHEuAeM8AsZzCRjnEzAuIGBcSMC4iIDxPALG8wkYFxMwLiFgXErAuIyAcTkB4woCxpUEjBcQMF5IwHgRAePFBIyXEDCuImC8lIDxMgLGywkYryBgvJKA8SoCxqsJGK8hYLyWgPE6AsbrCRhXEzDeQMB4IwHjTQSMNxMw3kLAeCsB420EjLcTMN5BwHgnAeNdBIxrCBjvJmC8h4DxXgLG+wgY7ydgfICA8UECxocIGB8mYHyEgPFRAsbHCBgfJ2B8goDxSQLGpwgYnyZgfIaA8VkCxucIGJ8nYHyBgPFFAsaXCBhfJmB8hYDxVQLG1wgYXydgfIOA8U0CxrcIGN8mYHyHgPFdAsb3CBjfJ2D8gIDxQwLGjwgY1xIwfkzA+AkB46cEjJ8RMH5OwPgFAeOXBIxfETB+TcC4joBxPQHjNwSMGwgYvyVg/I6A8XsCxo0EjD8QMG4iYPyRgPEnAsafCRg3EzD+QsC4hYDxVwLGrQSMvxEwbiNg/J2A8Q8Cxj8JGLcTMKaVTn3GIgSMRQkYixEwFidgLEHAWNICo/8DaTskxx9bbZsMp6ivbwva/LFsWtpPop9Fm0W/iLaIfhVtFf0m2ib6XfSH6E/RdlFaOWlHVFRUTFRcVEJUUnSAqJToQNFBotKig0VlRIeIyorKicqLKojSRRVFlUSVRVVEVUXVRNVFh4oOEx0uOkJ0pKiGqKboKNHRomNEx4qOEx0vOkF0ougk0cmiU0Snik4TnS5yRKbcjj4IlfM6pZj31+2UUgmxn5TYz0pssxL7RYltUWK/KrGtSuw3JbZNif2uxP5QYn8qse1KzC16YqyIEiuqxIopseJKrIQSK6nEDlBipZTYgUrsICVWWokdrMTKKLFDlFhZJVZOiZVXYhWUWLoSq6jEKimxykqsihKrqsSqKbHqSuxQJXaYEjtciR2hxI5UYjWUWE0ldpQSO1qJHaPEjlVixymx45XYCUrsRCV2khI7WYmdosROVWKnKbHTlZijxIwScw+IddJ2/RQsHgXxsJOVkZGfHco3YRN1Qjm5kUwnIzM3K2IiJjOSGQtFwuH8SEYkOyc3J9vJMRnhfBPPzAnHvfVoNu6FwsY9XoPacmzmPAeY808kOc8F5vwzSc7zgDlvJsn5XGDOv5DkPB+Y8xaSnBcAc/6VJOeFwJy3kuS8CJjzbyQ5nwfMeRtJzucDc/6dJOfFwJz/IMl5CTDnP0lyXgrMeTtJzsuAOaeV48h5OTDnIiQ5rwDmXJQk5864DURTjCTnLsCci5Pk3BWYcwmSnLsBcy5JknN3YM4HkOTcA5hzKZKcewJzPpAk517AnA8iybk3MOfSJDn3AeZ8MEnOUWDOZUhyzgXmfAhJznnAnMuS5BwD5lyOJOd8YM7lSXKOA3OuQJJzX2DO6SQ59wPmXJEk5/7AnCuR5DwAmHNlkpwHAnOuQpLzIGDOVUlyHgzMuRpJzkOAOVcnyXkoMOdDSXIeBsz5MJKchwNzPpwk5xHAnI8gyXkkMOcjSXIeBcy5BknOo4E51yTJeQww56NIch4LzPlokpzHAXM+hiTn8cCcjyXJeQIw5+NIcp4IzPl4kpwnAXM+gSTnycCcTyTJeQow55NIcp4KzPlkkpynAXM+hSTn6cCcTyXJeQYw59NIcp4JzPl0kpxnAXN2SHI+B5izAeZcIu2vRx78L1//p3hCHzj7+jE7/oDm91+tweaNwY5HYJ0dpSTJtm0KvvjrHS6342+G+9d/k7z7L9YmxNz/UY20YKAke0DYerydgQKrxY7PLgN6H3MOeTmbcDlc/2XgDoLGVi2KgmuB7L9Mpa1cJy+WaXKzYtkmP5oZycvLCRsTimZFs3JDkXh+bqaJZEakzbxoKCL/uVA0z+Q70ax8dxFxH5hUJO3vnyLgPsgELn5+3qxyFoHdxtHtZgMHg628s8vt7GBQuyor4mDisqImbEG7yBpFwAO/YEF3260pfwvTCU4BLvBTgQs88kzDdEInmOPN1zMSnWCO4gTPKAQnyDBQkp3Y20ic4HSgE8wBHhjPADrBbSROENl/Z5I6wTMtOcGzylkEPsuCE6yV4k7QzbsWiRM8w2NFO0Fkjc625ATP3g9OcAJwgZ8IXOCRe8iTCZ1gbW++1kl0grUVJ1inEJwgw0BJdmL/QeIEJwOdYG3ggbEO0An+QeIEkf1Xl9QJ1rXkBOuVswhcz4ITrJ/iTtDNuz6JE6zjsaKdILJGDSw5wQb7wQmOAS7wY4ELPPLq4PGETrChN18bJTrBhooTbFQITpBhoCQ7sbeTOMHxQCfYEHhgbAR0gttJnCCy/xqTOsHGlpxgk3IWgZtYcIJNU9wJunk3JXGCjTxWtBNE1qiZJSfYbD84wRHABX4kcIFH3vc5mtAJNvfma4tEJ9hccYItCsEJMgyUZCd2kRM4nOBooBNsDjwwtgA6QVu1QDtBZP+1JHWCLS05wVblLAK3suAEW6e4E3Tzbk3iBFt4rGgniKxRG0tOsM1+cIJDgAv8UOACj3yiz3BCJ9jWm6/tEp1gW8UJtisEJ8gwUJKd2MVInOBwoBNsCzwwtgM6wWIkThDZf+1JnWB7S06wQzmLwB0sOMGOKe4E3bw7kjjBdh4r2gkia9TJkhPstB+c4ADgAj8QuMAjn9U6mNAJdvbma5dEJ9hZcYJdCsEJMgyUZCd2CRInOBjoBDsDD4xdgE6wBIkTRPZfV1In2NWSE+xWziJwNwtOsHuKO0E37+4kTrCLx4p2gsga9bDkBHvsBycYBy7wfYELPPItHP0JnWBPb772SnSCPRUn2KsQnCDDQEl2Yh9A4gT7A51gT+CBsRfQCR5A4gSR/deb1An2tuQE+5SzCNzHghOMprgTdPOOkjjBXh4r2gkia5RryQnm7gcnmAtc4POACzzy/Yr5hE4wz5uvsUQnmKc4wVghOEGGgZLsxD6QxAnmA51gHvDAGAM6wQNJnCCy//JJnWC+JScYL2cROG7BCfZNcSfo5t2XxAnGPFa0E0TWqJ8lJ9hvPzjBXsAFvjdwge8DdIJRQifY35uvAxKdYH/FCQ4oBCfIMFCSndilSZxgFOgE+wMPjAOATrA0iRNE9t9AUic40JITHFTOIvAgC05wcIo7QTfvwSROcIDHinaCyBoNseQEh+wHJ9gNuMB3By7wPYBOsCehExzqzddhiU5wqOIEhxWCE2QYKMlO7DIkTrAn0AkOBR4YhwGdYBkSJ4jsv+GkTnC4JSc4opxF4BEWnODIFHeCbt4jSZzgMI8V7QSRNRplyQmOKkwn6C3KnYGLchege+t6EM7ErDiYzwmO9ubrmEQnOFpxgmNsOkGigZLsxC6b6k5QGdDJOsHRwAPjGKATLEviBJH9N5bUCY615ATHlbMIPM6CExyf4k7QzXs8iRMc47GinSCyRhMsOcEJ++Gc4JKDcWZh6cE4s7AM597MckInONGbr5MSneBExQlOKoRzggwDJdmJXZ7knOByoBOcCDwwTgI6wfIkThDZf5NJneBkS05wSjmLwFMsOMGpKe4E3bynkjjBSR4r2gkiazTNkhOcth+c4CLgAn8ecIE/H+gEFxM6wenefJ2R6ASnK05wRiE4QYaBkuzETidxgouBTnA68MA4A+gE00mcILL/ZpI6wZmWnOCschaBZ1lwguekuBN08z6HxAnO8FjRThBZo9mWnODs/eAEzwUu8POBC/wCoBNcSOgE53jzdW6iE5yjOMG5heAEGQZKshO7EokTXAh0gnOAB8a5QCdYicQJIvtvHqkTnGfJCZ5bziLwuRac4PwUd4Ju3vNJnOBcjxXtBJE1WmDJCS7YD05wNnCBnwNc4OcCneA8Qie40JuvixKd4ELFCS4qBCfIMFCSndhVSJzgPKATXAg8MC4COsEqJE4Q2X/nkTrB8yw5wfPLWQQ+34ITXJziTtDNezGJE1zksaKdILJGSyw5wSWeE3S/V0nbdZH3n/rxbwj6LxPz3zzgv6XU/6AR93vM972X73sX3/d2vu8tfN8b+b7X8X0/w/c9w/f9m7I7v2/wff/W9/073/fvfd83+r7/4Pu+yfu+VP47y0TLRStEK0UXiC4UXVRuh6M+yOvfgrFaRLPXafacYtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7Q7v+vdtF7OK3LpD7jVwenPuPXBIzrCBjXEzB+Q8C4gYDxWwLG7wgYvydg3EjA+AMB4yYCxh8JGH8iYPyZgHEzAeMvBIxbCBh/JWDcSsD4GwHjNgLG3wkY/yBg/JOAcTsBYxrBuZQiBIxFCRiLETAWJ2CsVTL1Gc8mYKxNwFiHgLEuAWM9Asb6BIwNCBgbEjA2ImBsTMDYhICxKQFjMwLG5gSMLQgYWxIwtiJgbE3A2IaAsS0BYzsCxvYEjB0IGDsSMHYiYOxMwNiFgLErAWM3AsbuBIw9CBh7EjD2ImDsTcDYh4AxSsCYS8CYR8AYI2DMJ2CMEzD2JWDsR8DYn4BxAAHjQALGQQSMJ5VKfcaTCRhPIWA8lYDxNALG0wkYHQJGQ8AYImAMEzBmEDBmEjBmETBmEzBGCBhzCBjPIGA8k4DxLALGWgSMZxMw1iZgrEPAWJeAsR4BY30CxgYEjA0JGBsRMDYmYGxCwNiUgLEZAWNzAsYWBIwtCRhbETC2JmBsQ8DYloCxHQFjewLGDgSMHQkYOxEwdiZg7ELA2JWA8QCC5yqUImA8kIDxIALG0gSMBxMwliFgPISAsSwBYzkCxvIEjBUIGNMJGCsSMFYiYKxMwFiFgLEqAWM1AsbqBIyHEjAeRsB4OAHjEQSMRxIw1iBgrEnAeBQB49EEjMcQMB5LwHgcAePxBIwnEDCeSMB4EgHjyQSMpxAwnkrAeBoB4+kEjA4BoyFgDBEwhgkYMwgYMwkYswgYswkYIwSMOQSMZxAwnknAeBYBYy0CxrMJGGsTMNYhYKxLwFiPgLE+AWMDAsaGBIyNCBgbEzA2IWBsSsDYjICxOQFjCwLGlgSMrQgYWxMwtiFgbEvA2I6AsT0BYwcCxo4EjJ0IGDsTMHYhYOxKwNiNgLE7AWMPAsaeBIy9CBh7EzD2IWCMEjDmEjDmETDGCBjzCRjjBIx9CRj7ETD2J2AcQMA4kIBxEAHjYALGIQSMQwkYhxEwDidgHEHAOJKAcRQB42gCxjEEjGMJGMcRMI4nYJxAwDiRgHESAeNkAsYpBIxTCRinETBOJ2CcQcA4k4BxFgHjOQSMswkY5xAwziVgnEfAeC4B43wCxgUEjAsJGBcRMJ5HwHg+AeNiAsYlBIxLCRiXETAuJ2BcwXD940Gpz9iFgLErAWM3AsbuBIw9CBh7EjD2ImDsTcDYh4AxSsCYS8CYR8AYI2DMJ2CMEzD2JWDsR8DYn4BxAAHjQALGQQSMgwkYhxAwDiVgHEbAOJyAcQQB40gCxlEEjKMJGMcQMI4lYBxHwDiegHECAeNEAsZJBIyTCRinEDBOJWCcRsA4nYBxBgHjTALGWQSM5xAwziZgnEPAOJeAcR4B47kEjPMJGBcQMC4kYFxEwHgeAeP5BIyLCRiXEDAuJWBcRsC4nIBxBQHjSgLGCwgYLyRgvIiA8WICxksIGFcRMF5KwHgZAePlBIxXEDBeScB4FQHj1QSM1xAwXkvAeB0B4/UEjKsJGG8gYLyRgPEmAsabCRhvIWC8lYDxNgLG2wkY7yBgvJOA8S4CxjUEjHcTMN5DwHgvAeN9BIz3EzA+QMD4IAHjQwSMDxMwPkLA+CgB42MEjI8TMD5BwPgkAeNTBIxPEzA+Q8D4LAHjcwSMzxMwvkDA+CIB40sEjC8TML5CwPgqAeNrBIyvEzC+QcD4JgHjWwSMbxMwvkPA+C4B43sEjO8TMH5AwPghAeNHBIxrCRg/JmD8hIDxUwLGzwgYPydg/IKA8UsCxq8IGL8mYFxHwLiegPEbAsYNBIzfEjB+R8D4PQHjRgLGHwgYNxEw/kjA+BMB488EjJsJGH8hYNxCwPgrAeNWAsbfCBi3ETD+TsD4BwHjnwSM2wkY00qnPmMRAsaiBIzFCBiLEzCWIGAsaYHR/4G0HZLjj622TcQp6uvbgjYvLpeWdololehS0WWiy0VXiK4UXSW6WnSN6FrRdaLrRatFN4huFN0kull0i+hW0W2i20V3iO4U3SVaI7pbdI/oXtF9ovtFD4geFD0kelj0iOhR0WOix0VPiJ4UPSV6WvSM6FnRc6LnRS+IXhS9JHpZ9IroVdFrotdFb4jeFL0lelv0juhd0Xui98vt6IMPynmdUsz763ZKqYTYJUpslRK7VIldpsQuV2JXKLErldhVSuxqJXaNErtWiV2nxK5XYquV2A1K7EYldpMSu1mJ3aLEblVitymx25XYHUrsTiV2lxJbo8TuVmL3KLF7ldh9Sux+JfaAEntQiT2kxB5WYo8osUeV2GNK7HEl9oQSe1KJPaXEnlZizyixZ5XYc0rseSX2ghJ7UYm9pMReVmKvKLFXldhrSux1JfaGEntTib2lxN5WYu8osXeV2HtK7H0l5h4Q66Tt+ilYPAriYScrIyM/O5RvwibqhHJyI5lORmZuVsRETGYkMxaKhMP5kYxIdk5uTraTYzLC+SaemROOe+sR8IHM5uJydhZ3dM7ABzybS0hyBj4w2qwiyRn4AGpzKUnOwAdam8tIcgY+INtcTpIz8IHb5gqSnIEP8DZXkuQMfCC4uYokZ+ADxs3VJDkDH1huriHJGfgAdHMtSc7AB6qb60hyBj6g3VxPkjPwge9mNUnOwAfImxtIcgY+kN7cSJIz8AH35iaSnIEPzDc3k+QMfAC/uYUkZ+AD/c2tJDkDXxBgbiPJGfjCAXM7Sc7AFxiYO0hyBr4QwdxJkjPwBQvmLpKcgS9sMGtIcga+AMLcTZIz8IUS5h6SnIEvqDD3kuQMfOGFuY8kZ+ALNMz9JDkDX8hhHiDJGfiCD/MgSc7AF4aYh0hyBr6AxDxMkjPwhSbmEZKcgS9IMY+S5Ax84Yp5jCRn4AtczOMkOQNfCGOeIMkZ+IIZ8yRJzsAX1pinSHIGvgDHPE2SM/CFOuYZkpyBL+gxz5LkDHzhj3mOJGfgC4TM8yQ5A19IZF4gyRn4giPzIknOwBcmmZdIcga+gMm8TJIz8IVO5hWSnIEviDKvkuQMfOGUeY0kZ+ALrMzrJDkDX4hl3iDJGfiCLfMmSc7AF3aZt0hyBr4AzLxNkjPwhWLmHZKcgS8oM++S5Ax84Zl5jyRn4AvUzPvAnEtIG+V8+fo/xRP6wNnXj9nxBzS//2oNNm8MdjzaeFGe/5Nk26bgi7/eH5bb8fcj96//Jnn3X6xNiLn/oxppwUBJ9oBQ7QQ7AwVWix2fXQb0PuYc8nI2H5bD9d9HuIOgsVWLouBaIPtvrdJWrpMXyzS5WbFskx/NjOTl5YSNCUWzolm5oUg8PzfTRDIj0mZeNBSR/1wommfynWhWvruIlE3bcXxI/BQB98Fa4OLn5/24nEVgt3F0u58AB4OtvD8pt7ODQe2qrIiDicuKmrAF7SJr9Cl44Bcs6G67NeVvYTrBh4EL/CPABR55puExQif4mTdfP090gp8pTvDzQnCCDAMl2Yl9KIkTfAzoBD8DHhg/BzrBQ0mcILL/viB1gl9YcoJflrMI/KUFJ/hVijtBN++vSJzg5x4r2gkia/S1JSf49X5wgvcDF/gHgAs8cg/5IUInuM6br+sTneA6xQmuLwQnyDBQkp3Yh5M4wYeATnAd8MC4HugEDydxgsj++4bUCX5jyQluKGcReIMFJ/htijtBN+9vSZzgeo8V7QSRNfrOkhP8bj84wbuBC/w9wAUeeXXwfYRO8Htvvm5MdILfK05wYyE4QYaBkuzEPpLECd4HdILfAw+MG4FO8EgSJ4jsvx9IneAPlpzgpnIWgTdZcII/prgTdPP+kcQJbvRY0U4QWaOfLDnBn/aDE7wDuMDfCVzgkfd9riF0gj9783VzohP8WXGCmwvBCTIMlGQndk0SJ7gG6AR/Bh4YNwOdYE0SJ4jsv19IneAvlpzglnIWgbdYcIK/prgTdPP+lcQJbvZY0U4QWaOtlpzg1v3gBG8BLvC3Ahd45BN9bid0gr9583VbohP8TXGC2wrBCTIMlGQn9tEkTvB2oBP8DXhg3AZ0gkeTOEFk//1O6gR/t+QE/yhnEfgPC07wzxR3gm7ef5I4wW0eK9oJImu03ZIT3L4fnOANwAX+RuACj3xW682ETjCt/I4/Rcqn7er63H+R6ATd/1GNtGCgJDuxjyVxgjcDnaA7nlD9V6Q8LsdjSZwgsv+Klud0gkXLYxfEgk+x8haB3cbR7RYHDgZbeRcvv7ODQe1acYJFPFa0E0TWqER5O07QbbewneC1wAX+OuACj3wLx2pCJ1jSm68HJDrBkooTPKAQnCDDQEl2Yh9P4gRXA51gSeCB8QCgEzyexAki+68UqRMsZckJHljeIvCBFpzgQSnuBN28DyJxggd4rGgniKxRaUtOsPR+cIJXAhf4q4ALPPL9itcQOsGDvflaJtEJHqw4wTKF4AQZBkqyE/tEEid4DdAJHgw8MJYBOsETSZwgsv8OIXWCh1hygmXLWwQua8EJlktxJ+jmXY7ECZbxWNFOEFmj8pacYPn94AQvBS7wlwEX+MuBTvAKQidYwZuv6YlOsILiBNMLwQkyDJRkJ/bJJE7wCqATrAA8MKYDneDJJE4Q2X8VSZ1gRUtOsFJ5i8CVLDjByinuBN28K5M4wXSPFe0EkTWqYskJVtkPTvAi4AJ/MXCBvwToBFcROsGq3nytlugEqypOsFohOEGGgZLsxD6VxAmuAjrBqsADYzWgEzyVxAki+686qROsbskJHlreIvChFpzgYSnuBN28DyNxgtU8VrQTRNbocEtO8PD94ARXABf4lcAF/gKgE7yQ0Ake4c3XIxOd4BGKEzyyEJwgw0BJdmKfTuIELwQ6wSOAB8YjgU7wdBIniOy/GqROsIYlJ1izvEXgmhac4FEp7gTdvI8icYJHeqxoJ4is0dGWnODR+8EJLgEu8EuBC/wyoBNcTugEj/Hm67GJTvAYxQkeWwhOkGGgJDuxDYkTXA50gscAD4zHAp2gIXGCyP47jtQJHmfJCR5f3iLw8Rac4Akp7gTdvE8gcYLHeqxoJ4is0YmWnOCJ+8EJLgIu8OcBF/jzgU5wMaETPMmbrycnOsGTFCd4ciE4QYaBkuzEDpM4wcVAJ3gS8MB4MtAJhkmcILL/TiF1gqdYcoKnlrcIfKoFJ3haijtBN+/TSJzgyR4r2gkia3S6JSd4+n5wgucCF/j5wAV+AdAJLiR0go43X02iE3QUJ2gKwQkyDJRkJ3YmiRNcCHSCDvDAaIBOMJPECSL7L0TqBEOWnGC4vEXgsAUnmJHiTtDNO4PECRqPFe0EkTXKtOQEM/eDE5wNXODnABf4uUAnOI/QCWZ58zU70QlmKU4wuxCcIMNASXZiZ5M4wXlAJ5gFPDBmA51gNokTRPZfhNQJRiw5wZzyFoFzLDjBM1LcCbp5n0HiBLM9VrQTRNboTEtO8EzPCf51H3Harou8/9SPf0PQf5mY/+YB/y2l/geNuN/L+L4f4PtexPe94AVm7vfNvu8bfd/X+75/7vv+ke/7Ut/3Zb7vy33fV/i+r/R9v8D3/ULf94u872cJby3R2aLabk1EdUX1RPXL73DUB3n9WzBWi2j2Os2eUwzaDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2v3/1S56D6d1mdRn/Org1Gf8moBxHQHjegLGbwgYNxAwfkvA+B0B4/cEjBsJGH8gYNxEwPgjAeNPBIw/EzBuJmD8hYBxCwHjrwSMWwkYfyNg3EbA+DsB4x8EjH8SMG4nYEwjOJdShICxKAFjMQLG4gSMtUqmPuPZBIy1CRjrEDDWJWCsR8BYn4CxAQFjQwLGRgSMjQkYmxAwNiVgbEbA2JyAsQUBY0sCxlYEjK0JGNsQMLYlYGxHwNiegLEDAWNHAsZOBIydCRi7EDB2JWDsRsDYnYCxBwFjTwLGXgSMvQkY+xAwRgkYcwkY8wgYYwSM+QSMcQLGvgSM/QgY+xMwDiBgHEjAOIiA8aRSqc94MgHjKQSMpxIwnkbAeDoBo0PAaAgYQwSMYQLGDALGTALGLALGbALGCAFjDgHjGQSMZxIwnkXAWIuA8WwCxtoEjHUIGOsSMNYjYKxPwNiAgLEhAWMjAsbGBIxNCBibEjA2I2BsTsDYgoCxJQFjKwLG1gSMbQgY2xIwtiNgbE/A2IGAsSMBYycCxs4EjF0IGLsSMB5A8FyFUgSMBxIwHkTAWJqA8WACxjIEjIcQMJYlYCxHwFiegLECAWM6AWNFAsZKBIyVCRirEDBWJWCsRsBYnYDxUALGwwgYDydgPIKA8UgCxhoEjDUJGI8iYDyagPEYAsZjCRiPI2A8noDxBALGEwkYTyJgPJmA8RQCxlMJGE8jYDydgNEhYDQEjCECxjABYwYBYyYBYxYBYzYBY4SAMYeA8QwCxjMJGM8iYKxFwHg2AWNtAsY6BIx1CRjrETDWJ2BsQMDYkICxEQFjYwLGJgSMTQkYmxEwNidgbEHA2JKAsRUBY2sCxjYEjG0JGNsRMLYnYOxAwNiRgLETAWNnAsYuBIxdCRi7ETB2J2DsQcDYk4CxFwFjbwLGPgSMUQLGXALGPALGGAFjPgFjnICxLwFjPwLG/gSMAwgYBxIwDiJgHEzAOISAcSgB4zACxuEEjCMIGEcSMI4iYBxNwDiGgHEsAeM4AsbxBIwTCBgnEjBOImCcTMA4hYBxKgHjNALG6QSMMwgYZxIwziJgPIeAcTYB4xwCxrkEjPMIGM8lYJxPwLiAgHEhAeMiAsbzCBjPJ2BcTMC4hIBxKQHjMgLG5QSMKxiufzwo9Rm7EDB2JWDsRsDYnYCxBwFjTwLGXgSMvQkY+xAwRgkYcwkY8wgYYwSM+QSMcQLGvgSM/QgY+xMwDiBgHEjAOIiAcTAB4xACxqEEjMMIGIcTMI4gYBxJwDiKgHE0AeMYAsaxBIzjCBjHEzBOIGCcSMA4iYBxMgHjFALGqQSM0wgYpxMwziBgnEnAOIuA8RwCxtkEjHMIGOcSMM4jYDyXgHE+AeMCAsaFBIyLCBjPI2A8n4BxMQHjEgLGpQSMywgYlxMwriBgXEnAeAEB44UEjBcRMF5MwHgJAeMqAsZLCRgvI2C8nIDxCgLGKwkYryJgvJqA8RoCxmsJGK8jYLyegHE1AeMNBIw3EjDeRMB4MwHjLQSMtxIw3kbAeDsB4x0EjHcSMN5FwLiGgPFuAsZ7CBjvJWC8j4DxfgLGBwgYHyRgfIiA8WECxkcIGB8lYHyMgPFxAsYnCBifJGB8ioDxaQLGZwgYnyVgfI6A8XkCxhcIGF8kYHyJgPFlAsZXCBhfJWB8jYDxdQLGNwgY3yRgfIuA8W0CxncIGN8lYHyPgPF9AsYPCBg/JGD8iIBxLQHjxwSMnxAwfkrA+BkB4+cEjF8QMH5JwPgVAePXBIzrCBjXEzB+Q8C4gYDxWwLG7wgYvydg3EjA+AMB4yYCxh8JGH8iYPyZgHEzAeMvBIxbCBh/JWDcSsD4GwHjNgLG3wkY/yBg/JOAcTsBY1rp1GcsQsBYlICxGAFjcQLGEgSMJS0w+j+QtkNy/LHVtslzivr6tqDNBuXT0hqKGokai5qImoqaiZqLWohailqJWovaiNqK2onaizqIOoo6iTqLuoi6irqJuot6iHqKeol6i/qIoqJcUZ4oJsoXxUV9Rf1E/UUDRANFg0SDRUNEQ0XDRMNFI0QjRaNEo0VjRGNF40TjRRNEE0WTRJNFU0RTRdNE00UzRDPL7+iDWeW9Tinm/XU7pVRCrKESa6TEGiuxJkqsqRJrpsSaK7EWSqylEmulxForsTZKrK0Sa6fE2iuxDkqsoxLrpMQ6K7EuSqyrEuumxLorsR5KrKcS66XEeiuxPkosqsRylVieEospsXwlFldifZVYPyXWX4kNUGIDldggJTZYiQ1RYkOV2DAlNlyJjVBiI5XYKCU2WomNUWJjldg4JTZeiU1QYhOV2CQlNlmJTVFiU5XYNCU2XYnNUGIzlZh7QKyTtuunYPEoiIedrIyM/OxQvgmbqBPKyY1kOhmZuVkREzGZkcxYKBIO50cyItk5uTnZTo7JCOebeGZOOO6tR8AbEkyD8nYWd3TOwBscTEOSnIE3TJhGJDkDb8AwjUlyBt7QYZqQ5Ay8QcQ0JckZeMOJaUaSM/AGFtOcJGfgDTGmBUnOwBtsTEuSnIE37JhWJDkDbwAyrUlyBt5QZNqQ5Ay8Qcm0JckZeMOTaUeSM/AGKtOeJGfgDVmmA0nOwBu8TEeSnIE3jJlOJDkDb0AznUlyBt7QZrqQ5Ay8Qc50JckZeMOd6UaSM/AGPtOdJGfgDYGmB0nOwBsMTU+SnIE3LJpeJDkDb4A0vUlyBt5QafqQ5Ay8QdNESXIG3vBpcklyBt5AavJIcgbekGpiJDkDb3A1+SQ5A2+YNXGSnIE34Jq+JDkDb+g1/UhyBt4gbPqT5Ay84dgMIMkZeAOzGUiSM/CGaDOIJGfgDdZmMEnOwBu2zRCSnIE3gJuhJDkDbyg3w0hyBt6gboaT5Ay84d2MIMkZeAO9GUmSM/CGfDOKJGfgDf5mNEnOwAcGmDEkOQMfQGDGkuQMfKCBGUeSM/ABCWY8Sc7ABy6YCSQ5Ax/gYCaS5Ax8IISZRJIz8AETZjJJzsAHVpgpJDkDH4BhppLkDHyghplGkjPwAR1mOknOwAd+mBkkOQMfIGJmAnMuIW2U8+Xr/xRP6ANnXz9mxx/Q/P6rNdi8MdjxWCK1H8JiCr74631O+R1/Z7t//TfJu/9ibULM/R/VSAsGSrIHhJwT7AwUWC12fHYZ0PuYc8jL2ZxTHtd/s3EHQWOrFkXBtUD23xylrVwnL5ZpcrNi2SY/mhnJy8sJGxOKZkWzckOReH5upolkRqTNvGgoIv+5UDTP5DvRrHx3ESmbtuP4kPgpAu6DOcDFz887t7xFYLdxdLvzgIPBVt7zyu/sYFC7KiviYOKyoiZsQbvIGp0LHvgFC7rbbk35W5hOEHTm5q/WYGdEDPZMQxFCJzjfm68LEp3gfMUJLigEJ8gwUJKd2GeSOMEiQCc4H3hgXAB0gmeSOEFk/y0kdYILLTnBReUtAi+y4ATPS3En6OZ9HokTXOCxop0gskbnW3KC5+8HJ/gbcIHfBlzgkXvINh6u7/8k2bbqBBd783VJohNcrDjBJYXgBBkGSrITuxaJE/zjIJwTXAw8MC4BOsFaJE4Q2X9LSZ3gUktOcFl5i8DLLDjB5SnuBN28l5M4wSUeK9oJImu0wpITXLEfnOAvwAV+C3CBR14dvJXQCa705usFiU5wpeIELygEJ8gwUJKd2LVJnOBWoBNcCTwwXgB0grVJnCCy/y4kdYIXWnKCF5W3CHyRBSd4cYo7QTfvi0mc4AUeK9oJImt0iSUneMl+cII/Ahf4n4ALPPK+z82ETnCVN18vTXSCqxQneGkhOEGGgZLsxK5L4gQ3A53gKuCB8VKgE6xL4gSR/XcZqRO8zJITvLy8ReDLLTjBK1LcCbp5X0HiBC/1WNFOEFmjKy05wSv3gxP8HrjAbwQu8Mgn+mwidIJXefP16kQneJXiBK8uBCfIMFCSndj1SZzgJqATvAp4YLwa6ATrkzhBZP9dQ+oEr7HkBK8tbxH4WgtO8LoUd4Ju3teROMGrPVa0E0TW6HpLTvD6/eAEvwEu8BuACzzyWa3fETrB1d58vSHRCa5WnOANheAEGQZKshO7IYkT/A7oBFcDD4w3AJ1gQxIniOy/G0md4I2WnOBN5S0C32TBCd6c4k7QzftmEid4g8eKdoLIGt1iyQnesh+c4FfABf5r4AKPfAvHekIneKs3X29LdIK3Kk7wtkJwggwDJdmJ3ZjECa4HOsFbgQfG24BOsDGJE0T23+2kTvB2S07wjvIWge+w4ATvTHEn6OZ9J4kTvM1jRTtBZI3usuQE79oPTvAz4AL/OXCBR75f8UtCJ7jGm693JzrBNYoTvLsQnCDDQEl2YjclcYJfAp3gGuCB8W6gE2xK4gSR/XcPqRO8x5ITvLe8ReB7LTjB+1LcCbp530fiBO/2WNFOEFmj+y05wfv3gxNcC1zgPwYu8J8AneCnhE7wAW++PpjoBB9QnOCDheAEGQZKshO7OYkT/BToBB8AHhgfBDrB5iROENl/D5E6wYcsOcGHy1sEftiCE3wkxZ2gm/cjJE7wQY8V7QSRNXrUkhN8dD84wfeBC/wHwAX+Q6AT/IjQCT7mzdfHE53gY4oTfLwQnCDDQEl2YrckcYIfAZ3gY8AD4+NAJ9iSxAki++8JUif4hCUn+GR5i8BPWnCCT6W4E3TzforECT7usaKdILJGT1tygk/vByf4NnCBfwe4wL8LdILvETrBZ7z5+myiE3xGcYLPFoITZBgoyU7s1iRO8D2gE3wGeGB8FugEW5M4QWT/PUfqBJ+z5ASfL28R+HkLTvCFFHeCbt4vkDjBZz1WtBNE1uhFS07wxf3gBF8HLvBvABf4N4FO8C1CJ/iSN19fTnSCLylO8OVCcIIMAyXZid2WxAm+BXSCLwEPjC8DnWBbEieI7L9XSJ3gK5ac4KvlLQK/asEJvpbiTtDN+zUSJ/iyx4p2gsgavW7JCb6+H5zgy8AF/hXgAv8q0Am+RugE3/Dm65uJTvANxQm+WQhOkGGgJDux25M4wdeATvAN4IHxTaATbE/iBJH99xapE3zLkhN8u7xF4LctOMF3UtwJunm/Q+IE3/RY0U4QWaN3LTnBd/eDE3weuMC/AFzgXwQ6wZcIneB73nx9P9EJvqc4wfcLwQkyDJRkJ3ZHEif4EtAJvgc8ML4PdIIdSZwgsv8+IHWCH1hygh+Wtwj8oQUn+FGKO0E3749InOD7HivaCSJrtNaSE1y7H5zg08AF/hngAv8s0Ak+R+gEP/bm6yeJTvBjxQl+UghOkGGgJDuxO5M4weeATvBj4IHxE6AT7EziBJH99ympE/zUkhP8rLxF4M8sOMHPU9wJunl/TuIEP/FY0U4QWaMvLDnBLzwn6H6vkrbrIu8/9ePfEPRfJua/ecB/S6n/QSPu97t932/zfb/B9/1q3/dLfd8v8H1f4vu+wPd9tu/7Wb7vtXzfz/Z9r+37Xsf3va7vez3f9/re9y/l71eir0XrROtF34g2iL4tv8NRH+T1b8FYLaLZ6zR7TjFoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aPf/V7voPZzWZVKf8auDU5/xawLGdQSM6wkYvyFg3EDA+C0B43cEjN8TMG4kYPyBgHETAeOPBIw/ETD+TMC4mYDxFwLGLQSMvxIwbiVg/I2AcRsB4+8EjH8QMP5JwLidgDGN4FxKEQLGogSMxQgYixMw1iqZ+oxnEzDWJmCsQ8BYl4CxHgFjfQLGBgSMDQkYGxEwNiZgbELA2JSAsRkBY3MCxhYEjC0JGFsRMLYmYGxDwNiWgLEdAWN7AsYOBIwdCRg7ETB2JmDsQsDYlYCxGwFjdwLGHgSMPQkYexEw9iZg7EPAGCVgzCVgzCNgjBEw5hMwxgkY+xIw9iNg7E/AOICAcSAB4yACxpNKpT7jyQSMpxAwnkrAeBoB4+kEjA4BoyFgDBEwhgkYMwgYMwkYswgYswkYIwSMOQSMZxAwnknAeBYBYy0CxrMJGGsTMNYhYKxLwFiPgLE+AWMDAsaGBIyNCBgbEzA2IWBsSsDYjICxOQFjCwLGlgSMrQgYWxMwtiFgbEvA2I6AsT0BYwcCxo4EjJ0IGDsTMHYhYOxKwHgAwXMVShEwHkjAeBABY2kCxoMJGMsQMB5CwFiWgLEcAWN5AsYKBIzpBIwVCRgrETBWJmCsQsBYlYCxGgFjdQLGQwkYDyNgPJyA8QgCxiMJGGsQMNYkYDyKgPFoAsZjCBiPJWA8joDxeALGEwgYTyRgPImA8WQCxlMIGE8lYDyNgPF0AkaHgNEQMIYIGMMEjBkEjJkEjFkEjNkEjBECxhwCxjMIGM8kYDyLgLEWAePZBIy1CRjrEDDWJWCsR8BYn4CxAQFjQwLGRgSMjQkYmxAwNiVgbEbA2JyAsQUBY0sCxlYEjK0JGNsQMLYlYGxHwNiegLEDAWNHAsZOBIydCRi7EDB2JWDsRsDYnYCxBwFjTwLGXgSMvQkY+xAwRgkYcwkY8wgYYwSM+QSMcQLGvgSM/QgY+xMwDiBgHEjAOIiAcTAB4xACxqEEjMMIGIcTMI4gYBxJwDiKgHE0AeMYAsaxBIzjCBjHEzBOIGCcSMA4iYBxMgHjFALGqQSM0wgYpxMwziBgnEnAOIuA8RwCxtkEjHMIGOcSMM4jYDyXgHE+AeMCAsaFBIyLCBjPI2A8n4BxMQHjEgLGpQSMywgYlxMwrmC4/vGg1GfsQsDYlYCxGwFjdwLGHgSMPQkYexEw9iZg7EPAGCVgzCVgzCNgjBEw5hMwxgkY+xIw9iNg7E/AOICAcSAB4yACxsEEjEMIGIcSMA4jYBxOwDiCgHEkAeMoAsbRBIxjCBjHEjCOI2AcT8A4gYBxIgHjJALGyQSMUwgYpxIwTiNgnE7AOIOAcSYB4ywCxnMIGGcTMM4hYJxLwDiPgPFcAsb5BIwLCBgXEjAuImA8j4DxfALGxQSMSwgYlxIwLiNgXE7AuIKAcSUB4wUEjBcSMF5EwHgxAeMlBIyrCBgvJWC8jIDxcgLGKwgYryRgvIqA8WoCxmsIGK8lYLyOgPF6AsbVBIw3EDDeSMB4EwHjzQSMtxAw3krAeBsB4+0EjHcQMN5JwHgXAeMaAsa7CRjvIWC8l4DxPgLG+wkYHyBgfJCA8SECxocJGB8hYHyUgPExAsbHCRifIGB8koDxKQLGpwkYnyFgfJaA8TkCxucJGF8gYHyRgPElAsaXCRhfIWB8lYDxNQLG1wkY3yBgfJOA8S0CxrcJGN8hYHyXgPE9Asb3CRg/IGD8kIDxIwLGtQSMHxMwfkLA+CkB42cEjJ8TMH5BwPglAeNXBIxfEzCuI2BcT8D4DQHjBgLGbwkYvyNg/J6AcSMB4w8EjJsIGH8kYPyJgPFnAsbNBIy/EDBuIWD8lYBxKwHjbwSM2wgYfydg/IOA8U8Cxu0EjGmlU5+xCAFjUQLGYgSMxQkYSxAwlrTA6P9A2g7J8cde205RX98WtPld+bS070UbRT+INol+FP0k+lm0WfSLaIvoV9FW0W+ibaLfRX+I/hRtF6VVkLZFRUXFRMVFJUQlRQeISokOFB0kKi06WFRGdIiorKicqLyogihdVFFUSVRZVEVUVVRNVF10qOgw0eGiI0RHimqIaoqOEh0tOkZ0rOg40fGiE0Qnik4SnSw6pcKOPji1gtcpxby/bqeUSoh9r8Q2KrEflNgmJfajEvtJif2sxDYrsV+U2BYl9qsS26rEflNi25TY70rsDyX2pxLbrsTcQZQYK6LEiiqxYkqsuBIrocRKKrEDlFgpJXagEjtIiZVWYgcrsTJK7BAlVlaJlVNi5ZVYBSWWrsQqKrFKSqyyEquixKoqsWpKrLoSO1SJHabEDldiRyixI5VYDSVWU4kdpcSOVmLHKLFjldhxSux4JXaCEjtRiZ2kxE5WYqcoMfeAWCdt10/B4lEQDztZGRn52aF8EzZRJ5STG8l0MjJzsyImYjIjmbFQJBzOj2REsnNyc7KdHJMRzjfxzJxw3FuPgAuycY/XoLacEmk7+kNbLNN8MX9fOMl9rJoTTLsRe5sK5VPfPP5AwLiJgPFHAsafCBh/JmDcTMD4CwHjFgLGXwkYtxIw/kbAuI2A8XcCxj8IGP8kYNxOwJhWgWBTgYCxKAFjMQLG4gSMJQgYSxIwHkDAWIqA8UACxoMIGEsTMB5MwFiGgPEQAsayBIzlCBjLEzBWIGBMJ2CsSMBYiYCxMgFjFQLGqgSM1QgYqxMwHkrAeBgB4+EEjEcQMB5JwFiDgLEmAeNRBIxHEzAeQ8B4LAHjcQSMxxMwnkDAeCIB40kEjCcTMJ5igdH/AbUdKurLv6DN04T9dJEjMqKQKCzKEGWKskTZoogoR3SG6EzRWaJaorNFtd38RXVF9UT1RQ1EDUWNRI1FTURNRc1EzUUtRC1FrUStRW1EbUXtRO1FHUQdRZ1EnUVdRF1F3UTdRT1EPUW9RL1FfURRUa4oTxQT5Yvior6ifqL+ogGigaJBosEVdvTBkAppu15Qe5pyka2jxIwSCymxsBLLUGKZSixLiWUrsYgSy1FiZyixM5XYWUqslhI7W4nVVmJ1lFhdJVZPidVXYg2UWEMl1kiJNVZiTZRYUyXWTIk1V2ItlFhLJdZKibVWYm2UWFsl1k6JtVdiHZRYRyXWSYl1VmJdlFhXJdZNiXVXYj2UWE8l1kuJ9VZifZRYVInlKrE8JRZTYvlKLK7E+iqxfkqsvxIboMQGKrFBSmywEhviW7wKPgULRUE8lW4eOK2CncW2SELOTnIfc3qF5PsvP+5+IsZmbYAX9BvHUm3QOQNvEDCGJGfgDQcmRJIz8AYGEybJGXhDhMkgyRl4g4XJJMkZeMOGySLJGXgDiMkmyRl4Q4mJkOQMvEHF5JDkDLzhxZxBkjPwBhpzJknOwBtyzFkkOQNv8DG1SHIG3jBkzibJGXgDkqlNkjPwhiZThyRn4A1Spi5JzsAbrkw9kpyBN3CZ+iQ5A28IMw1IcgbeYGYakuQMvGHNNCLJGXgDnGlMkjPwhjrThCRn4A16pilJzsAb/kwzkpyBNxCa5iQ5A29INC1Icgbe4GhakuQMvGHStCLJGXgDpmlNkjPwhk7ThiRn4A2ipi1JzsAbTk07kpyBN7Ca9iQ5A2+INR1IcgbeYGs6kuQMvGHXdCLJGXgDsOlMkjPwhmLThSRn4A3KpitJzsAbnk03kpyBN1Cb7iQ5A2/INj1Icgbe4G16kuQMvGHc9CLJGXgDuulNkjPwhnbThyRn4A3yJkqSM/CGe5NLkjPwBn6TR5Iz8IEAJkaSM/ABAyafJGfgAwtMnCRn4AMQTF+SnIEPVDD9SHIGPqDB9CfJGfjABzOAJGfgAyTMQJKcgQ+kMINIcgY+4MIMBubsvvzrwLQd9zK7nyK+nNN8MX9fOMl9gpd/gXNHMwYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMAYv/8IwBi//wjAGL//CMLK8/Mta2yHZj/T1bUGbQ6VfhomGi0aIRopGiUaLxojGisaJxosmiCaKJokmi6aIpoqmiaaLZohmimaJzhHNFs0RzRXNE50rmi9aIFooWiQ6T3S+aLFoiWipaJlouWiFaKXoAtGFootEF4suEa0SXSq6THS56ArRlaKrRFeLrhFdK7pOdL1otegG0Y2im0Q3i26pkLbrS3bczkh88c51Sux6JbZaid2gxG5UYjcpsZuV2C1ezP8pmjBIUuklQEMtTTr0wWFYheT7T3sJEJpzOEl/jiDhHEnCOYqEczQJ5xgSzrEknONIOMeTcE4g4ZxIwjmJhHMyCecUEs6pJJzTSDink3DOIOGcScI5i4TzHBLO2SScc0g455JwziPhPJeEcz4J5wISzoUknItIOM8j4TyfhHMxCecSEs6lJJzLSDiXk3CuIOFcScJ5AQnnhSScF5FwXkzCeQkJ5yoSzktJOC8j4bychPMKEs4rSTivIuG8moTzGhLOay1xFk+W0+z6j9clx7lLa9cnm7OvtdWA65UKrvfqekKK1sLZNesbEGPGa+1GzPj7q7WbgLXoltq1cAqyvhk3f80twLaAY9n4a5HMNYGiHPcBqOXSdl6raaU2lse2k8wndceMjYu5/3fM8tf71go7/t6WeNGx+y/WJsTc/1GNtGCgJHtA7clwQE0Y0PuYc8jL2dwK7L/bgJPWVi2KgmuB7L/blbZynbxYpsnNimWb/GhmJC8vJ2xMKJoVzcoNReL5uZkmkhmRNvOioYj850LRPJPvRLPy3UWkbNpOM+7/oA367cADrJ/3jgoWgd3G0e3eCRwMtvK+s8LODga1q7IiDiYuK2rCFrSLrNFd4IFfsKC77daUv4XpBK8DLvDXAxf41cBF5YYKdhYV0HxSneAab77enegE1yhO8G6bTtCDvAHoPtYAJ+PdvrZCscx8JyeSGwnlRsPZuRnh3JycqLSbZUwkHgs5sYxQPNNkZeXl5OfETTiem5kfzcqM5mTF/lo9Y11J3Aey/+4hdR/3WHIf91awCHyvBfdxX4q7Dzfv+0jcx90eK9p9IGt0vyX3cf8euA/Y2PDWPMx9xJG//q+Ca2VlfsAbyw8mrswPKCvzg8rKXMxiJya7Mj8AHKgPVrBTXPRqisz5IdLV9CFLq+nDFSwCP2xhNX0kxVdTN+9HSFbTBz1W9GqKrNGjllbTR73V1P1eJW3XxcD9fm3x1P1+t4/zNt/3L8vv/P6V7/vXvu/rfN/X+75/4/u+wff9W+/7Y/LfeVz0hOhJ0VOip0XPiJ6t8Hc3gp5XzwLHQcFP7+ekzedFL4he9NyCf4y4/z7x6S3PK7EXlNiLFf7+lBf0T/5ngfPsOUBbO56e4pjngVy9Lf3kTzR5yeTs1uIFSP/tqOuLwHNryP6zPcefsTDHX5I2Xxa9InpVmeMvKXP3ZSX2ihJ7tRDm+DPAufQScI6/DOSKkszxV4Bz/FXgHI8SzfGnLczx16TN10VviN5U5vhrytx9XYm9ocTeLIQ5/jRwLr0GnOOvA7nySOb4G8A5/iZwjucRzfGnLMzxt6TNt0XviN5V5vhbytx9W4m9o8TeLYQ5/hRwLr0FnONvA7nySeb4O8A5/i5wjucTzfEnLczx96TN90UfiD5U5vh7ytx9X4l9oMQ+LIQ5/iRwLr0HnOPvA7n6kszxD4Bz/EPgHO9LNMefsDDHP3I34UQfiz5R5vhHytxdq8Q+VmKfFMIcfwI4lz4CzvG1QK7+JHP8Y+Ac/wQ4x/sTzfHHLczxT6XNz0Sfi75Q5vinytz9TIl9rsS+KIQ5/jhwLn0KnOOfAbkGkszxz4Fz/AvgHB9INMcfszDHv5Q2vxJ9LVqnzPEvlbn7lRL7WomtK4Q5/hhwLn0JnONfAbkGk8zxr4FzfB1wjtvqP/QFUk2L48bMemD/+ef0eu86BfeiqdK+MeT/oI97RxTDXjtSpGia+kH9N4J2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdoN2g3aDdv9/t4s+D966TOozfnVw6jN+TcC4joBxPQHjNwSMGwgYvyVg/I6A8XsCxo0EjD8QMG4iYPyRgPEnAsafCRg3EzD+QsC4hYDxVwLGrQSMvxEwbiNg/J2A8Q8Cxj8JGLcTMKYRnEspQsBYlICxGAFjcQLGWiVTn/FsAsbaBIx1CBjrEjDWI2CsT8DYgICxIQFjIwLGxgSMTQgYmxIwNiNgbE7A2IKAsSUBYysCxtYEjG0IGNsSMLYjYGxPwNiBgLEjAWMnAsbOBIxdCBi7EjB2I2DsTsDYg4CxJwFjLwLG3gSMfQgYowSMuQSMeQSMMQLGfALGOAFjXwLGfgSM/QkYBxAwDiRgHETAeFKp1Gc8mYDxFALGUwkYTyNgPJ2A0SFgNASMIQLGMAFjBgFjJgFjFgFjNgFjhIAxh4DxDALGMwkYzyJgrEXAeDYBY20CxjoEjHUJGOsRMNYnYGxAwNiQgLERAWNjAsYmBIxNCRibETA2J2BsQcDYkoCxFQFjawLGNgSMbQkY2xEwtidg7EDA2JGAsRMBY2cCxi4EjF0JGA8geK5CKQLGAwkYDyJgLE3AeDABYxkCxkMIGMsSMJYjYCxPwFiBgDGdgLEiAWMlAsbKBIxVCBirEjBWI2CsTsB4KAHjYQSMhxMwHkHAeCQBYw0CxpoEjEcRMB5NwHgMAeOxBIzHETAeT8B4AgHjiQSMJxEwnkzAeAoB46kEjKcRMJ5OwOgQMBoCxhABY5iAMYOAMZOAMYuAMZuAMULAmEPAeAYB45kEjGcRMNYiYDybgLE2AWMdAsa6BIz1CBjrEzA2IGBsSMDYiICxMQFjEwLGpgSMzQgYmxMwtiBgbEnA2IqAsTUBYxsCxrYEjO0IGNsTMHYgYOxIwNiJgLEzAWMXAsauBIzdCBi7EzD2IGDsScDYi4CxNwFjHwLGKAFjLgFjHgFjjIAxn4AxTsDYl4CxHwFjfwLGAQSMAwkYBxEwDiZgHELAOJSAcRgB43ACxhEEjCMJGEcRMI4mYBxDwDiWgHEcAeN4AsYJBIwTCRgnETBOJmCcQsA4lYBxGgHjdALGGQSMMwkYZxEwnkPAOJuAcQ4B41wCxnkEjOcSMM4nYFxAwLiQgHERAeN5BIznEzAuJmBcQsC4lIBxGQHjcgLGFQzXPx6U+oxdCBi7EjB2I2DsTsDYg4CxJwFjLwLG3gSMfQgYowSMuQSMeQSMMQLGfALGOAFjXwLGfgSM/QkYBxAwDiRgHETAOJiAcQgB41ACxmEEjMMJGEcQMI4kYBxFwDiagHEMAeNYAsZxBIzjCRgnEDBOJGCcRMA4mYBxCgHjVALGaQSM0wkYZxAwziRgnEXAeA4B42wCxjkEjHMJGOcRMJ5LwDifgHEBAeNCAsZFBIznETCeT8C4mIBxCQHjUgLGZQSMywkYVxAwriRgvICA8UICxosIGC8mYLyEgHEVAeOlBIyXETBeTsB4BQHjlQSMVxEwXk3AeA0B47UEjNcRMF5PwLiagPEGAsYbCRhvImC8mYDxFgLGWwkYbyNgvJ2A8Q4CxjsJGO8iYFxDwHg3AeM9BIz3EjDeR8B4PwHjAwSMDxIwPkTA+DAB4yMEjI8SMD5GwPg4AeMTBIxPEjA+RcD4NAHjMwSMzxIwPkfA+DwB4wsEjC8SML5EwPgyAeMrBIyvEjC+RsD4OgHjGwSMbxIwvkXA+DYB4zsEjO8SML5HwPg+AeMHBIwfEjB+RMC4loDxYwLGTwgYPyVg/IyA8XMCxi8IGL8kYPyKgPFrAsZ1BIzrCRi/IWDcQMD4LQHjdwSM3xMwbiRg/IGAcRMB448EjD8RMP5MwLiZgPEXAsYtBIy/EjBuJWD8jYBxGwHj7wSMfxAw/knAuJ2AMa106jMWIWAsSsBYjICxOAFjCQLGkhYYbXA2LW6Bs0QCrM0Ejse15ZTxcX5TYcffDd7fb72/33l/v/f+bvT+/uD93eT9/dH7+5P392fv72bv7y8VvM4o5v11/wNFEmIbldiPSmyzF3M7vmxa4XS820Ggthw/75YKFoG3VLDwE8fXEWEnKyMjPzuUb8Im6oRyciOZTkZmblbERExmJDMWioTD+ZGMSHZObk62k2MywvkmnpkTjnuN2cr71wo7OxjUrlOYg22DpcG2tYJF4K0WBttvKT7Y3Lx/szDYNNZk8//WmxhFwX2APCBsq8A5Yb+zNGF/r2AR+HcLE/aPFJ+wbt5/kK8O31sabH9WsAj8p4XBtj3FB5ub93aS1WGjNzHQqwP0gJButw+d5D5/uZVtFfC1KZLief81xtPxeRdN5zxA/2DpAF0s3SJwsXQLp9fSU/sA7eZdPH1nB4PaLdTBtsnSYCuRbhG4hIXBVjLFB5ubd0kLg01jTTb/H72JgXYDyAPCASm+KrqrdlELq2KpFM/bHeMHWMj7QFI38JOlA/RB6RaBD7JwgC6d4gdoN+/S5G7gZ0uD7eB0i8AHWxhsZVJ8sLl5lyFxA5u9iYF2A8gDwiEpviq6q/aBFlbFsimetzvGD7GQd7l07IGusqi41577z41ks/lP77u7pVjwfYPve2Pvf1Pw/1demCqI0kUV03fGCz7FwH37Le5gb8oD52Il8Ji01X/AXRtTAdh/lUn6D7gRYdKB/VfF8rHBHd8Fx4DKvu9VfN8rpu96bKgq/1xNVF10aCEcGzYCa1MVWJvDSMY28ByuqQbsv8NJ+g94WtJUB/bfEZaPDYf5jgGH+74f4ft+aMKx4Uj55xqimqKjCuHY8COwNkcCa3M0ydgGntExNYD9dwxJ/wFPUpiawP471vKx4WjfMeAY3/djfd+PSjg2HCf/fLzoBNGJhXBs2AyszXHA2pxkuTYn+WpwvO/7Cb7vJybU5mT551NEp4pOS9+1PX9NEL/xy1n4DX06rk+NlreT3Me4/Xu6hbwdy2Opr+/cgeMbP7/4zh30Tzh3YOR/FxKFRRnKPEefezse2J/Gcn/+0/mXb/+lPzOFKUuULYp4/VkibdeT8P7vOeleoJSvs91/XlN8538kP23Hd/dzRnrh3oBwBriTCz5nplsEPtPCmf2zUvzMvpv3Wek7OxjUrtX7os4C760WTeO7Haqoj7OWV7+z0xMSQNst5GG41p5PjLzdtGXOLqQBceTf+9M4SXxOSKxNEq2d+Pc673NrJ2ljZh9bOzlNrc0+tXZK2j/UeR9aOzXtH8fMXrd2Wtq/jL+9bO30tH8dy3vXWtpu5sVetGbSdjvH9ri1UNoezNc9bC28J23tYWsZe9bWHrWWuadt7UFrWXve1m5by96btnbTWmTv2vrX1nL2tq1/ae2MvW/rH1s7c1/a+ofWztq3ttTWau1rW0prZ+97W39rrXYybSW0Vie5tnZprW6ybflaq5d8W/9rrT6iLa+1Bpi2/mqtIaotaa0Rrq1djG9tz/DWSTS+Bb+rff/R//dGLVlDPvQEO7/+lFo4yWTNYCiTrcWwwq6Fs29ZMxjfZGsxfP/UwtnbrBkMerK1GLE/a+HsedYMPySSrcXI/V8LZ0+yZvjBk2wtRqVKLZx/z5rhh1mytRidWrVw/ilrhh+QydZiTCrWwvl71nXSkuQshB+6ydZibOrWwvFnzfCDPNlajEv1Wuz47HLiINmcawM3nOoAd3XHk9QCeH7AAH/fGv/vs2RrMYGkFsDfQQbo480oYC0mktQC6PcM0K+YscBaTCKpBXBdM8DjspkArMVkS7VAXywCnL8GOP4Msv/+7WKRw//en0ntQTROw+1BNEnD7UE0TcOd22+Whju33zwNd26/RRrunHnLNNw581ZpuHPmrdNw56LbpO12ju1xa23T9mC+7mFr7fakrT1srf2etbVHrXXY07b2oLWOe97WblvrtDdt7aa1znvX1r+21mVv2/qX1rrufVv/2Fq3fWnrH1rrvm9tqa312Ne2lNZ67ntbf2utVzJtJbTWO7m2dmmtT7Jt+VqLJt/W/1rLRbTltZaHaeuvT9G0nZ+63sUY9WxflMFgiJI1+wtJLspgMG7J1mIRyUUZDAYz2VqcR3JRBoMRTrYW55NclMFg2JOtxWKSizIYflgkW4slJBdlMPwASrYWS0kuymD4oZZsLZaRXJTB8IMy2VosJ7kow9YP32T7ry7wQoAVhVSLZC9+qAd8EAfw961ZBNxkW0my4Qn8HWSAPt4sBtbiApJaAP2eAfoVswxYiwtJagFc1wzwuGxWAmtxEcmFAMD5a4Djz1xUSBcCoB8jkgl82kVRH2d974R9A9uPEckEmqb6wKs6G5A+VybH0oBo6A2ERrYHRA5wQDQEDohGpAPiDEsDorE3EJrYHhBnAAdEY+CAaAJ+rFlpke+Vmz7OjFBWflZGND8/7OTn5ETyTDgvkpefnxeLhqPZ2REnO5abH41lhnLzQvFwbtzJj+ZHMk1uRm62cfLMnwntGck3MyvqZEXiWU7YCYVDGU5eTlZuRiyamZGdkZUlzYVzI9nG5GWGTF52RiRkQlGTmZvnhDPyo1l/YuvrJA74UCSUmZedk5eXFc3My83Nz49nx7KikbjJzYqaUG5YYKLhcCQjw4nmx/NzM8I5WSYjkheRCmXnORk5f8tXShuPGTe73GwnKxTLys10C58fzsrNcbLDWeFMJ54Vz406JhSK5GVIyiEnJyfTyYlnZjsm33a+Tn4s1+SHcsJ54bz8HJMblyTy5Ws0munEQnmZGSYezYnJABQuSdcJ58dzTV48GsrLDYczs+N/yzecYWJZ2ZnxqFQ3Py8/LAWX0RHOi4YzpB/CuSYnNys/Jzsr5GRkZUssQ7ovlJGXIb0cyw9n2s/XiUVjoVCmkxkJx0PRnLgTzcuVnGP5sbiRHpeJmOuEpT+i+dmZ4bhUymTkRiLReMTk5WaG/saXkx3OdaSj8qLRvHA4Jz8/Q9KNRXMzTTiUkxNy4tm5fw0eRxqScH5mLJ6V7WQ4uWHHyckKWR/P8XA4I5Sf4zj5Mrokj1AkR4440fysiBxXssOReCwvS7KLyRgwTiw/OzcccvLk1FSOE3Ii2bG/1Tc3npMZkf+fsPRaTiwzJyRHMicsh7CsHJn4WbGseE4oI0emcygjQ1oMZ5q4DIFQLC5dkedErNc3Q+ZRWCajHEodOabG8iKh/Eg0MzOakxmKZbgYocyseL4jx9JYTkaOhGXORR1HxoEU6u/jLxpxR36WE3Pk/8QzYxE5TGfkxDIicTk0ZsQcmf5Obk4kP5ZtsqM5uZnhUDSeFZYjX2bYyc4xNvI92GvL/V7L95zUs33fa/u+1/F9r+v7Xs/3vb7vewPf94a+74183xv7vjfxvjeVv81Ezb1HfLqcJdL+/kllk6HgJt12bjgWC4ciWUWU/kjlJzsWMBYFM9be83rtdsu6Tnrq51sXmG89C/mm8mkBW4w5lo4ZaM6mJJzrLb1AsUXiDzw0eAtLHYw+iPg7ONkfoi2B+2ZuPYp5dXHbrZG24xz6wrQd393PePkfHCG6tvj+UZrHuDDt7x9UP9gan3cWT/2DKfQgxVqoNQSFQh6l/2dlC+M8YgzXllPGx9nKW15ae3/beH/ben/beX/be387eH87en87eX87e3+7eH+7en+7FbweoeAQ2cZ7sr8/1l6JdVJiXb1YYb4+oZWl1yd0T7cI3D0d326PFH99gpt3DwuvTyjMwdba0mDrmW4RuKeFwdYrxQebm3cvS+/qQL+1qI03MdCGHHlA6J3OOWHbWpqwfdItAvexMGGjKT5h3byj5KtDO0uDLTfdInCuhcGWl+KDzc07j2R1aO9NDPTqgDwgxNLt9qGT3Ocvt9I7HV+b/BTP2x3jMQt5x0ndQAdLB+i+6RaB+1o4QPdL8QO0m3c/cjfQ0dJg659uEbi/hcE2IMUHm5v3ABI30MmbGGg3gDwgDEzxVdFdteMWVsVBKZ63O8YHWsh7MKkb6GzpAD0k3SLwEAsH6KEpfoB28x5K7ga6WBpsw9ItAg+zMNiGp/hgc/MeTuIGunoTA+0GkAeEESm+Krqr9mALq+LIFM/bHeMjLOQ9Cnygq5y285bXv67xLbbzut5Wvmt8W/uv/fX+NwX/f6Pl340RjRWNS98ZL/ig78lpA7x8aTRwLo4Hj0lb/QfctTFjgP03gaT/gBsRZiyw/yZaPjaM9x0DJvi+T/R9H5e+67FhkvzzZNEU0dRCODa0B9ZmErA200jGNvAcrpkM7L/pJP0HPC1ppgD7b4blY8M03zFguu/7DN/3qQnHhpnyz7NE54hmF8KxoROwNjOBtZlDMraBZ3TMLGD/zSXpP+BJCnMOsP/mWT42zPEdA+b6vs/zfZ+dcGw4V/55vmiBaGEhHBu6AmtzLrA2iyzXZpGvBvN93xf4vi9MqM158s/nixaLlqTv2p6/Jojf+KMs/IZeCqy1lreT3Me4/bvUQt7LLI+lvr5zB8t846eb73v/hHMHy+XfrRCtFF2gzHP0ubcYsD+Xg3dm/GPJ/2G5meJC77zuRd7fi72/l3h/V3l/L/X+Xub9vdz7e4X390rv71Xe36u9v9ekp+16Q8TF6X+/SeIKJXZ1euHfOHEheLIVfK5Ntwh8rYUdietSfEfCzfu69J0dDGq3ULe/LrI02K5Ptwh8vYXBtjrFB5ub92qS7a+LvYmBXoKRB4Qb0jkn7CWWJuyN6RaBb7QwYW9K8Qnr5n0T+eqwytJguzndIvDNFgbbLSk+2Ny8byFZHS71JgZ6dUAeEG5Nt9uHTnKfv9zKDRZ+6N+W4nm7Y/xWC3nfTuoGLrN0gL4j3SLwHRYO0Hem+AHazftOcjdwuaXBdle6ReC7LAy2NSk+2Ny815C4gSu8iYF2A8gDwt0pviq6q/btFlbFe1I8b3eM320h73tJ3cCVlg7Q96VbBL7PwgH6/hQ/QLt530/uBq6yNNgeSLcI/ICFwfZgig82N+8HSdzA1d7EQLsB5AHhoRRfFd1V+14Lq+LDKZ63O8YfspD3I5YvfvDfOHGh74KHi9L/+caJR+XfPSZ6XPREuv2LnC4GXvjyKHAuPgkek7b6D7hrYx4D9t9TJP0H3IgwjwP772nLx4YnfceAp3zfn/Z9fyJ912PDM/LPz4qeEz1fCMeGS4G1eQZYmxdIxjbwHK55Fth/L5L0H/C0pHkO2H8vWT42vOA7Brzo+/6S7/vzCceGl+WfXxG9KnqtEI4NVwBr8zKwNq+TjG3gGR3zCrD/3iDpP+BJCvMqsP/etHxseN13DHjD9/1N3/fXEo4Nb8k/vy16R/RuIRwbrgbW5i1gbd6zXJv3fDV42/f9Hd/3dxNq87788weiD0Ufpdu7ccL9jf+Ihd/Qa4G11vJ2kvsYt3/XWsj7Y8tjyX/jxMe+8XNN+j/fOPGJ/LtPRZ+JPk/nunHiE8v92cHXbx193zv9S39+If/uS9FXoq/3oD+T7YPqxXFtrbM8LxG5HlocPyYPBfbhesvnRRF9eJiFPjwM2IffEPTh4Rb68HBgH24g6MMjLPThEcA+/DbF9zjc4/V6Cz7lO4K8v7GQ9/cEeW+wkPdGyz7qO59f+t73feO/+Kgf5N9tEv0o+qkQfn9+AfzN+AOwrZ+BtSnMC0J+Bo+pgs/mdIvAm9Px7f4CHAy28v4lfWcHg9r9a7C5k7Zomv3B9oWlE5DgPgn5D2JbvD7/1fu71fv7m28Mwo/0vwB/4blsBXfGb03febd84tF/i+8o/6vv+9Z/Ofpvk3/3u+gP93/zL2e4nOQ+fw2cXyysqKtPSG337ea8zULeN5xgZyIWB3MCDxhmG7At4LgxyFq4B/NyaYVzMEechYrv+Ng4mJuCL/6+2F6wgFZM2/WRIdvT//4YEfd/VCMBCm1n1yXvOkLeZDHbkQ6mIra4NtzadgsHxu2WHArqdHL+X12aF0eeTi5SEZVz+C/ntErUxmtvvXcKwP057J6mcf9b++u18Iwq+KDG+Y7xE89b5xkq8Gm9zHXAY1DRiri5WMwbl4kfVPv/VCcnuY9B9oEtxmJoRhsueouFxeJmy78enOQ+fy2SbnHQed9SSL8enOQ+ZgvwYFQcN8gNcNwYZC0sHyRNQXv/xYNk8VQ9SCY6AvAvHKgjQJ6jLQGc0P5fjSV8vxqDGiXXVklgjVgdYEmCg9sBDA7wVwsO8HYCB3iABQd4B4kD/BV4MCoFPBgBx425I3CAFAfJUoEDTJoxjnQXB+IKEvI7wAP/ow7QRo0OAtaI1QEeRHBwK83gALdacIBrCBxgaQsO8G4SB7gVeDA6GOgAgePG3B04QIqD5MGBA0yaMR/pLsrgChL2O8Ay/20HCK3RIcAasTrAQwgObmUZHOBvFhzgfQQOsKwFB3g/iQP8DXgwKgd0gMBxY+4PHCDFQbJc4ACTZowh3UV5XEEy/A6w/H/bAUJrVAFYI1YHWIHg4JZu++DmJPf5ywm5kEXTkBMyD3rCuyLwYmzWlZxhsFdM9cG+ruCKe9BgLxiglYKrss21xVOfsTJygLIW6naCQlUJCuWYOwkKVTXVD/kbLN0l/RDBXdJVLZzhepjkDJd/YCabczXgGS7guDHIWvh/qFeruPOmX8YD5xqCA2f1YIVzzD0EhTo0KJSclyco1GFBoRzzAEGhDg8KJT6AoFBHBIVyzCMEhToyKJRjHiMoVI2gUI55gqBQNYNCOeYpgkIdFRTKMc8QFOrooFCOeY6gUMcEhXLMCwSFOjYolGPc98akOuNxQaEc8zLBjDo+KJRjXiUo1AlBoRzzOkGhTgwK5Zg3CQp1UlAox7xNUKiTg0I55l2CQp0SFMox7xMU6tSgUI75kKBQpwWFcsxagkKdHhTKMZ8QFMoJCuWYzwgKZYJCOeYLgkKFgkI55iuCQoWDQjlmHUGhMoJCOeYbgkJlBoVyzLcEhcqycC+pCprsjRfZMNAQ7X2V2RVTnzHCMqBycAOK9uH5OQQD6gyWAXUmbkDRPov3TIIBdRbLgKqFG1C0j/arRTCgzmYZULVxA4r2SUG1CQZUHZYBVRc3oDJZB1RdggFVj2VA1ccNqCzWAVWfYEA1YBlQDXEDKpt1QDUkGFCNWAZUY9yAirAOqMYEA6oJy4BqihtQOawDqinBgGrGMqCa4wZUlHVANScYUC1YBlRL3IDKZR1QLQkGVKtg09Uxs4umPmNrlpnfBjfzY6wDqg3BzG/LMqDa4QZUPuuAakcwoNqzDKgOuAEVZx1QHQgGVEeWAdUJ94IB2uuMOhEMqM4sA6oLbkDRXmfUhWBAdWUZUN14XoFirVjdCAZUd5YB1QM3oGivM+pBMKB6Bud3ZKOQ4CFPvVhmfm/czKe9fqc3wczvwzKgorgBRXv9TpRgQOUGS4lj3i+d+ox5LDM/hpv5tNfFxAhmfj7LgIrjBhTtdTFxggHVl2VA9cMNKNrrYvoRDKj+LANqAG5A0V4XM4BgQA1kGVCDcAMqj3VADSIYUINZBtQQ3ICivX5nCMGAGsoyoIbhBhTt9TvDCAbUcJYBNQI3oGiv3xlBMKBGsgyoUTDQDNrrd0YRDKjRLANqDG5A0V6/M4ZgQI1lGVDjcAOK9vqdcQQDajzLgJqAG1C01+9MIBhQE1kG1CTcgKJ9TtAkggE1mWVATcENKNrrjKYQDKipLANqGm5A0V5nNI1gQE1nGVAzcAOK9jlBMwgG1EyWATULN6Bor4eaRTCgzmEZULNxA4r2eqjZBANqDsuAmosbULTXQ80lGFDzWAbUubgBRXs91LkEA2o+y4BagBtQtNdDLSAYUAtZBtQi3ICivR5qEcGAOo9lQJ2PG1C010OdTzCgFrMMqCW4AUV7PdQSggG1FH0D5cI0vkLdTvCCu2W2Zn4xMOj6CrijiD/pZNtaDuzAEtJGWV+R/R904ZHcft4VFS0Cu42j210JHAy28l5ZcWcHg9p1WI+qawiOqhf8F4+qFwAn0oWkR9ULLR1VL6poEfgiC0fVi1P8qOrmfXFwVC34mPsIjqqX/BePqpcAJ9Iq0qPqKktH1UsrWgS+1MJR9bIUP6q6eV9m4aiqsSab/0pvBUBP/pUVU3MVvbxisMo9RLDKXfFfXOWuAA70K0lXuSstrXJXVbQIfJWFVe7qFF/l3LyvJlnl3NX4cgur3GXAVe5yYL2vCVY58xjBKnftf3GVuxY40K8jXeWus7TKXV/RIvD1Fla51Sm+yrl5ryZZ5dzV+BoLq9zVwFXuGmC9bwhWOfMUwSp3439xlbsRONBvIl3lbrK0yt1c0SLwzRZWuVtSfJVz876FZJVzV+MbLKxyq4Gr3A3Aet8arHLmOYJV7rb/4ip3G3Cg3066yt1uaZW7o6JF4DssrHJ3pvgq5+Z9J8kq567Gt1pY5W4BrnK3Aut9V7DKmb4Eby1b819c5dYAB/rdpKvc3ZZWuXsqWgS+x8Iqd2+Kr3Ju3veSrHLuanyXhVXuTuAqdxew3vcFq5x5leC33P3/xVXufuBAf4B0lXvA0ir3YEWLwA9aWOUeSvFVzs37IZJVzl2N77Owyt0LXOXuA9b74WCVM28SrHKP/BdXuUeAA/1R0lXuUUur3GMVLQI/ZmGVezzFVzk378dJVjl3NX7Ywir3EHCVexhY7yeCVc68S7DKPflfXOWeBA70p0hXuacsrXJPV7QI/LSFVe6ZFF/l3LyfIVnl3NX4CQur3OPAVe4JYL2fDVY58yHBKvfcf3GVew440J8nXeWet7TKvVDRIvALFla5F1N8lXPzfpFklXNX42ctrHLPAFe5Z4H1filY5cwnBKvcy//FVe5l4EB/hXSVe8XSKvdqRYvAr1pY5V5L8VXOzfs1klXOXY1fsrDKvQhc5V4C1vv1YJUzXxCscm/8F1e5N4AD/U3SVe5NS6vcWxUtAr9lYZV7O8VXOTfvt0lWOXc1ft3CKvcacJV7HVjvd4JVzqwjWOXe/S+ucu8CB/p7pKvce5ZWufcrWgR+38Iq90GKr3Ju3h+QrHLuavyOhVXubeAq9w6w3h8Gq5z5lmCV++i/uMp9BBzoa0lXubWWVrmPK1oE/tjCKvdJiq9ybt6fkKxy7mr8oYVV7gPgKvchsN6fVkzterjjxmUsanHOOMl9zKfAepRI2/Xg6f/+mTuH3P9B0bTCOcJ+BhwcRX2cn3sHgy8qJiSAnnWfASvz+Z63lbebtswX4KWrtK/vkP3357+3F8qLm3BmfnamkxXNyIxlhUOxULYTy8iMG+mIUE6GdEM8LyMSi4TC8VB2KO9PLN9fuRf1DX63Rn9637/wvn8pf78SfV1xx+Qp5/v/8X/Qk+drW74Uyxny98U6b0Kur+h1SDHvr/sv/kgAQE/WrwGTNT++47MOOPHXWyokeklD5vyNry0TCYdC2WH3fxeJOSYjJoe3UCiWm+HkOdG8UH5OhsmJZ4QywnmxvFxpM2riTjyalxOP7OAqzN8E31j6TbChokXgDRZ+E3yb4r8J3Ly/JflNsN5jRbf7HXiwFhysv6u40yL6nYH7z5ek71whV/m+X5q+4+/uVtPv5e9G0Q+FvJr+QLiabvLG94+Jq+mmQlhNfwCuppuAB5MfSVZTZM4/ka6mP1laTX+uaBH4Zwur6eYUX03dvDeTrKY/eqzodn+xtJr+UvHvKxy6fsiDom3W74GsNbx2tkibv4q2in4TbRP97i6SrusQbXfHdiXJRVRUVExUXFRCVFJ0gKiU6EDRQaLSooNFZUSHiMqKyonKiyqI0kUVRZVElSvt6CR/zV2eUmm7xn5VYluV2G9KbJsS+12J/aHE/lRi25WY2z+JsSJKrKgSK6bEiiuxEkqspBI7QImVUmIHKrGDlFhpJXawEiujxA5RYmWVWDklVl6JVVBi6UqsohKrpMQqezH/p7j3t47310nus8ucTfY4uwVmLB3zK5DrsRPsGMvEWiSTs1uLrZD+21HX35JvK1RwTnobsBaPp3ItMnaeh/89uZwd/zn9P5JpK7Tr/sCfwFo8kZq1cBL3RLbvY85Z8b/vr7hr4T60FdH2aopUwtXiyVSrRUTfnyq69zln/9NeV7G9bSv7n/fNigNr8VTq1CL0b3uFJfYm5+x/33csuedt7XYP8wBgLZ5OhVpk75bTlNqznJ09yNkcuCdtOXvUf+YgYC2e2b+1yNxDTlN6dzln7HHO5uB/bSsjvhf9Z8oAa/Hs/qpF9l5xmkP+OefIXuZsyv5DWznxve4/Uw5Yi+cKvxbOPnCa8lrOzj7lbCr8vS2zj/1n0oG1eL4waxHbZ05Tcdecw0nkbCr52grFk+o/UxlYixcKqRZOch8DPD9ggL9vjf/3WdL325PUAvg7yAB9vHkaWIuXSGoB9HsG6FfMc8BavExSC+C6ZoDHZfMisBavWKoF+gIK4Pw1wPFnkP3njt/LRTW89ip7e2IVvT2yCt6eWTlvD+0Qb0/tYG+P7SBvz62UtwdX0tuTK+7t0RX19uzc83Hbvb28P7y9vW3eXt9Wb+9vS+LF4Gl/v6gj2bG3EXhetUol2EUdhXrblJ/bSfLj561aySKw2zi63WpAE2wr72qVdnYwqN2/BlvBXSS2B9vGQrpsL9kJ6B/I1X1jDX6VSjXc7DP+XWQ/9F4y5+3ukjOX2W1/by+x212nVwdOwEPBR7WCfnXbnbaPY8FI3+UZJ+7khORMTnZeVnZuTiyUG4nGw/HMcCy8r/26u8GO7NfDLPXrYfver/8vxuvhlvr18P/4eD3CUr8e4fVrYd5+iVw8/Yv9kZ6pqOGuGTYWuOoW3Fr1SlgnYSvvvZ0czl7knSxjTct96CT3Me7ArFkJX5ujLB0UjvqXg62T3MfUsNQXR1vqi6Mt9oV7ILTRFx+fkNrHFFvz4ZP9m/duLy2xNfY/JTn1CByXBlhrg+w/10iVTNPPQqTtZX/ubjz527SxZqH6xG8qj/m3sxBOch9T09IicMy/nIXYTTNmd/8dl/kYCweFL1Nkb2hvzFuyOR9bKTUPMMha+MflsT5zsq/12V2fI+tznH9vIRyWuRHLNvFYPJyZnRPKNVnhrKx4Rjw7K5IRi2dmRGPZ+SYjGg7l5Gc7cRPJz8/ODOdlZ8VzYnlZcf9B28TC4YxYTm6eyQxlRXOdSCwcdeIZ2WH5wR8LZ8di4UhWVjQcjmVF4pEc+ZEuP/0jTmZ2do6TFQrnhGzV5zjfr2vUorC7szn+NlkWheMZF4XjLS8Kx1tYFL5OkUXhHwdx9o4785EHnRNSdFH42tJB5wTAorC7U5vI+pyYoouCrfqc+P/olOtJ3inXk7VTrk5yn3/c70DuVSbbFvD0rbFR+II+LEbSh8m2dUqK18OdMKdYWNhPtWRyTrV4+vNkS31xmqW+OM3yqWAbfbE+xU8F25oP36T4qWBbY38Dyalg4Lg0wFqbDcGp4MTPX2sWqk/8Zvd0m7/6T7G0CJxu8Ve/y3y6hYPCRpJTwacAjaBTKTUPMBst/ap0CuFUMLI+BvirfwPwV7+t+hilPnt7Tc3uTv0i6xOydPwMAfphd2enkP0QttQPYbLxkGGpHzLIxkOmpX7I3IOtolQ2dgoubBz7TWMWo2nMsmwasyyYxk2p8RyhvMI8yGUD20Kaxk2WTEn2HpjGZK+uR9YnUgln9JCm0VZ9IoDFcTcf6DMzcmDHz4iVC7GreWfd0DtKyDF+RorvYLg1PsPCenOmpbXXbbeU98+Xp/39g/pvFrSH7u9rCd5VehbaSLIM2p9SfHvFzfksC3n/TPLgkbOAB+ZawAMzcNwYZC0sHyT/t03xXzxI1vqvHiTPTvHb89ycz7aQd21LjqZ2pZ1P1rdxu6fmkJ3kPgbpkOuk+Hj66xeVhfFUl2Ae1bWQdz1L86jev8wjJ7mPtWPKlhP+m2Pg10K6riVZzvpAkwistfnV0hmq+sGva+uMDWwbR8SvzAYWJv02kl+ZDQgmfbK1+J3kANwQWAvg+DO/B7/SKQ62DZEHW9ZV8XaCQjUKCuWYOwkK1TgolGPWEBSqSVAox9xDUKimQaEccx9BoZoFhXLMAwSFah4UyjEPERSqRVAoxzxCUKiWQaEc8xhBoVoFhXLMEwSFah0UyjFPERSqTVAoxzxDUKi2QaEc8xxBodoFhXLMCwSFah8UyjF9i6U+Y4egUI55mWBGdQwK5ZhXCQrVKSiUY14nKFTnoFCOeZOgUF2CQjnmbYJCdQ0K5Zh3CQrVLSiUY94nKFT3oFCO+ZCgUD2CQjlmLUGhegaFcswnBIXqFRTKMZ8RFKp3UCjHfEFQqD5BoRzzFUGhokGhHLOOoFC5QaEc8w1BofKCQjnmW4JCxZCFcp+heUDaznvLXNiaCUUrCk4A+JALg77R30bBGhEwNiZgbELA2JSAsRkBY3MCxhYEjC0JGFsRMLYmYGxDwNiWgLEdAWN7AsYOBIwdCRg7ETB2JmDsQsDYlYCxGwFjdwLGHgSMPQkYexEw9iZg7EPAGCVgzCVgzCNgjFlgTIMyhrPTlA+m7ZCx1/bON5MX8bWZL/0dF/UV9RP1Fw0QDRQNEg0WDRENFQ0TDReNEI0UjRKNFo0RjRWNE40XTRBNFE0STRZNEU0VTRNNF80QzRTNEp0jmi2aI5ormic6VzRftEC0ULRIdJ7ofNFi0RLRUtEy0XLRCtFK0QWiC0UXiS4WXSJaJbpUdJnoctEVoitFV4murrSjD66p5HVKwVMb3U4plRCLK7G+SqyfEuuvxAYosYFKbJASG6zEhiixoUpsmBIbrsRGKLGRSmyUEhutxMYosbFKbJwSG6/EJiixiUpskhKbrMSmKLGpSmyaEpuuxGYosZlKbJYSm63E5iixuUpsnhI7V4nNV2ILlNhCJbZIiZ2nxM5XYouV2BIltlSJLVNiy5XYCiW2UoldoMQuVGIXKbGLldglSmyVErtUiV2mxC5XYlcosSuV2FVK7Goldo1vwS34oB866d/8S6GnfJv8SnbMRlFw/wE3E02cJGfg5qTpS5IzcLPT9CPJGbh5avqT5AzcjDUDSHIGbu6agSQ5AzeLzSCSnIGbz2YwSc7AzWwzhCRn4Oa4GUqSM3Cz3QwjyRm4eW+Gk+QMvBjAjCDJGXhxgRlJkjPwYgUziiRn4MUPZjRJzsCLKcwYkpyBF2eYsSQ5Ay/2MONIcgZePGLGk+QMvBjFTCDJGXhxi5lIkjPwYhkziSRn4MU3ZjJJzsCLecwUkpyBFweZqSQ5Ay82MtNIcgZevGSmk+QMvBjKzCDJGXhxlZlJkjPwYi0zy1LORRJydpL7mHMAe9n5cfeTF3VvxC3lq0sRH6ctfht73mjG4OZZDGNw8yyGMbh5FsMY3DyLYQxunsUwBjfPYhiDm2cxjMHNsxjG4OZZDGNw8yyGMbh5FsMY3DyLYQxunsUwBjfPYhiDm2cxjIw3z2LajVjr0zkEdZ9LwDiPgPFcAsb5BIwLCBgXEjAuImA8j4DxfALGxQSMSwgYlxIwLiNgXE7AuIKAcSUB4wUEjBcSMF5EwHgxAeMlBIyrCBgvJWC8jIDxcgLGKwgYryRgvIqA8WqL5/lwnKGQdl3jtcJ+neh60WrRDaIbRTeJbhbdIrpVdJvodtEdojtFd4nWiO4W3SO6V3Sf6H7RA6IHRQ+JHhY9InpU9JjocdEToidFT4meFj0jelb0nOh50QuiF0UviV4WvSJ6VfSa6HXRG6I3RW+J3ha9I3pX9J7ofdEHog9FH4nWij4WfSL6VPSZ6HPRF6IvK+3og68qpe36ECa3UxIfzHSdErteia1WYjcosRuV2E1K7GYldosSu1WJ3abEbldidyixO5XYXUpsjRK7W4ndo8TuVWL3KbH7ldgDSuxBJfaQEntYiT2ixB5VYo8psceV2BNK7Ekl9pQSe1aJPafEnldiLyixF5XYS0rsZSX2ihJ7VYm9psReV2JvKLE3ldhbSuxtJfaOEntXib2nxN5XYh8osQ+V2EdKbK0S+1iJfaLEPlVinymxz5XYF0rsSyX2VaW/X9BesCgUxJO9CQF4Qbu5tpKdhRWdM/KBcNeR5Ix8INz1JDkjHwi3miRn5APhbiDJGflAuBtJckY+EO4mkpyRD4S7mSRn5APhbiHJGflAuFtJckY+EO42kpyRD4S7nSRn5APh7iDJGflAuDtJckY+EO4ukpyRD4RbQ5Iz8oFwd5PkjHwg3D0kOSMfCHcvSc7IB8LdR5Iz8oFw95PkjHwg3AMkOSMfCPcgSc7IB8I9RJIz8oFwD5PkjHwg3CMkOSMfCPcoSc7IB8I9RpIz8oFwj5PkjHwg3BMkOSMfCPckSc7IB8I9ZSnnIgk5O8l9zNOVku+/ggfC2eR8BsYZMTbHEPCGS/MsybwB3sBpniPJGXhDqHmeJGfgDabmBZKcgTesmhdJcgbeAGteIskZeEOteZkkZ+ANuuYVkpyBN/yaV0lyBt5AbF4jyRl4Q7J5nSRn4A3O5g2SnIE3TJs3SXIG3oBt3iLJGXhDt3mbJGfgDeLmHZKcgTecm3dJcgbewG7eI8kZeEO8eZ8kZ+AN9uYDkpyBN+ybD0lyBj4AwHxEkjPwgQJmLUnOwAcUmI9JcgY+8MB8QpIz8AEK5lOSnIEPZDCfkeQMfMCD+ZwkZ+ADI8wXJDkDH0BhvgTm7L5Q68C0Hfcfu58ivpzTfDF/XzjJfYIXaoEYgxdqYRiDF2phGIMXamEYgxdqYRiDF2phGIMXamEYgxdqYRiDF2phGIMXamEYgxdqYRiDF2phGIMXamEYgxdqYRiDF2phGIMXaiHaDV6oZYMxeKEWhjF4oRaGMXihFoYxeKEWhjF4oRaGMXihFoYxeKEWhjF4oRaGMXihFoYxeKEWhjF4oRaGMXihFoYxeKEWhjF4oRaGkeWFWhbbNkV8fVvQ5tfSL+tE60XfiDaIvhV9J/petFH0g2iT6EfRT6KfRZtFv4i2iH4VbRX9Jtom+l30h+hP0XZRWmX5b4qKioqJiotKiEqKDhCVEh0oOkhUWnSwqIzoEFFZUTlReVEFUbqooqiSqLKoiqiqqJqouuhQ0WGiw0VHiI4U1RDVFB0lOlp0jOhY0XGV03Z9mY3bGYkvuFmnxNYrsW+U2AYl9q0S+06Jfa/ENiqxH5TYJiX2oxL7SYn9rMQ2K7FflNgWJfarEtuqxH5TYtuU2O9K7A8l9qcS267E3MGZGCuixIoqsWJKrLgSK6HESiqxI5VYDSVWU4kdpcSOVmLHKLFjldhxXsz/Ker9reP9TaUXO31NcmE98sVO60hyRr7YaT1JzsgXO31DkjPyxU4bSHJGvtjpW5KckS92+o4kZ+SLnb4nyRn5YqeNJDkjX+z0A0nOyBc7bSLJGflipx9Jcka+2OknkpyRL3b6mSRn5IudNpPkjHyx0y8kOSNf7LSFJGfki51+JckZ+WKnrSQ5I1/s9BtJzsgXO20jyRn5YqffSXJGvtjpD5KckS92+pMkZ+SLnbaT5Ix8sZO7N8OQM/LFTkVIcka+2KkoSc7IFzsVI8kZ+WKn4iQ5I1/sVIIkZ+SLnUpayhl9UdABlZPvv8J4sVMpGOeuL3ZCcx5IUveDSDhLk3AeTMJZhoTzEBLOsiSc5Ug4y5NwViDhTCfhrEjCWYmEszIJZxUSzqoknNVIOKuTcB5KwnkYCefhJJxHWOIsniyn2fUfj0yOc5fWaiSbs6+1moDf6wXnZbafkKK1cHbN+ijEmPFaOxoz/v5q7RhgLdJOTOlaOAVZH4ubv+Y4YFvAsWz8tUjqnFh+PMd9qUC5tJ3nVK3UxvLYdpL5pO6YsXGz5f+OWf56H195x98TEm8KdP/F2oSY+z+qkRYMlGQPqMUYDqgJA3ofcw55OZvjgf13AnDS2qpFUXAtkP13otJWrpMXyzS5WbFskx/NjOTl5YSNCUWzolm5oUg8PzfTRDIj0mZeNBSR/1wommfynWhWvruIlE3bacb9H7RBPxF4gPXznlTZIrDbOLrdk5HuzlLeJ1fe2cGgdlVWxMHEZUVN2IJ2kTU6BTzwCxZ0t92a8rcwneCRwAW+BnCBrwlcVI6qbGdRAc0n1Qme6s3X0xKd4KmKEzzNphP0II8Cuo9TgZPxNF9boVhmvpMTyY2EcqPh7NyMcG5OTlTazTImEo+FnFhGKJ5psrLycvJz4iYcz83Mj2ZlRnOyYn+tnjFbpznQ7gPZf6eTuo/TLbkPp7JFYMeC+zAp7j7cvA2J+zjNY0W7D2SNQpbcR2g/uA/Qtax/tQa7RtRgr720+XB/QC1U9xH25mtGovsIK+4joxDOQzEMlGQndgmS81CxSjgnGAYeGDOAPxlKkJyHQvZfJqkTzLTkBLMqWwTOsuAEs1PcCbp5Z5M4wQyPFe0EkTWKWHKCkf3gBHsCF/hewAUeeVddH0InmOPN1zMSnWCO4gTPKAQnyDBQkp3YB5A4wT5AJ5gDPDCeAXSCB5A4QWT/nUnqBM+05ATPqmwR+CwLTrBWijtBN+9aJE7wDI8V7QSRNTrbkhM8ez84wa7ABb4bcIFHPi+lB6ETrO3N1zqJTrC24gTrFIITZBgoyU7sA0mcYA+gE6wNPDDWATrBA0mcILL/6pI6wbqWnGC9yhaB61lwgvVT3Am6edcncYJ1PFa0E0TWqIElJ9hgPzjBjsAFvhNwgUc+CbMLoRNs6M3XRolOsKHiBBsVghNkGCjJTuzSJE6wC9AJNgQeGBsBnWBpEieI7L/GpE6wsSUn2KSyReAmFpxg0xR3gm7eTUmcYCOPFe0EkTVqZskJNtsPTrAtcIFvB1zgke846EDoBJt787VFohNsrjjBFoXgBBkGSrITuwyJE+wAdILNgQfGFkAnWIbECSL7ryWpE2xpyQm2qmwRuJUFJ9g6xZ2gm3drEifYwmNFO0FkjdpYcoJt9oMTbAlc4FsBF3jk2+vaEDrBtt58bZfoBNsqTrBdIThBhoGS7MQuS+IE2wCdYFvggbEd0AmWJXGCyP5rT+oE21tygh0qWwTuYMEJdkxxJ+jm3ZHECbbzWNFOEFmjTpacYKf94ASbAhf4ZsAFHvle8haETrCzN1+7JDrBzooT7FIITpBhoCQ7scuTOMEWQCfYGXhg7AJ0guVJnCCy/7qSOsGulpxgt8oWgbtZcILdU9wJunl3J3GCXTxWtBNE1qiHJSfYozCdoLcoNwIuyo2B7q1JJZyJySd0gj29+dor0Qn2VJxgL5tOkGigJDux01PdCSoDOlkn2BN4YOwFdILpJE4Q2X+9SZ1gb0tOsE9li8B9LDjBaIo7QTfvKIkT7OWxop0gska5lpxgrucE3e9V0nZd5P2nfvwbgv7LxPw3D/hvKfU/aMT9nuH7/m2Jnd+vLb7v30/ztXmC7/t3vva/933f6Pv+g+/7Jt/3H33ff/J9/9n7nif/nZgoXxQX9RX1E/UXDaj8dyeNnlcDgOOgwCwMlDYHiQaLhngu0D9G3H9fKm3X2CAlNliJDfFi/g/6dNUA4DwbCGhrx/uTHTMIyFXJkkkpllCLZHJ2azEY0n876joEaPKQ/Wd7jve3MMeHSpvDRMNFI5Q5PlSZu8OU2HAlNqIQ5nh/4FwaCpzjw4BcVUjm+HDgHB8BnONViOZ4PwtzfKS0OUo0WjRGmeMjlbk7SomNVmJjCmGO9wPOpZHAOT4KyFWNZI6PBs7xMcA5Xo1ojve1MMfHSpvjRONFE5Q5PlaZu+OU2HglNqEQ5nhf4FwaC5zj44Bch5LM8fHAOT4BOMcPJZrjcQtzfKK0OUk0WTRFmeMTlbk7SYlNVmJTCmGOx4FzaSJwjk8Cch1OMscnA+f4FOAcP5xojudbmONTpc1poumiGcocn6rM3WlKbLoSm1EIczwfOJemAuf4NCDXkSRzfDpwjs8AzvEjieZ4zMIcnyltzhKdI5qtzPGZytydpcTOUWKzC2GOx4BzaSZwjs8CctUkmePnAOf4bOAcr0k0x/MszPE50uZc0TzRucocn6PM3blKbJ4SO7cQ5ngecC7NAc7xuUCuo0nm+DzgHD8XOMePJprjRXBtOTW8duZLXy4QLRQtEp0nOl+0WLREtFS0TLRctEK0UnSB6ELRRaKLRZeIVokuFV0mulx0hehK0VWiq0XXiK4VXSe6XrRadINyTJmvHCsWKLGFSmyREjtPiZ2vxBYrsSVKbKkSW6bEliuxFUpspRK7QIldqMQuUmIXK7FLlNgqJXapErtMiV2uxK5QYlcqsauU2NVK7Boldq0Su06JXa/EViuxGwphDfLP2WSP9fOBa9AC4Bp0bCFd8JvsGrQQuAYtSr6t/108fB6wFselci0y/sdpzk8uZ8eXs1mcTFuhXfrPLAHW4vjUrIWTwGmW7mPOWfG/5WyW7VtbEaX/zHJgLU5ItVpEVE6zYu9zzv6HnM3KvW0r+x/7z1wArMWJqVOL0L9wmgv3Jufsf83ZXLTnbeXtpv/MxcBanJQKtcjeLae5ZM9ydvYgZ7NqT9py9qj/zKXAWpy8f2uRuYec5rLd5Zyxxzmby/+1rYz4XvSfuQJYi1P2Vy2y94rTXPnPOUf2Mmdz1T+0lRPf6/4zVwNrcWrh18LZB05zjZazs085m2v/3pbZx/4z1wFrcVph1iK2z5zm+l1zDieRs1ntaysUT6r/zA3AWpxO8sgV4PkBA/x9a/y/z5KthUNSC+DvIAP08eYkYC0MSS2Afs8A/Yo5FViLEEktgOuaAR6XjQOsRbiQ9gqd5D4GOH8NcPwZZP8V7A3W8P769yMS9yv8+xn+/Q7/foh/v8S/n+Lfb/Hvx/j3a/z7Of79Hv9+kH+/yL+f5N9v8u9H+fer/PtZ/v0u/36Yf7/Mv5/m32/z78f59+v8+3n+/T7/fqB/v9C/n+jfb5zg++6/h8B/j4H/HoQxvu/++4r89x3570sa4fvuv9fQfy+i/17FIb7v/vuP/fcn++9fPtf33X/Nhf+aDP81G7N93/3XYfmv0/JfxzXD991/bab/2k3/tZ1TfN/912v7r+cuuN674IByo/zzTaKbRbeIbhXdJrpddIfoTtFdojWiu0X3iO4V3Se6X/SA6EHRQ6KHRY+IHhU9Jnpc9IToSdFToqdFz4ieFT0nel70guhF0Uuil0WviF4VvSZ6XfSG6E3RW6K3Re+I3hW9J3q/8o6cSqftPCa6/9whPS3tT+97R9/3Tuk7/hb1/W8/r7jz33/hff9A2v1Q9FHlf3+qVcExpY7310nuYz6qbGe9SMNyhvx9sbbyjr8fV07bdbPX/Rd/JACgF66PAD/udmzQxuNrgT8UP7ZUyKLg/kPm/ImvLSMn+uUEvfu/i8QckxGTU+yhUCw3w8lzonmh/JwMOceVEcoI58Xy5KRjJGriTjyalxOP7OAqzKcAfVIZbzLcz6eVLQJ/Whnf7mfAwWAr788q7+xgULtWngL0sceKbvdz8GAtOFi77dq+mg55ULTN+gGQtYbXzhfS5peir0Rfi9aJ1ou+EW0QfSv6TvS9aKPoB9Em0Y+in0Q/izaLfhFtEf0q2ir6TbRN9Lu74Ir+FG1350kV6RdRUVEx73FM/pp/UfnvV2h9qcS+UmJfK7F1Smy9EvtGiW1QYt8qse+U2PdKbKMS+0GJbVJiPyqxn5TYz0pssxL7RYltUWK/KrGtSuw3JbZNif2uxP5QYn8qse1KzB1PibEiSqyoEitWxf6Vfx8A168vYMbSMV8CueqTXPn3FaT/dtT16+Tb+t+Vf+uAtWhAcuXf+uRy3uXKv2+SaSvhyr8NwFo0JLny79t9zFm78u+7fWtLvfLve2AtGpFc+bdx73P+xyv/ftjbtv7lyr9NwFo0Jrny78e9yXk3V/79tOdt7fbKv5+BtWhCcuXf5j3LeY+u/PtlT9rawyv/tgBr0ZTkyr9fd5fzXlz5t7Uy7sq/34C1aEZy5d+2yrgr/36vjLvy7w9gLZqTXPn3Z2XclX/bK+Ou/HN/I6Nq0YLkyr8iVXBX/hWtgrvyrxiwFi1JrqoBnh8wwN+3piHwqppWJLUA/g4yQB9vmgBr0ZqkFkC/Z4B+xTQH1qINywshgf0HPC6bVsBatCW58g84fw1w/Blk/7nj9zZRjYI+9PbEXN/i+rXt3p7ZH94e2jZvT22rt8e2xdtz2+ztwf3k7clt8vboNnp7dt95e3gbvD299d4e39fenp+7D/BF5bS/fRIv6kh27H0I/D1QvArsog6nMC/q8HM7SX78vCWqWAR2G0e3WxJogm3lXbLKzg4GtfvXYHNVNM3+YPuwsp2DfWKfJDsB/QP5AN9Yg1+lUhI3+4x/F9kPvZfMebu75Mxldtvf20vsdtfpBwAnYCnwUa2gX912p+3jWDDuc9+ME3dyQnImJzsvKzs3JxbKjUTj4XhmOBbe137d3WBH9uuBlvr1wH3v1/8X4/UgS/160H98vJa21K+lvX4tWDgLw6khF0//Yn+wZyrKuGuGjQXuAAtu7YAqWCdhK++9nRzOXuSdLOMhlvvQSe5j3IF5SBV8bcpaOiiU/ZeDrZPcx5Sx1BflLPVFOYt94R4IbfRF9MTUPqbYmg+5+zfv3V5aYmvs55GcegSOSwOstUH2n2ukSqbpZyHS9rI/d7v17PvYWLNQfeI3leX/7SyEk9zHHGJpESj/L2chdtOM2d1/x2Uub+Gg0DdF9ob2xrwlm3OFKql5gEHWwj8uK/jMyb7WZ3d9jqxPun9vIRyWuRHLNvFYPJyZnRPKNVnhrKx4Rjw7K5IRi2dmRGPZ+SYjGg7l5Gc7cRPJz8/ODOdlZ8VzYnlZcf9B28TC4YxYTm6eyQxlRXOdSCwcdeIZ2WH5wR8LZ8di4UhWVjQcjmVF4pEc+ZEuP/0jTmZ2do6TFQrnhGzVJ9336xq1KOzubI6/TZZFoSLjolDR8qJQ0cKi0D9FFoV/HMTZO+7MRx50KqXootDf0kGnEmBR2N2pTWR9KqfoomCrPpX/H51yreKdcq2qnXJ1kvv8434Hcq8y2baAp2+NjcIX9CHqXUO2+zDZtqqleD3cCVPNwsJe3ZLJqW7x9GdVS31xqKW+ONTyqWAbfTEwxU8F25oPg1L8VLCtsT+Y5FQwcFwaYK3N4OBUcOLnrzUL1Sd+s3uYzV/91SwtAodZ/NXvMh9m4aAwnORUcDWgETy8SmoeYIZb+lV5eCGcCkbW5wjgr/7BwF/9tupzhFKfvb2mZnenfpH1OdLS8fNIQD/s7uwUsh9qWOqHGmTjoaalfqhJNh6OstQPR+3BVlEqGzsFFzaO/abxaEbTeLRl03i0BdM4MjWeI5RXmAe5Y4BtIU3jSEum5Jg9MI3JXl2PrM+xVXBGD2kabdXnWMDiuJsP9JkZx8GOnxErF2KX9M66oXeUkGP8+BTfwXBrfLyF9eYES2uv224p759vS/v7B/XfLGgP3d/XFk99xhPRRpJl0I5O8e0VN+cTLeQ9huTBIycCD8wnAQ/MwHFjkLWwfJD83zbFf/EgedJ/9SB5corfnufmfLKFvE+x5GhOqbLzyfo2bvfUHLKT3McgHfKpKT6e3F9Up1oYT6cRzKPTLOR9uqV5dPq/zCMnuY+1Y8r4E/+bY2BCIV3XkvQ7qoEmEVhrM8HSGSon+HVtndHYNo6IX5nGwqSfTPIr0xBM+mRrMYXkABwC1gI4/syU4Fc6xcE2hDzYsq6KtxMUKhwUyjF3EhQqIyiUY9YQFCozKJRj7iEoVFZQKMfcR1Co7KBQjnmAoFCRoFCOeYigUDlBoRzzCEGhzggK5ZjHCAp1ZlAoxzxBUKizgkI55imCQtUKCuWYZwgKdXZQKMc8R1Co2kGhHPMCQaHqBIVyTN9iqc9YNyiUY14mmFH1gkI55lWCQtUPCuWY1wkK1SAolGPeJChUw6BQjnmboFCNgkI55l2CQjUOCuWY9wkK1SQolGM+JChU06BQjllLUKhmQaEc8wlBoZoHhXLMZwSFahEUyjFfEBSqZVAox3xFUKhWQaEcs46gUK2DQjnmG4JCtQkK5ZhvCQrVFlko9xmaB6TtvLfsr+eMJhStKDgB4EMuDPpGfxsFCxMwZhAwZhIwZhEwZhMwRggYcwgYzyBgPJOA8SwCxloEjGcTMNYmYKxDwFiXgLEeAWN9AsYGBIwNCRgbETA2JmBsQsDYlICxGQFjcwLGFgSMLQkYWxEwtiZgbEPA2NYCYxqUMZydpnwwbYeMvbZ3vpm8iK/NdtLf7UUdRB1FnUSdRV1EXUXdRN1FPUQ9Rb1EvUV9RFFRrihPFBPli+KivqJ+ov6iAaKBokGiwaIhoqGiYaLhohGikaJRotGiMaKxonGi8aIJoomiSaLJoimiqaJpoumiGaKZolmic0SzRXNEc0XzROeK5osWiBaKFonOE50vWlxlRx8sqeJ1SsFTG91OKZUQa6/EOiixjkqskxLrrMS6KLGuSqybEuuuxHoosZ5KrJcS663E+iixqBLLVWJ5SiymxPKVWFyJ9VVi/ZRYfyU2QIkNVGKDlNhgJTZEiQ1VYsOU2HAlNlKJjVJio5XYGCU2VomNU2LjldgEJTZRiU1SYpOV2BQlNlWJTVNi05XYDCU2U4nNUmLnKLHZSmyOEpurxOYpsXOV2HwltkCJLVRii5TYeUrsfCW2WIm5B786abt+0A+d9G/+pdBTvk27KnbMRlFw/wE3E017kpyBm5OmA0nOwM1O05EkZ+DmqelEkjNwM9Z0JskZuLlrupDkDNwsNl1JcgZuPptuJDkDN7NNd5KcgZvjpgdJzsDNdtOTJGfg5r3pRZIz8GIA05skZ+DFBaYPSc7AixVMlCRn4MUPJpckZ+DFFCaPJGfgxRkmRpIz8GIPk0+SM/DiERMnyRl4MYrpS5Iz8OIW048kZ+DFMqY/Sc7Ai2/MAJKcgRfzmIEkOQMvDjKDSHIGXmxkBpPkDLx4yQwhyRl4MZQZSpIz8OIqM4wkZ+DFWma4pZyLJOTsJPcxIwB72flx95MXdW/ELeWrSxEfpy1+G3veaMbg5lkMY3DzLIYxuHkWwxjcPIthDG6exTAGN89iGIObZzGMwc2zGMbg5lkMY3DzLIYxuHkWwxjcPIthDG6exTAGN89iGIObZzGMjDfPYtqNWOvTUQR1H03AOIaAcSwB4zgCxvEEjBMIGCcSME4iYJxMwDiFgHEqAeM0AsbpBIwzCBhnEjDOImA8h4BxNgHjHALGuQSM8wgYzyVgnE/AuICAcSEB4yICxvMIGM8nYFxs8TwfjjMU0q5rXCrsy0TLRStEK0UXiC4UXSS6WHSJaJXoUtFlostFV4iuFF0lulp0jeha0XWi60WrRTeIbhTdJLpZdIvoVtFtottFd4juFN0lWiO6W3SP6F7RfaL7RQ+IHhQ9JHpY9IjoUdFjosdFT4ieFD0lelr0jOhZ0XOi50UviF4UvSR6WfSK6FXRa6LXq+zogzeqpO36ECa3UxIfzLRMiS1XYiuU2EoldoESu1CJXaTELlZilyixVUrsUiV2mRK7XIldocSuVGJXKbGrldg1SuxaJXadErteia1WYjcosRuV2E1K7GYldosSu1WJ3abEbldidyixNUrsbiV2jxK7V4ndp8TuV2IPKLEHldhDSuxhJfaIEntUiT2mxB5XYk8osSeV2FNK7Gkl9owSe1aJPafEnldiLyixF5XYS0rsZSX2ihJ7VYm9psReV2JvVPn7Be0Fi0JBPNmbEIAXtJulVewsrOickQ+EW0aSM/KBcMtJckY+EG4FSc7IB8KtJMkZ+UC4C0hyRj4Q7kKSnJEPhLuIJGfkA+EuJskZ+UC4S0hyRj4QbhVJzsgHwl1KkjPygXCXkeSMfCDc5SQ5Ix8IdwVJzsgHwl1JkjPygXBXkeSMfCDc1SQ5Ix8Idw1JzsgHwl1LkjPygXDXkeSMfCDc9SQ5Ix8It5okZ+QD4W4gyRn5QLgbSXJGPhDuJpKckQ+Eu5kkZ+QD4W4hyRn5QLhbSXJGPhDuNpKckQ+Eu50kZ+QD4e6wlHORhJyd5D7mzirJ91/BA+Fsct4F44wYm2MIeMOlWUMyb4A3cJq7SXIG3hBq7iHJGXiDqbmXJGfgDavmPpKcgTfAmvtJcgbeUGseIMkZeIOueZAkZ+ANv+YhkpyBNxCbh0lyBt6QbB4hyRl4g7N5lCRn4A3T5jGSnIE3YJvHSXIG3tBtniDJGXiDuHmSJGfgDefmKZKcgTewm6dJcgbeEG+eIckZeIO9eZYkZ+AN++Y5kpyBDwAwz5PkDHyggHmBJGfgAwrMiyQ5Ax94YF4iyRn4AAXzMknOwAcymFdIcgY+4MG8SpIz8IER5jWSnIEPoDCvA3N2X6h1YNqO+4/dTxFfzmm+mL8vnOQ+wQu1QIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1EO0GL9SywRi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8PI8kIti22bIr6+LWjzTemXt0Rvi94RvSt6T/S+6APRh6KPRGtFH4s+EX0q+kz0uegL0Zeir0Rfi9aJ1ou+EW0QfSv6TvS9aKPoB9Em0Y+in0Q/izaLfhFtEf0q2ir6TbRN9LvoD9Gfou2itKrCLyoqKiYqLiohKik6QFRKdKDoIFFp0cGiMqJDRGVF5UTlRRVE6VXTdn2ZjdsZiS+4eUuJva3E3lFi7yqx95TY+0rsAyX2oRL7SImtVWIfK7FPlNinSuwzJfa5EvtCiX2pxL5SYl8rsXVKbL0S+0aJbVBi3yqx75TY90psoxL7QYltUmI/KrGflJg7WBNjZZTYIUqsrBIrp8TKK7EKSizdi/k/Rb2/dby/qfRipzctHeDROSNf7PQWSc7IFzu9TZIz8sVO75DkjHyx07skOSNf7PQeSc7IFzu9T5Iz8sVOH5DkjHyx04ckOSNf7PQRSc7IFzutJckZ+WKnj0lyRr7Y6ROSnJEvdvqUJGfki50+I8kZ+WKnz0lyRr7Y6QuSnJEvdvqSJGfki52+IskZ+WKnr0lyRr7YaR1JzsgXO60nyRn5YqdvSHJGvthpA0nOyBc7fUuSM/LFTt+R5Ix8sdP3JDkjX+y0kSRn5IudfiDJGflip00kOSNf7PQjSc7IFzv9ZCln9EVBP1dJvv8K48VOm2Gcu77YCc35C0ndt5Bw/krCuZWE8zcSzm0knL+TcP5BwvknCed2Ek73YlEGziIknEVJOIuRcBYn4SxBwlmShPMAEs5SJJwHknAeRMJZ2hJn8WQ5za7/eHBynLu0VibZnH2tHVIVd15m+okpWgtn16zLIsaM11o5zPj7q7XywFrMSO1aOAVZV8DNX5MObAs4lo2/FkmdE8uP57gvFSiXtvOcqpXaWB7bTjKf1B0zNm62/N8xy1/vilV3/K2UeFOg+y/WJsTc/1GNtGCgJP1WP4YDasKA3secQ17OpiKw/yoBJ62tWhQF1wLZf5WVtnKdvFimyc2KZZv8aGYkLy8nbEwomhXNyg1F4vm5mSaSGZE286KhiPznQtE8k+9Es/LdRaRs2k4z7v+gDXpl4AHWz1ulqkVgt3F0u1WBg8FW3lWr7uxgULsqK+Jg4rKiJmxBu8gaVQMP/IIF3W23pvwtTCd4MHCBLwNc4A8BLiplq9pZVEDzSXWC1b35emiiE6yuOMFDbTpBD7Is0H1UB07GQ31thWKZ+U5OJDcSyo2Gs3Mzwrk5OVFpN8uYSDwWcmIZoXimycrKy8nPiZtwPDczP5qVGc3Jiv21esamk7gPZP8dRuo+DrPkPg6vahH4cAvu44gUdx9u3keQuI9DPVa0+0DW6EhL7uPI/eA+QNey/tUa7BpRg7320ubD/QG1UN1HDW++1kx0HzUU91GzEM5DMQyUZCf2HJLzUG2r4JxgDeCBsSbwJ8McEieI7L+jSJ3gUZac4NFVLQIfbcEJHpPiTtDN+xgSJ1jTY0U7QWSNjrXkBI/dD06wGXCBbw5c4JF31bUkdILHefP1+EQneJziBI8vBCfIMFCSndjzSJxgS6ATPA54YDwe6ATnkThBZP+dQOoET7DkBE+sahH4RAtO8KQUd4Ju3ieROMHjPVa0E0TW6GRLTvDk/eAEGwEX+MbABR75vJSmhE7wFG++nproBE9RnOCpheAEGQZKshN7PokTbAp0gqcAD4ynAp3gfBIniOy/00id4GmWnODpVS0Cn27BCTop7gTdvB0SJ3iqx4p2gsgaGUtO0OwHJ1gPuMDXBy7wyCdhNiR0giFvvoYTnWBIcYLhQnCCDAMl2Ym9kMQJNgQ6wRDwwBgGOsGFJE4Q2X8ZpE4ww5ITzKxqETjTghPMSnEn6OadReIEwx4r2gkia5RtyQlm7wcneDZwga8NXOCR7zioS+gEI958zUl0ghHFCeYUghNkGCjJTuzzSJxgXaATjAAPjDlAJ3geiRNE9t8ZpE7wDEtO8MyqFoHPtOAEz0pxJ+jmfRaJE8zxWNFOEFmjWpacYK394ATPAC7wZwIXeOTb62oROsGzvflaO9EJnq04wdqF4AQZBkqyE3sxiROsBXSCZwMPjLWBTnAxiRNE9l8dUidYx5ITrFvVInBdC06wXoo7QTfveiROsLbHinaCyBrVt+QE6+8HJ5gFXOCzgQs88r3kOYROsIE3XxsmOsEGihNsWAhOkGGgJDuxl5I4wRygE2wAPDA2BDrBpSROENl/jUidYCNLTrBxVYvAjS04wSYp7gTdvJuQOMGGHivaCSJr1NSSE2xamE7QW5TDwEU5A+jeMqvgTEw7QifYzJuvzROdYDPFCTa36QSJBkqyE3t5qjtBZUAn6wSbAQ+MzYFOcDmJE0T2XwtSJ9jCkhNsWdUicEsLTrBVijtBN+9WJE6wuceKdoLIGrW25ARbe07Q/V4lbddF3n/qx78h6L9MzH/zgP+WUv+DRtzvNX3fvy2x8/u1xff9+6G+Niv5vn/na/973/eNvu8/+L5v8n3/0ff9J9/3n73vbeS/01bUTtRe1EHUUdRJ1Lnq3500el51Bo6DArPQRdrsKuom6u65QP8Ycf99qbRdY12VWDcl1t2L+T/o01WdgfOsC6CtHe9PdkxXINdKSyalWEItksnZrUU3SP/tqGt3oMlD9p/tOd7JwhzvIW32FPUS9VbmeA9l7vZUYr2UWO9CmOOdgHOpB3CO9wRyXUgyx3sB53hv4By/kGiOd7Qwx/tIm1FRrihPmeN9lLkbVWK5SiyvEOZ4R+Bc6gOc41Eg18UkczwXOMfzgHP8YqI53sHCHI9Jm/miuKivMsdjytzNV2JxJda3EOZ4B+BcigHneD6QaxXJHI8D53hf4BxfRTTH21uY4/2kzf6iAaKByhzvp8zd/kpsgBIbWAhzvD1wLvUDzvH+QK7LSOb4AOAcHwic45cRzfF2Fub4IGlzsGiIaKgyxwcpc3ewEhuixIYWwhxvB5xLg4BzfDCQ6wqSOT4EOMeHAuf4FURzvK2FOT5M2hwuGiEaqczxYcrcHa7ERiixkYUwx9sC59Iw4BwfDuS6imSOjwDO8ZHAOX4V0RxvY2GOj5I2R4vGiMYqc3yUMndHK7ExSmxsIczxNsC5NAo4x0cDua4hmeNjgHN8LHCOX0M0x4vg2nJqeO2Mk74cL5ogmiiaJJosmiKaKpommi6aIZopmiU6RzRbNEc0VzRPdK5ovmiBaKFokeg80fmixaIloqWiZaLlohWilcoxZZxyrBivxCYosYlKbJISm6zEpiixqUpsmhKbrsRmKLGZSmyWEjtHic1WYnOU2FwlNk+JnavE5iuxBUpsoRJbpMTOU2LnK7HFSmyJEluqxJYpseVKbIUSW1kIa5B/ziZ7rB8HXIPGA9eg6wrpgt9k16AJwDVoYvJt/e/i4UnAWlyfyrXI+B+nmZxczo4vZzMlmbZCu/SfmQqsxerUrIWTwGmm7WPOWfG/5Wym71tbEaX/zAxgLW5ItVpEVE4zc+9zzv6HnM2svW0r+x/7z5wDrMWNqVOL0L9wmtl7k3P2v+Zs5ux5W3m76T8zF1iLm1KhFtm75TTz9ixnZw9yNufuSVvOHvWfmQ+sxc37txaZe8hpFuwu54w9ztks/Ne2MuJ70X9mEbAWt+yvWmTvFac5759zjuxlzub8f2grJ77X/WcWA2txa+HXwtkHTrNEy9nZp5zN0r+3Zfax/8wyYC1uK8xaxPaZ0yzfNedwEjmbFb62QvGk+s+sBNbidpJHrgDPDxjg71vj/32WbC3uIKkF8HeQAfp4cxOwFneS1ALo9wzQr5hbgbW4i6QWwHXNAI/L5g5gLdYU0l6hk9zHAOevAY4/g+y/gr3BGt5f/35E4n6Ffz/Dv9/h3w/x75f491P8+y3+/Rj/fo1/P8e/3+PfD/LvF/n3k/z7Tf79KP9+lX8/y7/f5d8P8++X+ffT/Ptt/v04/36dfz/Pv9/n3w/07xf69xP9+419fd/99xD47zHw34OQ5/vuv6/If9+R/76k3r7v/nsN/fci+u9V7O777r//2H9/sv/+5bG+7/5rLvzXZPiv2Rjp++6/Dst/nZb/Oq6hvu/+azP91276r+0c6Pvuv17bfz13wfXeBQeUC+SfLxRdJLpYdIlolehS0WWiy0VXiK4UXSW6WnSN6FrRdaLrRatFN4huFN0kull0i+hW0W2i20V3iO4U3SVaI7pbdI/oXtF9ovtFD4geFD0kelj0iOhR0WOix0VPiJ4UPSV6WvRMVfv3yJ+Rjr8G4Fnhfk70vOgF0Yuil0Qvi14RvSp6TfS66A3Rm6K3RG+L3hG9K3pP9L7oA9GHoo9Ea0Ufiz4RfSr6TPS56AvRl6KvRF9X3dFJ/n3ZZ6v+fa/2OSX2vBJ7QYm9qMReUmIvK7FXlNirSuw1Jfa6EntDib2pxN5SYm8rsXeU2LtK7D0l9r4S+0CJfajEPlJia5XYx0rsEyX2qRL7TIl9rsS+UGJfKrGvlNjXVe1fA+Cfs8l6OHduJNtWwTUAz1XFcT1Fcg3A85D+21HXF5Jv63/XALwIrMXTJNcAvJRczrtcA/ByMm0lXAPwCrAWz5BcA/DqPuasXQPw2r61pV4D8DqwFs+SXAPwxt7n/I/XALy5t239yzUAbwFr8RzJNQBv703Ou7kG4J09b2u31wC8C6zF8yTXALy3Zznv0TUA7+9JW3t4DcAHwFq8QHINwIe7y3kvrgH4qCruGoC1wFq8SHINwMdVcdcAfFIVdw3Ap8BavERyDcBnVXHXAHxeFXcNwBfAWrxMcg3Al1Vx1wB8VRV3DcDXwFq8QrK/Bjw/YIC/b80zwP21V0lqAfwdZIA+3jwPrMVrJLUA+j0D9CvmJWAtXiepBXBdM8DjsnkVWIs3SK4BAM5fAxx/Btl/tvcKj8e19b+9wnXiXdaLvhFtEH0r+k70vWij6AfRJtGPop9EP4s2i34RbRH9Ktoq+k20TfS76A/Rn6Lt7l5gNekHUVFRMVFxUQlRSdEB1dL+tle4TtnTWa/EvlFiG5TYt0rsOyX2vRLbqMR+UGKblNiPSuwnJfazEtusxH5RYluU2K9KbKsS+02JbVNivyuxP5TYn0psuxJzx0NirIgSK6rEiimx4kqshBIrqcQOqGZ/r9A/Z5M91q8D7hWuB/5m+Zxkr/Ab4F7hBuBe4bfAWnxBslf4HXCv8HvgXuFGYC2+JNkr/AG4V7gJuFf4I7AWX5HsFf4E3Cv8GbhXuBlYi69J9gp/Ae4VbgHuFf4KrMU6kr3CrcC9wt+Ae4XbgLVYT7JX+Dtwr/AP4F7hn8BafEOyV7gduFfo/jbT2tqXvcIi1XC12ECyV1i0Gm6vsFg13F5hcWAtviXZKyxRDbdXWLIabq/wAGAtviM5Dw88P2CAv2/Nl8Dz8N+T1AL4O8gAfbxZB6zFRpJaAP2eAfoVswFYix9IagFc1wzwuGy+B9ZiE8leIXD+GuD4M5ss7hUWBfdh7T2/r9Ds5t87dSzco1hKfNCBooNEpUUHi8qIDhGVFZUTlRdVEKWLKooqiSqLqoiqiqqJqosOFR0mOlx0hOhIUQ1RTdFRoqNFx4iOFR0nOl7Zdyyl7A8dqMQOUmKlldjBSqyMEjtEiZVVYuWUWHklVkGJpSuxikqskhKrrMSqKLGqSqyaEquuxA5VYocpscOV2BFK7EglVkOJ1VRiRymxo5XYMUrsWCV2nBI7vhD2HW3N/2TXoFLA3z9FTkr9fUd3r/XAapi23FodBGlrR91LA2tRNLVr8b+91oOTzdm3h1kmubZ22cM8BFiLYqlai4S91rL7nvPf9jDL7WNb2h5meWAtiqdeLdS91gr7kvM/7GGm731b/7iHWRFYixKpVIt/2WuttHc5/+seZuW9aWs3e5hVgLUomRq12O1ea9U9zXkP9jCr7Vlbe7SHWR1YiwP2dy32cK/10N3nvMd7mIftrq292MM8HFiLUvutFnu313pENdwe5pHVcHuYNYC1OHA/1GJf9lprVsPtYR4F3MM8GliLgwq3Fvu813pMNdwe5rHAPczjgLUoXUi1SHav9fhquPMpwHMNxv9bOdlaHFxItXCS+xjgb1ID/E1lSgBrUYakFkDvbYDe0ZQC1uIQkloAPYYBrpGmNLAWZUlqATyWGuCxwADHskHWwvYeZl3gHkY9C3uYJ4i/OFF0kuhk0SmiU0WniU4XOSIjConCogxRpihLlC2KiHJEZ4jOFJ0lqiU6W1Tb9S6iuqJ6ovqiBqKGokaixsoe5gnKXtOJSuwkJXayEjtFiZ2qxE5TYqcrMUeJGSUWUmJhJZahxDKVWJYSy1ZiESWWo8TOUGJnKrGzlFgtJXa2EqutxOoosbpKrJ4Sq6/EGiixhkqskRJrXM3+Hqat+Z/senYC8LfUkSR7mCcC9zBPAu5hngysRQ2SPcxTgHuYpwL3ME8D1qImyR7m6cA9TAe4h2mAtTiKZA8zBNzDDAP3MDOAtTiaZA8zE7iHmQXcw8wG1uIYkj3MCHAPMwe4h3kGsBbHkuxhngncwzwLuIdZC1iL40j2MM8G7mHWBu5h1gHW4niSPcy6wD3MesA9zPrAWpxAsofZALiH2RC4h9kIWIsTSfYwGwP3MIHnGkwN4P7ASST7A8DfpAb4m8ocDazFySS1AHpvA/SO5jhgLU4hqQXQYxjgGmlOBNbiVJJaAI+lBngsMMCxbE61uIdZBFyPTAv7jk3EEzQVNRM1F7UQtRS1ErUWtRG1FbUTtRd1EHUUdRJ1FnURdRV1E3UX9RD1FPUS9Rb1EUVFuaI8UUyUL4qL+ir7jk2U/aGmSqyZEmuuxFoosZZKrJUSa63E2iixtkqsnRJrr8Q6KLGOSqyTEuusxLoosa5KrJsS667EeiixnkqslxLrrcT6KLGoEstVYnlKLKbE8pVYXIn1rWZ/3zETuFfYBLRv5u7BNQX+/qlFsO/o1qIZcK+wefJt/W8PrgWwFmenci18e4UtgXuFrZJpK2EPrjWwFrVTsxZ/2ytsA9wrbLtvbal7cO2AtaiTarX4h73C9sC9wg5729a/7MF1BNaiburU4l/3CjsB9wo773lbu92D6wKsRb1UqMUe7BV2Be4VdtuTtvZwD647sBb1928t9nivsAdwr7BnNdweXC9gLRrsr1rs5V5hb+BeYZ9quD24KLAWDQu/Fvu0V5gL3CvMq4bbg4sBa9GoMGuRxF5hPnCvMF4NtwfXF1iLxiTnkYHnBwzw962pDTyn34SkFsDfQQbo4009YC2aktQC6PcM0K+YhsBaNCOpBXBdM8DjsmkCrEVzS7VAP7MVOH8NcPyZ5kR7hTkW9gr7iXfpLxogGigaJBosGiIaKhomGi4aIRopGiUaLRojGisaJxovmiCaKJokmiyaIpoqmiaaLpohmimaJTpHNFs0R9kr7Kfs6fRXYgOU2EAlNkiJDVZiQ5TYUCU2TIkNV2IjlNhIJTZKiY1WYmOU2FglNk6JjVdiE5TYRCU2SYlNVmJTlNhUJTZNiU1XYjOU2EwlNkuJnaPEZiuxOdXs7xXmAPcK+wH3CvsDf7N0J9krHADcKxwI3CscBKxFD5K9wsHAvcIhwL3CocBa9CTZKxwG3CscDtwrHAGsRS+SvcKRwL3CUcC9wtHAWvQm2SscA9wrHAvcKxwHrEUfkr3C8cC9wgnAvcKJwFpESfYKJwH3CicD9wqnAGuRS7JXOBW4VzgNuFc4HViLPJK9whnAvcKZwL3CWcBaxEj2Cs8B7hXOBu4VzgHWIp/kPDzw/IAB/r41PYHn4eMktQD+DjJAH2/6AGvRl6QWQL9ngH7F5AFr0Y+kFsB1zQCPyyYOrEV/kr1C4Pw1wPFnkP3n7j+U9vWd+8+XyF7Bn973Vb7vl6bv+FvU97/9vOLOf/+F932ueIt5onNFJeSfy/n+f/wf9L7kudXsjKs0LGfI3xfzq+34u8Dbg/zfppD7L/5IAEAP8HNhGznx+HygoVxgqZBFwf2HzHmhry0jJwTlRJ77v4vEHJMRk1NxoVAsN8PJc6J5ofycDPktnBHKCOfF8uTkRCRq4k48mpcTj+zgcidd2bSdE8z/QU+6hdWwB6OCz6JqFoHdxtHtngccDLbyPq/azg4GtauyIg4A51XDt3s+eLAWHKzddm1fdYM8KNpmnQtkreG1s1jaXCJaKlomWi5aIVopukB0oegi0cWiS0SrRJeKLhNdLrpCdKXoKtHVomtE14quE10vWi26QXSj6CbRzaJbRLeKbvNWZ3/NFytXcixRYkuV2DIltlyJrVBiK5XYBUrsQiV2kRK7WIldosRWKbFLldhlSuxyJXaFErtSiV2lxK5WYtcosWuV2HVK7HoltlqJ3aDEblRiNymxm5XYLUrsViV2WzX7VwjNBa5fi4FXCC0Bco0nuUJoKfAKoWXAK4SWA2sxgeQKoRXAK4RWAq8QugBYi4kkVwhdCLxC6CLgFUIXA2sxieQKoUuAVwitAl4hdCmwFpNJrhC6DHiF0OXAK4SuANZiCskVQlcCrxC6CniF0NXAWkwluULoGuAVQtcCrxC6DliLaSRXCF0PvEJoNfAKoRuAtZhOcoXQjcArhG4CXiF0M7AWM0iuELoFeIXQrcArhG4D1mImye478PyAAf6+NROBu++zSGoB/B1kgD7eTAHW4hySWgD9ngH6FTMdWIvZJLUArmsGeFw2s4C1mENyhRBw/hrg+DPI/nPH79OiGl57t3l7Yrd4e2Q3eXtmN3h7aNd7e2rXentsV3t7bld6e3CXe3tyl3p7dJd4e3YXeXt4F3h7eiu8Pb5l3p6fuw/g7iskfhIv6kh27M0D+p7bq8Eu6nAK86IOP7eT5MfPe0c1i8Bu4+h27wQOBlt53+mbFKB2/xpsroqm2R9s86rZOdgn9kmyE9A/kO/yjTX4VSp34jrE+HeR/dB7yZy3u0vOXGa3/b29xG53nX4XcAKuAR/VCvrVbXfaPo4F417nbpy4kxOSMznZeVnZuTmxUG4kGg/HM8Ox8L726+4GO7Jf77bUr3fve7/+vxiv91jq13v+4+P1Xkv9eq/XrwULZ2E4NeTi6V/s7/NMxf3ummFjgbvLglu7C+wkbOW9t5PD2Yu8k2V8wHIfOsl9jDswH6iGr82Dlg4KD/7LwdZJ7mPut9QXD1nqi4cs9sU8S32x8qTUPqbYmg8X7N+8d3tpia2xfyHJqUfguDTAWhtk/7lGqmSafhYibS/7c3fjyd+mjTUL1Sd+U/nwv52FcJL7mAcsLQIP/8tZiN00Y3b333GZH7ZwUFiVIntDe2Peks35kWqpeYBB1sI/Lh/xmZN9rc/u+hxZn0f9ewvhsMyNWLaJx+LhzOycUK7JCmdlxTPi2VmRjFg8MyMay843GdFwKCc/24mbSH5+dmY4LzsrnhPLy4r7D9omFg5nxHJy80xmKCua60Ri4agTz8gOyw/+WDg7FgtHsrKi4XAsKxKP5MiPdPnpH3Eys7NznKxQOCdkqz6P+n5doxaF3Z3N8bfJsig8xrgoPGZ5UXjMwqJwWYosCv84iLN33JmPPOg8nqKLwmWWDjqPAxaF3Z3aRNbniRRdFGzV54n/R6dcn/ROuT6lnXJ1kvv8434Hcq8y2baAp2+NjcIX9GExkj5Mtq2nU7we7oR52sLC/owlk/OMxdOfT1nqi2ct9cWzlk8F2+iLK1L8VLCt+XBlip8KtjX2ryI5FQwclwZYa3NVcCo48fPXmoXqE7/Zfc7mr/6nLS0Cz1n81e8yP2fhoHAdyangp4FG8PlqqXmAuc7Sr8rnC+FUMLI+LwB/9V8F/NVvqz4vKPXZ22tqdnfqF1mfFy0dP18E9MPuzk4h++ElS/3wEtl4eNlSP7xMNh5esdQPr+zBVlEqGzsFFzaO/abxVUbT+Kpl0/iqBdO4OjWeI5RXmAe514BtIU3jakum5LU9MI3JXl2PrM/r1XBGD2kabdXndcDiuJsP9JkZb8COnxErF2Lf6Z11Q+8oIcf4mym+g+HW+E0L681bltZet91S3j8/nfb3D+q/WdAeur+vLZ76jG+jjSTLoL0xxbdX3JzftpD3TSQPHnkbeGB+B3hgBo4bg6yF5YPk/7Yp/osHyXf+qwfJd1P89jw353ct5P2eJUfzXrWdT9a3cbun5pCd5D4G6ZDfT/Hx5P6iet/CePqAYB59YCHvDy3Now//ZR45yX2sHVNuPem/OQZuK6TrWpLl/AhoEoG1NrdZOkP1UfDr2jrjWtvGEfErc62FSX8nya/MtQSTPumLtEkOwB8DawEcf+au4Fc6xcH2Y+TBlnVVvJ2gUJ8EhZIjFEGhPg0K5Zg1BIX6LCiUY+4hKNTnQaEccx9Bob4ICuWYBwgK9WVQKMc8RFCor4JCOeYRgkJ9HRTKMY8RFGpdUCjHPEFQqPVBoRzzFEGhvgkK5ZhnCAq1ISiUY54jKNS3QaEc8wJBob4LCuWYvsVSn/H7oFCOeZlgRm0MCuWYVwkK9UNQKMe8TlCoTUGhHPMmQaF+DArlmLcJCvVTUCjHvEtQqJ+DQjnmfYJCbQ4K5ZgPCQr1S1Aox6wlKNSWoFCO+YSgUL8GhXLMZwSF2hoUyjFfEBTqt6BQjvmKoFDbgkI5Zh1BoX4PCiXb3ASF+iMolOyeEhTqT2Sh3GdoHpC2894yF7ZmQtGKghMAPuTCoG/0t1GwTwgYPyVg/IyA8XMCxi8IGL8kYPyKgPFrAsZ1BIzrCRi/IWDcQMD4LQHjdwSM3xMwbiRg/IGAcRMB448EjD8RMP5MwLiZgPEXAsYtBIy/EjBuJWD8jYBxGwHj7wSMfxAw/mmBMQ3KGM5OUz6YtkPGXts730xexNfmdunvtOoSExUVFRMVF5UQlRQdIColOlB0kKi06GBRGdEhorKicqLyogqidFFFUSVRZVEVUVVRNVF10aGiw0SHi44QHSmqIaopOkp0tOgY0bGi40THi04QnSg6SXSy6BTRqaLTRKeLHJERhURhUYYoU5QlyhZFRDmiM0Rnis4S1RKdXX1HH9Su7nVKwVMbt3tPbfTH3E5KjBVRYkWVWDElVlyJlVBiJZXYAUqslBI7UIkdpMRKK7GDlVgZJXaIEiurxMopsfJKrIISS1diFZVYJSVWWYlVUWJVlVg1JVZdiR2qxA5TYocrsSOUWA0lVlOJHaXEjlZixyixY5XYcUrseCV2ghI7UYmdpMROVmKnKLFTldhpSux0JeYoMaPEQkosrMQylFimEstSYtlKLKLEcpTYGUrsTCV2lhKrpcTOVmLuwa9O2q4f9EMn3wU+3Ry4+We2WzIbRcH9B9xMNGnVOXIGbk6aIiQ5Azc7TVGSnIGbp6YYSc7AzVhTnCRn4OauKUGSM3Cz2JQkyRm4+WwOIMkZuJltSpHkDNwcNweS5AzcbDcHkeQM3Lw3pUlyBl4MYA4myRl4cYEpQ5Iz8GIFcwhJzsCLH0xZkpyBF1OYciQ5Ay/OMOVJcgZe7GEqkOQMvHjEpJPkDLwYxVQkyRl4cYupRJIz8GIZU5kkZ+DFN6YKSc7Ai3lMVZKcgRcHmWokOQMvNjLVSXIGXrxkDiXJGXgxlDmMJGfgxVXmcJKcgRdrmSMs5VwkIWcnuY85snry/Zcfdz95UfdG3FK+uhTxcdrit7HnjWYMbp7FMAY3z2IYg5tnMYzBzbMYxuDmWQxjcPMshjG4eRbDGNw8i2EMbp7FMAY3z2IYg5tnMYzBzbMYxuDmWQxjcPMshjG4eRbDyHjzLKbdiLU+rVk99et+FAHj0QSMxxAwHkvAeBwB4/EEjCcQMJ5IwHgSAePJBIynEDCeSsB4GgHj6QSMDgGjIWAMETCGCRgzCBgzCRizCBizCRgjBIw5BIxnEDCeScB4FgFjLQLGsy1dK5kG5QyFtOsa6wh7XVE9UX1RA1FDUSNRY1ETUVNRM1FzUQtRS1ErUWtRG1FbUTtRe1EHUUdRJ1FnURdRV1E3UXdRD1FPUS9Rb1EfUVSUK8oTxUT5orior6ifqL9ogGigaJBosGiIaKhomGi4aIRopGiUaLRojGisaJxovGiCaKJokmiyaIpoavUdfTCtetquD2GqozyYqa4Sq6fE6iuxBkqsoRJrpMQaK7EmSqypEmumxJorsRZKrKUSa6XEWiuxNkqsrRJrp8TaK7EOSqyjEuukxDorsS5KrKsS66bEuiuxHkqspxLrpcR6K7FcJZanxGJKLF+JxZVYXyXWT4n1V2IDlNhAJTZIiQ1WYkOU2FAlNkyJDVdiI5TYSCU2SomNVmJjlNhYJTZOiY1XYhOU2EQlNkmJTVZiU5TYVCU2zbdQFXwKFoWCeLI3IQAvaDd1qttZWNE5Ix8IV5ckZ+QD4eqR5Ix8IFx9kpyRD4RrQJIz8oFwDUlyRj4QrhFJzsgHwjUmyRn5QLgmJDkjHwjXlCRn5APhmpHkjHwgXHOSnJEPhGtBkjPygXAtSXJGPhCuFUnOyAfCtSbJGflAuDYkOSMfCNeWJGfkA+HakeSMfCBce5KckQ+E60CSM/KBcB1JckY+EK4TSc7IB8J1JskZ+UC4LiQ5Ix8I15UkZ+QD4bqR5Ix8IFx3kpyRD4TrQZIz8oFwPUlyRj4QrhdJzsgHwvW2lHORhJyd5D6mT/Xk+6/ggXA2OaMwzoixOYaAN1yaXJJ5A7yB0+SR5Ay8IdTESHIG3mBq8klyBt6wauIkOQNvgDV9SXIG3lBr+pHkDLxB1/QnyRl4w68ZQJIz8AZiM5AkZ+ANyWYQSc7AG5zNYJKcgTdMmyEkOQNvwDZDSXIG3tBthpHkDLxB3AwnyRl4w7kZQZIz8AZ2M5IkZ+AN8WYUSc7AG+zNaJKcgTfsmzEkOQMfAGDGkuQMfKCAGUeSM/ABBWY8Sc7ABx6YCSQ5Ax+gYCaS5Ax8IIOZRJIz8AEPZjJJzsAHRpgpJDkDH0BhpgJzdl+odWDajvuP3U8RX85pvpi/L5zkPsELtUCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtTCMwQu1MIzBC7UwjMELtRDtBi/UssEYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDGLxQC8MYvFALwxi8UAvDyPJCLYttmyK+vi1oc7r0ywzRTNEs0Tmi2aI5ormieaJzRfNFC0QLRYtE54nOFy0WLREtFS0TLRetEK0UXSC6UHSR6GLRJaJVoktFl4kuF10hulJ0lehq0TWia0XXia4XrRbdILpRdJPoZtEtoltFt4luF90hulN0l2iN6G7RPaJ7RfeJ7hc9IHpQ9JDoYdEjokerp+36Mhu3MxJfcDNDic1UYrOU2DlKbLYSm6PE5iqxeUrsXCU2X4ktUGILldgiJXaeEjtfiS1WYkuU2FIltkyJLVdiK5TYSiV2gRK7UIldpMQuVmKXKLFVSuxSJXaZErtcid2nxO5XYg8osQeV2ENK7GEl9ogSe9SL+T9Fvb91vL+p9GKn6ZYO8OickS92mkGSM/LFTjNJcka+2GkWSc7IFzudQ5Iz8sVOs0lyRr7YaQ5JzsgXO80lyRn5Yqd5JDkjX+x0LknOyBc7zSfJGflipwUkOSNf7LSQJGfki50WkeSMfLHTeSQ5I1/sdD5JzsgXOy0myRn5YqclJDkjX+y0lCRn5IudlpHkjHyx03KSnJEvdlpBkjPyxU4rSXJGvtjpApKckS92upAkZ+SLnS4iyRn5YqeLSXJGvtjpEpKckS92WkWSM/LFTpeS5Ix8sdNlJDkjX+x0uaWc0RcFXVE9+f4rjBc7XQnj3PXFTmjOq0jqfjUJ5zUknNeScF5Hwnk9CedqEs4bSDhvJOG8iYTzZhLOW0g4byXhvI2E83YSzjtIOO8k4byLhHMNCefdJJz3kHDea4mzeLKcZtd/vC85zl1auz/ZnH2tPQD4vV5wXuaek1K0Fs6uWT+IGDNeaw9hxt9frT0MrMW9qV0LpyDrR3Dz1zwKbAs4lo2/FkmdE8uP57gvFSiXtvOcqpXaWB7bTjKf1B0zNm62/N8xy1/vx6rv+Pt44k2B7r9YmxBz/0c10oKBkuwB9QGGA2rCgN7HnENezuYxYP89Dpy0tmpRFFwLZP89obSV6+TFMk1uVizb5P8fe+cBJ0WVve0mZ0FRRGIzqGTtmtgjICACKqICKiDJiSTJAiIgSQREREUlRxUl55wzSM7BnDAnsiDy3VpqlqL/d9fQ5870s1/X7/duX8/MHp5zQ913uqqrE2L8SUnxUZYVmRCbEJsY6U9NSYyx/DF+lTMpIdKv/rnIhCQrxZcQm2JvIvk9V824+5A26BsFT7Bu3k1FDALbyaXzbhacDKbq3lzkagcL5dWySpxMbFapBZuWV3KMtghP/LQN3c5bSr2mpxNcLrjBrxDc4FcKbiqripjZVITWk9YJbnXW67ZAJ7hV4wS3mXSCDuQqQfexVXAxbnPlikyOSfHF+xP9kYkJUXGJ0VGJ8fEJKm+sZflTkyN9ydGRqTFWbGxSfEp8qhWVmhiTkhAbkxAfm/yv3TN5KcR9SPbfdqj72G7IfbxfxCDw+wbcx44Qdx923Tsg7mObwyrtPiTHaKch97EzA9yH0L2s/8omdo+oJXvvpcmH+wuMhdZ97HLW6+5A97FL4z52p8P7UISJEuzCXg15H+qPW+Sc4C7BE+NuwT8ZVkOcoGT/7YE6wT2GnODeIgaB9xpwgvtC3Anade+DOMHdDqu0E5Qco/2GnOD+DHCC5wQ3+POCG7zkp+ouAJ3gAWe9Hgx0ggc0TvBgOjhBwkQJdmGvhTjBC4JO8IDgifGgoBNcC3GCkv13COoEDxlygoeLGAQ+bMAJHglxJ2jXfQTiBA86rNJOUHKMjhpygkczwAmeEtzgTwtu8JLPSzkLdILHnPV6PNAJHtM4wePp4AQJEyXYhb0e4gTPCjrBY4InxuOCTnA9xAlK9t8HUCf4gSEn+GERg8AfGnCCH4W4E7Tr/gjiBI87rNJOUHKMPjbkBD/OACf4s+AG/4vgBi/5JMyTQCf4ibNePw10gp9onOCn6eAECRMl6LvEIU7wpKAT/ETwxPipoBPcCHGCkv33GdQJfmbICX5exCDw5wac4Bch7gTtur+AOMFPHVZpJyg5Rl8acoJfZoAT/F5wg/9BcIOX/I6Dn4BO8CtnvZ4IdIJfaZzgiXRwgoSJEuzC3gxxgj8JOsGvBE+MJwSd4GaIE5Tsv6+hTvBrQ07wmyIGgb8x4AS/DXEnaNf9LcQJnnBYpZ2g5Bh9Z8gJfpcBTvBrwQ3+G8ENXvLb674DOsHvnfX6Q6AT/F7jBH9IBydImCjBLuytECf4naAT/F7wxPiDoBPcCnGCkv33I9QJ/mjICf5UxCDwTwac4M8h7gTtun+GOMEfHFZpJyg5Rr8YcoK/ZIAT/EJwg/9ScIOX/F7yE0An+KuzXk8GOsFfNU7wZDo4QcJECfopHhAneELQCf4qeGI8KegEt0OcoGT/nYI6wVOGnODpIgaBTxtwgmdC3AnadZ+BOMGTDqu0E5Qco7OGnODZ9HSCzqb8qeCm/Jmge/v8FjkTcxnoBM856/V8oBM8p3GC5006QdBECXZh7wh1J6iZ0ME6wXOCJ8bzgk5wB8QJSvbfb1An+JshJ3ihiEHgCwac4MUQd4J23RchTvC8wyrtBCXH6HdDTvB3xwna7Zs9127y7rd+3BcE3beJuT884P5IqftBI3Z7tztPtqvtaVn/eXubK+cGV/tHV/6fXO2fXe1fXO1fXe2TrvYpV/u0076k/p0/lC7bc7uo+plSZqUsSlmL/l8nLb2u7H9DKJcvzSxkUzmzK+VQyln0CrR7jtg/z+m5NpZdE8uhieV0Yu5D+u0qd58Eu86yCeS68v3JPiu7INcuQyYlS8BYBFOzPRY5RPrvyrjmlJvrlmT/mV7jWQys8VwqZ26lPEp5NWs8l2bt5tbE8mhiedNhjWcRXEu5BNd4bkGuPZA1nkdwjecVXON7QGs8s4E1nk/lvE4pv1IBzRrPp1m712li+TWxAumwxjMLrqV8gmv8OkGufZA1nl9wjRcQXOP7QGs8k4E1fr3KeYNSQaUbNWv8es3avUETK6iJ3ZgOazyT4Fq6XnCN3yDIdQCyxgsKrvEbBdf4AdAa9xhY4zepnIWUblYqrFnjN2nWbiFN7GZNrHA6rHGP4Fq6SXCNFxLkOgRZ4zcLrvHCgmv8EGiNXy4iv8ZvUX1ZRKmoUjHNGr9Fs3aLaGJFNbFi6bDGLwu+t32L4BovIrjGj0DWeFHBNV5McI0fAa3xPwys8eKqL0solVTyatZ4cc3aLaGJldTEvOmwxv8QXOPFBdd4CcE1fgyyxksKrnGv4Bo/Blrjlwys8VKqLyOUSivdqlnjpTRrN0ITK62J3ZoOa/yS4BovJbjGIwTX+AeQNV5acI3fKrjGJfsvbU1/6rza//114atz/4Sr/ZWr/aWr/YWr/bmr/Zmr/amr/Ymr/bGr/ZGr/aGr/YGrfdzVPuZqH3W1j7jah13tQ672QVf7gKu939Xe52rvdbX3uNq7Xe1drvZOV3uHq/2+q73d1d5W+Oq5pbrQ2IbzhfOF84XzhfOF84XzhfOx8iVGyeZLTpbNFxUpm88fm+YFc9xy1Rdmd7WzudpZXe0srnZmVzuTq+1xtS+7fOcfrvYlV/t3V/uiq33B1f7N1T7vap9ztc+62mdc7dOu9ilX+6Sr/aur/Yur/bOr/ZOr/aOr/YOr/b2r/Z2r/a2r/Y2rXcbVV7e72re52re62qVd7QhXu5Sr7XW1S7raJVzt4q52MVe7qKtdxNW+xdUu7Grf7GoXcrVvcrVvdLULuto3uNrXu9oFXO38rvZ1rnY+Vzuvq53H1c7taudytXO62nVc7dqudi1X+15Xu6arfY+rXcPVru5qV3O173a1q7raVVztyq72Xa52vKvtd7XjXO1YVzvG1Y52taNc7UhX23K1fa72na72Ha52JVe7oqtdwdUu72qXc7XLutqtXO1UVzvF1U52tZNc7URXO8HVftLVbulqt3C1m7vazVztpq72E652E1e7savdyNV+3NV+zNV+1NVu6Go3cLXru9qPuNoPu9oPudr1XO0HXe26rvYDrvb9rvZ9rvZgV/sFV3uQq/28qz3Q1R7gavd3tfu52n1d7edc7T6udm9Xu5er/ayr3dPVfsbV7uFqd3e1u7naT7vaXV3tLq52Z1e7k6vd0dXu4Gq3d7WfcrXbudptXe02rnZr97nR9d6v+74s931b7vu6Crja7ns13fdyuu/1zOtqu+/fdt/f7b7/O6er7f5Mh/szH+7PhNzqarvfx3a/z+1+H9zraruvbbmvfbmvjRVztd3Xu93Xw93Xywu72u57YNz3yKTdQ/OL58pxm/rv25XKKJVVKqdUXqmCUkWlSkp3KN2p5FOylCKVopSilWKUYpXilPxK8Up3KVVWqqJUVelupWr2+7JKNZTuUaqpdK9SLaXaSnWU7lO6X+kBpbpKDyrVU3pI6WGlR5TqKzVQaqj0qNJjSo8rNVJqrNRE6QmlpkrNlJortVBqqfSkUoJSolKSUrJSilKqUiul1kptlNoqtVN6Sqm9UgeljkqdlDordVHqqvS0Ujel7ko9lJ5R6qn0rFIvpd5KfZSeU+qr1E+pv9IApYFKzysNUnpBabDSEKWhSi8qDVN6SWm40stKI5ReUXpV6TWlkUqvK72h9KbSKKXRSmOUxiqNUxqvNEFpotIkpclKU5SmKr2l9LbSO0rTlN5Vek9putIMpZlKs5RmK81Rmqs0T2m+0gKlhUqLlBYrLVFaqrRMabnSCqWVSquUViutUVqrtE5pvdIGpY1Km5Q2K21R2qq0TWm70vtKO5R2Ku1S2q20R2mv0j6l/UoHlA4qHVI6rHRE6ajSMaXjSh8ofaj0kdLHSp8ofar0mdLnSl8ofan0ldIJpa+VvlH6Vuk7pe+VflD6UeknpZ+VflH6Vemk0iml00pnlM4qnVM6r/Sb0gWli0q/K11S+kPpclF7Qas1qJRZKYtSVqVsStmVcijlVMqllFspj1JepXxK1ynlVyqgdL3SDUoFlW4sduVJFpmdtZ12ZHZeqzuvQT+No6CqqaDcdRU73003XmWWyivIeM012ZuKXXktVMzp6H/fkKgC/QJihZyYxyNf4H/quGAH+CPKN7oXFLzBsthfzpX0J7msQsXkuD5Op4u2vuAOa3lZuVyC88+S7D/75Jrdo39MkOdv9uefzSF3Tunzhnuu+4I83BvNzYEnRDuQKaCDpO4W0C3cP2G1/qyYmwUXbuFiYpPhmicVFHZtKKb6VPIEJtmnt/yNPv2zf8vdp7c4fWr6zqsvb5RbeF4nTxHFXlSpmFJxpRJKJZW8SqWUIpRKK92qdJvS7UpllMoqlVMqr1RBqaJSJaU7lO5U8ilZSpFKUUrRSjFKsUpxSn6leGfBu/vS5kn76/Lfd2drYsU0seKaWAlNrKQm5tXESmliEZpYaU3sVk3sNk3sdk2sjCZWVhMrp4mV18QqaGIVNbFKmtgdmtidmphPE7M0sUhNLEoTi9bEYjSxWE0sThPza2LxTsx9SJtM95oN9vxVROBcmHZnYFHB8+pn6WT4g70zsJhI/10Z1+LB5/r3I91KCI7F56E8FtFXDWrJ4Gr2uc2uN5hckdca51KCY/FFaI6FL/CPhYh/WHNs6v/9w6P0P8vl1/0Rc6vgWHwZamPh1//hdtvfrznuP/0RePvfzRX3n/+gLCM4Fl+FzlhE/rc/osv+nZrj/vsf5OUE3yAqLzgWJ0JhLOL+lNOq8Ndq9v2Fmq2KfyWX7y/1n1VJcCy+ztixiPmLnNYdf1Zz9F+u2brzv+aKTv0b/Wf5BMfim4wai7i/xWlZ/7lm/9+s2Yr8D7niU/92/1lRgmPxbfqPhe8fcFrRupp9/6hmK+b/5rL+Yf9ZsYJj8V16jkXyP+a04q6tOSqImi2/K1dkalD9Z8ULjsX3kAttgu8PWIJ/31ruv8+C/kY0yFgI/h1kCfp464TgWPwIGQtBv2cJ+hXrW8Gx+Inyta2C/Sd4XrZ+EByLnyE3AwiuX0tw/lmS/Wf6WuEXBq4V3qW8S2WlKkpVle5Wqmb7GaUaSvco1VS6V6mWUm2lOkr3Kd2v9IBSXaUHleopPaT0sNIjSvWVGig1VHpU6TGlx5UaKTVWaqK5VniX5ppOZU2siiZWVRO7WxOrpolV18RqaGL3aGI1NbF7NbFamlhtTayOJnafJna/JvaAJlZXE3tQE6uniT2kiT2siT2iidXXxBpoYg01sUc1scc0scc1sUaaWGNNrEkx89cKvxC8VniX4LXCyoJ/s1yGXCusInitsKrgtcK7BcfCU4FxrbCa4LXC6oLXCmsIjkWm0ByL/3Ot8B7Ba4U1Ba8V3is4FplDbSz+w7XCWoLXCmsLXiusIzgWWUJnLP7rtcL7BK8V3i94rfABwbHIGgpj8ReuFdYVvFb4oOC1wnqCY5EtY8fiL18rfEjwWuHDgtcKHxEci+wZNRZ/81phfcFrhQ0ErxU2FByLHOk/Fv/oWuGjgtcKHxO8Vvi44FjkTM+xCOJaYSPBa4WNBa8VNhEci1zpNBa+4A5L8P0BS/DvW8v991mwY5EbMhaCfwdZgj7eyio4FnkgYyHo9yxBv2LlEByLvJCxENzXLMHzspVbcCzyGRoL6WuFguvXEpx/lmT/mb5WmCyX69/XCp9Q3qWpUjOl5kotlFoqPamUoJSolKSUrJSilKrUSqm1UhultkrtlJ5Saq/UQamjUielzkpdlLoqPa3UTam7Ug+lZ5R6aq4VPqG5ptNUE2umiTXXxFpoYi01sSc1sQRNLFETS9LEkjWxFE0sVRNrpYm11sTaaGJtNbF2mthTmlh7TayDJtZRE+ukiXXWxLpoYl01sac1sW6aWHdNrIcm9owm1rOY+WuF7jUb7Ln+CcFrhU0F/2YpHsrXp1zXCpsJXitsLnitsIXgWJSAXCtsKXit8EnBa4UJgmNREnKtMFHwWmGS4LXCZMGx8EKuFaYIXitMFbxW2EpwLEpBrhW2FrxW2EbwWmFbwbGIgFwrbCd4rfApwWuF7QXHojTkWmEHwWuFHQWvFXYSHItbIdcKOwteK+wieK2wq+BY3Aa5Vvi04LXCboLXCrsLjsXtkGuFPQSvFT4jeK2wp+BYlIG8Dy/4/oAl+PetVVLwffiykLEQ/DvIEvTxVoTgWJSDjIWg37ME/Yp1m+BYlIeMheC+Zgmel62ygmNRAXKtUHD9WoLzzzLVf9LXCScaeiK6CdbxgqxeJ8+zymP1Uuqt1EfpOaW+Sv2U+isNUBqo9LzSIKUXlAYrDVEaqvSi0jCll5SGK72sNELpFaVXlV5TGqn0utIbSm8qjVIarTRGc03zWc21p16aWG9NrI8m9pwm1lcT66eJ9dfEBmhiAzWx5zWxQZrYC5rYYE1siCY2VBN7URMbpom9pIkN18Re1sRGaGKvaGKvamKvaWIjNbHXNbE3NLE3NbFRmthoTWxMMfPXNMcLPpD/WcFrmr0E/7aqDLmm2VvwmmYfwWuazwmORRXINc2+gtc0+wle0+wvOBZVIdc0Bwhe0xwoeE3zecGxuBtyTXOQ4DXNFwSvaQ4WHItqkGuaQwSvaQ4VvKb5ouBYVIdc0xwmeE3zJcFrmsMFx6IG5Jrmy4LXNEcIXtN8RXAs7oFc03xV8Jrma4LXNEcKjkVNyDXN1wWvab4heE3zTcGxuBdyTXOU4DXN0YLXNMcIjkUtyPUCwfcHLMG/b62qgtcLakPGQvDvIEvQx1vVBceiDmQsBP2eJehXrJqCY3EfZCwE9zVL8Lxs1RYci/sh1zQF168lOP8syf6z5+8RJa+Tb4xzTWyUc43sDeea2UjnGtqrzjW1Ec41tuHONbdhzjW4oc41ucHONbpBzjW7gc41vP7ONb2+zjW+Ps41P/s6gH1dIfDIHDCmwc69CYLXQca6PJSl3sNR773Yv+dP9lnRyerdk8jI5MRoX5IvISkyJT5a/fkSHRkdlZScpP6e9CdYqb7UhKT4VP+VXPYX2Ob3XL1W6z6kr9+6uX1BHm7eccUMAtvJxS9kC5pgU3WPdy0Kobz/mmxpX0dverJNKGjmZB/YJ8EuQPdEnuCaa/+nQ4KdKOPlVp/lvorshv6bzEl/0jn/Wih2/sCz8Z8B/lmnTxBcgBOFz2pp/Wrn7fcP54Jlf7rO8qX64iPVOzlxSbFxifHJkYn+hNSo1Jio5Kh/2q9/Ntkl+3WSoX6d9M/79X9ivk421K+T/z+fr1MM9esUp1/TNs70cGoTDN0VONUxFW/Ze4aJDW6CAbc2oZiskzBV999dHL6/UXewjG8b7kNfcIdlT8y3i8mPzTuGTgrv/JeTrS+4w3rLUF9MM9QX0wz2hX0iNNEXTSqE9jnF1Hp4ImPr/tNbS0zN/aaQtx4F56UlONaWZP/ZRiq7R/8uhOdv9uefzSd3ThN7llSfuE3lu//tXQhfcIf1tqFN4N3/8i7En6Sx/uzfsZnfNXBSaBki14b+jnkLtub3ioXmCUZyLNzz8j2XOfmn4/NnfS45PtPd1xaiotTaSI6zUpNTo2Li4iMTrdio2NjU6NS4WH90cmpMdEJyXIoVnRAVGZ8S50u1/CkpcTFRSXGxqfHJSbGp7pO2lRwVFZ0cn5hkxUTGJiT6/MlRCb7U6Lgo9Qd/clRccnKUPzY2ISoqOdaf6o9Xf6SrP/39vpi4uHhfbGRUfKSp8Znu+utaalP4s3dz3Dkpm8IM4qYww/CmMMPAppAQIpvCf5zEcf/6BFWq5ElnZohuCgmGTjozBTaFP3trU3J8ZoXopmBqfGb9D73lOtt5y3WO7i1XX3DHf7zeIXmtMug7LwRPLiYGPq0Ps0D6MNhcc0N8POwFM9fAxj7PkMmZZ/DtzzmG+mK+ob6Yb/itYBN9kRTibwWbWg/JIf5WsKm5nwJ5K1hwXlqCY22lhN8KDjz+tWdJ9Ynb7C4w+Vf/XEObwAKDf/XbzAsMnBTaQN4KnitoBBcWC80TTBtDf1UuTIe3giXHZ5HgX/0pgn/1mxqfRZrx+bv31PzZW7+S47PY0PlzsUA//Nm7U5L9sMRQPyyBzYelhvphKWw+LDPUD8v+wqWiUDZ2Glyxeew2jcuJpnG5YdO43IBpbBcazxFKSs+T3ArBXJKmsZ0hU7LiL5jGYO+ulxyflcXkjJ6kaTQ1PisFNsc/OUSfmbFK7PzpN3Ij9njnXTfpK0qSc3x1iF/BsMd4tYH9Zo2hvdfOm9P57yOe/3tI/Ztp+aT7e1rW0GdcK20kKZO2fYhfXrFrXmug7g6QB4+sFTwxrxM8MQvOG0tyLAyfJP99meL/x5Pkuv9fT5LrQ/zjeXbN6w3UvcGQo9lQ7OqT9U183FPnkH3BHZakQ94Y4vPJ/otqo4H5tAmwjjYZqHuzoXW0+b+sI19wh7FzSucK/3/OgS7pdF9LsJxbBE2i4FhbXQy9Q7Ul/Ne1ccatpo2jxF+ZWw0s+m6QvzK3AhZ9sGPRHXIC3iY4FoLzz+oe/isdcbLdJnmype6K8wEDtT08UD5rIWCg3g8PlM9aDBioHeGB8llLAQO1MzxQPms5YKB2hQfKZ60EDNTu8ECp9+4AA7UnPFDqqjZgoPaGB8pnrQcM1L7wQPmsjYCB2h8eKJ+1GTBQB8IDpd4TBwzUwfBAqffRAAN1KDxQ6u0ZwEAdDg+Uz2qVJfQZj4QHSv3VD1hRR8MDpf6YBAzUsfBAqb9RAAN1PDxQyvoCBuqD8EApRwUYqA/DA6U2asBAfRQeKHX+BwzUx+GBUqcVwEB9Eh4oNVsBA/VpeKBUJwAG6rPwQPmszwED9Xl4oHzWl4CB+iI8UD7rBGCgvgwPlM/6BjBQX4UHymd9BxioE+GB8lk/AAbqa8mBsuEKea5+zs/+7+N5PJ4/nHahYlfbN7naHzi/k/b/+0b97Ful75S+L3Y1nnZIPxT/qxsFT6OCD1z4wdBzQqX774Rg/30r2H8/Cj/AIHBu/+Cawz+62t+52t8Xu3Zu/6T++2elX5R+deZ2Zs+1h/Qi/0mwH7xOnpMq5yml00pnlM4qnVM6r/Sb0gWli0q/K12y+0DpspKnuKpPKbNSFqWsStmUsivlUMqplEspt1IepbxK+ZSuU8qvVEDp+uJXOsn9gfiTzgfi3bFTmthpTeyMJnZWEzuniZ3XxH7TxC5oYhc1sd81sUua2B+a2GVNzO7vwFgmTSyzJpZFE8uqiWXTxLJrYjk0sZyaWC5NLLcmlkcTy6uJ5dPErtPE8mtiBTSx64tffYBJ2iH92fafBM+DJwVypfzr+yF91ilBrp6h8ajj/1qzPRanRfrvyrieCT5XZNqXz5wVHItnQ3ksoq9+4c654Gr2ub+853wwuSKv/SKg3wTHoldojoUv8MuPLvzDmmNT/+8XKV38Z7n8ui9l+l1wLHqH2lj49V9Edenv1xz3n77U6o+/myvuP39B1mXBsegTOmMR+V+/FKz438gV99+/YCzTX8/1p19+l7m43Fg8FwpjEfennFaWv1az7y/UbGX9K7l8f6n/rGyCY9E3Y8ci5i9yWtn/rObov1yzleO/5opO/Rv9Z+UUHIt+GTUWcX+L08r1n2v2/82ardz/IVd86t/uPyuP4Fj0T/+x8P0DTiuvrmbfP6rZyvd/c1n/sP+s6wTHYkB6jkXyP+a08l9bc1QQNVsFXLkiU4PqP+t6wbEYCHm+n+D7A5bg37dWL8Hn+z0PGQvBv4MsQR9vPSc4FoMgYyHo9yxBv2L1FxyLFyBjIbivWYLnZet5wbEYDPlyc8H1awnOP4vSf4JfGGFtEnzf54bistdx7aOf82r/d7zrupnf1Y5ztWNd7RhXO9rVjnK1I11ty9X2udp3utp3uNqVXO2KrnYFV7u8q13O1S7rapdxtW93tW9ztW91tUu72hGudilX2+tql3S1S7jaxV3tYq52UVe7iKvdxNVu7Go3crUfd7Ufc7UfdbUbutoNXO36rvYjrvbDrvZDrnY9V/tBV7uuq/2Aq32/q32fq13H1a7tatdyte91tWu62ve42jVc7equdjVX+25Xu6qrXcXVruxq3+Vq93S1n3G1e7ja3V3tbq720652V1e7i6vd2dXu5Gp3dLU7uNrtXe2nXO12rnZbV7uNq93a1W7laqe62imudrKrneRqJ7raCa72k652S1e7havd3NVu5mo3dbWfcLVvcF1j3u6Kv+9q73C1d7rau1zt3a72Hld7r6u9z9Xe72ofcLUPutqHXO3DrvYRV/uoq33M1T7uan/gan/oan/kan/san/ian/qan/man/uan/han/pan/lap9wtb92td33Q7jvl3DfT+G+38J9P4b7fg33/Rzu+z3c94O47xdx30/ivt/EfT+K+34V9/0s7vtdrncxu+9XcN/P4L7fwX0/hPt+Cff9FO77Ldz3Y7jv13Dfz+G+38N9P8g194u42mn3m7ziuXIUVP99o9JNSoWUblYqrHSLUhGlokrFlIorlVAqqeRVKqUUoVRa6Val25RuVyqjVFapnFJ5pQpKFZUqKd2hdKeST8lSilSKUopWilGKVYpT8ivFK92lVFmpilJVpbuVqtmeRKmG0j1KNZXuVaqlVFupjtJ9SvcrPaBUV+lBpXpKDyk9rPSIUn2lBkoNlR5VekzpcaVGSo2Vmig9odRUqZlSc6UWSi2VnlRKUEpUSlJKVkpRSlVqpdRaqY1SW6V2Sk8ptVfqoNRRqZNSZ6UuSl2VnlbqptRdqYfSM0o9lZ5V6qXUW6mP0nNKfZX6KfVXGqA0UOl5pUFKLygNVhqiNFTpRaVhSi8pDVd6WWmE0itKryq9pjRS6XWlN5TeVBqlNFppjNJYpXFK45UmKE1UmqQ0WWmK0tTinmuOTM5rdefVF9xhfSt3f6PP9L1+gvey/vtev7dU/76t9I7SNKV3ld5Tmq40Q2mm0iyl2UpzlOYqzVOar7RAaaHSIqXFSkuUliotU1qutEJppdIqpdVKa5TWKq1TWq+0ofiVTvrX+cPpL5vn3+cU5/VtTewdTWyaJvauJvaeJjZdE5uhic3UxGZpYrM1sTma2FxNbJ4mNl8TW6CJLdTEFmliizWxJZrYUk1smSa2XBNboYmt1MRWaWKrNbE1mthaTWydJrZeE9vgxNyH9HtI7jUb7N/K9toINlfavX5vF5fjGgW51+8dkf67Mq7Tgs/173v93hUci9GQe/3eC67ma+71mx5MroB7/WYIjsUYyL1+M/9hzbp7/Wb9s1zae/1mC47FWMi9fnP+fs3/8V6/uX8313+512+e4FiMg9zrN//v1Pwn9/ot+Ou5/vRev4WCYzEecq/for9W81+612/xX8n1F+/1WyI4FhMg9/ot/bOa/8a9fsuKy93rt1xwLCZC7vVbUVzuXr+VxeXu9VslOBaTIPf6rS4ud6/fmuJy9/qtFRyLyZB7/dYVl7vXb31xuXv9NgiOxRTIfTSC7w9Ygn/fWmME76OZChkLwb+DLEEfb40XHIu3IGMh6PcsQb9iTRIci7chYyG4r1mC52VrquBYvAO5V01w/VqC88+S7D97/n6o5HXybXCuia1zrpGtca6ZrXKuoa1wrqktc66xLXGuuS1yrsEtcK7JzXOu0c1xrtnNcq7hzXCu6b3nXOOb5lzzs68DvBVwjdU+MgeMabBz74TgdZCNLg9lqfdw1Hsv9u/5k31WdLJ69yQyMjkx2pfkS0iKTImPVn++REdGRyUlJ6m/J/0JVqovNSEpPtV/JVc2lSO/5+q1Wvchff3Wze0L8nDzbipuENhOLp13s6AJNlX3ZteiEMr7r8lmK7PH/GQTfHCTT4MrtgDdE3mLa679nw4JdqJsllt9lvsqshv6bzIn/Unn/Guh2PkDz8Z/Bvhnnb5FcAFuFT6rpfWrnbffP5wLluq7JMuX6ouPVO/kxCXFxiXGJ0cm+hNSo1JjopKj/mm//tlkl+zXbYb6dds/79f/ifm63VC/bv//fL6+b6hf33f6NW3jTA+ndsLQXYE7HFOx094zTGxwWwy4tS3FZZ2Eqbr/7uLw/Y26g2XcZbgPfcEdlj0xdxWXH5vdhk4Ku//LydYX3GHtNNQXewz1xR6DfWGfCE30xeIKoX1OMbUelmRs3X96a4mpub8U8taj4Ly0BMfakuw/20hl9+jfhfD8zf78s/nkzmliz5LqE7ep3Pvf3oXwBXdYuwxtAnv/y7sQf5LG+rN/x2bea+CksDJErg39HfMWbM37iofmCUZyLNzzcp/LnPzT8fmzPpccn/3uawtRUWptJMdZqcmpUTFx8ZGJVmxUbGxqdGpcrD86OTUmOiE5LsWKToiKjE+J86Va/pSUuJiopLjY1PjkpNhU90nbSo6Kik6OT0yyYiJjExJ9/uSoBF9qdFyU+oM/OSouOTnKHxubEBWVHOtP9cerP9LVn/5+X0xcXLwvNjIqPtLU+Ox3/XUttSn82bs57pyUTeEAcVM4YHhTOGBgU1gdIpvCf5zEcf/6BFWq5EnnYIhuCqsNnXQOCmwKf/bWpuT4HArRTcHU+Bz6H3rL9bDzlusR3VuuvuCO/3i9Q/JaZbC5BN++tUwMfFofZoH0YbC5job4eNgL5qiBjf2YIZNzzODbn0cM9cVxQ31x3PBbwSb6Ym2IvxVsaj2sC/G3gk3N/fWQt4IF56UlONbW+vBbwYHHv/YsqT5xm90PTP7Vf9TQJvCBwb/6beYPDJwUNkPeCj4qaAQ/LB6aJ5jNhv6q/DAd3gqWHJ+PBP/qXy/4V7+p8flIMz5/956aP3vrV3J8PjZ0/vxYoB/+7N0pyX74xFA/fAKbD58a6odPYfPhM0P98NlfuFQUysZOgys2j92m8XOiafzcsGn83IBp3BoazxFKSs+T3BeCuSRN41ZDpuSLv2Aag727XnJ8viwuZ/QkTaOp8flSYHP8k0P0mRlfiZ0//UZuxN7svOsmfUVJco6fCPErGPYYnzCw33xtaO+18+Z0/vtDz/89pP7NtHzS/T0ta+gzfiNtJCmTdnuIX16xa/7GQN3vQx488o3giflbwROz4LyxJMfC8Eny35cp/n88SX77/+tJ8rsQ/3ieXfN3Bur+3pCj+b741Sfrm/i4p84h+4I7LEmH/EOIzyf7L6ofDMynHwHr6EcDdf9kaB399F/WkS+4w9g5ZVeF/z/nwO50uq8lWM6fBU2i4Fhbuw29Q/Vz+K9r44y/mDaOEn9l/mJg0e+D/JX5C2DRB/3RPcgJ+FfBsRCcf9b+8F/piJPtr5InW+quOB8wUCfDA+WzFgIG6lR4oHzWYsBAnQ4PlM9aChioM+GB8lnLAQN1NjxQPmslYKDOhQfKZ60GDNT58ED5rLWAgfotPFA+az1goC6EB8pnbQQM1MXwQPmszYCB+j08UD5rK2CgLoUHymdtBwzUH+GB8lk7AAN1OTxQPqtVltBn9JQID5S1G7CiMoUHymftBQxU5vBAqavcgIHKEh4on3UQMFBZwwPlsw4DBipbeKB81lHAQGUPD5TPOg4YqBzhgfJZHwIGKmd4oHzWx4CByhUeKJ/1KWCgcocHymd9DhioPOGB8llfAgYqb3igfNYJwEDlCw+Uz/oGMFDXhQfKZ30HGKj84YHyWT8ABqqA5EDZz9DM57n62TIbtkZmj/YQ+0fDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5rznCecN5w3nDef/X8maWzWsJPjzZkn6ArH2E9GOdDDGeAjCeBjCeATCeBTCeAzCeBzD+BmC8AGC8CGD8HcB4CcD4B4DxMoBR9AO5hhgzARgzAxizABizAhizARizAxhzABhzAhhzARhzAxjzABjzAhjzARivAzDmBzAWADDOLBT6jLMAjLMBjHMAjHMBjPMAjPMBjAsAjAsBjIsAjIsBjEsAjEsBjMsAjMsBjCsAjCsBjKsAjKsBjGsAjGsBjOsAjOsBjBsAjBsBjJsAjJsBjFsAjFsBjNsAjNsBjO8DGHcAGHcCGHcBGHcDGPcAGPcCGPcBGPcDGA8AGA8CGA8BGA8DGI8AGI8CGI8BGI8DGEcXDn3GMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGtwCMbwMY3wEwTgMwvgtgfA/AOB3AOAPAOBPAOAvAOBvAOAfAOBfAOA/AOB/AuADAuBDAuAjAuBjAuATAuBTAuAzAuBzAuALAuBLAuArAuBrAuAbAuBbAuA7AuB7AuAHAuBHAuAnAuBnAuAXAuBXAWBDwHKQbAYw3ARgLARhvBjAWBjDeAmAsAmAsCmAsBmAsDmAsAWAsCWD0AhhLARgjAIylAYy3AhhvAzDeDmAsA2AsC2AsB2AsD2CsAGCsCGCsBGC8A8B4J4DRB2C0AIyRAMYoAGM0gDEGwBgLYIwDMPoBjPEAxrsAjJUBjFUAjFUBjHcDGKsBGKsDGGsAGO8BMNYEMN4LYKwFYKwNYKwDYLwPwHg/gPEBAGNdAOODAMZ6AMaHAIwPAxgfATDWBzA2ADA2BDA+CmB8DMD4OICxEYCxMYCxCYDxCQBjUwBjMwBjcwBjCwBjSwDjkwDGBABjIoAxCcCYDGBMATCmAhhbARhbAxjbABjbAhjbARifAjC2BzB2ADB2BDB2AjB2BjB2ATB2BTA+DWDsBmDsDmDsAWB8BsDYE8D4LICxF4CxN4CxD4DxOQBjXwBjPwBjfwDjAADjQADj8wDGQQDGFwCMgwGMQwCMQwGMLwIYhwEYXwIwDgcwvgxgHAFgfAXA+CqA8TUA40gA4+sAxjcAjG8CGEcBGEcDGMcAGMcCGMcBGMcDGCcAGCcCGCcBGCcDGKcAGKcSnltYNPQZbwcwlgEwlgUwlgMwlgcwVgAwVgQwVgIw3gFgvBPA6AMwWgDGSABjFIAxGsAYA2CMBTDGARj9AMZ4AONdAMbKAMYqAMaqAMa7AYzVAIzVAYw1AIz3ABhrAhjvBTDWAjDWBjDWATDeB2C8H8D4AICxLoDxQQBjPQDjQwDGhwGMjwAY6wMYGwAYGwIYHwUwPgZgfBzA2AjA2BjA2ATA+ASAsSmAsRmAsTmAsQWAsSWA8UkAYwKAMRHAmARgTAYwpgAYUwGMrQCMrQGMbQCMbQGM7QCMTwEY2wMYOwAYOwIYOwEYOwMYuwAYuwIYnwYwdgMwdgcw9gAwPgNg7AlgfBbA2AvA2BvA2AfA+ByAsS+AsR+AsT+AcQCAcSCA8XkA4yAA4wsAxsEAxiEAxqEAxhcBjMMAjC8BGIcDGF8GMI4AML4CYHwVwPgagHEkgPF1AOMbAMY3AYyjAIyjAYxjAIxjAYzjAIzjAYwTAIwTAYyTAIyTAYxTAIxTAYxvARjfBjC+A2CcBmB8F8D4HoBxOoBxBoBxJoBxFoBxNoBxDoBxLoBxHoBxPoBxAYBxIYBxEYBxMYBxCYBxKYBxGYBxOYBxBYBxJYBxFYBxNYBxDYBxLYBxHYBxPYBxA4BxI4BxE4BxM4BxC4BxK4BxG4BxO4DxfQDjDgDjTgDjLgDjbgDjHgDjXgDjPgDjfgDjAQDjQQDjIQDjYQDjEQDjUQDjMQDjcQDjBwDGDwGMHwEYPwYwfgJg/BTA+BmA8XMA4xcAxi8BjF8BGE8AGL8GMH4DYPwWwPgdgPF7AOMPAMYfAYw/ARh/BjD+AmD8FcB4EsB4CsB4GsB4BsB4FsB4DsB4HsD4G4DxAoDxIoDxdwDjJQDjHwDGywBGT7HQZ8wEYMwMYMwCYMwKYMwGYMwOYMwBYMwJYMwFYMwNYMwDYMwLYMwHYLwOwJgfwFgAwHg9gPEGAGNBAOONBhjdh0juyGjLWG51ZHb1bVrO60t4PDcoFVS6UekmpUJKNysVVrpFqYhSUaViSsWVSiiVVPIqlVKKUCqtdKvSbUq3K5VRKqtUTqm8UgWlikqVlO5QulPJp2QpRSpFKUUrxSjFKsUp+ZXile5SqqxURamq0t1K1ZSqK9VQukepptK9SrWUaivVUbpP6X6lB5TqKj2oVE/pIaWHlR4pcaUP6pdwOiWL82oHqgcMgvjJp4SZCSl+AoJwFoRw3gjhvAnCWQjCeTOEszCE8xYIZxEIZ1EIZzEIZ3EIZwkIZ0kIpxfCWQrCGQHhLA3hvBXCeRuE83YIZxkIZ1kIZzkIZ3kIZwUIZ0UIZyUI5x0QzjshnD4IpwXhjIRwRkE4oyGcMRDOWAhnHITTD+GMh3DeBeGsDOGsAuGsCuG8G8JZDcJZHcJZA8J5D4SzJoTzXghnLQhnbQhnHQjnfRDO+yGcD0A460I4H4Rw1oNwPgThfBjC+Yggp812s8M4LavH4wW3f8x2tf2Tq/2zq/2Lq/2rq33S1T7lap922g1UnzdUelTpMaXHlRopNVZqoqR+zZPPc+X+2rQxr5HZoz2qC41dOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzjv/3bezLJ5re+Ky+X6sbh8vdLXU04CGE8BGE8DGM8AGM8CGM8BGM8DGH8DMF4AMF4EMP4OYLwEYPwDwHgZwOgpEfqMmQCMmQGMWQCMWQGM2QCM2QGMOQCMOQGMuQCMuQGMeQCMeQGM+QCM1wEY8wMYCwAYZxYKfcZZAMbZAMY5AMa5AMZ5AMb5AMYFAMaFAMZFAMbFAMYlAMalAMZlAMblAMYVAMaVAMZVAMbVAMY1AMa1AMZ1AMb1AMYNAMaNAMZNAMbNAMYtAMatAMZtAMbtAMb3AYw7AIw7AYy7AIy7AYx7AIx7AYz7AIz7AYwHAIwHAYyHAIyHAYxHAIxHAYzHAIzHAYyjC4c+4xgA41gA4zgA43gA4wQA40QA4yQA42QA4xQA41QA41sAxrcBjO8AGKcBGN8FML4HYJwOYJwBYJwJYJwFYJwNYJwDYJwLYJwHYJwPYFwAYFwIYFwEYFwMYFwCYFwKYFwGYFwOYFwBYFwJYFwFYFwNYFwDYFwLYFwHYFwPYNwAYNwIYNwEYNwMYNwCYNwKYCwIeA7SjQDGmwCMhQCMNwMYCwMYbwEwFgEwFgUwFgMwFgcwlgAwlgQwegGMpQCMEQDG0gDGWwGMtwEYbwcwlgEwlgUwlgMwlgcwVgAwVgQwVgIw3gFgvBPA6AMwWgDGSABjFIAxGsAYA2CMBTDGARj9AMZ4AONdAMbKAMYqAMaqAMa7AYzVAIzVAYw1AIz3ABhrAhjvBTDWAjDWBjDWATDeB2C8H8D4AICxLoDxQQBjPQDjQwDGhwGMjwAY6wMYGwAYGwIYHwUwPgZgfBzA2AjA2BjA2ATA+ASAsSmAsRmAsTmAsQWAsSWA8UkAYwKAMRHAmARgTAYwpgAYUwGMrQCMrQGMbQCMbQGM7QCMTwEY2wMYOwAYOwIYOwEYOwMYuwAYuwIYnwYwdgMwdgcw9gAwPgNg7AlgfBbA2AvA2BvA2AfA+ByAsS+AsR+AsT+AcQCAcSCA8XkA4yAA4wsAxsEAxiEAxqEAxhcBjMMAjC8BGIcDGF8GMI4AML4CYHwVwPgagHEkgPF1AOMbAMY3AYyjAIyjAYxjAIxjAYzjAIzjAYwTAIwTAYyTAIyTAYxTAIxTCc8tLBr6jLcDGMsAGMsCGMsBGMsDGCsAGCsCGCsBGO8AMN4JYPQBGC0AYySAMQrAGA1gjAEwxgIY4wCMfgBjPIDxLgBjZQBjFQBjVQDj3QDGagDG6gDGGgDGewCMNQGM9wIYawEYawMY6wAY7wMw3g9gfADAWBfA+CCAsR6A8SEA48MAxkcAjPUBjA0AjA0BjI8CGB8DMD4OYGwEYGwMYGwCYHwCwNgUwNgMwNgcwNgCwNgSwPgkgDEBwJgIYEwCMCYDGFMAjKkAxlYAxtYAxjYAxrYAxnYAxqcAjO0BjB0AjB0BjJ0AjJ0BjF0AjF0BjE8DGLsBGLsDGHsAGJ8BMPYEMD4LYOwFYOwNYOwDYHwOwNgXwNgPwNgfwDgAwDgQwPg8gHEQgPEFAONgAOMQAONQAOOLAMZhAMaXAIzDAYwvAxhHABhfATC+CmB8DcA4EsD4OoDxDQDjmwDGUQDG0QDGMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGtwCMbwMY3wEwTgMwvgtgfA/AOB3AOAPAOBPAOAvAOBvAOAfAOBfAOA/AOB/AuADAuBDAuAjAuBjAuATAuBTAuAzAuBzAuALAuBLAuArAuBrAuAbAuBbAuA7AuB7AuAHAuBHAuAnAuBnAuAXAuBXAuA3AuB3A+D6AcQeAcSeAcReAcTeAcQ+AcS+AcR+AcT+A8QCA8SCA8RCA8TCA8QiA8SiA8RiA8TiA8QMA44cAxo8AjB8DGD8BMH4KYPwMwPg5gPELAOOXAMavAIwnAIxfAxi/ATB+C2D8DsD4PYDxBwDjjwDGnwCMPwMYfwEw/gpgPAlgPAVgPA1gPANgPAtgPAdgPA9g/A3AeAHAeBHA+DuA8RKA8Q8A42UAo6dY6DNmAjBmBjBmATBmBTBmAzBmBzDmADDmBDDmAjDmBjDmATDmBTDmAzBeB2DMD2AsAGC8HsB4A4CxIIDxRgOM7kMkd2S0ZSy3L9qX2dW3aTmfKOHxNFVqptRcqYVSS6UnlRKUEpWSlJKVUpRSlVoptVZqo9RWqZ3SU0rtlToodVTqpNRZqYtSV6WnlbopdVfqofSMUk+lZ5V6KfVW6qP0nFJfpX5K/ZUGKA1Uel5pkNILSoOVhigNVXpRaZjSS0rDlV5WGqH0itKrSq8pjVR6XekNpTeVRimNVhpT4kofjC3hdEoW59XukJwBsWaaWHNNrIUm1lITe1ITS9DEEjWxJE0sWRNL0cRSNbFWmlhrTayNJtZWE2uniT2libXXxDpoYh01sU6aWGdNrIsm1lUTe1oT66aJddfEemhiz2hiPTWxZzWxXppYb02sjyb2nCbWVxPrp4n118QGaGIDNbHnNbFBmtgLmthgTWyIJjZUE3tRExumib2kiQ3XxF7WxEZoYq9oYq9qYq9pYiM1sdc1sTc0sTc1sVGa2GhNbIwmZp/8qnuuPTI5r2lxX3CH9UQJM5tvlgDOKF9sdHRKXGSKFWUl+CLjE/0xvuiYxFi/5bdi/DHJkf6oqBR/tD8uPjE+zhdvRUelWKkx8VGpTu7visvl+rG4XP81NdR/mYX776Rgzc0gNZ8SrLk5pObTgjW3gNR8RrDmlpCazwrW/CSk5nOCNSdAaj4vWHMipObfBGtOgtR8QbDmZEjNFwVrToHU/LtgzamQmi8J1twKUvMfgjW3htR8WbDmNpCaPXKcVltIzZkEa24HqTmzYM1PQWrOIlhze0jNWQVr7gCpOZtgzR0hNWcXrLkTpOYcgjV3htScU7DmLpCacwnW3BVSc27Bmp+G1JxHsOZukJrzCtbcHVJzPsGae0Bqvk6w5mcgNecXrLknpOYCgjU/C6l5ZiG5mntBap4lWHNvSM2zBWvuA6l5jmDNz0FqnitYc19IzfMEa+4HqXm+YM39ITUvEKx5AKTmhYI1D4TUvEiw5uchNS8WrHkQpOYlgjW/AKl5qWDNgyE1LxOseQik5uWCNQ+F1LxCsOYXITWvFKx5GKTmVYI1vwSpebVgzcMhNa8RrPllSM1rBWseAal5nWDNr0BqXi9Y86uQmjcI1vwapOaNgjWPhNS8SbDm1yE1bxas+Q1IzVsEa34TUvNWwZpHQWreJljzaEjN2wVrHiNYczaVo4CrXveRNaAPfP/0sK68CK3vf2UTWzeW7HwUHGcTD1yx0hru8R5X4srrePvV/SF5+wcfB8TsX/J6whMl2BPCoQpmJorYWFw5rpnQ/7DmSKdma1wJuf4bL3hzi6mxyCw8FpL9N0GTK9GXlBxjJcYmx1kpCTH+pKT4KMuKTIhNiE2M9KemJMZY/hi/ypmUEOlX/1xkQpKV4kuITbE3kfyeqw/QcB/SD9WYILj5uXknljAIbCeXzjtJcDKYqntSiasdLJRXyypxMrFZpRZsWl7JMZosPPHTNnQ7byn1mp5OcIPgBr9RcIOXfKdhM9AJTnHW69RAJzhF4wSnpoMTJEyUYBf2EYgT3CzoBKcInhinCjrBIxAnKNl/b0Gd4FuGnODbJQwCv23ACb4T4k7QrvsdiBOc6rBKO0HJMZpmyAlOywAnuEZwg18ruMFLXkNeD3SC7zrr9b1AJ/iuxgm+lw5OkDBRgl3YxyBOcL2gE3xX8MT4nqATPAZxgpL9Nx3qBKcbcoIzShgEnmHACc4McSdo1z0T4gTfc1ilnaDkGM0y5ARnZYATXCG4wa8U3OAl7w5eDXSCs531OifQCc7WOME56eAECRMl2IX9AcQJrhZ0grMFT4xzBJ3gBxAnKNl/c6FOcK4hJzivhEHgeQac4PwQd4J23fMhTnCOwyrtBCXHaIEhJ7ggA5zgEsENfqngBi/5uc/lQCe40FmviwKd4EKNE1yUDk6QMFGCXdgfQZzgckEnuFDwxLhI0Al+BHGCkv23GOoEFxtygktKGAReYsAJLg1xJ2jXvRTiBBc5rNJOUHKMlhlygssywAkuENzgFwpu8JJP9FkMdILLnfW6ItAJLtc4wRXp4AQJEyXYhf0JxAkuFnSCywVPjCsEneAnECco2X8roU5wpSEnuKqEQeBVBpzg6hB3gnbdqyFOcIXDKu0EJcdojSEnuCYDnOAcwQ1+ruAGL/ms1vlAJ7jWWa/rAp3gWo0TXJcOTpAwUYJd2J9BnOB8QSe4VvDEuE7QCX4GcYKS/bce6gTXG3KCG0oYBN5gwAluDHEnaNe9EeIE1zms0k5Qcow2GXKCm9LTCTqb8kzBTVnymzNEvpHCMTGC39ySbk5ws7NetwQ6wc0aJ7jFpBMETZRgF/YXoe4ENRM6WCe4WfDEuEXQCX4BcYKS/bcV6gS3GnKC20oYBN5mwAluD3EnaNe9HeIEtzis0k5QcozeN+QE38+A9wSFvq/yX9nEvgfSkv1+xfxAJ7jDWa87A53gDo0T3JkO7wkSJkqwC/sryHuC+QWd4A7B/tspuGi/gjhByf7bBXWCuww5wd0lDALvNuAE94S4E7Tr3gNxgjsdVmknKDlGew05wb0Z4ARzCm7wuQQ3+NyCm0oeoBPc56zX/YFOcJ/GCe5PBydImCjBLuyvIU4wj6AT3CfYf/sFF+3XECco2X8HoE7wgCEneLCEQeCDBpzgoRB3gnbdhyBOcL/DKu0EJcfosCEneDgDnGBWwQ0+m+AGn11wU8kBdIJHnPV6NNAJHtE4waPp4AQJEyXYhf0txAnmEHSCRwT776jgov0W4gQl++8Y1AkeM+QEj5cwCHzcgBP8IMSdoF33BxAneNRhlXaCkmP0oSEn+GEGOEGP4AafSXCDzyy4qWQBOsGPnPX6caAT/EjjBD9OBydImCjBLuzvIU4wi6AT/Eiw/z4WXLTfQ5ygZP99AnWCnxhygp+WMAj8qQEn+FmIO0G77s8gTvBjh1XaCUqO0eeGnODnGeAEfy8ut8FfKi63wf9RXG7+Xy5uZlMRWk9aJ/iFs16/DHSCX2ic4Jfp4AQJEyXYhf0jxAleLi7nBL8QPDF+KegEf4Q4Qcn++wrqBL8y5ARPlDAIfMKAE/w6xJ2gXffXECf4pcMq7QQlx+gbQ07wmwxwgucFN/jfBDf4C4JO8CLQCX7rrNfvAp3gtxon+F06OEHCRAl2Yf8McYIXBZ3gt4Inxu8EneDPECco2X/fQ53g94ac4A8lDAL/YMAJ/hjiTtCu+0eIE/zOYZV2gpJj9JMhJ/hTBjjB04Ib/BnBDf6soBM8B3SCPzvr9ZdAJ/izxgn+kg5OkDBRgl3Yv0Kc4DlBJ/iz4InxF0En+CvECUr2369QJ/irISd4soRB4JMGnOCpEHeCdt2nIE7wF4dV2glKjtFpQ07w9F9wglkkx1BtpCcFHdcpQbPQFHhv3xlnjZ0NdG9nNO7trEn35iASBjfYxXjKkGMIXGjBOq4zgjWfFXRcpyCOS7L/zkEd1zlDjut8CYPA5w04rt9C3HHZdf8GcVxnHVZpxyU5RhcMOa4LjuOy2zd7rt2Y3W+xuC+8uW/Hct+k7/7opvuBHnZ7p6u9xdVe52qvcLUXudpzXO33XO2prvZ4V7uBq93Q1X7U1X7M1X7c1W7kajd2tZs47Yvq9XelS0p/KF2253hJ9TtKmUteca75PFc3T/v/W0NnYz3m3F04bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOO//Vl7pazgm7kCQZjxZPPQZTwEYTwMYzwAYzwIYzwEYzwMYfwMwXgAwXgQw/g5gvARg/APAeBnA6AF4s0wAxswAxiwAxqwAxmwAxuwAxhwAxpwAxlwAxtwAxjwAxrwAxnwAxusAjPkBjAUAjDMLhT7jLADjbADjHADjXADjPADjfADjAgDjQgDjIgDjYgDjEgDjUgDjMgDjcgDjCgDjSgDjKgDjagDjGgDjWgDjOgDjegDjBgDjRgDjJgDjZgDjFgDjVgDjNgDjdgDj+wDGHQDGnQDGXQDG3QDGPQDGvQDGfQDG/QDGAwDGgwDGQwDGwwDGIwDGowDGYwDG4wDG0YVDn3EMgHEsgHEcgHE8gHECgHEigHESgHEygHEKgHEqgPEtAOPbAMZ3AIzTAIzvAhjfAzBOBzDOADDOBDDOAjDOBjDOATDOBTDOAzDOBzAuADAuBDAuAjAuBjAuATAuBTAuAzAuBzCuADCuBDCuAjCuBjCuATCuBTCuAzCuBzBuADBuBDBuAjBuBjBuATBuBTAWBDwH6UYA400AxkIAxpsBjIUBjLcAGIsAGIsCGIsBGIsDGEsAGEsCGL0AxlIAxggAY2kA460AxtsAjLcDGMsAGMsCGMsBGMsDGCsAGCsCGCsBGO8AMN4JYPQBGC0AYySAMQrAGA1gjAEwxgIY4wCMfgBjPIDxLgBjZQBjFQBjVQDj3QDGagDG6gDGGgDGewCMNQGM9wIYawEYawMY6wAY7wMw3g9gfADAWBfA+CCAsR6A8SEA48MAxkcAjPUBjA0AjA0BjI8CGB8DMD4OYGwEYGwMYGwCYHwCwNgUwNgMwNgcwNgCwNgSwPgkgDEBwJgIYEwCMCYDGFMAjKkAxlYAxtYAxjYAxrYAxnYAxqcAjO0BjB0AjB0BjJ0AjJ0BjF0AjF0BjE8DGLsBGLsDGHsAGJ8BMPYEMD4LYOwFYOwNYOwDYHwOwNgXwNgPwNgfwDgAwDgQwPg8gHEQgPEFAONgAOMQAONQAOOLAMZhAMaXAIzDAYwvAxhHABhfATC+CmB8DcA4EsD4OoDxDQDjmwDGUQDG0QDGMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqYTnFhYNfcbbAYxlAIxlAYzlAIzlAYwVAIwVAYyVAIx3ABjvBDD6AIwWgDESwBgFYIwGMMYAGGMBjHEARj+AMR7AeBeAsTKAsQqAsSqA8W4AYzUAY3UAYw0A4z0AxpoAxnsBjLUAjLUBjHUAjPcBGO8HMD4AYKwLYHwQwFgPwPgQgPFhAOMjAMb6AMYGAMaGAMZHAYyPARgfBzA2AjA2BjA2ATA+AWBsCmBsBmBsDmBsAWBsCWB8EsCYAGBMBDAmARiTAYwpAMZUAGMrAGNrAGMbAGNbAGM7AONTAMb2AMYOAMaOAMZOAMbOAMYuAMauAManAYzdAIzdAYw9AIzPABh7AhifBTD2AjD2BjD2ATA+B2DsC2DsB2DsD2AcAGAcCGB8HsA4CMD4AoBxMIBxCIBxKIDxRQDjMADjSwDG4QDGlwGMIwCMrwAYXwUwvgZgHAlgfB3A+AaA8U0A4ygA42gA4xgA41gA4zgA43gA4wQA40QA4yQA42QA4xQA41QA41sAxrcBjO8AGKcBGN8FML4HYJwOYJwBYJwJYJwFYJwNYJwDYJwLYJwHYJwPYFwAYFwIYFwEYFwMYFwCYFwKYFwGYFwOYFwBYFwJYFwFYFwNYFwDYFwLYFwHYFwPYNwAYNwIYNwEYNwMYNwCYNwKYNwGYNwOYHwfwLgDwLgTwLgLwLgbwLgHwLgXwLgPwLgfwHgAwHgQwHgIwHgYwHgEwHgUwHgMwHgcwPgBgPFDAONHAMaPAYyfABg/BTB+BmD8HMD4BYDxSwDjVwDGEwDGrwGM3wAYvwUwfgdg/B7A+AOA8UcA408Axp8BjL8AGH8FMJ4EMJ4CMJ4GMJ4BMJ4FMJ4DMJ4HMP4GYLwAYLwIYPwdwHgJwPgHgPEygNFTLPQZMwEYMwMYswAYswIYswEYswMYcwAYcwIYcwEYcwMY8wAY8wIY8wEYrwMw5gcwFgAwXg9gvAHAWBDAeKMBRvchkjsy2jKW2+f3ZXb1bVrOLCU9nqxK2ZSyK+VQyqmUSym3Uh6lvEr5lK5Tyq9UQOl6pRuUCirdqHSTUiGlm5UKK92iVESpqFIxpeJKJZRKKnmVSilFKJVWulXpNqXblcoolVUqp1ReqYJSRaVKSnco3ankU7KUIpWilKKVYpRileKU/ErxSncpVVaqolRV6W6lakrVlWoo3VPySh/ULOl0Spa0V7sTAmJZNbFsmlh2TSyHJpZTE8ulieXWxPJoYnk1sXya2HWaWH5NrIAmdr0mdoMmVlATu1ETu0kTK6SJ3ayJFdbEbtHEimhiRTWxYppYcU2shCZWUhPzamKlNLEITay0JnarJnabJna7JlZGEyuriZXTxMprYhU0sYqaWCVN7A5N7E5NzKeJWZpYpCYWpYlFa2IxmlisJhanifk1sXhN7C5NrLImVkUTq6qJ3a2JVdPEqmtiNTSxezQx+4RY3XPtkbZ5pMWjfLHR0SlxkSlWlJXgi4xP9Mf4omMSY/2W34rxxyRH+qOiUvzR/rj4xPg4X7wVHZVipcbER6U629H7hQTfwCppZnOXrnmHYM1ZITXvFKw5G6TmXYI1Z4fUvFuw5hyQmvcI1pwTUvNewZpzQWreJ1hzbkjN+wVrzgOp+YBgzXkhNR8UrDkfpOZDgjVfB6n5sGDN+SE1HxGsuQCk5qOCNV8PqfmYYM03QGo+LlhzQUjNowsLXhCA1DxGsOabIDWPFay5EKTmcYI13wypebxgzYUhNU8QrPkWSM0TBWsuAql5kmDNRSE1TxasuRik5imCNReH1DxVsOYSkJrfEqy5JKTmtwVr9kJqfkew5lKQmqcJ1hwBqfldwZpLQ2p+T7DmWyE1Txes+TZIzTMEa74dUvNMwZrLQGqeJVhzWUjNswVrLgepeY5gzeUhNc8VrLkCpOZ5gjVXhNQ8X7DmSpCaFwjWfAek5oWCNd8JqXmRYM0+SM2LBWu2IDUvEaw5ElLzUsGaoyA1LxOsORpS83LBmmMgNa8QrDkWUvNKwZrjIDWvEqzZD6l5tWDN8ZCa1wjWfBek5rWCNVeG1LxOsOYqkJrXC9ZcFVLzBsGa74bUvFGw5mqQmjcJ1lwdUvNmwZprQGreIljzPYI1Z1M5CrjqdR9ZA/rA908P68qL0Pr+VzaxdWPJzkfBcTbxEBYrreEe73tLXnmtZb+6PyRv/+DjgJj9S15PeKIEe0I4U8HMRBEbiyvHNRP6H9Yc6dRs3VtSrv9qyZ0ELVNjkVl4LCT7r7YmV6IvKTnGSoxNjrNSEmL8SUnxUZYVmRCbEJsY6U9NSYyx/DF+lTMpIdKv/rnIhCQrxZcQm2JvIvk9V84PgUcm4T6oLbj5uXnrlDQIbCeXznuf4GQwVfd9Ja92sFBeLavEycRmlVqwaXklx+h+4YmftqHbeUup1/R0gmsFN/h1ghu85DsNG4BO8AFnvdYNdIIPaJxg3XRwgoSJEuzCPgdxghsEneADgifGuoJO8BzECUr234NQJ/igISdYr6RB4HoGnOBDIe4E7bofgjjBug6rtBOUHKOHDTnBhzPACa4U3OBXCW7wkteQ1wCd4CPOeq0f6AQf0TjB+ungBAkTJdiF/RvECa4RdIKPCJ4Y6ws6wd8gTlCy/xpAnWADQ06wYUmDwA0NOMFHQ9wJ2nU/CnGC9R1WaScoOUaPGXKCj2WAE1wquMEvE9zgJe8OXgF0go8767VRoBN8XOMEG6WDEyRMlGAX9kWIE1wh6AQfFzwxNhJ0ghchTlCy/xpDnWBjQ06wSUmDwE0MOMEnQtwJ2nU/AXGCjRxWaScoOUZNDTnBphngBBcKbvCLBDd4yc99LgE6wWbOem0e6ASbaZxg83RwgoSJEuzCvgRxgksEnWAzwRNjc0EneAniBCX7rwXUCbYw5ARbljQI3NKAE3wyxJ2gXfeTECfY3GGVdoKSY5RgyAkmZIATnCu4wc8T3OAln+izAOgEE531mhToBBM1TjApHZwgYaIEu7AvQ5zgAkEnmCh4YkwSdIKXIU5Qsv+SoU4w2ZATTClpEDjFgBNMDXEnaNedCnGCSQ6rtBOUHKNWhpxgqwxwgjMFN/hZghu85LNa5wCdYGtnvbYJdIKtNU6wTTo4QcJECXZhZ6rIcIJzBJ1ga8ETYxtBJ2hqLKSdoGT/tYU6wbaGnGC7kgaB2xlwgk+FuBO0634K4gTbOKzSTlByjNobcoLtM8AJviu4wb8nuMFLfgvHDKAT7OCs146BTrCDxgl2TAcnSJgowS7sLBAnOEPQCXYQPDF2FHSCWSBOULL/OkGdYCdDTrBzSYPAnQ04wS4h7gTturtAnGBHh1XaCUqOUVdDTrBrBjjBtwQ3+LcFN3jJ71ecBnSCTzvrtVugE3xa4wS7pYMTJEyUYBd2NogTnCboBJ8WPDF2E3SC2SBOULL/ukOdYHdDTrBHSYPAPQw4wWdC3AnadT8DcYLdHFZpJyg5Rj0NOcGeGeAEJwlu8JMFN/gpgk5wKtAJPuus116BTvBZjRPslQ5OkDBRgl3YOSBOcKqgE3xW8MTYS9AJ5oA4Qcn+6w11gr0NOcE+JQ0C9zHgBJ8LcSdo1/0cxAn2clilnaDkGPU15AT7ZoATHCe4wY8X3OAnCDrBiUAn2M9Zr/0DnWA/jRPsnw5OkDBRgl3YuSBOcKKgE+wneGLsL+gEc0GcoGT/DYA6wQGGnODAkgaBBxpwgs+HuBO0634e4gT7O6zSTlByjAYZcoKDMsAJHi8kt8GPFtzgxwg6wbFAJ/iCs14HBzrBFzROcHA6OEHCRAl2YeeBOMGxgk7wBcET42BBJ5gH4gQl+28I1AkOMeQEh5Y0CDzUgBN8McSdoF33ixAnONhhlXaCkmM0zJATHJYBTvCw4AZ/pJDcBn+0kNz8P1bIzKYitJ60TvAlZ70OD3SCL2mc4PB0cIKEiRLsws4HcYLHCsk5wZcET4zDBZ1gPogTlOy/l6FO8GVDTnBESYPAIww4wVdC3Anadb8CcYLDHVZpJyg5Rq8acoKvZoAT3C+4wR8Q3OAPCjrBQ0An+JqzXkcGOsHXNE5wZDo4QcJECXZh54c4wUOCTvA1wRPjSEEnmB/iBCX773WoE3zdkBN8o6RB4DcMOME3Q9wJ2nW/CXGCIx1WaScoOUajDDnBURngBHcLbvB7BDf4vYJOcB/QCY521uuYQCc4WuMEx6SDEyRMlGAX9vUQJ7hP0AmOFjwxjhF0gtdDnKBk/42FOsGxhpzguJIGgccZcILjQ9wJ2nWPhzjBMQ6rtBOUHKMJhpzghAxwgu8LbvA7BDf4nYJOcBfQCU501uukQCc4UeMEJ6WDEyRMlGAXdkGIE9wl6AQnCp4YJwk6wYIQJyjZf5OhTnCyISc4paRB4CkGnODUEHeCdt1TIU5wksMq7QQlx+gtQ07wLccJ2u2bPddu8u63ftwXBN23ibk/POD+SKn7QSN2u5ur3dHVbuNqJ7nazV3tRq52fVe7rqtdy9W+WOJq+3dX+5Kr/YerfdnV9rjyZHK1Mzvtt9XrO0rTlN5Vek9putIMpZklrzjqfE7/ps3VGjp77THnFMN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDef+38kpfw2laIvQZTxYPfcZTAMbTAMYzAMazAMZzAMbzAMbfAIwXAIwXAYy/AxgvARj/ADBeBjB6AN4sE4AxM4AxC4AxK4AxG4AxO4AxB4AxJ4AxF4AxN4AxD4AxL4AxH4DxOgBjfgBjAQDjzEKhzzgLwDgbwDgHwDgXwDgPwDgfwLgAwLgQwLgIwLgYwLgEwLgUwLgMwLgcwLgCwLgSwLgKwLgawLgGwLgWwLgOwLgewLgBwLgRwLgJwLgZwLgFwLgVwLgNwLgdwPg+gHEHgHEngHEXgHE3gHEPgHEvgHEfgHE/gPEAgPEggPEQgPEwgPEIgPEogPEYgPE4gHF04dBnHANgHAtgHAdgHA9gnABgnAhgnARgnAxgnAJgnApgfAvA+DaA8R0A4zQA47sAxvcAjNMBjDMAjDMBjLMAjLMBjHMAjHMBjPMAjPMBjAsAjAsBjIsAjIsBjEsAjEsBjMsAjMsBjCsAjCsBjKsAjKsBjGsAjGsBjOsAjOsBjBsAjBsBjJsAjJsBjFsAjFsBjAUBz0G6EcB4E4CxEIDxZgBjYQDjLQDGIgDGogDGYgDG4gDGEgDGkgBGL4CxFIAxAsBYGsB4K4DxNgDj7QDGMgDGsgDGcgDG8gDGCgDGigDGSgDGOwCMdwIYfQBGC8AYCWCMAjBGAxhjAIyxAMY4AKMfwBgPYLwLwFgZwFgFwFgVwHg3gLEagLE6gLEGgPEeAGNNAOO9AMZaAMbaAMY6AMb7AIz3AxgfADDWBTA+CGCsB2B8CMD4MIDxEQBjfQBjAwBjQwDjowDGxwCMjwMYGwEYGwMYmwAYnwAwNgUwNgMwNgcwtgAwtgQwPglgTAAwJgIYkwCMyQDGFABjKoCxFYCxNYCxDYCxLYCxHYDxKQBjewBjBwBjRwBjJwBjZwBjFwBjVwDj0wDGbgDG7gDGHgDGZwCMPQGMzwIYewEYewMY+wAYnwMw9gUw9gMw9gcwDgAwDgQwPg9gHARgfAHAOBjAOATAOBTA+CKAcRiA8SUA43AA48sAxhEAxlcAjK8CGF8DMI4EML4OYHwDwPgmgHEUgHE0gHEMgHEsgHEcgHE8gHECgHEigHESgHEygHEKgHEq4bmFRUOf8XYAYxkAY1kAYzkAY3kAYwUAY0UAYyUA4x0AxjsBjD4AowVgjAQwRgEYowGMMQDGWABjHIDRD2CMBzDeBWCsDGCsAmCsCmC8G8BYDcBYHcBYA8B4D4CxJoDxXgBjLQBjbQBjHQDjfQDG+wGMDwAY6wIYHwQw1gMwPgRgfBjA+AiAsT6AsQGAsSGA8VEA42MAxscBjI0AjI0BjE0AjE8AGJsCGJsBGJsDGFsAGFsCGJ8EMCYAGBMBjEkAxmQAYwqAMRXA2ArA2BrA2AbA2BbA2A7A+BSAsT2AsQOAsSOAsROAsTOAsQuAsSuA8WkAYzcAY3cAYw8A4zMAxp4AxmcBjL0AjL0BjH0AjM8BGPsCGPsBGPsDGAcAGAcCGJ8HMA4CML4AYBwMYBwCYBwKYHwRwDgMwPgSgHE4gPFlAOMIAOMrAMZXAYyvARhHAhhfBzC+AWB8E8A4CsA4GsA4BsA4FsA4DsA4HsA4AcA4EcA4CcA4GcA4BcA4FcD4FoDxbQDjOwDGaQDGdwGM7wEYpwMYZwAYZwIYZwEYZwMY5wAY5wIY5wEY5wMYFwAYFwIYFwEYFwMYlwAYlwIYlwEYlwMYVwAYVwIYVwEYVwMY1wAY1wIY1wEY1wMYNwAYNwIYNwEYNwMYtwAYtwIYtwEYtwMY3wcw7gAw7gQw7gIw7gYw7gEw7gUw7gMw7gcwHgAwHgQwHgIwHgYwHgEwHgUwHgMwHgcwfgBg/BDA+BGA8WMA4ycAxk8BjJ8BGD8HMH4BYPwSwPgVgPEEgPFrAOM3AMZvAYzfARi/BzD+AGD8EcD4E4DxZwDjLwDGXwGMJwGMpwCMpwGMZwCMZwGM5wCM5wGMvwEYLwAYLwIYfwcwXgIw/gFgvAxg9BQLfcZMAMbMAMYsAMasAMZsAMbsAMYcAMacAMZcAMbcAMY8AMa8AMZ8AMbrAIz5AYwFAIzXAxhvADAWBDDeaIDRfYjkjoy2jOX2Jfkyu/o2Leeskh7PbKU5SnOV5inNV1qgtFBpkdJipSVKS5WWKS1XWqG0UmmV0mqlNUprldYprVfaoLRRaZPSZqUtSluVtiltV3pfaYfSTqVdSruV9ijtVdqntF/pgNJBpUNKh5WOKB1VOqZ0XOkDpQ+VPlL6WOkTpU+VPlP6XOkLpS+VvlI6ofS10jdK3yp9p/R9ySt98ENJp1OyOK92p+QMiM3WxOZoYnM1sXma2HxNbIEmtlATW6SJLdbElmhiSzWxZZrYck1shSa2UhNbpYmt1sTWaGJrNbF1mth6TWyDJrZRE9ukiW3WxLZoYls1sW2a2HZN7H1NbIcmtlMT26WJ7dbE9mhiezWxfZrYfk3sgCZ2UBM7pIkd1sSOaGJHNbFjmthxTewDTexDTewjTexjTewTTexTTewzTexzTewLTexLTewrTeyEJva1JvaNJvatJvadJva9JmafEKt7rj3SNo+0eJQvNjo6JS4yxYqyEnyR8Yn+GF90TGKs3/JbMf6Y5Eh/VFSKP9ofF58YH+eLt6KjUqzUmPioVGc72lpYbnOfVdLM5i5dc8HicjXPhtR8o2DNcyA13yRY81xIzYUEa54HqflmwZrnQ2ouLFjzAkjNtwjWvBBScxHBmhdBai4qWPNiSM3FBGteAqm5uGDNSyE1lxCseRmk5pKCNS+H1OwVrHkFpOZSgjWvhNQcIVjzKkjNpQVrXg2p+VbBmtdAar5NsOa1kJpvF6x5HaTmMoI1r4fUXFaw5g2QmssJ1rwRUnN5wZo3QWquIFjzZkjNFQVr3gKpuZJgzVshNd8hWPM2SM13Cta8HVKzT7Dm9yE1W4I174DUHClY805IzVGCNe+C1BwtWPNuSM0xgjXvgdQcK1jzXkjNcYI174PU7BeseT+k5njBmg9Aar5LsOaDkJorC9Z8CFJzFcGaD0NqripY8xFIzXcL1nwUUnM1wZqPQWquLljzcUjNNQRr/gBS8z2CNX8IqbmmYM0fQWq+V7DmjyE11xKs+RNIzbUFa/4UUnMdwZo/g9R8n2DNn0Nqvl+w5i8gNT8gWPOXkJrrCtb8FaTmBwVrPgGpuZ5gzV9Dan5IsOZvIDU/LFjzt5CaHxGs+TtIzfUFa/5esOZsKkcBV73uI2tAH/j+6WFdeRFa3//KJrZuLNn5KDjOJh7CYqU13OP9Y8krrz/Zr+4Pyds/+DggZv+S1xOeKEF/gLqimYkiNhZXjmsm9D+sOdKp2fqxpFz//SR3ErRMjUVm4bGQ7L+fNbkSfUnJMVZibHKclZIQ409Kio+yrMiE2ITYxEh/akpijOWP8aucSQmRfvXPRSYkWSm+hNgUexPJ77lyfgg8Mgn3wc+Cm5+b95eSBoHt5NJ5fxWcDKbq/rXk1Q4WyqtllTiZ2KxSCzYtr+QYnRSe+Gkbup23lHpNTyf4gOAGX1dwg5d8p6Ee0Amectbr6UAneErjBE+ngxMkTJSgH7ECcYL1BJ3gKcET42lBJ3gzxAlK9t8ZqBM8Y8gJni1pEPisASd4LsSdoF33OYgTPO2wSjtByTE6b8gJns8AJ1hbcIOvI7jBS15Dvh/oBH9z1uuFQCf4m8YJXkgHJ0iYKEE/hA3iBO8XdIK/CZ4YLwg6wVsgTlCy/y5CneBFQ07w95IGgX834AQvhbgTtOu+BHGCFxxWaScoOUZ/GHKCf2SAE7xHcIOvKbjBS94dXAvoBC+nrVev51rXd1njBO1f8nrCEyXox7RCnGAtQSd4WXLz8srVWBTiBCX7L5OX6QQzeWU3xH+PldcgsJ1cOm8Wb2g7QbvuLN6rHSyU14gT9Dis0k5Qcoyyes04QTtvejvBuwU3+GqCG7zk5z5rAJ1gNu+V1+xez7Wuz/5BoBO0f8nrCU+UoB/kDnGCNQSdoD2fpPovu1euxuIQJyjZfzm8TCeYwyu7IaYdOb0Gge3k0nlzCU4GU3Xn8l7tYKG8RpxgdodV2glKjlFurxknaOdNbyd4l+AGX1lwg5d8ok9VoBPM473ymtfrudb12T8IdIL2L3k94YkS9Fe9QJxgVUEnaM8nqf7L65WrsSTECUr2Xz4v0wnm88puiGnHdV6DwHZy6bz5BSeDqbrze692sFBeI04wr8Mq7QQlx6iA14wTtPOmtxOMFdzg4wQ3eMlntcYDneD13iuvN3g917o++weBTtD+Ja8nPFGC/jI4iBOMF3SC9nyS6r8bvHI1loI4Qcn+K+hlOsGCXtkNMe240WsQ2E4unfcmwclgqu6bvFc7WCivESd4g8Mq7QQlx6iQ14wTtPOmtxOMFNzgowQ3eMlv4YgBOsGbvVdeC3s917o++weBTtD+Ja8nPFGC/rpYiBOMEXSC9nyS6r/CXrkaS0OcoGT/3eJlOsFbvLIbYtpRxGsQ2E4unbeo4GQwVXdR79UOFsprxAkWdlilnaDkGBXzmnGCdt70doJ3CG7wdwpu8JLfr2gBnWBx75XXEl7Pta7P/kGgE7R/yesJT5Sgv1Ae4gQtQSdozyep/ivhlavxNogTlOy/kl6mEyzpld0Q0w6v1yCwnVw6bynByWCq7lLeqx0slNeIEyzhsEo7QckxivCacYJ23vR2guUFN/gKght8RUEnWAnoBEt7r7ze6vVc6/rsHwQ6QfuXvJ7wRAl2YZeBOMFKgk7Qnk9S/XerV67GMhAnKNl/t3mZTvA2r+yGmHbc7jUIbCeXzltGcDKYqruM92oHC+U14gRvdVilnaDkGJX1mnGCdt70doK3C27wZQQ3+LKCTrAc0AmW8155Le/1XOv67B8EOkH7l7ye8EQJdmGXgzjBcoJO0J5PUv1X3itYI8QJSvZfBS/TCVbwym6IaUdFr0FgO7l03kqCk8FU3ZW8VztYKK8RJ1jeYZV2gpJjdIfXjBO086a3E4wQ3OBLC27wtwo6wduATvBOr5PT67nW9dk/CHSC9i95PeGJEvRODHGCtwk6QXs+SfWfzyu4aUGcoGT/WV6mE7S8shti2hHpNQhsJ5fOGyU4GUzVHeW92sFCeY04QZ/DKu0EJcco2mvGCdp509sJlhDc4EsKbvBeQSdYCugEY7xXXmO9nmtdn/2DQCdo/5LXE54owS7sShAnWErQCdrzSar/Yr2Cb69AnKBk/8V5mU4wziu7IaYdfq9BYDu5dN54wclgqu5479UOFsprxAnGOqzSTlByjO7ymnGCdt70doJFBDf4ooIbfDFBJ1gc6AQre6+8VvF6rnV99g8CnaD9S15PeKIEu7DvhDjB4oJO0J5PUv1XxSv4XhvECUr2X1Uv0wlW9cpuiGnH3V6DwHZy6bzVBCeDqbqrea92sFBeI06wisMq7QQlx6i614wTtPOmtxMsJLjB3yy4wRcWdIK3AJ1gDe+V13u8nmtdn/2DQCdo/5LXE54oQV+dgzjBWwSdoD2fpPrvHq/ghSyIE5Tsv5pephOs6ZXdENOOe70Gge3k0nlrCU4GU3XX8l7tYKG8RpzgPQ6rtBOUHKPaXjNO0M6b3k5wa2G5Db6g4AZ/o6ATvAnoBOt4r7ze5/Vc6/rsHwQ6QfuXvJ7wRAl2YUdBnOBNgk7Qnk9S/XefV/CWK4gTlOy/+71MJ3i/V3ZDTDse8BoEtpNL560rOBlM1V3Xe7WDhfIacYL3OazSTlByjB70mnGCdt5STvtmz7WbvPutH/cFQfdtYu4PD7g/Uup+0IjdLuFqF3a1b3C187ra2V1tj6t9oeTV9mlX+ydX+21X+x1Xe5qr/a6r/Z6rPd3VnuFqz3Ta9dT/PKT0sNIjSvWVGig1VHrUe8VR53P61+P8f2vo7LXHnFMM5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDef938orfQ2naYnQZzxZPPQZTwEYTwMYzwAYzwIYzwEYzwMYfwMwXgAwXgQw/g5gvARg/APAeBnA6AF4s0wAxswAxiwAxqwAxmwAxuwAxhwAxpwAxlwAxtwAxjwAxrwAxnwAxusAjPkBjAUAjDMLhT7jLADjbADjHADjXADjPADjfADjAgDjQgDjIgDjYgDjEgDjUgDjMgDjcgDjCgDjSgDjKgDjagDjGgDjWgDjOgDjegDjBgDjRgDjJgDjZgDjFgDjVgDjNgDjdgDj+wDGHQDGnQDGXQDG3QDGPQDGvQDGfQDG/QDGAwDGgwDGQwDGwwDGIwDGowDGYwDG4wDG0YVDn3EMgHEsgHEcgHE8gHECgHEigHESgHEygHEKgHEqgPEtAOPbAMZ3AIzTAIzvAhjfAzBOBzDOADDOBDDOAjDOBjDOATDOBTDOAzDOBzAuADAuBDAuAjAuBjAuATAuBTAuAzAuBzCuADCuBDCuAjCuBjCuATCuBTCuAzCuBzBuADBuBDBuAjBuBjBuATBuBTAWBDwH6UYA400AxkIAxpsBjIUBjLcAGIsAGIsCGIsBGIsDGEsAGEsCGL0AxlIAxggAY2kA460AxtsAjLcDGMsAGMsCGMsBGMsDGCsAGCsCGCsBGO8AMN4JYPQBGC0AYySAMQrAGA1gjAEwxgIY4wCMfgBjPIDxLgBjZQBjFQBjVQDj3QDGagDG6gDGGgDGewCMNQGM9wIYawEYawMY6wAY7wMw3g9gfADAWBfA+CCAsR6A8SEA48MAxkcAjPUBjA0AjA0BjI8CGB8DMD4OYGwEYGwMYGwCYHwCwNgUwNgMwNgcwNgCwNgSwPgkgDEBwJgIYEwCMCYDGFMAjKkAxlYAxtYAxjYAxrYAxnYAxqcAjO0BjB0AjB0BjJ0AjJ0BjF0AjF0BjE8DGLsBGLsDGHsAGJ8BMPYEMD4LYOwFYOwNYOwDYHwOwNgXwNgPwNgfwDgAwDgQwPg8gHEQgPEFAONgAOMQAONQAOOLAMZhAMaXAIzDAYwvAxhHABhfATC+CmB8DcA4EsD4OoDxDQDjmwDGUQDG0QDGMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqYTnFhYNfcbbAYxlAIxlAYzlAIzlAYwVAIwVAYyVAIx3ABjvBDD6AIwWgDESwBgFYIwGMMYAGGMBjHEARj+AMR7AeBeAsTKAsQqAsSqA8W4AYzUAY3UAYw0A4z0AxpoAxnsBjLUAjLUBjHUAjPcBGO8HMD4AYKwLYHwQwFgPwPgQgPFhAOMjAMb6AMYGAMaGAMZHAYyPARgfBzA2AjA2BjA2ATA+AWBsCmBsBmBsDmBsAWBsCWB8EsCYAGBMBDAmARiTAYwpAMZUAGMrAGNrAGMbAGNbAGM7AONTAMb2AMYOAMaOAMZOAMbOAMYuAMauAManAYzdAIzdAYw9AIzPABh7AhifBTD2AjD2BjD2ATA+B2DsC2DsB2DsD2AcAGAcCGB8HsA4CMD4AoBxMIBxCIBxKIDxRQDjMADjSwDG4QDGlwGMIwCMrwAYXwUwvgZgHAlgfB3A+AaA8U0A4ygA42gA4xgA41gA4zgA43gA4wQA40QA4yQA42QA4xQA41QA41sAxrcBjO8AGKcBGN8FML4HYJwOYJwBYJwJYJwFYJwNYJwDYJwLYJwHYJwPYFwAYFwIYFwEYFwMYFwCYFwKYFwGYFwOYFwBYFwJYFwFYFwNYFwDYFwLYFwHYFwPYNwAYNwIYNwEYNwMYNwCYNwKYNwGYNwOYHwfwLgDwLgTwLgLwLgbwLgHwLgXwLgPwLgfwHgAwHgQwHgIwHgYwHgEwHgUwHgMwHgcwPgBgPFDAONHAMaPAYyfABg/BTB+BmD8HMD4BYDxSwDjVwDGEwDGrwGM3wAYvwUwfgdg/B7A+AOA8UcA408Axp8BjL8AGH8FMJ4EMJ4CMJ4GMJ4BMJ4FMJ4DMJ4HMP4GYLwAYLwIYPwdwHgJwPgHgPEygNFTLPQZMwEYMwMYswAYswIYswEYswMYcwAYcwIYcwEYcwMY8wAY8wIY8wEYrwMw5gcwFgAwXg9gvAHAWBDAeKMBRvchkjsy2jKW2/L5Mrv6Ni3nY16P53GlRkqNlZooPaHUVKmZUnOlFkotlZ5USlBKVEpSSlZKUUpVaqXUWqmNUluldkpPKbVX6qDUUamTUmelLkpdlZ5W6qbUXamH0jNKPZWeVeql1Fupj9JzSn2V+in1VxqgNFDpeaVBSi8oDVYaojRU6UWlYUovKQ1XellphNIrSq8qvaY0Uul175U+eMPrdEoW59XulJwBscc1sUaaWGNNrIkm9oQm1lQTa6aJNdfEWmhiLTWxJzWxBE0sURNL0sSSNbEUTSxVE2ulibXWxNpoYm01sXaa2FOaWHtNrIMm1lET66SJddbEumhiXTWxpzWxbppYd02shyb2jCbWUxN7VhPrpYn11sT6aGLPaWJ9NbF+mlh/TWyAJjZQE3teExukib2giQ3WxIZoYkM1sRc1sWGa2Eua2HBN7GVNbIQm9oom9qom9pomNlITe10Ts0+I1T3XHmmbR1o8yhcbHZ0SF5liRVkJvsj4RH+MLzomMdZv+a0Yf0xypD8qKsUf7Y+LT4yP88Vb0VEpVmpMfFSqsx81KC63uT/mNbO5S9fcULDmxyE1PypYcyNIzY8J1twYUvPjgjU3gdTcSLDmJyA1NxasuSmk5iaCNTeD1PyEYM3NITU3Fay5BaTmZoI1t4TU3Fyw5ichNbcQrDkBUnNLwZoTITU/KVhzEqTmBMGakyE1JwrWnAKpOUmw5lRIzcmCNbeC1JwiWHNrSM2pgjW3gdTcSrDmtpCaWwvW3A5ScxvBmp+C1NxWsOb2kJrbCdbcAVLzU4I1d4TU3F6w5k6QmjsI1twZUnNHwZq7QGruJFhzV0jNnQVrfhpScxfBmrtBau4qWHN3SM1PC9bcA1JzN8Gan4HU3F2w5p6QmnsI1vwspOZnBGvuBam5p2DNvSE1PytYcx9Izb0Ea34OUnNvwZr7QmruI1hzP0jNzwnW3B9Sc1/BmgdAau4nWPNASM39BWt+HlLzAMGaB0FqHihY8wuQmp8XrHkwpOZBgjUPgdT8gmDNQyE1Dxas+UVIzUMEax4GqXmoYM0vQWp+UbDm4ZCahwnW/DKk5pcEax4BqXm4YM2vQGp+WbDmVyE1jxCs+TVIza8I1jwSUvOrgjW/LlhzNpWjgKte95E1oA98//SwrrwIre9/ZRNbN5bsfBQcZxMPYbHSGu7xftN75XWU/er+kLz9g48DYvYveT3hiRLsCSGmopmJIjYWV45rJvQ/rDnSqdmy55NU/43yytVoaiwyC4+FZP+N1uRK9CUlx1iJsclxVkpCjD8pKT7KsiITYhNiEyP9qSmJMZY/xq9yJiVE+tU/F5mQZKX4EmJT7E0kv+fK+SHwyCTcB6Plxt3n5h3jNQhsJ5fOO1ZwMpiqe6z3agcL5dWySpxMbFapBZuWV3KMxnllJ37ahm7nLaVe09MJvii4wQ8T3OAl32kYDnSC471XXid4Pde6PvsHgU7Q/iWvJzxRgl3YcRAnOFzQCdrzSar/JnjlaoyDOEHJ/pvoZTrBiV7ZDTHtmOQ1CGwnl847WXAymKp7svdqBwvlNeIEJzis0k5QcoymeM04QTtvejvBFwQ3+MGCG7zkNeShQCc41Xvl9S2v51rXZ/8g0Anav+T1hCdKsAs7HuIEhwo6QXs+SfXfW165GuMhTlCy/972Mp3g217ZDTHteMdrENhOLp13muBkMFX3NO/VDhbKa8QJvuWwSjtByTF612vGCdp509sJDhDc4AcKbvCSdwcPAjrB97xXXqd7Pde6PvsHgU7Q/iWvJzxRgl3YlSFOcJCgE7Tnk1T/TffK1VgZ4gQl+2+Gl+kEZ3hlN8S0Y6bXILCdXDrvLMHJYKruWd6rHSyU14gTnO6wSjtByTGa7TXjBO286e0EnxPc4PsKbvCSn/vsD3SCc7xXXud6Pde6PvsHgU7Q/iWvJzxRgl3YVSFOsL+gE7Tnk1T/zfXK1VgV4gQl+2+el+kE53llN8S0Y77XILCdXDrvAsHJYKruBd6rHSyU14gTnOuwSjtByTFa6DXjBO286e0EnxXc4HsJbvCST/TpA3SCi7xXXhd7Pde6PvsHgU7Q/iWvJzxRgl3Y1SBOsI+gE7Tnk1T/LfbK1VgN4gQl+2+Jl+kEl3hlN8S0Y6nXILCdXDrvMsHJYKruZd6rHSyU14gTXOywSjtByTFa7jXjBO286e0Euwtu8D0EN3jJZ7X2BDrBFd4rryu9nmtdn/2DQCdo/5LXE54owS7sGhAn2FPQCdrzSar/VnrlaqwBcYKS/bfKy3SCq7yyG2LasdprENhOLp13jeBkMFX3Gu/VDhbKa8QJrnRYpZ2g5Bit9Zpxgnbe9HaCXQQ3+K6CG7zkt3B0AzrBdd4rr+u9nmtdn/2DQCdo/5LXE54owS7smhAn2E3QCdrzSar/1nvlaqwJcYKS/bfBy3SCG7yyG2LasdFrENhOLp13k+BkMFX3Ju/VDhbKa8QJrndYpZ2g5Bht9ppxgnbe9HaCHQQ3+I6CG7zk9yt2BjrBLd4rr1u9nmtdn/2DQCdo/5LXE54owS7sWhAn2FnQCdrzSar/tnrlaqwFcYKS/bfNy3SC27yyG2Lasd1rENhOLp33fcHJYKru971XO1gorxEnuNVhlXaCkmO0w2vGCdp509sJthXc4NsJbvBPCTrB9kAnuNN75XWX13Ot67N/EOgE7V/yesITJdiFXQfiBNsLOkF7Pkn13y6vXI11IE5Qsv92e5lOcLdXdkNMO/Z4DQLbyaXz7hWcDKbq3uu92sFCeY04wV0Oq7QTlByjfV4zTtDOm95OMFVwg28luMG3FnSCbYBOcL/3yusBr+da12f/INAJ2r/k9YQnSrAL+36IE2wj6ATt+STVfwe8cjXeD3GCkv130Mt0gge9shti2nHIaxDYTi6d97DgZDBV92Hv1Q4WymvECR5wWKWdoOQYHfGacYJ23vR2gomCG3yS4AafLOgEU4BO8Kj3yusxr+da12f/INAJ2r/k9YQnSrALuy7ECaYIOkF7Pkn13zGvXI11IU5Qsv+Oe5lO8LhXdkNMOz7wGgS2k0vn/VBwMpiq+0Pv1Q4WymvECR5zWKWdoOQYfeQ14wTtvOntBFsIbvAtBTf4JwWdYALQCX7svfL6iddzreuzfxDoBO1f8nrCEyXYhV0P4gQTBJ2gPZ+k+u8Tr1yN9SBOULL/PvUyneCnXtkNMe34zGsQ2E4unfdzwclgqu7PvVc7WCivESf4icMq7QQlx+gLrxknaOdNbyf4hOAG31Rwg28m6ASbA53gl94rr195Pde6PvsHgU7Q/iWvJzxRgl3YD0OcYHNBJ2jPJ6n++8orV+PDECco2X8nvEwneMIruyGmHV97DQLbyaXzfiM4GUzV/Y33agcL5TXiBL9yWKWdoOQYfes14wTtvOntBB8X3OAbCW7wjQWdYBOgE/zOe+X1e6/nWtdn/yDQCdq/5PWEJ0qwC7s+xAk2EXSC9nyS6r/vvXI11oc4Qcn++8HLdII/eGU3xLTjR69BYDu5dN6fBCeDqbp/8l7tYKG8Rpzg9w6rtBOUHKOfvWacoJ03vZ1gA8ENvqHgBv+ooBN8DOgEf/Feef3V67nW9dk/CHSC9i95PeGJEuzCbghxgo8JOkF7Pkn1369euRobQpygZP+d9DKd4Emv7IaYdpzyGgS2k0vnPS04GUzVfdp7tYOF8hpxgr86rNJOUHKMznjNOEE7bymnfbPn2k3e/daP+4Kg+zYx94cH3B8pdT9oxG5vdbXXu9orXe3FrvZcV3u6q/2Wqz3B1R7latdztR9ytR92tR9xteu72g1c7Yau9qNO+6z6n3NK55V+U7qgdFHpd6VL3iuOOp/Tvx7n/1tDZ6895pxiOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzjv/1Ze6Ws4TUuEPuPJ4qHPeArAeBrAeAbAeBbAeA7AeB7A+BuA8QKA8SKA8XcA4yUA4x8AxssARg/Am2UCMGYGMGYBMGYFMGYDMGYHMOYAMOYEMOYCMOYGMOYBMOYFMOYDMF4HYMwPYCwAYJxZKPQZZwEYZwMY5wAY5wIY5wEY5wMYFwAYFwIYFwEYFwMYlwAYlwIYlwEYlwMYVwAYVwIYVwEYVwMY1wAY1wIY1wEY1wMYNwAYNwIYNwEYNwMYtwAYtwIYtwEYtwMY3wcw7gAw7gQw7gIw7gYw7gEw7gUw7gMw7gcwHgAwHgQwHgIwHgYwHgEwHgUwHgMwHgcwji4c+oxjAIxjAYzjAIzjAYwTAIwTAYyTAIyTAYxTAIxTAYxvARjfBjC+A2CcBmB8F8D4HoBxOoBxBoBxJoBxFoBxNoBxDoBxLoBxHoBxPoBxAYBxIYBxEYBxMYBxCYBxKYBxGYBxOYBxBYBxJYBxFYBxNYBxDYBxLYBxHYBxPYBxA4BxI4BxE4BxM4BxC4BxK4CxIOA5SDcCGG8CMBYCMN4MYCwMYLwFwFgEwFgUwFgMwFgcwFgCwFgSwOgFMJYCMEYAGEsDGG8FMN4GYLwdwFgGwFgWwFgOwFgewFgBwFgRwFgJwHgHgPFOAKMPwGgBGCMBjFEAxmgAYwyAMRbAGAdg9AMY4wGMdwEYKwMYqwAYqwIY7wYwVgMwVgcw1gAw3gNgrAlgvBfAWAvAWBvAWAfAeB+A8X4A4wMAxroAxgcBjPUAjA8BGB8GMD4CYKwPYGwAYGwIYHwUwPgYgPFxAGMjAGNjAGMTAOMTAMamAMZmAMbmAMYWAMaWAMYnAYwJAMZEAGMSgDEZwJgCYEwFMLYCMLYGMLYBMLYFMLYDMD4FYGwPYOwAYOwIYOwEYOwMYOwCYOwKYHwawNgNwNgdwNgDwPgMgLEngPFZAGMvAGNvAGMfAONzAMa+AMZ+AMb+AMYBAMaBAMbnAYyDAIwvABgHAxiHABiHAhhfBDAOAzC+BGAcDmB8GcA4AsD4CoDxVQDjawDGkQDG1wGMbwAY3wQwjgIwjgYwjgEwjgUwjgMwjgcwTgAwTgQwTgIwTgYwTgEwTiU8t7Bo6DPeDmAsA2AsC2AsB2AsD2CsAGCsCGCsBGC8A8B4J4DRB2C0AIyRAMYoAGM0gDEGwBgLYIwDMPoBjPEAxrsAjJUBjFUAjFUBjHcDGKsBGKsDGGsAGO8BMNYEMN4LYKwFYKwNYKwDYLwPwHg/gPEBAGNdAOODAMZ6AMaHAIwPAxgfATDWBzA2ADA2BDA+CmB8DMD4OICxEYCxMYCxCYDxCQBjUwBjMwBjcwBjCwBjSwDjkwDGBABjIoAxCcCYDGBMATCmAhhbARhbAxjbABjbAhjbARifAjC2BzB2ADB2BDB2AjB2BjB2ATB2BTA+DWDsBmDsDmDsAWB8BsDYE8D4LICxF4CxN4CxD4DxOQBjXwBjPwBjfwDjAADjQADj8wDGQQDGFwCMgwGMQwCMQwGMLwIYhwEYXwIwDgcwvgxgHAFgfAXA+CqA8TUA40gA4+sAxjcAjG8CGEcBGEcDGMcAGMcCGMcBGMcDGCcAGCcCGCcBGCcDGKcAGKcCGN8CML4NYHwHwDgNwPgugPE9AON0AOMMAONMAOMsAONsAOMcAONcAOM8AON8AOMCAONCAOMiAONiAOMSAONSAOMyAONyAOMKAONKAOMqAONqAOMaAONaAOM6AON6AOMGAONGAOMmAONmAOMWAONWAOM2AON2AOP7AMYdAMadAMZdAMbdAMY9AMa9AMZ9AMb9AMYDAMaDAMZDAMbDAMYjAMajAMZjAMbjAMYPAIwfAhg/AjB+DGD8BMD4KYDxMwDj5wDGLwCMXwIYvwIwngAwfg1g/AbA+C2A8TsA4/cAxh8AjD8CGH8CMP4MYPwFwPgrgPEkgPEUgPE0gPEMgPEsgPEcgPE8gPE3AOMFAONFAOPvAMZLAMY/AIyXAYyeYqHPmAnAmBnAmAXAmBXAmA3AmB3AmAPAmBPAmAvAmBvAmAfAmBfAmA/AeB2AMT+AsQCA8XoA4w0AxoIAxhsNMLoPkdyR0Zax3Fa0L7Orb9Ny/uH1eC4reUqpuFJmpSxKWZWyKWVXyqGUUymXUm6lPEp5lfIpXaeUX6mA0vVKNygVVLpR6SalQko3KxVWukWpiFJRpWJKxZVKKJVU8iqVUopQKq10q9JtSrcrlVEqq1ROqbxSBaWKSpWU7lC6U8mnZClFKkUpRSvFKMUqxSn5leKV7lKqrFRFqWqpK31wdymnU7I4r3an5AyIXdbE7E4LjGXSxDJrYlk0sayaWDZNLLsmlkMTy6mJ5dLEcmtieTSxvJpYPk3sOk0svyZWQBO7XhO7QRMrqIndqIndpIkV0sRu1sQKa2K3aGJFNLGimlgxTay4JlZCEyupiXk1sVKaWIQmVloTu1UTu00Tu10TK6OJldXEymli5TWxCppYRU2skiZ2hyZ2pybm08QsTSxSE4vSxKI1sRhNLFYTi9PE/JpYvCZ2lyZWWROroolV1cTsE2J1z7VH2uaRFo/yxUZHp8RFplhRVoIvMj7RH+OLjkmM9Vt+K8Yfkxzpj4pK8Uf74+IT4+N88VZ0VIqVGhMflersR68VF3zT12tmc5eueaRgzZchNb8uWLOnFKPmNwRrzgSp+U3BmjNDah4lWHMWSM2jBWvOCql5jGDN2SA1jxWsOTuk5nGCNeeA1DxesOackJonCNacC1LzRMGac0NqniRYcx5IzZMFa84LqXmKYM35IDVPFaz5OkjNt8ndOGXlh9R8u2DNBSA1lxGs+XpIzWUFa74BUnM5wZoLQmouL1jzjZCaKwjWfBOk5oqCNReC1FxJsOabITXfIVhzYUjNdwrWfAukZp9gzUUgNVuCNReF1BwpWHMxSM1RgjUXh9QcLVhzCUjNMYI1l4TUHCtYsxdSc5xgzaUgNfsFa46A1BwvWHNpSM13CdZ8K6TmyoI13wapuYpgzbdDaq4qWHMZSM13C9ZcFlJzNcGay0Fqri5Yc3lIzTUEa64AqfkewZorQmquKVhzJUjN9wrWfAek5lqCNd8Jqbm2YM0+SM11BGu2IDXfJ1hzJKTm+wVrjoLU/IBgzdGQmusK1hwDqflBwZpjITXXE6w5DlLzQ4I1+yE1PyxYczyk5kcEa74LUnN9wZorQ2puIFhzFUjNDQVrripYczaVo4CrXveRNaAPfP/0sK68CK3vf2UTWzeW7HwUHGcTD2Gx0hru8a5Wysltv2byXP2QvP2DjwNi9i95PeGJEuwJ4bGKZiaK2FhcOa6Z0P+w5kinZqtaKcE32+VOgpapscgsPBaS/VdDkyvRl5QcYyXGJsdZKQkx/qSk+CjLikyITYhNjPSnpiTGWP4Yv8qZlBDpV/9cZEKSleJLiE2xN5H8nivnh8Ajk3Af1BDc/Ny895QyCGwnl85bU3AymKq7ZqmrHSyUV8sqcTKxWaUW7L+vmgiO0b3CEz9tQ7fz2sOUnk7wQcENvp7gBi/5TsPDQCdYy1mvtQOdYC2NE6ydDk6QMFGCXdiNIE7wYUEnWEvwxFhb0Ak2gjhByf6rA3WCdQw5wftKGQS+z4ATvD/EnaBd9/0QJ1jbYZV2gpJj9IAhJ/hABjjB+wQ3+PsFN3jJa8h1gU6wrrNeHwx0gnU1TvDBdHCChIkS7MJuAnGCdQWdYF3BE+ODgk6wCcQJSvZfPagTrGfICT5UyiDwQwac4MMh7gTtuh+GOMEHHVZpJyg5Ro8YcoKPZIATvFdwg68luMFL3h1cB+gE6zvrtUGgE6yvcYIN0sEJEiZKsAu7KcQJ1hF0gvUFT4wNBJ1gU4gTlOy/hlAn2NCQE3y0lEHgRw04wcdC3AnadT8GcYINHFZpJyg5Ro8bcoKPZ4ATrC64wdcQ3OAlP/dZE+gEGznrtXGgE2ykcYKN08EJEiZKsAu7OcQJ1hR0go0ET4yNBZ1gc4gTlOy/JlAn2MSQE3yilEHgJww4waYh7gTtuptCnGBjh1XaCUqOUTNDTrBZBjjBKoIbfFXBDV7yiT7VgE6wubNeWwQ6weYaJ9giHZwgYaIEu7BbQpxgNUEn2FzwxNhC0Am2hDhByf5rCXWCLQ05wSdLGQR+0oATTAhxJ2jXnQBxgi0cVmknKDlGiYacYGIGOEG/4AYfL7jBSz6rtTLQCSY56zU50AkmaZxgcjo4QcJECXZhJ0CcYGVBJ5gkeGJMFnSCCRAnKNl/KVAnmGLICaaWMgicasAJtgpxJ2jX3QriBJMdVmknKDlGrQ05wdYZ4ASjBTf4GMENXvJbOOKATrCNs17bBjrBNhon2DYdnCBhogS7sJMgTjBO0Am2ETwxthV0gkkQJyjZf+2gTrCdISf4VCmDwE8ZcILtQ9wJ2nW3hzjBtg6rtBOUHKMOhpxghwxwgj7BDd4S3OAlv18xCugEOzrrtVOgE+yocYKd0sEJEiZK0O/JQJxglKAT7Ch4Yuwk6ARTIE5Qsv86Q51gZ0NOsEspg8BdDDjBriHuBO26u0KcYCeHVdoJSo7R04ac4NMZ4AQrCm7wlQQ3+Dskv00J6AS7Oeu1e6ATtH8Q6AS7p4MTJEyUYBd2K4gTvFPQCXYTPDF2F3SCrSBOULL/ekCdYA9DTvCZUgaBnzHgBHuGuBO06+4JcYLdHVZpJyg5Rs8acoLPZoATLCu4wZcT3ODLS35PLtAJ9nLWa+9AJ9hL4wR7p4MTJEyUYBd2G4gTrCDoBHsJnhh7CzrBNhAnKNl/faBOsI8hJ/hcKYPAzxlwgn1D3AnadfeFOMHeDqu0E5Qco36GnGC/9HSCzqZ8m+CmfLugeytTVM7ETC3Oc4L9nfU6INAJ9tc4wQEmnSBoogR9n1aoO0HNhA7WCfYXPDEOEHSC7SBOULL/BkKd4EBDTvD5UgaBnzfgBAeFuBO06x4EcYIDHFZpJyg5Ri8YcoIvZMB7ghOLy5mFScXlzMJkOfdmTQE6wcHOeh0S6AQHa5zgkHR4T5AwUYJd2O0h7wlOEXSCgwVPjEMEnWB7iBOU7L+hUCc41JATfLGUQeAXDTjBYSHuBO26h0Gc4BCHVdoJSo7RS4ac4EsZ4ATHCm7w4wQ3+PGCTnAC0AkOd9bry4FOcLjGCb6cDk6QMFGCXdgdIU5wgqATHC54YnxZ0Al2hDhByf4bAXWCIww5wVdKGQR+xYATfDXEnaBd96sQJ/iywyrtBCXH6DVDTvC1DHCCbwpu8KMEN/jRgk5wDNAJjnTW6+uBTnCkxgm+ng5OkDBRgv7sJsQJjhF0giMFT4yvCzrBzhAnKNl/b0Cd4BuGnOCbpQwCv2nACY4KcSdo1z0K4gRfd1ilnaDkGI025ARHZ4ATfE1wgx8puMG/LugE3wA6wTHOeh0b6ATHaJzg2HRwgoSJEuzC7gpxgm8IOsExgifGsYJOsCvECUr23zioExxnyAmOL2UQeLwBJzghxJ2gXfcEiBMc67BKO0HJMZpoyAlOdJyg3b7Zc+0m737rx31B0G4PcbUHuNq9Xe3urnYnV7utq53sardwtRu72g1c7Qdd7dqudnVX+6z3avucq33e1f7N1b7gal90tX93tS857Unq35msNEVpqtJbSm8rvaM0rdQVR53P6V+P8/+tobPXHnNOMZw3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDec938rr/Q1nKYlQp/xZPHQZzwFYDwNYDwDYDwLYDwHYDwPYPwNwHgBwHgRwPg7gPESgPEPAONlAKMH4M0yARgzAxizABizAhizARizAxhzABhzAhhzARhzAxjzABjzAhjzARivAzDmBzAWADDOLBT6jLMAjLMBjHMAjHMBjPMAjPMBjAsAjAsBjIsAjIsBjEsAjEsBjMsAjMsBjCsAjCsBjKsAjKsBjGsAjGsBjOsAjOsBjBsAjBsBjJsAjJsBjFsAjFsBjNsAjNsBjO8DGHcAGHcCGHcBGHcDGPcAGPcCGPcBGPcDGA8AGA8CGA8BGA8DGI8AGI8CGI8BGI8DGEcXDn3GMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGtwCMbwMY3wEwTgMwvgtgfA/AOB3AOAPAOBPAOAvAOBvAOAfAOBfAOA/AOB/AuADAuBDAuAjAuBjAuATAuBTAuAzAuBzAuALAuBLAuArAuBrAuAbAuBbAuA7AuB7AuAHAuBHAuAnAuBnAuAXAuBXAWBDwHKQbAYw3ARgLARhvBjAWBjDeAmAsAmAsCmAsBmAsDmAsAWAsCWD0AhhLARgjAIylAYy3AhhvAzDeDmAsA2AsC2AsB2AsD2CsAGCsCGCsBGC8A8B4J4DRB2C0AIyRAMYoAGM0gDEGwBgLYIwDMPoBjPEAxrsAjJUBjFUAjFUBjHcDGKsBGKsDGGsAGO8BMNYEMN4LYKwFYKwNYKwDYLwPwHg/gPEBAGNdAOODAMZ6AMaHAIwPAxgfATDWBzA2ADA2BDA+CmB8DMD4OICxEYCxMYCxCYDxCQBjUwBjMwBjcwBjCwBjSwDjkwDGBABjIoAxCcCYDGBMATCmAhhbARhbAxjbABjbAhjbARifAjC2BzB2ADB2BDB2AjB2BjB2ATB2BTA+DWDsBmDsDmDsAWB8BsDYE8D4LICxF4CxN4CxD4DxOQBjXwBjPwBjfwDjAADjQADj8wDGQQDGFwCMgwGMQwCMQwGMLwIYhwEYXwIwDgcwvgxgHAFgfAXA+CqA8TUA40gA4+sAxjcAjG8CGEcBGEcDGMcAGMcCGMcBGMcDGCcAGCcCGCcBGCcDGKcAGKcSnltYNPQZbwcwlgEwlgUwlgMwlgcwVgAwVgQwVgIw3gFgvBPA6AMwWgDGSABjFIAxGsAYA2CMBTDGARj9AMZ4AONdAMbKAMYqAMaqAMa7AYzVAIzVAYw1AIz3ABhrAhjvBTDWAjDWBjDWATDeB2C8H8D4AICxLoDxQQBjPQDjQwDGhwGMjwAY6wMYGwAYGwIYHwUwPgZgfBzA2AjA2BjA2ATA+ASAsSmAsRmAsTmAsQWAsSWA8UkAYwKAMRHAmARgTAYwpgAYUwGMrQCMrQGMbQCMbQGM7QCMTwEY2wMYOwAYOwIYOwEYOwMYuwAYuwIYnwYwdgMwdgcw9gAwPgNg7AlgfBbA2AvA2BvA2AfA+ByAsS+AsR+AsT+AcQCAcSCA8XkA4yAA4wsAxsEAxiEAxqEAxhcBjMMAjC8BGIcDGF8GMI4AML4CYHwVwPgagHEkgPF1AOMbAMY3AYyjAIyjAYxjAIxjAYzjAIzjAYwTAIwTAYyTAIyTAYxTAIxTAYxvARjfBjC+A2CcBmB8F8D4HoBxOoBxBoBxJoBxFoBxNoBxDoBxLoBxHoBxPoBxAYBxIYBxEYBxMYBxCYBxKYBxGYBxOYBxBYBxJYBxFYBxNYBxDYBxLYBxHYBxPYBxA4BxI4BxE4BxM4BxC4BxK4BxG4BxO4DxfQDjDgDjTgDjLgDjbgDjHgDjXgDjPgDjfgDjAQDjQQDjIQDjYQDjEQDjUQDjMQDjcQDjBwDGDwGMHwEYPwYwfgJg/BTA+BmA8XMA4xcAxi8BjF8BGE8AGL8GMH4DYPwWwPgdgPF7AOMPAMYfAYw/ARh/BjD+AmD8FcB4EsB4CsB4GsB4BsB4FsB4DsB4HsD4G4DxAoDxIoDxdwDjJQDjHwDGywBGT7HQZ8wEYMwMYMwCYMwKYMwGYMwOYMwBYMwJYMwFYMwNYMwDYMwLYMwHYLwOwJgfwFgAwHg9gPEGAGNBAOONBhjdh0juyGjLWG7L78vs6tu0nO+W8njeU5quNENpptIspdlKc5TmKs1Tmq+0QGmh0iKlxUpLlJYqLVNarrRCaaXSKqXVSmuU1iqtU1qvtEFpo9Impc1KW5S2Km1T2q70vtIOpZ1Ku5R2K+1R2qu0T2m/0gGlg0qHlA4rHVE6qnRM6bjSB0ofKn2k9LHSJ0qfKn2m9LnSF0pfKn2ldKLUlT74upTTKVmcV7tTcgbE3tPEpmtiMzSxmZrYLE1stiY2RxObq4nN08Tma2ILNLGFmtgiTWyxJrZEE1uqiS3TxJZrYis0sZWa2CpNbLUmtkYTW6uJrdPE1mtiGzSxjZrYJk1ssya2RRPbqolt08S2a2Lva2I7NLGdmtguTWy3JrZHE9urie3TxPZrYgc0sYOa2CFN7LAmdkQTO6qJHdPEjmtiH2hiH2piH2liH2tin2hin2pin2lin2tiX2hiX2piX2liJzQx+4RY3XPtkbZ5pMWjfLHR0SlxkSlWlJXgi4xP9Mf4omMSY/2W34rxxyRH+qOiUvzR/rj4xPg4X7wVHZVipcbER6U6+9Gjcm+CWu+WMrO5S9f8mGDN70Fqflyw5umQmhsJ1jwDUnNjwZpnQmpuIljzLEjNTwjWPBtSc1PBmudAam4mWPNcSM3NBWueB6m5hWDN8yE1txSseQGk5icFa14IqTlBsOZFkJoTBWteDKk5SbDmJZCakwVrXgqpOUWw5mWQmlMFa14OqbmVYM0rIDW3Fqx5JaTmNoI1r4LU3Faw5tWQmtsJ1rwGUvNTgjWvhdTcXrDmdZCaOwjWvB5Sc0fBmjdAau4kWPNGSM2dBWveBKm5i2DNmyE1dxWseQuk5qcFa94KqbmbYM3bIDV3F6x5O6TmHoI1vw+p+RnBmndAau4pWPNOSM3PCta8C1JzL8Gad0Nq7i1Y8x5IzX0Ea94Lqfk5wZr3QWruK1jzfkjN/QRrPgCpub9gzQchNQ8QrPkQpOaBgjUfhtT8vGDNRyA1DxKs+Sik5hcEaz4GqXmwYM3HITUPEaz5A0jNQwVr/hBS84uCNX8EqXmYYM0fQ2p+SbDmTyA1Dxes+VNIzS8L1vwZpOYRgjV/Dqn5FcGav4DU/KpgzV9Can5NsOavIDWPFKz5hGDN2VSOAq563UfWgD7w/dPDuvIitL7/lU1s3Viy81FwnE08hMVKa7jH+5tSV16/tV8zea5+SN7+wccBMfuXvJ7wRAn6RoWKZiaK2FhcOa6Z0P+w5kinZuubUnL9963cSdAyNRaZhcdCsv++0+RK9CUlx1iJsclxVkpCjD8pKT7KsiITYhNiEyP9qSmJMZY/xq9yJiVE+tU/F5mQZKX4EmJT7E0kv+fK+SHwyCTcB98Jbn5u3u9LGQS2k0vn/UFwMpiq+4dSVztYKK+WVeJkYrNKLdi0vJJj9KPwxE/b0O289jClpxN8SXCDHy64wUu+0zAC6AR/ctbrz4FO8CeNE/w5HZwgYaIEfSsjxAmOEHSCPwmeGH8WdII9IE5Qsv9+gTrBXww5wV9LGQT+1YATPBniTtCu+yTECf7ssEo7QckxOmXICZ7KACc4RHCDHyq4wUteQx4GdIKnnfV6JtAJntY4wTPp4AQJEyXoDztAnOAwQSd4WvDEeEbQCfaEOEHJ/jsLdYJnDTnBc6UMAp8z4ATPh7gTtOs+D3GCZxxWaScoOUa/GXKCv2WAE3xecIMfJLjBS94dPBjoBC846/VioBO8oHGCF9PBCRImStAfh4Q4wcGCTvCC4InxoqAT7AVxgpL99zvUCf5uyAleKmUQ+JIBJ/hHiDtBu+4/IE7wosMq7QQlx+iyISd4OQOcYD/BDb6/4AYv+bnPgUAn6Im48pIpwnOt67N/EOgE7V/yesITJegHJkCc4EBBJ2jPJ6n+yxQhV2MfiBOU7L/MEUwnmDlCdkNMO7JEGAS2k0vnzSo4GUzVnTXiagcL5TXiBDM5rNJOUHKMsglP/LQN3c6b3k6wt+AG30dwg5d8ok9foBPM7qzXHIFOMLvGCeZIBydImChBP1IJ4gT7CjrB7IInxhyCTrAvxAlK9l9OqBPMacgJ5oowCJzLgBPMHeJO0K47d8TVDhbKa8QJ5nBYpZ2g5BjlMeQE82SAE3xGcIPvKbjBSz6rtRfQCeZ11mu+QCeYV+ME86WDEyRMlKAfughxgr0EnWBewRNjPkEn2B/iBCX77zqoE7zOkBPMH2EQOL8BJ1ggxJ2gXXeBiKsdLJTXiBPM57BKO0HJMbrekBO8PgOc4NOCG3w3wQ1e8ls4egCd4A3Oei0Y6ARv0DjBgungBAkTJejHMkOcYA9BJ3iD4ImxoKATHAhxgpL9dyPUCd5oyAneFGEQ+CYDTrBQiDtBu+5CEVc7WCivESdY0GGVdoKSY3SzISd4cwY4wU6CG3xnwQ1e8vsVuwKdYGFnvd4S6AQLa5zgLengBAkTJegvboA4wa6CTrCw4InxFkEnOAjiBCX7rwjUCRYx5ASLRhgELmrACRYLcSdo110s4moHC+U14gRvcVilnaDkGBU35ASLZ4ATfEpwg28vuMF3EHSCHYFOsISzXksGOsESGidYMh2cIGGiBP3VThAn2FHQCZYQPDGWFHSCgyFOULL/vFAn6DXkBEtFGAQuZcAJRoS4E7Trjoi42sFCeY04wZIOq7QTlByj0oacYOkMcIKtBTf4NoIbfFtBJ9gO6ARvddbrbYFO8FaNE7wtHZwgYaIE/eWPECfYTtAJ3ip4YrxN0AkOhThByf67HeoEbzfkBMtEGAQuY8AJlg1xJ2jXXTbiagcL5TXiBG9zWKWdoOQYlTPkBMtlgBNMFtzgUwQ3+FRBJ9gK6ATLO+u1QqATLK9xghXSwQkSJkrQXw8NcYKtBJ1gecETYwVBJzgM4gQl+68i1AlWNOQEK0UYBK5kwAneEeJO0K77joirHSyU14gTrOCwSjtByTG605ATvDMDnOCTght8guAGnyjoBJOATtDnrFcr0An6NE7QSgcnSJgowS7s4RAnmCToBH2CJ0ZL0AkOhzhByf6LhDrBSENOMCrCIHCUAScYHeJO0K47OuJqBwvlNeIELYdV2glKjlGMIScYkwFOsJngBt9ccINvIegEWwKdYKyzXuMCnWCsxgnGpYMTJEyUYBf2CIgTbCnoBGMFT4xxgk5wBMQJSvafH+oE/YacYHyEQeB4A07wrhB3gnbdd0Vc7WChvEacYJzDKu0EJceosiEnWDkDnGBjwQ2+ieAG/4SgE2wKdIJVnPVaNdAJVtE4warp4AQJEyXYhf0qxAk2FXSCVQRPjFUFneCrECco2X93Q53g3YacYLUIg8DVDDjB6iHuBP81UBFXO1gorxEnWNVhlXaCkmNUw5ATrJEBTvBRwQ3+McEN/nFBJ9gI6ATvcdZrzUAneI/GCdZMBydImCjBLuyRECfYSNAJ3iN4Yqwp6ARHQpygZP/dC3WC9xpygrUiDALXMuAEa4e4E7Trrh1xtYOF8hpxgjUdVmknKDlGdQw5wTqOE/zXswU9127y7rd+3BcE3beJuT884P5IqftBI3b7Fle7oKudz9XO4WpncrXt74VOa59xtX92tb91tSe52pNd7Smu9lRX+y1X+21X+x1Xe5rTvk9x3a/0gFJdpQeV6ik9pPRwxBVHnc/p37S5WiNtYgUc1YXGM5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDec9387r/Q1nKYlQp/xZPHQZzwFYDwNYDwDYDwLYDwHYDwPYPwNwHgBwHgRwPg7gPESgPEPAONlAKMH4M0yARgzAxizABizAhizARizAxhzABhzAhhzARhzAxjzABjzAhjzARivAzDmBzAWADDOLBT6jLMAjLMBjHMAjHMBjPMAjPMBjAsAjAsBjIsAjIsBjEsAjEsBjMsAjMsBjCsAjCsBjKsAjKsBjGsAjGsBjOsAjOsBjBsAjBsBjJsAjJsBjFsAjFsBjNsAjNsBjO8DGHcAGHcCGHcBGHcDGPcAGPcCGPcBGPcDGA8AGA8CGA8BGA8DGI8AGI8CGI8BGI8DGEcXDn3GMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGtwCMbwMY3wEwTgMwvgtgfA/AOB3AOAPAOBPAOAvAOBvAOAfAOBfAOA/AOB/AuADAuBDAuAjAuBjAuATAuBTAuAzAuBzAuALAuBLAuArAuBrAuAbAuBbAuA7AuB7AuAHAuBHAuAnAuBnAuAXAuBXAWBDwHKQbAYw3ARgLARhvBjAWBjDeAmAsAmAsCmAsBmAsDmAsAWAsCWD0AhhLARgjAIylAYy3AhhvAzDeDmAsA2AsC2AsB2AsD2CsAGCsCGCsBGC8A8B4J4DRB2C0AIyRAMYoAGM0gDEGwBgLYIwDMPoBjPEAxrsAjJUBjFUAjFUBjHcDGKsBGKsDGGsAGO8BMNYEMN4LYKwFYKwNYKwDYLwPwHg/gPEBAGNdAOODAMZ6AMaHAIwPAxgfATDWBzA2ADA2BDA+CmB8DMD4OICxEYCxMYCxCYDxCQBjUwBjMwBjcwBjCwBjSwDjkwDGBABjIoAxCcCYDGBMATCmAhhbARhbAxjbABjbAhjbARifAjC2BzB2ADB2BDB2AjB2BjB2ATB2BTA+DWDsBmDsDmDsAWB8BsDYE8D4LICxF4CxN4CxD4DxOQBjXwBjPwBjfwDjAADjQADj8wDGQQDGFwCMgwGMQwCMQwGMLwIYhwEYXwIwDgcwvgxgHAFgfAXA+CqA8TUA40gA4+sAxjcAjG8CGEcBGEcDGMcAGMcCGMcBGMcDGCcAGCcCGCcBGCcDGKcAGKcSnltYNPQZbwcwlgEwlgUwlgMwlgcwVgAwVgQwVgIw3gFgvBPA6AMwWgDGSABjFIAxGsAYA2CMBTDGARj9AMZ4AONdAMbKAMYqAMaqAMa7AYzVAIzVAYw1AIz3ABhrAhjvBTDWAjDWBjDWATDeB2C8H8D4AICxLoDxQQBjPQDjQwDGhwGMjwAY6wMYGwAYGwIYHwUwPgZgfBzA2AjA2BjA2ATA+ASAsSmAsRmAsTmAsQWAsSWA8UkAYwKAMRHAmARgTAYwpgAYUwGMrQCMrQGMbQCMbQGM7QCMTwEY2wMYOwAYOwIYOwEYOwMYuwAYuwIYnwYwdgMwdgcw9gAwPgNg7AlgfBbA2AvA2BvA2AfA+ByAsS+AsR+AsT+AcQCAcSCA8XkA4yAA4wsAxsEAxiEAxqEAxhcBjMMAjC8BGIcDGF8GMI4AML4CYHwVwPgagHEkgPF1AOMbAMY3AYyjAIyjAYxjAIxjAYzjAIzjAYwTAIwTAYyTAIyTAYxTAIxTAYxvARjfBjC+A2CcBmB8F8D4HoBxOoBxBoBxJoBxFoBxNoBxDoBxLoBxHoBxPoBxAYBxIYBxEYBxMYBxCYBxKYBxGYBxOYBxBYBxJYBxFYBxNYBxDYBxLYBxHYBxPYBxA4BxI4BxE4BxM4BxC4BxK4BxG4BxO4DxfQDjDgDjTgDjLgDjbgDjHgDjXgDjPgDjfgDjAQDjQQDjIQDjYQDjEQDjUQDjMQDjcQDjBwDGDwGMHwEYPwYwfgJg/BTA+BmA8XMA4xcAxi8BjF8BGE8AGL8GMH4DYPwWwPgdgPF7AOMPAMYfAYw/ARh/BjD+AmD8FcB4EsB4CsB4GsB4BsB4FsB4DsB4HsD4G4DxAoDxIoDxdwDjJQDjHwDGywBGT7HQZ8wEYMwMYMwCYMwKYMwGYMwOYMwBYMwJYMwFYMwNYMwDYMwLYMwHYLwOwJgfwFgAwHg9gPEGAGNBAOONBhjdh0juyGjLWG4ryZfZ1bdpOR+J8HjqKzVQaqj0qNJjSo8rNVJqrNRE6QmlpkrNlJortVBqqfSkUoJSolKSUrJSilKqUiul1kptlNoqtVN6Sqm9UgeljkqdlDordVHqqvS0Ujel7ko9lJ5R6qn0rFIvpd5KfZSeU+qr1E+pv9IApYFKzysNUnpBabDSEKWhSi8qDVN6SWm40stKIyKu9MErEU6nZHFe7U7JGRCrr4k10MQaamKPamKPaWKPa2KNNLHGmlgTTewJTaypJtZME2uuibXQxFpqYk9qYgmaWKImlqSJJWtiKZpYqibWShNrrYm10cTaamLtNLGnNLH2mlgHTayjJtZJE+usiXXRxLpqYk9rYt00se6aWA9N7BlNrKcm9qwm1ksT662J9dHEntPE+mpi/TSx/prYAE1soCb2vCY2SBN7QRMbrIkN0cSGamIvamLDNLGXNLHhmtjLmtgITcw+IVb3XHtkdl7T4lG+2OjolLjIFCvKSvBFxif6Y3zRMYmxfstvxfhjkiP9UVEp/mh/XHxifJwv3oqOSrFSY+KjUp39SPCBzNYjEWY2d+maBR/wbNWH1Cz4wGirAaRmwQdQWw0hNQs+0Np6FFKz4AOyrccgNQs+cNt6HFKz4AO8rUaQmgUfCG41htQs+IBxqwmkZsEHlltPQGoWfAC61RRSs+AD1a1mkJoFH9BuNYfULPjAd6sFpGbBB8hbLSE1Cz6Q3noSUrPgA+6tBEjNgg/MtxIhNQs+gN9KgtQs+EB/KxlSs+AXBFgpkJoFv3DASoXULPgFBlYrSM2CX4hgtYbULPgFC1YbSM2CX9hgtYXULPgFEFY7SM2CXyhhPQWpWfALKqz2kJoFv/DC6gCpWfALNKyOkJoFv5DD6gSpWfALPqzOkJoFvzDE6gKpWfALSKyukJoFv9DEehpSs+AXpFjdIDULfuGK1R1Ss+AXuFg9IDULfiGM9QykZsEvmLF6QmoW/MIa61lIzYJfgGP1gtQs+IU6Vm9IzYJf0GP1gdQs+IU/1nOQmgW/QMjqC6lZ8AuJrH6QmgW/4MjqD6lZ8AuTrAGQmgW/gMkaCKlZ8AudrOchNQt+QZQ1CFKz4BdOWS9Aahb8AitrMKRmwS/EsoZAahb8gi1rKKRmwS/ssl6E1Cz4BWDWMEjNgl8oZr0EqVnwC8qs4ZCaBb/wzHoZUrPgF6hZIwRrzqZyFHDV6z6yBvSB758e1pUXofX9r2xi68aSnY8mvijPfQSZ20pruMf71Ygrr6/Zr+4Pyds/+DggZv+S1xOeKEF/UL6imYkiNhZXjmsm9D+sOdKp2Xo1Qq7/XpM7CVqmxiKz8FhI9t9ITa5EX1JyjJUYmxxnpSTE+JOS4qMsKzIhNiE2MdKfmpIYY/lj/CpnUkKkX/1zkQlJVoovITbF3kTye66cHwKPTMJ9MFJw83Pzvh5hENhOLp33DcHJYKruNyKudrBQXi2rxMnEZpVasP8+yQuO0ZvCEz9tQ7fzllKv6ekEdwpu8LsEN3jJdxr2AJ3gKGe9jg50gqM0TnB0OjhBwkQJ+lE6ECe4R9AJjhI8MY4WdIKjIE5Qsv/GQJ3gGENOcGyEQeCxBpzguBB3gnbd4yKudrBQXiNOcLTDKu0EJcdovCEnOD4DnOA2wQ1+u+AGL3kNeQfQCU5w1uvEQCc4QeMEJ6aDEyRMlKB3YogT3CHoBCcInhgnCjrBMRAnKNl/k6BOcJIhJzg5wiDwZANOcEqIO0G77ikRVztYKK8RJzjRYZV2gpJjNNWQE5yaAU5wk+AGv1lwg5e8O3gr0Am+5azXtwOd4FsaJ/h2OjhBwkQJ+nG8ECe4VdAJviV4Ynxb0AmOgzhByf57B+oE3zHkBKdFGASeZsAJvhviTtCu+92Iqx0slNeIE3zbYZV2gpJj9J4hJ/heBjjBdYIb/HrBDV7yc58bgU5wurNeZwQ6wekaJzgjHZwgYaIE/cB+iBPcKOgEpwueGGcIOsEJECco2X8zoU5wpiEnOCvCIPAsA05wdog7Qbvu2RFXO1gorxEnOMNhlXaCkmM0x5ATnJMBTnCV4Aa/WnCDl3yiz1qgE5zrrNd5gU5wrsYJzksHJ0iYKEFfnYM4wbWCTnCu4IlxnqATnARxgpL9Nx/qBOcbcoILIgwCLzDgBBeGuBO0614YcbWDhfIacYLzHFZpJyg5RosMOcFFGeAElwlu8MsFN3jJZ7WuBDrBxc56XRLoBBdrnOCSdHCChIkS9Jf+QZzgSkEnuFjwxLhE0AlOgThByf5bCnWCSw05wWURBoGXGXCCy0PcCdp1L4+42sFCeY04wSUOq7QTlByjFYac4IoMcIKLBDf4xYIbvOS3cCwFOsGVznpdFegEV2qc4Kp0cIKEiRL01wJDnOBSQSe4UvDEuErQCb4FcYKS/bca6gRXG3KCayIMAq8x4ATXhrgTtOteG3G1g4XyGnGCqxxWaScoOUbrDDnBdRngBOcJbvDzBTd4ye9XXAh0guud9boh0Amu1zjBDengBAkTJeg79iFOcKGgE1wveGLcIOgE34E4Qcn+2wh1ghsNOcFNEQaBNxlwgptD3AnadW+OuNrBQnmNOMENDqu0E5Qcoy2GnOCWDHCCswQ3+NmCG/wcQSc4F+gEtzrrdVugE9yqcYLb0sEJEiZKsAv7XYgTnCvoBLcKnhi3CTrBdyFOULL/tkOd4HZDTvD9CIPA7xtwgjtC3Anade+IuNrBQnmNOMFtDqu0E5Qco52GnODODHCC7wlu8NMFN/gZgk5wJtAJ7nLW6+5AJ7hL4wR3p4MTJEyUYBf2dIgTnCnoBHcJnhh3CzrB6RAnKNl/e6BOcI8hJ7g3wiDwXgNOcF+IO0G77n0RVztYKK8RJ7jbYZV2gpJjtN+QE9yfAU7wbcEN/h3BDX6aoBN8F+gEDzjr9WCgEzygcYIH08EJEiZK0E/xgDjBdwWd4AHBE+NBQSc4E+IEJfvvENQJHjLkBA9HGAQ+bMAJHglxJ2jXfSTiagcL5TXiBA86rNJOUHKMjhpygkczwAlOFtzgpwhu8FMFneBbQCd4zFmvxwOd4DGNEzyeDk6QMFGCXdizIU7wLUEneEzwxHhc0AnOhjhByf77AOoEPzDkBD+MMAj8oQEn+FGIO0G77o8irnawUF4jTvC4wyrtBCXH6GNDTvDjDHCC4wU3+AmCG/xEQSc4CegEP3HW66eBTvATjRP8NB2cIGGiBLuw50Kc4CRBJ/iJ4InxU0EnOBfiBCX77zOoE/zMkBP8PMIg8OcGnOAXIe4E7bq/iLjawUJ5jTjBTx1WaScoOUZfGnKCX2aAExwtuMGPEdzgxwo6wXFAJ/iVs15PBDrBrzRO8EQ6OEHCRAn6yb4QJzhO0Al+JXhiPCHoBOdDnKBk/30NdYJfG3KC30QYBP7GgBP8NsSdoF33txFXO1gorxEneMJhlXaCkmP0nSEn+F0GOMHXBTf4NwQ3+DcFneAooBP83lmvPwQ6we81TvCHdHCChIkS7MJeCHGCowSd4PeCJ8YfBJ3gQogTlOy/H6FO8EdDTvCnCIPAPxlwgj+HuBO06/454moHC+U14gR/cFilnaDkGP1iyAn+4jhBu32z59pN3v3Wj/uCoPs2MfeHB9wfKXU/aMRub3C1V7naS1ztea72DFf7bVd7oqs92tV+zdW+z9W+39V+wNWu62o/6GrXc7UfcrUfdtq/qteTSqeUTiudUTqrdE7pfMQVR53P6d+0uVojbWIFHNWFxjOcN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nPd/O6/0NZymJUKf8WTx0Gc8BWA8DWA8A2A8C2A8B2A8D2D8DcB4AcB4EcD4O4DxEoDxDwDjZQCjB+DNMgEYMwMYswAYswIYswEYswMYcwAYcwIYcwEYcwMY8wAY8wIY8wEYrwMw5gcwFgAwziwU+oyzAIyzAYxzAIxzAYzzAIzzAYwLAIwLAYyLAIyLAYxLAIxLAYzLAIzLAYwrAIwrAYyrAIyrAYxrAIxrAYzrAIzrAYwbAIwbAYybAIybAYxbAIxbAYzbAIzbAYzvAxh3ABh3Ahh3ARh3Axj3ABj3Ahj3ARj3AxgPABgPAhgPARgPAxiPABiPAhiPARiPAxhHFw59xjEAxrEAxnEAxvEAxgkAxokAxkkAxskAxikAxqkAxrcAjG8DGN8BME4DML4LYHwPwDgdwDgDwDgTwDgLwDgbwDgHwDgXwDgPwDgfwLgAwLgQwLgIwLgYwLgEwLgUwLgMwLgcwLgCwLgSwLgKwLgawLgGwLgWwLgOwLgewLgBwLgRwLgJwLgZwLgFwLgVwFgQ8BykGwGMNwEYCwEYbwYwFgYw3gJgLAJgLApgLAZgLA5gLAFgLAlg9AIYSwEYIwCMpQGMtwIYbwMw3g5gLANgLAtgLAdgLA9grABgrAhgrARgvAPAeCeA0QdgtACMkQDGKABjNIAxBsAYC2CMAzD6AYzxAMa7AIyVAYxVAIxVAYx3AxirARirAxhrABjvATDWBDDeC2CsBWCsDWCsA2C8D8B4P4DxAQBjXQDjgwDGegDGhwCMDwMYHwEw1gcwNgAwNgQwPgpgfAzA+DiAsRGAsTGAsQmA8QkAY1MAYzMAY3MAYwsAY0sA45MAxgQAYyKAMQnAmAxgTAEwpgIYWwEYWwMY2wAY2wIY2wEYnwIwtgcwdgAwdgQwdgIwdgYwdgEwdgUwPg1g7AZg7A5g7AFgfAbA2BPA+CyAsReAsTeAsQ+A8TkAY18AYz8AY38A4wAA40AA4/MAxkEAxhcAjIMBjEMAjEMBjC8CGIcBGF8CMA4HML4MYBwBYHwFwPgqgPE1AONIAOPrAMY3AIxvAhhHARhHAxjHABjHAhjHARjHAxgnABgnAhgnARgnAxinABinEp5bWDT0GW8HMJYBMJYFMJYDMJYHMFYAMFYEMFYCMN4BYLwTwOgDMFoAxkgAYxSAMRrAGANgjAUwxgEY/QDGeADjXQDGygDGKgDGqgDGuwGM1QCM1QGMNQCM9wAYawIY7wUw1gIw1gYw1gEw3gdgvB/A+ACAsS6A8UEAYz0A40MAxocBjI8AGOsDGBsAGBsCGB8FMD4GYHwcwNgIwNgYwNgEwPgEgLEpgLEZgLE5gLEFgLElgPFJAGMCgDERwJgEYEwGMKYAGFMBjK0AjK0BjG0AjG0BjO0AjE8BGNsDGDsAGDsCGDsBGDsDGLsAGLsCGJ8GMHYDMHYHMPYAMD4DYOwJYHwWwNgLwNgbwNgHwPgcgLEvgLEfgLE/gHEAgHEggPF5AOMgAOMLAMbBAMYhAMahAMYXAYzDAIwvARiHAxhfBjCOADC+AmB8FcD4GoBxJIDxdQDjGwDGNwGMowCMowGMYwCMYwGM4wCM4wGMEwCMEwGMkwCMkwGMUwCMUwGMbwEY3wYwvgNgnAZgfBfA+B6AcTqAcQaAcSaAcRaAcTaAcQ6AcS6AcR6AcT6AcQGAcSGAcRGAcTGAcQmAcSmAcRmAcTmAcQWAcSWAcRWAcTWAcQ2AcS2AcR2AcT2AcQOAcSOAcROAcTOAcQuAcSuAcRuAcTuA8X0A4w4A404A4y4A424A4x4A414A4z4A434A4wEA40EA4yEA42EA4xEA41EA4zEA43EA4wcAxg8BjB8BGD8GMH4CYPwUwPgZgPFzAOMXAMYvAYxfARhPABi/BjB+A2D8FsD4HYDxewDjDwDGHwGMPwEYfwYw/gJg/BXAeBLAeArAeBrAeAbAeBbAeA7AeB7A+BuA8QKA8SKA8XcA4yUA4x8AxssARk+x0GfMBGDMDGDMAmDMCmDMBmDMDmDMAWDMCWDMBWDMDWDMA2DMC2DMB2C8DsCYH8BYAMB4PYDxBgBjQQDjjQYY3YdI7shoy1xuny+zq2/Tcv4W4fFcULqo9LvSJaU/lC4reUqr31XKrJRFKatSNqXsSjmUcirlUsqtlEcpr1I+peuU8isVULpe6Qalgko3Kt2kVEjpZqXCSrcoFVEqqlRMqbhSCaWSSl6lUkoRSqWVblW6Tel2pTJKZZXKKZVXqqBUUamS0h1Kdyr5lCylSKUopWilGKVYpTglf+krfRBf2umULM6r3Sk5A2IXNLGLmtjvmtglTewPTeyyJmYPQmAskyaWWRPLooll1cSyaWLZNbEcmlhOTSyXJpZbE8ujieXVxPJpYtdpYvk1sQKa2PWa2A2aWEFN7EZN7CZNrJAmdrMmVlgTu0UTK6KJFdXEimlixTWxEppYSU3Mq4mV0sQiNLHSmtitmthtmtjtmlgZTaysJlZOEyuviVXQxCpqYpU0sTs0sTs1MZ8mZmlikZpYlCYWrYnFaGKxmlicJubXxOwTYnXPtUfa5pEWj/LFRkenxEWmWFFWgi8yPtEf44uOSYz1W34rxh+THOmPikrxR/vj4hPj43zxVnRUipUaEx+V6uxHgh9IsOzztVAun8maBT/gYF2A1Cz4gQnrIqRmwQ9gWL9Dahb8QId1CVKz4AdErD8gNQt+4MS6DKlZ8AMslqc0o2bBD8RYmSA1C37AxsoMqVnwAztWFkjNgh8AsrJCahb8QJGVDVKz4AeUrOyQmgU/8GTlgNQs+AEqKyekZsEPZFm5IDULfsDLyg2pWfADY1YeSM2CH0Cz8kJqFvxAm5UPUrPgB+Ss6yA1C37gzsoPqVnwA3xWAUjNgh8ItK6H1Cz4AUPrBkjNgh9YtApCahb8AKR1I6RmwQ9UWjdBahb8gKZVCFKz4Ac+rZshNQt+gNQqDKlZ8AOp1i2QmgU/4GoVgdQs+IFZqyikZsEP4FrFIDULfqDXKg6pWfADwlYJSM2CHzi2SkJqFvwAs+WF1Cz4gWirFKRmwQ9YWxGQmgU/sG2VhtQs+AFw61ZIzYIfKLdug9Qs+AF163ZIzYIfeLfKQGoW/AC9VRZSs+AH8q1ykJoFP+BvlYfULPjAAKsCpGbBBxBYFSE1Cz7QwKoEqVnwAQnWHZCaBR+4YN0JqVnwAQ6WD1Kz4AMhLAtSs+ADJqxISM2CD6ywoiA1Cz4Aw4qG1Cz4QA0rBlKz4AM6rFhIzYIP/LDiIDULPkDE8gvWnE3lKOCq131kDegD3z89rCsvQuv7X9nE1o0lOx9NPCjGfQSZ20pruMf7rtJXXivbr+4Pyds/+DggZv+S1xOeKMGeEBZXNDNRxMbiynHNhP6HNUc6NVt3lZbrv8pyJ0HL1FhkFh4Lyf6rosmV6EtKjrESY5PjrJSEGH9SUnyUZUUmxCbEJkb6U1MSYyx/jF/lTEqI9Kt/LjIhyUrxJcSm2JtIfo/zMJ+AI5NwH1QR3PzcvFVLGwS2k0vnvVtwMpiq++7SVztYKK+WVeJkYrNKLdi0vJJjVE144qdt6HbeUuo1PZ1gXsENPp/gBi/5TkN+oBOs7qzXGoFOsLrGCdZIBydImCjBLuylECeYX9AJVhc8MdYQdIJLIU5Qsv/ugTrBeww5wZqlDQLXNOAE7w1xJ2jXfS/ECdZwWKWdoOQY1TLkBGtlgBPMKbjB5xLc4CWvIecBOsHaznqtE+gEa2ucYJ10cIKEiRLswl4OcYJ5BJ1gbcETYx1BJ7gc4gQl++8+qBO8z5ATvL+0QeD7DTjBB0LcCdp1PwBxgnUcVmknKDlGdQ05wboZ4ASzCm7w2QQ3eMm7g3MAneCDznqtF+gEH9Q4wXrp4AQJEyXYhb0S4gRzCDrBBwVPjPUEneBKiBOU7L+HoE7wIUNO8OHSBoEfNuAEHwlxJ2jX/QjECdZzWKWdoOQY1TfkBOtngBP0CG7wmQQ3eMnPfWYBOsEGznptGOgEG2icYMN0cIKEiRLswl4NcYJZBJ1gA8ETY0NBJ7ga4gQl++9RqBN81JATfKy0QeDHDDjBx0PcCdp1Pw5xgg0dVmknKDlGjQw5wUYZ4ASFnpD0r2xiTx6yZJ/oI/iknHRzgo2d9dok0Ak21jjBJungBAkTJdiFvRbiBC8XlXOCjQVPjE0EneBaiBOU7L8noE7wCUNOsGlpg8BNDTjBZiHuBO26m0GcYBOHVdoJSo5Rc0NOsHkGOMHzghv8b4IbvOSzWi8CnWALZ722DHSCLTROsGU6OEHCRAl2Ya+HOMGLgk6wheCJsaWgE1wPcYKS/fck1Ak+acgJJpQ2CJxgwAkmhrgTtOtOhDjBlg6rtBOUHKMkQ04wKQOc4GnBDf6M4AYv+S0c54BOMNlZrymBTjBZ4wRT0sEJEiZKsAt7I8QJnhN0gsmCJ8YUQSe4EeIEJfsvFeoEUw05wValDQK3MuAEW4e4E7Trbg1xgikOq7QTlByjNoacYJsMcIK/CG7wvwpu8JLfr3gK6ATbOuu1XaATbKtxgu3SwQkSJkqwC3szxAmeEnSCbQVPjO0EneBmiBOU7L+noE7wKUNOsH1pg8DtDTjBDiHuBO26O0CcYDuHVdoJSo5RR0NOsGMGOMEfBDf4HwU3+J8EneDPQCfYyVmvnQOdYCeNE+ycDk6QMFGCXdhbIU7wZ0En2EnwxNhZ0AluhThByf7rAnWCXQw5wa6lDQJ3NeAEnw5xJ2jX/TTECXZ2WKWdoOQYdTPkBLtlgBP8RnCD/1Zwg/9O0Al+D3SC3Z312iPQCXbXOMEe6eAECRMl2IW9HeIEvxd0gt0FT4w9BJ3gdogTlOy/Z6BO8BlDTrBnaYPAPQ04wWdD3AnadT8LcYI9HFZpJyg5Rr0MOcFeGeAEvxTc4L8S3OBPCDrBr4FOsLezXvsEOsHeGifYJx2cIGGiBLuwd0Cc4NeCTrC34Imxj6AT3AFxgpL99xzUCT5nyAn2LW0QuK8BJ9gvxJ2gXXc/iBPs47BKO0HJMepvyAn2zwAn+KngBv+Z4Ab/uaAT/ALoBAc463VgoBMcoHGCA9PBCRImSrALexfECX4h6AQHCJ4YBwo6wV0QJyjZf89DneDzhpzgoNIGgQcZcIIvhLgTtOt+AeIEBzqs0k5QcowGG3KCgzPACX4ouMF/JLjBfyzoBD8BOsEhznodGugEh2ic4NB0cIKEiRLswt4DcYKfCDrBIYInxqGCTnAPxAlK9t+LUCf4oiEnOKy0QeBhBpzgSyHuBO26X4I4waEOq7QTlByj4Yac4PAMcIJHBTf4Y4Ib/HFBJ/gB0Am+7KzXEYFO8GWNExyRDk6QMFGCXdj7IE7wA0En+LLgiXGEoBPcB3GCkv33CtQJvmLICb5a2iDwqwac4Gsh7gTtul+DOMERDqu0E5Qco5GGnODIDHCCBwU3+EOCG/xhQSd4BOgEX3fW6xuBTvB1jRN8Ix2cIGGiBLuwD0Cc4BFBJ/i64InxDUEneADiBCX7702oE3zTkBMcVdog8CgDTnB0iDtBu+7RECf4hsMq7QQlx2iMISc4xnGCdvtmz7WbvPutH/cFQfdtYu4PD7g/Uup+0Ijdbudqp7jaLV3tJq52Q1e7nqtdx9Wu4WpXdrV/jbjaPulqn3K1T7vaZ1zts672OVf7vNMeq/6dcUrjlSYoTVSapDRZaUrpK446n9O/aXO1hs5ee8w5xXDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3nDecN5w3v+tvNLXcJqWCH3Gk8VDn/EUgPE0gPEMgPEsgPEcgPE8gPE3AOMFAONFAOPvAMZLAMY/AIyXAYwegDfLBGDMDGDMAmDMCmDMBmDMDmDMAWDMCWDMBWDMDWDMA2DMC2DMB2C8DsCYH8BYAMA4s1DoM84CMM4GMM4BMM4FMM4DMM4HMC4AMC4EMC4CMC4GMC4BMC4FMC4DMC4HMK4AMK4EMK4CMK4GMK4BMK4FMK4DMK4HMG4AMG4EMG4CMG4GMG4BMG4FMG4DMG4HML4PYNwBYNwJYNwFYNwNYNwDYNwLYNwHYNwPYDwAYDwIYDwEYDwMYDwCYDwKYDwGYDwOYBxdOPQZxwAYxwIYxwEYxwMYJwAYJwIYJwEYJwMYpwAYpwIY3wIwvg1gfAfAOA3A+C6A8T0A43QA4wwA40wA4ywA42wA4xwA41wA4zwA43wA4wIA40IA4yIA42IA4xIA41IA4zIA43IA4woA40oA4yoA42oA4xoA41oA4zoA43oA4wYA40YA4yYA42YA4xYA41YAY0HAc5BuBDDeBGAsBGC8GcBYGMB4C4CxCICxKICxGICxOICxBICxJIDRC2AsBWCMADCWBjDeCmC8DcB4O4CxDICxLICxHICxPICxAoCxIoCxEoDxDgDjnQBGH4DRAjBGAhijAIzRAMYYAGMsgDEOwOgHMMYDGO8CMFYGMFYBMFYFMN4NYKwGYKwOYKwBYLwHwFgTwHgvgLEWgLE2gLEOgPE+AOP9AMYHAIx1AYwPAhjrARgfAjA+DGB8BMBYH8DYAMDYEMD4KIDxMQDj4wDGRgDGxgDGJgDGJwCMTQGMzQCMzQGMLQCMLQGMTwIYEwCMiQDGJABjMoAxBcCYCmBsBWBsDWBsA2BsC2BsB2B8CsDYHsDYAcDYEcDYCcDYGcDYBcDYFcD4NICxG4CxO4CxB4DxGQBjTwDjswDGXgDG3gDGPgDG5wCMfQGM/QCM/QGMAwCMAwGMzwMYBwEYXwAwDgYwDgEwDgUwvghgHAZgfAnAOBzA+DKAcQSA8RUA46sAxtcAjCMBjK8DGN8AML4JYBwFYBwNYBwDYBwLYBwHYBwPYJwAYJwIYJwEYJwMYJwCYJxKeG5h0dBnvB3AWAbAWBbAWA7AWB7AWAHAWBHAWAnAeAeA8U4Aow/AaAEYIwGMUQDGaABjDIAxFsAYB2D0AxjjAYx3ARgrAxirABirAhjvBjBWAzBWBzDWADDeA2CsCWC8F8BYC8BYG8BYB8B4H4DxfgDjAwDGugDGBwGM9QCMDwEYHwYwPgJgrA9gbABgbAhgfBTA+BiA8XEAYyMAY2MAYxMA4xMAxqYAxmYAxuYAxhYAxpYAxicBjAkAxkQAYxKAMRnAmAJgTAUwtgIwtgYwtgEwtgUwtgMwPgVgbA9g7ABg7Ahg7ARg7Axg7AJg7ApgfBrA2A3A2B3A2APA+AyAsSeA8VkAYy8AY28AYx8A43MAxr4Axn4Axv4AxgEAxoEAxucBjIMAjC8AGAcDGIcAGIcCGF8EMA4DML4EYBwOYHwZwDgCwPgKgPFVAONrAMaRAMbXAYxvABjfBDCOAjCOBjCOATCOBTCOAzCOBzBOADBOBDBOAjBOBjBOATBOBTC+BWB8G8D4DoBxGoDxXQDjewDG6QDGGQDGmQDGWQDG2QDGOQDGuQDGeQDG+QDGBQDGhQDGRQDGxQDGJQDGpQDGZQDG5QDGFQDGlQDGVQDG1QDGNQDGtQDGdQDG9QDGDQDGjQDGTQDGzQDGLQDGrQDGbQDG7QDG9wGMOwCMOwGMuwCMuwGMewCMewGM+wCM+wGMBwCMBwGMhwCMhwGMRwCMRwGMxwCMxwGMHwAYPwQwfgRg/BjA+AmA8VMA42cAxs8BjF8AGL8EMH4FYDwBYPwawPgNgPFbAON3AMbvAYw/ABh/BDD+BGD8GcD4C4DxVwDjSQDjKQDjaQDjGQDjWQDjOQDjeQDjbwDGCwDGiwDG3wGMlwCMfwAYLwMYPcVCnzETgDEzgDELgDErgDEbgDE7gDEHgDEngDEXgDE3gDEPgDEvgDEfgPE6AGN+AGMBAOP1AMYbAIwFAYw3GmB0HyK5I6Mtg7l9mV19m5ZzammP5y2lt5XeUZqm9K7Se0rTlWYozVSapTRbaY7SXKV5SvOVFigtVFqktFhpidJSpWVKy5VWKK1UWqW0WmmN0lqldUrrlTYobVTapLRZaYvSVqVtStuV3lfaobRTaZfSbqU9SnuV9intVzqgdFDpkNJhpSNKR5WOKR1X+kDpQ6WPlD5W+kTpU6XPSl/pg89LO52SxXm1OyVnQOwtTextTewdTWyaJvauJvaeJjZdE5uhic3UxGZpYrM1sTma2FxNbJ4mNl8TW6CJLdTEFmliizWxJZrYUk1smSa2XBNboYmt1MRWaWKrNbE1mthaTWydJrZeE9ugiW3UxDZpYps1sS2a2FZNbJsmtl0Te18T26GJ7dTEdmliuzWxPZrYXk1snya2XxM7oIkd1MQOaWKHNbEjmthRTeyYJnZcE/tAE/tQE/tIE/tYE/tEE/tUE/tME7NPiNU91x5pm0daPMoXGx2dEheZYkVZCb7I+ER/jC86JjHWb/mtGH9McqQ/KirFH+2Pi0+Mj/PFW9FRKVZqTHxUqrMfCW7I1tTScpt7Ns+V/tBtlh5XzN0XvuAOo+ZEJq/f3IMVS4e+eXwHwDgNwPgugPE9AON0AOMMAONMAOMsAONsAOMcAONcAOM8AON8AOMCAONCAOMiAONiAOMSAONSAOMyAONyAOMKAONKAOMqAONqAOMaAONaAOM6AON6AOMGAONGAOMmAONmAOMWAONWAOM2AON2AOP7AMYdAMadAMZdAMbdAMY9AMa9AMZ9AMb9AMYDAMaDAMZDAMbDAMYjAMajAMZjAMbjAMYPAIwfAhg/AjB+DGD8BMD4KYDxMwOM7kMod2RmV/1pOb9Q7F8qfaV0QulrpW+UvlX6Tul7pR+UflT6SelnpV+UflU6qXRK6bTSGaWzSueUziv9pnRB6aLS70qXlP5QuqzkuVUxKGVWyqKUVSmbUnalHEo5lXIp5VbKo5RXKZ/SdUr5lQooXa90g1JBpRuVblIqpHSzUmGlW5SKKBVVKqZUXKmEUkklr1IppYhbr/RB6Vs9195Q+4XmJtuvNLETmtjXmtg3mti3mth3mtj3mtgPmtiPmthPmtjPmtgvmtivmthJTeyUJnZaEzujiZ3VxM5pYuc1sd80sQua2EVN7HdN7JIm9ocmdlkTsyd0YCyTJpZZE8uiiWXVxLJpYtk1sRyaWE5NLJcmllsTy6OJ5dXE8mli12li+TWxAprY9ZrYDZpYQU3sRk3sJk2skCZ2syZWWBO7RRMrookV1cSKaWLFNbESmlhJTcyriZXSxCI0MfvkV91z7ZG2UaTFQ+nDA18Y2mwzBdTsC+6wviwdfP+lpNqH3zI5NoI39FtfGRob6ZoFPyBgnYDULPiBA+trSM2CH2CwvoHULPiBCOv/tfcd4FUU39s3lRQCCNhb1IiogHdDAsEapEqTIoIgJSEJRCChhA4ivUgHpaMoWGmKICKKYu9dsffee9dvNpwxJ5OTkJmd5Zfz/fc+zyGX990z+54zs3V2z/2cScwWX7BwvmASs8UXNpwvmcRs8QUQ5ysmMVt8ocT5mknMFl9Qcb5hErPFF16cb5nEbPEFGuc7JjFbfCHH+Z5JzBZf8HF+YBKzxReGnB+ZxGzxBSTnJyYxW3yhyfmZScwWX5ByfmESs8UXrpxfmcRs8QUu5zcmMVt8Icz5nUnMFl8wc/5gErPFF9acP5nEbPEFOOcvJjFbfKHO+ZtJzBZf0HP+YRKzxRf+nH+ZxGzxBUInlMIjZosvJDoRTGK2+IKjE8kkZosvTDpRTGK2+AKmE80kZosvdDoxTGK2+IKoE8skZosvnDrVmMRs8QVWJ45JzBZfiHXimcRs8QVbJ4FJzBZf2HUSmcRs8QVgpzqTmC2+UOwkMYnZ4gvKTg0mMVt84dmpySRmiy9QO7WYxGzxhWznMCYxW3zB26nNJGaLL4w7dZjEbPEFdKcuk5gtvtDuHM4kZosvyDtHMInZ4gv3zpFMYrb4Ar9zFJOYLRYEcI5mErPFAgPOMUxitliwwDmWScwWCyA4xzGJ2WJBBed4JjFbLNDgnMAkZosFH5wTmcRssYCEk8wkZosFKZyTmMRsscCFc7LFmN0f/4oPHXiX2f1EoJhDCMO5CHv7BD/+ZTl22xqDH/+yozH48S87GoMf/7KjMfjxLzsagx//sqMx+PEvOxqDH/+yozH48S87GoMf/7KjMfjxLzsagx//sqMx+PEvOxqDH/+yozH48S87GoMf/7KjMfjxLzsagx//sqMx+PEvOxqDH/+yozH48S87GoMf/7KjMfjxLzsagx//sqMx+PEvOxqDH/+yozH48S87GoMf/7KjMfjxLzsagx//sqMx+PEvOxq5/PiXb22npjkRKLeyzZSUUOhUYfWEnSasvrDThZ0h7ExhDYQ1FNZI2FnCwsIcYanCGgtLE5YurImwpsIyhDUTdrawc4SdK+w8YecLu8B9plRYc2EXCmshrKWwVsJaC2sjrK2wi4S1E9ZeWAdhHYV1EnaxsM7CugjrKqybsEuEdRd2qbAewnoKu0xYL2G9hV0urI+wvsL6CesvLEtYtrABKaHSP7KTQvzwzuUE1ofA+hJYPwLrT2BZBJZNYAMAw59IZZBUpR8BSvHpwWnbO4dTU7znj/oRINs66zHJ52lMdNZnovN0JjrPYKLzTCY6GzDR2ZCJzkZMdJ7FRGeYiU6Hic5UJjobM9GZxkRnOhOdTZjobMpEZwYTnc2Y6Dybic5zmOg8l4nO85joPJ+JzguY6MxkorM5E50XMtHZgonOlkx0tmKiszUTnW2Y6GzLROdFTHS2Y6KzPROdHZjo7MhEZycmOi9morMzE51dmOjsykRnNyY6L2GiszsTnZcy0dmDic6eTHRexkRnLyY6e/ukM9qrTqf0fy/3prNUa328xoxa62vheaX/irQ3qKJ9ES4ddT8bYwZa629n/BW3lmWxL16t2n0RllFn29t+nQEW27I4lh3cF16eCczNyWvmFkCtFSp5VtOXvvF5bIe9fKrumPHjYe7/9lm4v3NSDvzNVR86dol3FMxdKDkUDBTPv1jAYYeqDGjDmFMhZifHYv5yLW60fvVFpOW+sJm/PKKt7PCAnHQnu0lOUyc3Kz1jwIBmjR0nNatJVpPs1Iy83Ox0JyM9Q7Q5ICs1Q6wuNWuAkxvOapLrHkRqhkpOxvHH9gl6nsUdLNY7MMVHwW7jttsdZHEw+BX3oJSSBFtql9RqY2fiarW1wcp2bfZRvuWBLw/obrsnib+H8kzwcosH+D4WD/B9LR5U+qX4c1CxtD2RZ4JXwPY6WD0TvII4Exzs55kgiOxn8ezjCosb42DUVmpOem64WUZ2Rmp2VuOm2WmNs5s1yxLtNnGcjLyc1HBOWmpeutOkyYBmuc3ynMZ52em5WU3Ss5o1ySk+eua8wuTsw2b+hjA9+xji09nH0BQfBQ/14eyjoIqffbhxFzA5+xgMWm2ffdjso0Kfzj4KK3H2YW1swDHPznvEGcX/EnJ9OTIPg7E8XD0yDyOOzMOJI3OUj0n0emQeZnGgDk/xp3NtH01txjyC6dF0hE9H05EpPgoe6cPRtKiKH03duIuYHE2Hg1bbR1ObfTTKp6PpKDiaut+PDJU+GLjfb4quut8HI5256PuqU0q+r0bf16Dva9H3dej7dej79ej7evg+WqxnjLCxwsYJGy9sgrCJwiallD0bsb1dTbI4DuSl95WizcnCrhI2Bc4W8BhxebV6y2QCu4rApqSUrfJi+5J/ksXt7EoLbR2onhJ2JlvU9aZPl/zqSZ6XmN2+uMpK/g706xSL99Zs5s/vbXyiD9v4VNHmNGHThc0gtvGpxLY7jcCmE9iMQ7CNT7S4LU21uI1Ps6jrbSbb+HSL2/gMi9v424y28Qk+bOMzRZuzhM0WNofYxmcS2+4sAptNYHMOwTY+weK2NNPiNj7Loq53mWzjsy1u43MsbuPvMtrGx/uwjc8VbV4tbJ6w+cQ2PpfYdq8msHkENv8QbOPjLW5Lcy1u41db1PU+k218nsVtfL7Fbfx9Rtv4OB+28QWizYXCFglbTGzjC4htdyGBLSKwxYdgGx9ncVtaYHEbX2hR14dMtvFFFrfxxRa38Q8ZbeNjfdjGl4g2lwpbJuwaYhtfQmy7SwlsGYFdcwi28bEWt6UlFrfxpRZ1fcxkG19mcRu/xuI2/jGjbXyMD9v4taLN5cJWCFtJbOPXEtvucgJbQWArD8E2PsbitnStxW18uUVdnzLZxldY3MZXWtzGP2W0jY/2YRtfJdpcLWyNsLXENr6K2HZXE9gaAlt7CLbx0Ra3pVUWt/HVFnV9zmQbX2NxG19rcRv/nMnjxh3r2Bsz6yzmD2/TbrvJoQNPL9ZAYwh/bO/3Pq9t99mR5pEh8mNrHUG7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu0G7QbtBu/9/t2v7PnjvE6q+xh+Or/oaf2Sg8ScGGn9moPEXBhp/ZaDxNwYaf2eg8Q8GGv9koPEvBhr/ZqDxHwYa/2WgMcTg3CyCgcZIBhqjGGiMZqAxhoHGWAYaqzHQGMdAYzwDjQkMNCYy0FidgcYkBhprMNBYk4HGWgw03n5E1de4iYHGzQw0bmGgcSsDjdsYaLyDgcY7GWjczkDjXQw07mCgcScDjXcz0LiLgcZ7GGjczUDjvQw07mGg8T4GGu9noHEvA40PMND4IAON+xhofIiBxocZaHyEgcZHGWh8jIHGxxlofIKBxicZaHyKgcanGWh8hoHGZxlofI6BxucZaHyBgcYXGWh8iYHGlxlofIWBxlcZaHyNgcb9DDS+zkDjGww0rjiq6mtcyUDjKgYaVzPQuIaBxrUMNK5joPE6BhqvZ6BxPQONNzDQeCMDjRsYaNzIQONNDDTezEDjLQw03spA420MNN7OQOMmBho3M9C4hYHGrQw0bmOg8Q4GGu9koHE7A413MdC4g4HGnQw03s1A4y4GGu9hoHE3A433MtC4h4HG+xhovJ+Bxr0MND7AQOODDDTuY6DxIQYaH2ag8REGGh9loPExBhrrMKiDVJeBxsMZaDyCgcYjGWg8ioHGoxloPIaBxmMZaDyOgcbjGWg8gYHGExloTGag8SQGGk9moPEUBhpTGGg8lYHGegw0nsZAY30GGk9noPEMBhrPZKCxAQONDRlobMRA41kMNIYZaHQYaExloLExA41pDDSmM9DYhIHGpgw0ZjDQ2IyBxrMZaDyHgcZzGWg8j4HG8xlovICBxkwGGpsz0HghA40tGGhsyUBjKwYaWzPQ2IaBxrYMNF7EQGM7BhrbM9DYgYHGjgw0dmKg8WIGGjsz0NiFgcauDDR2Y6DxEgYauzPQeCkDjT0YaOzJQONlDDT2YqCxNwONlzPQ2IeBxr4MNPZjoLE/A41ZDDRmM9A4gIHGHAYacxlozGOgcSADjYMYaMxnoPEKBhoHM9A4hIHGoQw0FjDQWMhA4zAGGocz0DiCgcaRDDQWMdA4ioHG0Qw0jmGgcSwDjeMYaBzPQOMEBhonMtA4iYHGKxlonMxA41UMNE5hoHEqA43TGGiczkDjDAYaZzLQOIuBxtkMNM5hoHEuA41XM9A4j4HG+Qw0LmCgcSEDjYsYaFzMQOMSBhqXMtC4jIHGaxhovJaBxuUMNK5goHElA42rGGhczUDjGgYa1zLQuI6BxusYaLyegcb1DDTewKFu4bFVX2M9BhpPY6CxPgONpzPQeAYDjWcy0NiAgcaGDDQ2YqDxLAYawww0Ogw0pjLQ2JiBxjQGGtMZaGzCQGNTBhozGGhsxkDj2Qw0nsNA47kMNJ7HQOP5DDRewEBjJgONzRlovJCBxhYMNLZkoLEVA42tGWhsw0BjWwYaL2KgsR0Dje0ZaOzAQGNHBho7MdB4MQONnRlo7MJAY1cGGrsx0HgJA43dGWi8lIHGHgw09mSg8TIGGnsx0NibgcbLGWjsw0BjXwYa+zHQ2J+BxiwGGrMZaBzAQGMOA425DDTmMdA4kIHGQQw05jPQeAUDjYMZaBzCQONQBhoLGGgsZKBxGAONwxloHMFA40gGGosYaBzFQONoBhrHMNA4loHGcQw0jmegcQIDjRMZaJzEQOOVDDROZqDxKgYapzDQOJWBxmkMNE5noHEGA40zGWicxUDjbAYa5zDQOJeBxqsZaJzHQON8BhoXMNC4kIHGRQw0LmagcQkDjUsZaFzGQOM1DDRey0DjcgYaVzDQuJKBxlUMNK5moHENA41rGWhcx0DjdQw0Xs9A43oGGm9goPFGBho3MNC4kYHGmxhovJmBxlsYaLyVgcbbGGi8nYHGTQw0bmagcQsDjVsZaNzGQOMdDDTeyUDjdgYa72KgcQcDjTsZaLybgcZdDDTew0DjbgYa72WgcQ8Djfcx0Hg/A417GWh8gIHGBxlo3MdA40MMND7MQOMjDDQ+ykDjYww0Ps5A4xMMND7JQONTDDQ+zUDjMww0PstA43MMND7PQOMLDDS+yEDjSww0vsxA4ysMNL7KQONrDDTuZ6DxdQYa32Cg8U0GGt9ioPFtBhrfYaDxXQYa32Og8X0GGj9goPFDBho/YqDxYwYaP2Gg8VMGGj9joPFzBhq/YKDxSwYav2Kg8WsGGr9hoPFbBhq/Y6DxewYaf2Cg8UcGGn9ioPFnBhp/YaDxVwYaf2Og8XcGGv9goPFPBhr/YqDxbwYa/2Gg8V8GGkPHVX2NEQw0RjLQGMVAYzQDjTEMNMYy0FiNgcY4BhrjGWhMYKAxkYHG6gw0JjHQWIOBxpoMNNZioPEwBhprM9BYh4HGuj5o9ENnxzo+6IwSNj9U9mN7RdaLBUVXfY3XpVjUyLWj7mDQUdcHHRV2tjPoqPVBR4WdHQw66oago8LO3Qw66sago8LOPQw6akPQUWHnXgYdtTHoqLBzH4OOuinoqLCzl0FH3Rx0VNh5kEFH3RJ0VNh5iEFH3Rp0VNh5hEFH3RZ0VNh5jEFH3R50VNh5gkFHbQo6Kuw8xaCjNgcdFXYGRlV9jVuCjgo7zzLYorYGHRV2nmfQUduCjgo7LzLoqDuCjgo7LzPoqDuDjgo7rzLoqO1BR4Wd/Qw66q6go8LOGww6akfQUWHnLQYdtTPoqLDzDoOOujvoqLDzHoOO2hV0VNj5gEFH3RN0VNj5iEFH7Q46Kux8wqCj7g06Kux8xqCj9gQdFXa+YNBR9wUdFXa+YtBR96fY11j8iVSENg43SUvLbZqa6zR2ssKpzbIz0sNp6dlNMpwMJz0jPSc1o3Hj3Iy0jKbNsps1DTdz0hrnOnnpzRrnocZtBZ0X8ido2zFHWIx54CGKOezt4wyymL9To3n0c5TF/OWHeMQcbTHmK5iM7cEW83d0lD8x2z7ADAnx0DmUic4CJjoLmegcxkTncCY6RzDROZKJziImOkcx0Tmaic4xTHSOZaJzHBOd45nonMBE50QmOicx0XklE52Tmei8ionOKUx0TmWicxoTndOZ6JzBROdMJjpnMdE5m4nOOUx0zmWi82omOucx0Tmfic4FTHQuZKJzkU86q/Jc6OJDFHPY28dZYjF/xzOZL1oa4qFzGROd1zDReS0TncuZ6FzBROdKJjpXMdG5monONUx0rmWicx0Tndcx0Xk9E53rmei8gYnOG5no3MBE50YmOm9iovNmJjpvYaLzViY6b2Oi83YmOjcx0bmZic4tTHRuZaJzm2Wdqj6v9xM/rxMK/VLHfrtfNvA37rC3j+PGfERd+3F/1cCfcRltOf47LMbs5tGWLovjxvmqQdXe9r7wadv7lsG2d6QP2953TLa9Oy3GfKTFbc/iuHH86gvbc3PbLfbF0XWr9v7mK5/2Nz8y2N8c48P+5icm+5u7LMZ8jMX9jcVx4/xUxY/1xdudD2PwVwbb3rE+xP0bk21vh8WYj7W47VkcN85vDMbgcXXtnzvstNi3x9Wt+jk83occ3m0xh8czyOEJPuRwl8UcnsAghyf6kMN7LObwRAY5TPYhh7st5jCZQQ5P8iGH91rM4UkMcniyDzncYzGHJzPI4Sk+5PA+izk8hUEOU3zI4f0Wc5jCIIen+pDDvRZzeCqDHNbzIYcPWMxhPQY5PM2HHD5oMYenMchhfR9yuM9iDuszyOHpPuTwIYs5PJ1BDs/wIYcPW8zhGQxyeKYPOXzEYg7PZJDDBj7k8FGLOWzAIIcNfcjhYxZz2JBBDhv5kMPHLeawEYMcnuVDDp+wmMOzGOQw7EMOn7SYwzCDHDo+5PApizl0GOQw1YccPm0xh6kMctjYhxw+YzGHjRnkMM2HHD5rMYdpDHKY7kMOn7OYw3QGOWziQw6ft5jDJgxymOFDDl+wmMMMBjk824ccvmgxh2czyOG5PuTwJYs5PJdBDs/3IYcvW8zh+QxymOlDDl+xmMNMBjm80IccvmoxhxcyyGFLH3L4msUctmSQw9Y+5HC/xRy2ZpDDtj7k8HWLOWzLIIftfMjhGxZz2I5BDjv4kMM3LeawA4McdvIhh29ZzGEnBjm82Iccvm0xhxczyGEXH3L4jsUcdmGQw24+5PBdiznsxiCH3X3I4XsWc9idQQ57+JDD9y3msAeDHF7mQw4/sJjDyxjksLcPOfzQYg57M8hhHx9y+JHFHPZhkMO+PuTwY4s57Msgh/19yOEnFnPYn0EOs33I4acWc5jNIIcDfMjhZxZzOIBBDnN9yOHnFnOYyyCHA33I4RcWcziQQQ7zfcjhlxZzmM8gh4N9yOFXFnM4mEEOh/qQw68t5nAogxwW+pDDbyzmsJBBDof7kMNvLeZwOIMcjvQhh99ZzOFIBjkc5UMOv7eYw1EMcjjGhxz+YDGHYxjkcJwPOfzRYg7HMcjhBB9y+JPFHE5gkMNJPuTwZ4s5nMQgh5N9yOEvFnM4mUEOp/iQw18t5nAKgxxO8yGHv1nM4TQGOZzhQw5/t5jDGQxyOMuHHP5hMYezGORwjg85/NNiDucwyOHVPuTwL4s5vJpBDuf7kMO/LeZwPoMcLvQhh/9YzOFCBjlc7EMO/7WYw8UMcrjUhxy6Qm3lcKnlHMqP7ZgjLMZ8XQqPmCMtxnw9k5ijLMa8nknM0RZjvoFJzDEWY76RScyxFmPewCTmahZj3sgk5jiLMd/EJOZ4izHfzCTmBIsx38Ik5kSLMd/KJObqFmO+jUnMSRZjvp1JzDUsxryJScw1Lca8mUnMtSzGvIVJzIdZjHkrk5hrW4x5G5OY61iM+Q4mMde1GPOdTGI+3GLM25nEfITFmO9iEvORFmPewSTmoyzGvJNJzEdbjPluJjEfYzHmXUxiPtZizPcwifk4izHvZhLz8RZjvpdJzCdYjHkPk5hPtBjzfUxiTrYY8/0+xWx7Lv+kCB46T2ai8xQmOlOY6DyVic56THSexkRnfSY6T2ei8wwmOs9korMBE50NmehsxETnWUx0hpnodJjoTGWiszETnWlMdKYz0dmEic6mTHRmMNHZjInOs5noPIeJznOZ6DyPic7zmei8gInOTCY6mzPReSETnS2Y6GzJRGcrJjpbM9HZhonOtkx0XsREZzsmOtsz0dmBic6OTHR2YqLzYiY6OzPR2YWJzq5MdHZjovMSJjq7M9F5KROdPZjo7MlE52VMdPZiorM3E52XM9HZh4nOvkx09mOisz8TnVlMdGYz0TmAic4cJjpzmejMY6JzIBOdg5jozGei8womOgcz0TmEic6hTHQWMNFZyETnMCY6hzPROYKJzpFMdBYx0TmKic7RTHSOYaJzLBOd45joHM9E5wQmOicy0TmJic4rmeiczETnVUx0TmGicyoTndOY6JzOROcMJjpnMtE5i4nO2Ux0zmGicy4TnVcz0TmPic75THQuYKJzIROdi5joXMxE5xImOpcy0bmMic5rmOi8lonO5Ux0rmCicyUTnauY6FzNROcaJjrXMtG5jonO65jovJ6JzvVMdN7AROeNTHRuYKJzIxOdNzHReTMTnbcw0XkrE523MdF5OxOdm5jo3MxE5xYmOrcy0bmNic47mOi8k4nO7Ux03sVE5w4mOncy0Xk3E527mOi8h4nO3Ux03stE5x4mOu9jovN+Jjr3MtH5ABOdDzLRuY+JzoeY6HyYic5HmOh8lInOx5jofJyJzieY6HySic6nmOh8monOZ5jofJaJzueY6Hyeic4XmOh8kYnOl5jofJmJzleY6HyVic7XmOjcz0Tn60x0vsFE55tMdL7FROfbTHS+w0Tnu0x0vsdE5/tMdH7AROeHTHR+xETnx0x0fsJE56dMdH7GROfnTHR+wUTnl0x0fsVE59dMdH7DROe3THR+x0Tn90x0/sBE549MdP7EROfPTHT+wkTnr0x0/sZE5+9MdP7BROefTHT+xUTn30x0/sNE579MdIYieeiMYKIzkonOKCY6o5nojGGiM9YnnZGWdVZDOhuHm6Sl5TZNzXUaO1nh1GbZGenhtPTsJhlOhpOekZ6TmtG4cW5GWkbTZtnNmoabOWmNc5289GaN86Cx1tE8Yo6zGPO6FH9ijlZi9qrzydre28rNcz9h5ylLbbl98XRtezH+2aBq90XuAaHOM95jToWYnWe9tpX2X/6c5yz2xV9Vty/CSKfzvJeYU0vF7Lxg3lZYyZ/zosW++LsK9kWTvDI6nZfMYs4gYnZeNmkrg8yf84rFvvinavVF03J0Oq/qxty03Jid1/TaSq0gf85+i33xb1Xpi6YV6nRer3zMAw4Ss/NGZdtqetD8OW9a7ItQw/95X4QrodN5qzIxhysVs/P2wdtKr2T+nHcs9kXE/7Iv0iqt03m3wpjT8jRidt6rqK2mWvlz3rfYF5H/m77I0NTpfFBOzM3ytGN2PqTbChvkz/nIYl9EHeq+CBvpdD4uG7NjGLPzidpWjnH+nE8t9kX0oeuLxh50Op/VtjgXY+98xcHXZ177IuYQ9UXY28exeB3kWDyPd/612BexTPrC4vmeY/F8xcHHW699UY1JX1g8rjkW98tOjMW+iGPSF/H25g0ci/sCx+JYdvzqi0jLfZFgcZ7gIp/mRmzPWyVaiLl4niAnb4CffVPdYt+cEMVjDmdyir05nKssteX2xZQUezEe+b+/D1SpOZyp3mP+bw5nmte20BzOdIt9cVTV7YtSczgzvMSszOHMNG+rzBzOLIt9cXQV7AtqDme2WczkHM4ck7bKmcOZa7EvjqlafVHuHM7VujFXMIczT6+tCudw5lvsi2OrSl8cZA5nQeVjPugczsLKtlWJOZxFFvviOCZzOIsrE3Ml53CWHLytSs/hLLXYF8czmcNZlmJvDueaFHtzONda7IsTmMzhLE+xN4ezIsXeHM5Ki31xIpM5nFUp9uZwVqfYm8NZY7EvkpnM4ay194ynY/H61jnK4v3Rk5jcH7V4HeRYPI93jrXYFycz6QuL53uOxfMV5wSLfXEKk76weFxzLO6XnZMs9kUKk75IsjiHY3Ff4Fgcy04KkzmcGhbnCTrW4TGHU9PaHE62r3M4tSz2zee1efTNYZE8dNZmorMOE511meg8nInOI5joPJKJzqOY6Dyaic5jmOg8lonO45joPJ6JzhOY6DyRic5kJjpPYqLzZCY6T2GiM4WJzlOZ6KzHROdpTHTWZ6LzdCY6z2Ci80wmOhsw0dmQic5GTHSexURnmIlOh4nOVCY6GzPRmcZEZzoTnU2Y6GzKRGcGE53NmOg8m4nOc5joPJeJzvOY6Dyfic4LmOjMZKKzOROdFzLR2YKJzpZMdLZiorM1E51tmOhsy0TnRUx0tmOisz0TnR2Y6OzIRGcnJjovZqKzMxOdXZjo7MpEZzcmOi9horM7E52XMtHZg4nOnkx0XsZEZy8mOnsz0Xk5E519mOjsy0RnPyY6+zPRmcVEZzYTnQOY6MzxSWekotNzLWmLMeceopjD3j5OXqS9/NWP5tHP1SzmbyCTsR1nMeZBTGKOtxhzPpOYEyzGfAWTmBMtxjyYyX57iMX99plM9ttJFvM3lEk/F1js50ZM+rmmxfwVMunnYRb72WHSz4dZzN9wJv08wmI/pzHp5zoW8zeSyTlJXYsxFzGJ+XCLMY9iEvMRFmMezWQfNsbiPqwpk33YURbzN5bJ2D7aYszjmMR8jMWYxzOJ+ViLMU9gEvNxFmOeyCTm4y3GPIlJzCdYjPlKJsfnyRaPz2dH84j5Kosxn8ck5ikWY85kEvNUizG3YHLueYrF/E1jst9OsRjzdCYxn2ox5hkWY3afB5B1qvNQ/BGQgyjg3fnzWGHu/Ko73+jOv7nzUe78THVh7v37GsLc+7u1hLn3/2oLc+8PufdL3PsH7vX0kcLc6y33+sM9H3fPT93zNff8xT2enygsWdhJwk4W5m4f7nhx81dP2GnC6gs7XdgZws4U1kBYQ2GNhJ3l5kSYIyzV7TdhacLShTUR1lRYhrBmws4Wdo6wc4WdJ+x8YRdAPzUXdqGwFsJaCmslrLWwNsLaCrtIWDth7YV1ENZRWCdhFwvrLKyLsK7Cugm7RFh3YZcK6yGsp7DLhPUS1lvY5cL6COsrrJ+w/sKyhGULcwsl5wjLRX2THFnSXwOFDRKWL+wKYYOFDRE2VFiBsEJhw4QNFzZC2EhhRcJGCRstbIywscLGCRsvbIKwicImCbtS2GRhVwmbImyqsGnCpgubIWymsFnCZgubI2yusKuFzRM2X9gCYQuFLRK2WNgSYUuFLRN2jbBrhS0XtkLYSmGrhK0WtkbYWmHrhF0n7Hph64XdIOxGYRuEbRR2k7Cbhd0i7FZhtwm7XdgmYZuFbRG2Vdg2YXcIu1PYdmF3CdshbKewu4XtEnaPsN3C7hW2R9h9wu4XtlfYA8IeFLZP2EPCHhb2iLBHhT0m7HFhTwh7UthTwp4W9oywZ4U9J+x5YS8Ie1HYS8JeFvaKsFeFvSZsv7DXhb0h7E1hbwl7W9g7wt4V9p6w94V9IOxDYR8J+1jYJ8I+FfaZsM+FfSHsS2FfCfta2DfCvhX2nbDvhf0g7EdhPwn7Wdgvwn4V9puw34X9IexPYX8J+1vYP8L+FebuDCKERQqLEhYtLEZYrLBqwuKExQtLEJYorLqwJGE1hNUUVkvYYcJqC6sjrK6ww4UdIexIYUcJO1rYMcKOFXacsOOFnSDsRGHJwk4SdrKwU4SlCDtVWD1hpwmrL+x0YWcIO1NYA2ENhTUSdpYwdyfnCEsV1lhYmrB0YU2ENRWWIayZsLOFnSPsXGHnCTtf2AXCMoU1F3ahsBbCWgprJay1sDbC2gq7SFg7Ye2FdRDWUVgnYRcL6yysi7CuwroJu0RYd2GXCushrKewy4T1EtZb2OXC+gjrK6yfsP7CsoRlCxsgLEdYrrA8YQOFDRKWL+wKYYOFDRE2VFiBsEJhw4QNFzZC2EhhRcJGCRstbIywscLGCRsvbIKwicImCbtS2GRhVwmbImyqsGnCpgubIWymsFnCZgubI2yusKuFzRM2X9gCYQuFLRK2WNgSYUuFLRN2jbBrhS0XtkLYSmGrhK0WtkbYWmHrhF0n7Hph64XdIOxGYRuEbRR2k7Cbhd0i7FZhtwm7XdgmYZuFbRG2Vdg2YXcIu1PYdmF3CdshbKewu4XtEnaPsN3C7hW2R9h9wu4XtlfYA8IeFLZP2EPCHhb2iLBHhT0m7HFhTwh7UthTwp4W9oywZ4U9J+x5YS8Ie1HYS8JeFvaKsFeFvSZsv7DXhb0h7E1hbwl7W9g7wt4V9p6w94V9IOxDYR8J+1jYJ8I+FfaZsM+FfSHsS2FfCfta2DfCvhX2nbDvhf0g7EdhPwn7Wdgvwn4V9puw34X9IexPYX8J+1vYP8L+FeaeCEQIixQWJSxaWIywWGHVhMUJc39f3P1da/d3nt3fUHZ/q8L9jQT3NwPcevxufXq39rtbV92tWe7WA3drbbt1rN0a0W79Zbe2sVs32K3J69a7dWvJunVa3eOdW1/Urd3p1sV0a0669RzdWoluHUK3xp9bP8+tTefWfXNrqrn1ytxaYG6dLbeGlVsfyq295NY1cmsGufV43Fo3bh0Zt0aLW//ErS3i1u1wa2K49SbcWg7FdRKEue/3u+/Ou++lu+98u+9Tu+8qu+8Bu+/Yuu+vuu+Guu9duu80uu8Luu/iue+5ue+Que9nue8+ue8Vue/suO/DuO+auO9xuO9IuO8fuM/2u8/Nu8+ku897u89Su88p9xfmPl/rPrvqPhfqPnPpPoPoPt/nPqPmPrPlPsPkPtPjPuPiPj/iPgPhPl/gzpG788/uHKo7P+nOsblzTu4cjDsn4d7vd+9Zu/dw3Xua7j0+956Xew/IvSfi3m9wr7/d61H3+sy9xnDPud1z0AL35BA+15d8LT6fcz9ZRUW5Q4cVJRcVJmfl5CSPyS8alFw4OndE3pBC97Sj+Hiu6/Me8kmBvxcVjM4akp+TPGxU9pD8AcmDc8eNTB6UX1CUnFc4wm1lRO5I97Sn+Jiouz73+GK6vv4efIci35PKah06akhR/rAh48oKLjR1HB6hn52RpisbZeo4xkDlONOVTTB1nGSgcrLpyqaYOk4zUDnDdGWzTB3nGKi82nRl800dFxqoXGy6sqWmjtcYqFxuurKVpo6rDVSuNV3ZdaaO6w1U3mi6so2mjjcbqLzVdGW3mzpuNlC51XRld5g6bjdQucN0ZXebOt5joPJl5NMA/rbIKigoLEoemTsiX5yxjM9NHlbonqdkFSXnF+TlF+QXjUvOGpmcPa4od6R74634bF9+joW/A7KGDCle6UjRTFG/oVlj+2XnF/UbKZpz6Vr6LrX1Xerquxyl73KMvssp+i6n6rucoe/SQN8lrO+Squ9yjr7LefouF+i7NNd3aaHv0krfpZ2+Swd9l87IpbL7nMuQj9YOro+pY5aByleiS3xM94w1Y7QTepi+Sx19l8P1XY7WdzlW3yVF36WevsuZ+i4N9V0cfZfG+i7n6rucr++Sqe9yob5LS32X1vou7fVdOuq7dEEuld4zIh+9PaOpY5aByuZxJT6me8YJcdoJnaTvMlnfZYq+ywx9l1n6Lov0XZbouyzXd1mp77JW3+U6fZdb9F1u03fZpO+yRd9lm77Lnfoud+u73KPvch9yqew+5xHko7WDe8LU8RkDle8laCfjfX2XT/RdPtN3mZhY4mK6l9+ZqL3aXfouu/Vd9ui7PKDvsk/f5Sl9l2f0XV7Ud3lZ32W/vssb+i4f6rt8rO/yqb7L5/ouX+q7fK3v8oO+y0/6Lr8hl8ruP4sfKISP1s462tQxrrq+yjzkY7pnvL66dkJv0HfZoO9yk77Lbfoum/Rddui73K3vskff5X59l336Lg/ruzyj7/KcvssL+i4v6bu8ou/ymr7LW/ou7+i7fGCwz/nCdAf3janjDwYqk4/U9+mNfHSflclGvufC325FhSOyBuYmjxwi9sfhZHevLLqjcExuTqNkzI0UsY8Ue+yirBGi3RGFQ5Od4j3zIoMYnvEQQ+xR5r4nIt/a8HfYqJFC3Kii5MK85OzCUQU5xUuefpR+VI6BTzMDn+YGPh0NfOodXeLTCP6K43ZyYYEY/7lD88VAcYdLbvKQwoEHMl2QnDs2f2RRfsHAYqLY6XzUiunRfyxqo5I7jfH6LhP1Xa7Ud5mq7zJd32W+vstCfZdl+i7X6rus0ndZo++yUd/lZn2XW/Vdbtd32azvslXf5S59l536LruRS2X3XPuQj9ZB/FFTxycNVB55XImP6Z6xy3HaCe2m79Jd36WHvktvfZc++i55+i6D9F2G6rsU6ruM1HcZpe9ypb7LVfouU/Vdpuu7zNR3ma3vMl/fZaG+y1LkUtl9zmrko/f0p6njjQYqj0gu8THdM3ZO1k5oV32XS/RdLtV36aXvcrm+S66+y0B9lyH6LgX6LiP0XYr0XSbpu0zWd5mi7zJN32WGvsssfZd5+i4L9F2WIJfK7nNWIR+tHdw6U8cbDFTuOFk7GTv1Xe7Td9mr79LtlBIX0738/FO0V7tQ32WxvstSfZfl+i4r9V1u0HfZoO9yq77L7fouW/Vd7tB32a3vskff5X59lwf0Xfbpuzys7/KEvstT+i7PIZfK7j9fQz5aO+s3TR3fNVB5TkqJj+mecVSKdkLH6LuM03eZoO8yWd9lir7LXH2Xefoui/Vdluq7LNd3WanvcoO+ywZ9l5v0XW7Rd7lN32WTvssd+i7b9V3uRi6V3efsRT5aO7iHTB0fM1BZP6zn476u9yEsh8uWydu1zUeMyBon9qA5uWNLTwJix/NC5ittbrrSrgYr/dg00o89RPqxaaQfe4j0U9NIP/UQ6aemkX7qIdL7IwwjlY4mkUpf7Uilo0mkifDWWQbyJXYoI0dlF43IGlBUfgPn6qqWji1MHS8xCPdw8NXuWOlo0rHSV7tjpaNJx55I9ItWx8oGMnVVS8c2po49DMKt5zXceqbh1jMNt56HcBuajuOGHsZxQ9Nx3NDDOG7qtWObmnZsU9OObeqhY1t7Dbe1abitTcNt7SHcDeA7yIPvTF3B0nGBqeMaD2pvNPCNhVJmy3UFS8eNHla6ycB3JviOR76VvkzBDWz2sPIdHnx3hzQzLR33mTo+60HtftOVfuxhpV8Z+FaPObCc8dmmbED7bFM6tjB1NDnbPAJ8tY/S0tHkKC19tY/S0tHkKJ1M9ItWx8oGMnVVS8c2po4mh63TvIZ7mmm4p5mGe5qHcBuZjuNGHsZxI9Nx3MjDOM7w2rEZph2bYdqxGR46to3XcNuYhtvGNNw2HsKdCb6DPPhqn21KxwWmjiZnm9LX5GzzM/DVPtuUjiZnm9LX5GxzUOyB5YzPNmUDJmeb0neHB1/ts03puM/U0eRsU/pqn21KR5OzTelrcrY5FqojGJ9tyga0zzalYwtTR5Ozzangq32Ulo4mR2npq32Ulo4mR+l5RL9odaxsIFNXtXRsY+poctha6jXcpabhLjUNd6mHcFeZjuNVHsbxKtNxvMrDON7gtWM3mHbsBtOO3eChY7d7DXe7abjbTcPd7iHcH8B3kAdf7bNN6bjA1NHkbFP6mpxtXhJ/YDnts03paHK2KX1NzjZfBl/js03ZgMnZpvTd4cFX+2xTOu4zdTQ525S+2meb0tHkbFP6mpxtvgvlq7QPW9LR5LAlfbUPW9LR5LD1Ifga78dlA5m6qqVjG1NHo8MWFAkyvoyQDWhfRkjHFqaOJpcR94Gv9jiWjibjWPpqj2PpaDKOHyP6RatjZQOZuqqlYxtTR5Nx/KzXcJ81DfdZ03Cf9RDuK6bj+BUP4/gV03H8iodx/K7Xjn3XtGPfNe3Ydz107Ddew/3GNNxvTMP9xkO4a6HGkfHhRzagffiRji1MHU0OPzeDr/ZmKx1NNlvpq73ZSkeTzfYOol+0OlY2kKmrWjq2MXU0Gce7vIa7yzTcXabh7vIQ7l7TcbzXwzjeazqO93oYx0947dgnTDv2CdOOfcJDx+73Gu5+03D3m4a730O4RyYdWK5tpLlvXqSmYOlYYOo40YPaaQa+vTxkqZdplnqZZqmXhyz18pCleTXMsyR9tbMkHQtMHSd6UGuSpb01zbMkfbWzJB0LTB0nelBrkqUfaplnSfpqZ0k6Fpg6TvSg1iRLp9Y2z5L01c6SdCwwdZzoQa1JlnrWMc+S9NXOknQsMHWc6EGtSZaurmueJemrnSXpWGDqONGDWpMs3X+4eZakr3aWpGOBqeNED2pNshRxxIHltGf9pKPJrJ/0NZn1mwq+xrN+sgGTWT/pu8ODr/asn3TcFyr5aDmazPpJX+1ZP+loMusnfU1m/QYceWA57ct86WhymS99m5uu1OQyP9c00lwPkeaaRprrIdLRppGO9hDpaNNIR3uIdKZppDM9RDrTNNKZHiKdbRrpbA+RzjaNdLaHSOeaRjrXQ6RzTSOd6yHS+kcbRiodTSKVvtqRSkeTSEeBr/EckGzgXF3V0rGFqaPJHNBk046d7KFjJ5t27GQPHTuH6BetjpUNZOqqlo5tTB1NbiYv8hruItNwF5mGu8hDuMtNx/FyD+N4uek4Xu5hHK/32rHrTTt2vWnHrvfQsdu8hrvNNNxtpuFu8xDut+A7yIOv9pPM0nGBqeMaD2pNnmTucsyB5bTvaUhHk3sa0tfknsYL4Gt8T0M2YHJPQ/ru8OCrfU9DOu4zdTS5pyF9te9pSEeTexrS1+SeRidY0PhsUzagfbYpHVuYOpqcbfaEBbWP0tLR5CgtfbWP0tLR5CidTfSLVsfKBjJ1VUvHNqaOJoetfK/h5puGm28abr6HcIeZjuNhHsbxMNNxPMzDOB7vtWPHm3bseNOOHe+hY+d4DXeOabhzTMOd4yHcx2HBQR58tc82peMCU8c1HtSanG2ecfyB5bTPNqWjydmm9DU527wNfI3PNmUDJmeb0neHB1/ts03puM/U0eRsU/pqn21KR5OzTelrcrbZMfnAcsZnm7IB7bNN6djC1NHkbLMH+GofpaWjyVFa+mofpaWjyVE6C3yND1uygUxd1dKxjamjyWFrkNdwB5mGO8g03EEewi0EX+1xLB1NxrH01R7H0tFkHI8DX+OOlQ1k6qqWjm1MHU06drbXcGebhjvbNNzZHsJ9DHwHefDVPtuUjgtMHU3ONqWvydnm6TACtM82paPJ2ab0NTnbvBV8jc82ZQMmZ5vSd4cHX+2zTem4z9TR5GxT+mqfbUpHk7NN6WtytnnXyQeW0z5sSUeTw5b0bW66UpPD1m7wNd6PywYydVVLxzamjib78bnwk1/GlxGyAe3LCOnYwtTR5DJiGfhqj2PpaDKOpa/2OJaOJuN4HdEvWh0rG8jUVS0d25g6mozjjV7D3Wga7kbTcDd6CHeT6Tje5GEcbzIdx5s8jOOdXjt2p2nH7jTt2J0eOvYRr+E+YhruI6bhPuIh3BHwu2rGhx/ZgPbhRzq2MHU0OfxMBF/tzVY6mmy20ld7s5WORo9IE/2i1bGygUxd1dKxjamjyTie7zXc+abhzjcNd76HcJeZjuNlHsbxMtNxvMzDOF7ntWPXmXbsOtOOXeehYzd7DXezabibTcPd7CHcr8B3dqS57026Lw9Kxy2mjns8qH3IwPesU82zJH21syQdt5g67vGg1iRLWfXMsyR9tbMkHbeYOu7xoNYkS8tOM8+S9NXOknTcYuq4x4Nakyw9Vt88S9JXO0vScYup4x4Pak2y9Mfp5lmSvtpZko5bTB33eFBrkqWGZ5pnSfpqZ0k6bjF13ONBrUmW+jcwz5L01c6SdNxi6rjHg1qTLC1taJ4l6audJem4xdRxjwe1Jll6tJF5lqSvdpak4xZTxz0e1JpkKf6sA8tpz41KR5O5UelrMjc6F3yN50ZlAyZzo9J3hwdf7blR6bjP1NFkblT6as+NSkeTuVHpqzs3GjoMFhoCf91K+HJjcBuODpVcC4e9fZx4JM5q2xnpxW1H+6g7xp+2w9VEGy3gdzSkfrkut+ReFHyXy7h/Dkd8S8CjENZKac/FWseVbbsNYLEIawtYNYRdhNYtsXbwn3iEtQcsAWEdAEtEWEfAqiOsU1zJd/n3YsBqIKwzYFBCLuQWtmpJ+MrY5cfHPsyNUNaF1y3XmRDyb3xGoPXI9ct1yW3ZzfUJ8H1gblHnUdlD8ge0zx03snlBTuesEUX5WUOa5+SMyB05MgKpxKNFYvKvGrW6jPuJIjD3UxNxOCtRShRRShS10PKSi1fWY3PrdNuLVTSpmXWXqaYsE6todOOVuazmv26H0kTpjlOWqUbolrHE+a87ldJE6Y5XlokjdOM8S04uVw21JcddlBKn9FFzEoE0+JSHxlSMVB4SlGXiQ2XzIONJQPnwSXcapYnSnagsk0DolrEk+q87ndJE6a6uLJNI6JaxVEecXC4BtaWOO7z+KCInh2DcNaFipPKQpCxTPVQ2D/iIH/JXd1NKE6W7hrJMEqFbxlLDf90ZlCZKd01lmRqE7iT0XXL4zEm2pY47vP4oIieHYNw1o2Kk8lBLWaZmqGweZDxyWR91Z1GaKN2HKcvUInTLWA7zX3c2pYnSXVtZ5jBCt4ylNuLkcrVQW+q4w+uPInJyCMbdACpGKg91lGVqh8rmQcYjl8VXIfgKSz2fSgqVPUYnhcoeR5JCZfdNSaGy4x1fNeLzd/X8MylU9hwpKVT2uJsUKrsvTwqV3d8khcqO4cRQ6fMOfncW0tL8vL7w8a5FqTsL6rVWXKj0+FOXq4Mwee3mjj051sQVZNesgpzCoa3zc4fkVOaKT/24I6M7fGc6Mpr8X7rnhPdMlbnnhO/LRKJ+9iUmJxzGe9YQWl81P9YXTnUquucj15mANB2KK3y5LpzvOJ/y7e7h3XLp6lWz1JQsheFbHzgZ6g2rGEV8LbQ8dRgLobZCSlshIhH41lIm/A17/NRCevDGEBfS11grVPY2Bt4YdeOtZj9epxbSU41Yl+0dFT6Fkutwx8Qpvq/bCeNbMDGh0qeG1RAul2mA9MGTM6VuQ8UgTH7Hh+CKdsSyjcRQ6VsjMSgPib7kITWMbwmoeUhEuFzGgb/4tDqEtKm3F9SdFnUrpjr6HgqVvs2Cb8HI5fAtKLws3pYS0XopP/xdPSXG230CsZ64CmJRxxAeZ7Gh8vMrlzkf/lL5jUfLHYpxgG/NSVwuc2EFOis7DtRboNJHrre827ySx/tAvCweB9XReik//F29JMP77GoVrCc+VDreTPgb9vIRB2GsKRKtF+uLUrTHh0rfhrR9UlLe7UO8Trwvx8vg8SWX6QZ/qXGURPji40N9FDPDC4xs307gxC1T//YVpS8w8LSR+3HHo5xQviiu9Pqpiw/cxy3RpLMvFxIZaek+5rwxvr0SQnnxaXtMq+hcMQH99WkcOBVNUcntsbjPiYcToomHCWKUMeX+PRrzKKcSk8eVtmg8yX0LfrAhBfm0I26HtFNuhxSfe8b5krfiY20cykk0WlcMuqiWy8QhHTHo/3I/WHwsRRclxVPr8kEP9EBFrNy+4sr3i1b8aqFlYpFfNcWvmnIzwO0XKFZbfNylpn7Va0J3Hy9vLRYUFuXnjWsxIjerKDenU2FRqacw8IDGH3zxqD5rEFJEYB7fWahGtIU/8r51qJx14eXUnR4+0WyIMIYHr2Y+3sFKddv26c5KqYOXeuOisgeouFDpe+WtiDtmrYmntNoQO8K2ylNadUL0E17qePQxR+kVHVjkOhNCvvW/Qz2XQ+0s4Fdm3PvV7XPHXZo1JD8nqyi/sKBr7vBRuSOLIpC8WCUUzJUXbiTCog7C40/NUNnr/YhQ6TRSU1H4ulNyfk4hVCbNFd2IxNfr1H0jv26eU5oo3eU9/oR1U48/+aQ7tTLHQOq6OI7Qrfv4E54aCiEfNSd4WtanPJCPP1F5KO/cEueBmlqt7LSsOmXqHpbla7qcJ63+Lx+W8ThoRZzntyLO832JCSat8H5Krs+f68+KJ63wduLT/Xynon0unrvw5XqUmLSKV2JPlsKoA1ZEqHLPJ6s3/6hJHB9v1FbYyXKdCSF/nz2OP0ieDsXMpHpAk5qSpTB8dMfJUM941DvT+K4qdQQJobZCSlshIhHqkTUzZCER4QOzk+qZmI3ZyUNx5omPvvhofbrv604lZ/5ULXhGJoz0yYt2atabejBLzuipgzUyVPZsJkJZbxpqv7PveXHycF5k29RVTALSVV7u5DLN4G95s1n+3Bk90Md4dg2fPSYgXC5zXgU6cVsyTvWoRp2tqrNneBz4P1tDz+hROZDLtDxIDtSZn6hK5KA6ilPmgHpYHm8LkaGyM6SRRFsRiv728BdvL1hTTDlt4/1oef1icb/t4H1tAqHZ7yvn8q68oomcqds43m/KZeRjfuXN4Km+eD/fF3HB1Vapz/+XV1t4PTGhsg+uqk/82NzuYtC6eyEt+EUQv05aD+3MYMUXCVVlZtC3p5qIK0H1mJMsheErQZyMylwJ4ltv7qe8K0GfHt2qsJNxwH5eCSYeJE++DXLiSlB9ZCxZCsP3CXEy1HsV+Ozc/eArQep1jhBqK6S0FSIS4eeVoHr1hl8x0dFZC/kdqitB9SoWX2n5eMVDXiWoWvBVAr4ik89B4nvxFd1bdn0uRz7qoMXPp6lXhBLPQG118z0/4TycH/WKEJ+Z4GezysuhXKaiKy38HJ0fV0NJSA++QsNXSXKZ5hXoxG3JONWjG3XFJH3w843Riga/c1CjEjmQy7Q9SA7UV1ujKpGDGkQOkhQNeNypV4RJaB1qWxGK/ovhL95e1Ktiqm28P8XPWspttRrRrt9XbeqBlprPLm87pJ7j7gl/y7tqU33xPvlg+7fy7oTdC995Xu1lNfXviiy1sXrl49fVXqzSb1GIw68ERgInr/ZaEpy8umtFcPLxl9YEJx+DaUNw8nGYtgRHPVcqOfn8XjuCk4WL2hOcLGDUgeBkIaOOBCcLGnUiOFnY6GKCkwWOOhNcF8C6EFxXwLoSXDfAuhHcJYBdQnDdAetOcJcCdinB9QCsB8H1BKwnwV0G2GUE1wuwXgTXG7DeBHc5YJcTXB/A+hBcX8D6Elw/wPoRXH/A+hNcFmBZBJcNWDbBDQBsAMHlAJaDOHnnJBewXMTJcxFfLvoy0hr7uA90DvF8eWpF10NVZb4cPz+NbzREx5XWiZ+fxs+6ZOJ24DsuESBjzkF3+uQxOxetoz3KgfpuJ3XR78sYyWjSxL/jZFr4YM+qxxK5rlZOrm+KK8mP+3HvhuYB1hzlqao/Y94uVIJXxWfMZS7d88tD+5J4GsuXxCPtrT/s32MuaaVm6WVs8Upu8T0u3MfqPR08qydzI5dRrx3l/+UMAb7uw3lU727j+zjux+0H+RNM+B4RHgtq36n7fjwzSZV1CaG2QkpbIaItVYOXe5nqu/6Z8P+wxw++9o4tZ31+jzOqnoHOjGg+/D3YtXUItR9SNMgPNRbi0V8/Z5AOth3h7WUY/HU1jiA0JxB8TQUPhUqXKML9MArFGavoop5qkMtMQm2MRetVt6vy7uNST4JFK76JsJzaP3LbwOdMMYq+aAV3P1PQOq87iGa11oCP9w8d6h6qjJW6hzoL/lb2Hmpl7h/icoMyB+o9zChFJ86Ff/lJI++vJhH5kcssDJWfH3wuisdVtC/ni2mO2+xNaN3/jVe0PvV+L/XMfnn3e/G9VfU9f3xsqqiOho/HHUcdj3h7xOvE90PxMni8yWXWwl+qf/FxLgm1eV05sdo+b1Sv4fDTOVSseJkYItYNFcR6sH06vm6IIs7/5bxTrHL+H4OWuQ21uwmtN0Zp1+V3E7z8VHQsltte8Xmvj9dtCcp1m1xXNIpfLpOgXLfJ/+9C8SSWc90Wj67b5PVeYlz5fjGKXy20TFwF13vxxHXbVvieECq9j7E5znFfu+P0YfjOc/5hQLp/T5ulOf+rp82C+YcDWDD/EMw/cJl/kBw1/yA5ea8zj+AGAjaQ4AYBNojg8gHLJ7grALuC4AYDNpjghgA2hOCGAjaU4AoAKyC4QsAKCW4YYMMIbjhgwwluBGAjCG4kYCMJrgiwIoIbBdgoghsN2GiCGwPYGIIbC9hYghsH2DiCGw/YeIKbANgEgpsI2ESCmwTYJIK7ErArCW4yYJMJ7irAriK4KYBNIbipgE0luGmATUOcfBPIz3k8n84lwsF9+LL34Q82j4fv78rzYXz92we3A9+pe1JyDLl/BqF4/3dzdhlpVXnODuf14biS/Lgfd85uOmDNUZ6q+pzdwFAJXhXn7ORbP3LODo9N2Q7+lHc/XPrh7cnrvXXJU3Ueqe2cmrNR59nV8W/vvlXj4p/WkCmX96PU+9ORobL3tqUOiY+Gv24epvqu+8C90oPpjkHLjK+EPnvbYuNm5dUmnuT7usvmJvoguZmL9E0h8kTVI6LeYD7YG/Myzsq+MS8x/HytqkO+Ia3OTarz1ha3mVJvOsuxJ9dFbTPqfI7EFyHNt8D38mpCx6FlQ5AbtT4FnqPAmO05e39eSEqr8I1j6hnkFfD3YPMfpWpK+XLsPTD/sRWt+7+5RLQ+dW5DnfPH98zlMupby7XQMnEIk2OFqjft/zZR9hwWz2fjdeJ5ArwMVTNdzieVN/+hzmfi7cjH56HJ5+7U/asaK14mjoh1cwWxJhG++FhiY/5jO2p3B1ovNf/xEMHLT0XnS5zmPx5E8VTF+Q85P+P3/Ifsa3efcyR0Luf5D5+eA0oN3r8I5j+C+Y9g/kPlgvmPYP5D5YL5j0Mz/+Fy8v7rdIXj+Y5T2iGuCZrGoiao13ec+uJ24Dv1jpMcX/ie83S0jnwlB1gzNV/iy/xZRka63+NP5jqayHVMJXPtzo3MAD4T5aSqz40MCpXgVXFupB98l3MjXt/1wNtTnGFbcQqP7yer+2DcVjTRlnpPWK2bYPGeVga+hxMZKj3HgN/fSPRn/QfuZaB48fOy+BlaucwEpCMJ5RffZ8L7nOpK20no/3LZ6krb1P2pqFCozPss8rsv73dBRbRERYd/77Mc+Al6/MFjFVdE8+feOF0RDVe3lPEn+ZRvWSxLfV5dvcfr4wsS4Qx88ClVsB+w6kjMt/AdT1SpGypOpvoyAr7Rjge3Pw+9lC5khSfWFqB1+zO408iSxuqLV3gnsgLpWxIqyXNFL0VRk+AyjspMglMPrsjJP3UQqjsei5N/GXjsyMk/9cU2ta9sTrTEoPW/gPKxLlSS83giHzG+6Ck7aUcdbPCB5Eak+TPf9ZUunYm3q5uU9VH6oxXc/WxDbdwaKsl5RZNdsg21MF6EookaS3jdW+DvwV4IwhNPnyGNsh28feJ9ptSkvshElU6uoeiWy+AXmeQyOyvQHVVO+3Lyt6aCZcL/w94+xdtxLaQVT7bWRLhc5t4KYsBthUL0wTkCtSuXkT54vTXQdzU/SUR+avmSnwPbNc4Dzg/Om1zmoVD5+aEesvN7Mj4yomTd/41JtD61L3BhOLmM2qfSB+dBLlMDYfiYJdtStyn1pWNqm4pX2sHb1HPw92AvzOGXA+U+Dx8jKnoZGI899bxH3WfbfsikhrI+O21XPK7xy7dymddDFef5v8ngUMnfqj6u1RdxqXGNcyExdVzj4ov4+IHPrfGFJVWyP1ZZBh+L5TKfwN+DHffwsRSfW/j5g9Zq8YdYIlasCy9DHeO/riDWJMJXvUaI9ecGWnGxqxh0kxXfuIpFN0bljbL/9cMe+KbewR72iIgoweMUrXHKTTYXr8wDITInFT0QEqXcbCy+XtLwox4kqaaxPuwXW8ENSuoBlB/he2LIzgNIsRElbcehfRz1ANIRBC8/EaX/y/YBpLpoTFbFB5ASQZ/fDyDJvnbH2WoQwPIBpKwM/wrApoaDArCh4AGk4AGk4AEklQseQAoeQFK54AEk/x9Akhz1AJLk5AMQMwhuJmAzCW4WYLMIbjZgswluDmBzCG4uYHMJ7mrAria4eYDNI7j5gM0nuAWALSC4hYAtJLhFgC0iuMWALSa4JYAtIbilgC0luGWALSO4awC7huCuBexaglsO2HKCWwHYCoJbCdhKglsF2CqCWw3YaoJbA9gaglsL2FqCWwfYOoK7DrDrCO56wK4nuPWArSe4GwC7geBuBOxGgtsA2AaC2wjYRoKTBZhvIribAbuZ4G4B7BaCuxWwWwnuNsBuI7jbAbud4DYBtongNgO2meC2ALaF4LYCtpXgtgG2jeDuAOwOgrsTsDsJbjtg2wnuLsDuIrgdgO0guJ2A7SS4uwG7m+B2AbaL4O4B7B6C2w3YboK7F7B7CW4PYHsI7j7A7iO4+wG7n+D2AraX4B4A7AGCexCwBwluH2D7CO4hwB4iOFkU4WGCewSwRwjuUcAeJbjHAHuM4B4H7HGCewKwJwjuScCeJLinAHuK4J4G7GmCewawZwjuWcCeJbjnAHuO4J4H7HmCewGwFwjuRcBeJLiXAHuJ4F4G7GWCewWwVwjuVcBeJbjXAHuN4PYDtp/gXgfsdYJ7A7A3CO5NwN4kuLcAe4vg3gbsbYJ7B7B3CO5dwN4luPcAe4/g3gfsfYL7ALAPCO5DwD4kuI8A+4jgPgbsY4L7BLBPCO5TwD4luM8A+4zgPgfsc4L7ArAvCO5LwL4kuK8A+4rgvgbsa4L7BrBvCO5bwL4luO8A+47gvgfse4L7AbAfCO5HwH4kuJ8A+4ngfgbsZ4L7BbBfCO5XwH4luN8A+43gfgfsd4L7A7A/CO5PwP4kuL8A+4vg/gbsb4L7B7B/CO5fwP4luFITtQoXITGCiwQskuCiAIsiuGjAogkuBrAYgosFLJbgqgFWjeDiAIsjuHjA4gkuAbAEgksELJHgqgNWneCSAEsiuBqA1SC4moDVJLhagNUiuMMAO4zgagNWm+DqAFaH4OoCVpfgDgfscII7ArAjCO5IwI4kuKMAO4rgjgbsaII7BrBjCO5YwI4luOMAO47gjgfseII7AbATCO5EwE4kuGTAkgnuJMBOIriTATuZ4E4B7BSCSwEsheBOBexUgqsHWD2COw2w0wiuPmD1Ce50wE4nuDMAO4PgzgTsTIJrAFgDgmsIWEOCawRYI4I7C7CzCC4MWJjg5OSZQ3CpgKUSXGPAGhNcGmBpBJcOWDrBNQGsCcE1BawpwWUAlkFwzQBrRnBnA3Y2wZ0D2DkEdy5g5xLceYCdR3DnA3Y+wV0A2AUElwlYJsE1B6w5wV0I2IUE1wKwFgTXErCWBNcKsFYE1xqw1gTXBrA2BNcWsLYEdxFgFxFcO8DaEVx7wNoTXAfAOhBcR8A6ElwnwDoR3MWAXUxwnQHrTHBdAOtCcF0B60pw3QDrRnCXAHYJwXUHrDvBXQrYpQTXA7AeBNcTsJ4EdxlglxFcL8B6EVxvwHoT3OWAXU5wfQDrQ3B9AetLcP0A60dw/QHrT3BZgGURXDZg2QQ3ALABBJcDWA7B5QKWS3B5gOUR3EDABhLcIMAGEVw+YPkEdwVgVxDcYMAGE9wQwIYQ3FDAhhJcAWAFBFcIWCHBDQNsGMENB2w4wY0AbATBjQRsJMEVAVZEcKMAG0VwowEbTXBjABtDcGMBG0tw4wAbR3DjARtPcBMAm0BwEwGbSHCTAJtEcFcCdiXBTQZsMsFdBdhVBDcFsCkENxWwqQQ3DbBpBDcdsOkENwOwGQQ3E7CZBDcLsFkENxuw2QQ3B7A5BDcXsLkEdzVgVxPcPMDmEdx8wOYT3ALAFhDcQsAWEtwiwBYR3GLAFhPcEsCWENxSwJYS3DLAlhHcNYBdQ3DXAnYtwS0HbDnBrQBsBcGtBGwlwa0CbBXBrQZsNcGtAWwNwa0FbC3BrQNsHcFdB9h1BHc9YNcT3HrA1hPcDYDdQHA3AnYjwW0AbAPBbQRsI8HdBNhNBHczYDcT3C2A3UJwtwJ2K8HdBthtBHc7YLcT3CbANhHcZsA2E9wWwLYQ3FbAthLcNsC2EdwdgN1BcHcCdifBbQdsO8HdBdhdBLcDsB0EtxOwnQR3N2B3E9wuwHYR3D2A3UNwuwHbTXD3AnYvwe0BbA/B3QfYfQR3P2D3E9xewPYS3AOAPUBwDwL2IMHtA2wfwT0E2EME9zBgDxPcI4A9QnCPAvYowT0G2GME9zhgjxPcE4A9QXBPAvYkwT0F2FME9zRgTxPcM4A9Q3DPAvYswT0H2HME9zxgzxPcC4C9QHAvAvYiwb0E2EsE9zJgLxPcK4C9QnCvAvYqwb0G2GsEtx+w/QT3OmCvE9wbgL1BcG8C9ibBvQXYWwT3NmBvE9w7gL1DcO8C9i7BvQfYewT3PmDvE9wHgH1AcB8C9iHBfQTYRwT3MWAfE9wngH1CcJ8C9inBfQbYZwT3OWCfE9wXgH1BcF8C9iXBfQXYVwT3NWBfE9w3gH1DcN8C9i3BfQfYdwT3PWDfE9wPgP1AcD8C9iPB/QTYTwT3M2A/E9wvgP1CcL8C9ivB/QbYbwT3O2C/E9wfgP1BcH8C9ifB/QXYXwT3N2B/E9w/gP1DcP8C9i/BlarWonAREiO4SMAiCS4KsCiCiwYsmuBiAIshuFjAYgmuGmDVCC4OsDiCiwcsnuASAEsguETAEgmuOmDVCS4JsCSCqwFYDYKrCVhNgqsFWC2COwywwwiuNmC1Ca4OYHUIri5gdQnucMAOJ7gjADuC4I4E7EiCOwqwowjuaMCOJrhjADuG4I4F7FiCOw6w4wjueMCOJ7gTADuB4E4E7ESCSwYsmeBOAuwkgjsZsJMJ7hTATiG4FMBSCO5UwE4luHqA1SO40wA7jeDqA1af4E4H7HSCOwOwMwjuTMDOJLgGgDUguIaANSS4RoA1IrizADuL4MKAhQnOAcwhuFTAUgmuMWCNCS4NsDSCSwcsneCaANaE4JoC1pTgMgDLILhmgDUjuLMBO5vgzgHsHII7F7BzCe48wM4juPMBO5/gLgDsAoLLBCyT4JoD1pzgLgTsQoJrAVgLgmsJWEvEyeKsrQBrhThZWyIqVBrLhP+HvXz8LM6aGnYOaXHW1APv5OPP/4/FWZMjUTuAU8VZ5fjCxVnluHLbOTOyJAdq7bcoRbNvYyQrrfhxhKr6Y3Y41zMTSvLjftyCra3l/gHlqaoXbD0D9XtVLNh6EvxHFmwNfviydI7U/WekvfUXP8IU709uS9VUlLHFK7nFPxSF+xjXnYwOla0JF4mWUWtayv+fDQmsFaJr00kspKwDj800+A/1A2tU31F1HNV6ATaKEuP9WJxBW+r+3Wa9QVyPKLac9fk9zmKU9eP+jlWWkb649uBFkKiD1SAKofZDigb5ocZCPPqbgNqweS5Wme0Iby+dQairsWtkWc04f13RdoFxmR/cvuS6o+NQrKIrXllHDFqmD9LVE623olqr+JwqitAXrfgmwnJq/8htA58zxSj6qBqZWUjz5INoVmvOuev2pX4wjAlcZwznHte5k8sMrGA7wG3JPKjnkRGhsj/6l4TilDlIVDREhcrWQ8PXRv7UVz6wL6mh5CeJyI9cpvAg+4ko5bzT1e5nbbyZ6Pz1v/GK1qfWvVNrPlP9VQPF435qoWUSEUb9aCc1tn067jjqeMTbI15nIsLwMni8yWUmVdC/+DiHa0zK7d2/Y96BWNVruHikgYoVLxNDxDr9IGO5on26jfpnc9E+cx4ex0q7Lr+K4EMobvzhWv9sBTpeVsX6ZwvhPwkhf+ufrULXh/XQtoX3WTzqnx249/F/pf6ZPB8I6p8F9c9ULqh/FgrqnylcUP8sqH+mckH9s6D+mcoF9c+C+mcqF9Q/C+qfqVxQ/yyof6ZyQf2zoP6ZygX1z4L6ZyoX1D8L6p+pXFD/LKh/pnJB/bOg/pnKBfXPgvpnKhfUPwvqn6lcUP8sqH+mckH9s6D+mcoF9c+C+mcqF9Q/C+qfqVxQ/yyof6ZyQf2zoP6Zyj0AWFD/rDQX1D8L6p+pXFD/LKh/pnJB/bOg/pnKBfXPgvpnKhfUPwvqn6lcUP8sqH+mcv8X659Jrrz6Z7hug3ynMD5U8i6vXC4T/h/28slIK55aDmqiWVi/QU20aIRVtibaUZHIB3BcX4eqf3YK+OA6XvLj9kdVr+N1cmQJXhXreB0N/0kEH1wjR77/j33cGhJ14Xvu0PyiVgUDRowbVpSb06mwKLdD4cCQ8okivuP1RESW8DGEj+zXCDCMRyr+clk3lvqAxYdKtNveZuIJnVbazkjL8W1fEw4XPwYT70/bpd45j0N9IPuVeie7vGNHqTqJ6HgS40/O033MeTquxRFCeUnwZ31NKjqeJKC/Po2D4uNJgrJ+uS7qeELVfUxAWIwypty/R2Me5VRich/TDo0nebxpj9pLQT6yHoAci3VCpWsEyHVU9ePOKaESvCoed46B7/K4o557qDWO3OPOYfC9oLAoP29cixG5WXDcwYMdD2j8wYV3opSVhRQReFl8QKxG8PijHqTKW5ba6UndbkLejCzB2B28sgY09e/EPK3KFUz574IJsKBgSmkuKJgSFExRuaBgSlAwReWCgilBwRSVCwqmBAVTVC4omBIUTFG5oGBKUDBF5YKCKUHBFJULCqYEBVNULiiYEhRMUbmgYEooKJiicEHBlKBgisoFBVOCgikqFxRMCQqmqFxQMCUomKJyQcGUoGCKygUFU4KCKSoXFEwJCqaoXFAwJSiYonJBwZSgYIrKBQVTgoIpKhcUTAkKpqhcUDAlKJiickHBlKBgisoFBVOCgikqFxRMCQqmqFxQMCUomKJyQcGU0gVTJCeLWrQmuDaAtSG4toC1JbiLALuI4NoB1o7g2gPWnuA6ANaB4DoC1pHgOgHWieAuBuxigusMWGeC6wJYF4LrClhXgusGWDeCuwSwSwiuO2DdCe5SwC4luB6A9SC4noD1JLjLALuM4HoB1ovgegPWm+AuB+xygusDWB+C6wtYX4LrB1g/gusPWH+CywIsi+CyAcsmuAGADSC4HMByCC4XsFyCywMsj+AGAjaQ4AYBNojg8gHLJ7grALuC4AYDNpjghgA2hOCGAjaU4AoAKyC4QsAKCW4YYMMIbjhgwwluBGAjCG4kYCMJrgiwIoIbBdgoghsN2GiCGwPYGIIbC9hYghsH2DiCGw/YeIKbANgEgpsI2ESCmwTYJIK7ErArCW4yYJMJ7irAriK4KYBNIbipgE0luGmATSO46YBNR1wMcDMAm4E4WRAkKlQay4T/h718Mg7UCfCpBsEhLg6Wxq44WBTCKlscrH8kagdwXBxMxizHFy76IseV287gyJIcxCiaoxTNvo2RrIzix/H86Y+08MEK58QSua5WTq4fTSjJj/txC97MBKw5ylNVL3hzBer3qljwJgv+49Z3wcWJ5MfH8eJUtP+Q60wI+bQtwP6jmrJ+uS68LeL9Z6S99Rc/whvvT26Lx2+8Elu8ktukUMntWNzHifBdjvsElAuZG7lMIvKLQf8fDwmshfxxHiUWUtaBx2YR/Kcm0ofHgtp36r6/VqhsvRzqGFnROMRtqRqSQqWPP5VtS92/u3nLhP+HPX5qIU2x5azP73EWo6wf93essoz0jUHLzIFE1Q6V/VD7qMr2H86H/JuA2rB5LlaZ7QhvL4tAqKtxSWRZzTh/S9B2gXGZH9y+5K5Bx6FYRVe8so4YtMxapGsFWq+6XeFtFJ9TRRH61CKribCc2j9y28DnTDGKvmgFdz/rkea9B9Eco2h2110drd/2mEhCenHuqyNcLnNzBdsBbkvmQT2PjEDtymWSUJwyB4mKhihFJ86Fb/mBfUmNUOn8JBH5kctsPch+Iko573S1R/tyvpjmuM0+is5f/xuvaH01kD6qmCDVXzVQPO6nFlomEWFqDcDyxrZPxx1HHY94e8TrTEQYXgaPN7nMfRX0Lz7OJaE25fbu3zHvQKzqNVw80kDFipeJIWJ9+CBjuaJ9Or5uiCLO/2XB5Fjl/D8GLfMk2mc+jcex0q7Lv0HwIRQ3/uBjsdz2is97fbxuS1Cu2+S6olH8cpkE5bpN/n8/Ol4mlnPdFo+u2+T1XmJc+X4xil8ttExcBdd78cR123Pwn4RQ6X2MzXGO+9odp3lo28L7LB71Pw/c+/i/Uv9Tng8E9T+D+p8qF9T/DAX1PxUuqP8Z1P9UuaD+Z1D/U+WC+p9B/U+VC+p/BvU/VS6o/xnU/1S5oP5nUP9T5YL6n0H9T5UL6n8G9T9VLqj/GdT/VLmg/mdQ/1PlgvqfQf1PlQvqfwb1P1UuqP8Z1P9UuaD+Z1D/U+WC+p9B/U+VC+p/BvU/VS6o/xnU/1S5oP5nUP9T5R4ALKj/WZoL6n8G9T9VLqj/GdT/VLmg/mdQ/1PlgvqfQf1PlQvqfwb1P1UuqP8Z1P9UuaD+Z1D/U+WC+p9B/U+VC+p/BvU/VS6o/8mz/qfkyqv/iesWyXfq40MltSzkcpnw/7CXT0Za8aNVQU1QC+s3qAkajbDK1gTtGYl8AMf15aj6nwPAB9exlB+3P6p6HcvsyBK8KtaxvAz+kwg+uEacrH+DfdwaSnXhe+7Q/KJWBQNGjBtWlJvTqbAot0PhwJDyiSK+4/U0jyzhYwgf2a8RYBiPVPzlsm4scAut+G9dhc+E/4e9fYofFz3cn7bDeN8j9R+OYkJhW1snzj2u0xSJMMnHIS0R9rU4qMnidar7xzroewShKQFxFvul+DHgRH/aLtXnUn9iqGw/RBOx4++RaFmKp7AkYj11COz/Af4SuYKdEUYA","debug_symbols":"7L3fbuTau133Lr9rX5BcH//5VYIgcBInMGDYQexcGefdo727SVW3aolb1uqvJuca5+qcA0K7ao7Z0pqDEut//Ov//I//+//3f/9v/+m//F//9b/969//L//jX//5v/4f/+G//6f/+l/e/q//8a81/v7//bf/5z/8l7/+z//23//D//vf//Xvx3WKf/ev//hf/s+//tcS//bv/vV//af//B//9e/X4d/+3YeLp31cfl487WU7Lx7j2dVl3tefV5flr6/36dXjsJZyvJJhjeX9+n19dn05v/oY4/vVf72HjxePw/kux7k8Xvy//rt/rTPJVJJZSKaSzEoylWQ2kqkks5PM82S2gWQqyYwkU0lmIplKMoVkKskEyVSS4QxcS4YzcC0ZzsC1ZDgD15LhDFxJZucMXEuGM3AtGc7AtWQ4A9eSCZKpJMMZuJYMZ+BaMpyBa8lwBq4lwxm4ksw4cAiuRsMpuBoNx+BqNJyDq9EE0dSi4SRcjYajcDUazsLVaDgMV6PhNFyLZuQ0XI2G03A1Gk7D1Wg4DVejCaKpRcNpuBoNp+FqNJyGq9FwGq5Gw2m4Fs3EabgaDafhajSchqvRcBquRhNEU4uG03A1Gk7D1Wg4DVej4TRcjYbTcC2awmm4Gg2n4Wo0nIar0XAarkYTRFOLhtNwNRpOw9VoOA1Xo+E0XI2G03AtmuA0XI2G03A1Gk7D1Wg4DVejCaKpRcNpuBoNp+FqNJyGq9FwGq5Gw2m4Fs3MabgaDafhajSchqvRcBquRhNEU4uG03A1Gk7D1WjkT8Pr8B7NFlfRbMt4XL5tw/eikT8Nvy6a75+GyzZOx5vd4iGacf77P7EMf/4/8f3T2TiVA/A4reP7f2Jenly9T+v+8+p92pdfXtCT8kwxzkd7poj4+Aamu7+BpyedOebjDcyxTVdvIM5aT9t8XrxvP/4L8cf/C/Mf/y8sf/y/sP7x/8L2/f9CifPHXnn4Bvb2X3jWvS3O6u3v//b35el3u20/v9s91Hoan169z+fV+8PVz7/0Nmznd93p/d/X9OMb6bITy5NY1oFYnsUy9hrLdP6Q2sr+IZaJWJ7FUojlWSzRaSzrcl68xfAhltkmlmkYjzk9DfP0vW+5C7E8i2Ullmex+JxyvxjL599yfU65LWPZfE65TWPxOeV+LZbPf0BvVqfc7T2W8vil/36nVgfXT99pGFX9bO80Dldf+vMfo5vTWbRhLE5n0YaxOJ1FvxTL5z9Gnc6iDWNxOou2i2V3Oot+JZbPD127lXHd3mPZfz+K7J7Hy2fv1Od4OY3TeYP17W7wt36M7kZn0ZaxGJ1FW8ZidBb9Wiyf/xg1Oou2jMXoLNoyFqOz6Jdi+fTQNQ1Wd//fjyLL7/5nGkyPl0/eafbxssT5TqPMF+90mPbz3+lQHo6Mf/wXcKehEMzzYIJgngczE8zzYBaCeR7MSjDPg9kI5nkwO8E8DWYcCOZ5MCPBPA+Gk28lGE6+lWCCYJ4Hw8m3Egwn30ow2iff8vB3v2//matg2v0F5zRqn3xfGIzOyfevlzO1OG+eanaM4eLljGU+o5ynBzU7hhioaSSZSjITyVSSKSRTSSYaJHM+7OD3ZP7+L1wf3vby+X9hK8ff828P4Tz9EVL2425ElMcbTOOTa/f1/DP1fX24dfE89XLeFXn8yk8zn9b1/N6+btsFoJY0K+fBaX/Permguc5nF9fl4eKf/4XnB6t5PB5JMc9x9eiBJc5/Scv+/pNv/OtG6Yer1/1kP75/4f0Zzzj/Ki4eaK7xzUuHsyUxzO8wp/1HIFt3gYzTccyJcd0/BLLTkF8Cef4ZKh035Pknp/TckImG/BpI6S2Qso7HwaWsSzycXH4EEsmBbO8uZoj9MZG/X878wpfz+FtGP1/OkvxyxmE9rx729fPCzPMwnq9j/PVxVE/OjlcPT5rK2tW7vT5fLevn77Ys5+PV1offfXp26RTLcFqZh+9Lf/89wcdgPn320VT22770GO770sf7vvTpvi+9CL90v0dCTRHknZr3TN6peS/k3Tjvz/4kYYqVvFPzVj7WOuatfBb3e6zcNCsPCL8nkE2z8upxzFt5qjnmzb5snfenPy9n9mVu3uzL3LzZl43zvjgPsi+/9KfUHx8aOM1Mxm9HyArMfETftLACc/NmBebmzQpsnfenp7aFFZibd5B3at6swMZ5f75KFlbgN5+qOS0Mu29HyLDLfIbltLACU/NeWYG5ebMCW+f96altZQXm5s0KzM07yLtt3p+vkpUV+N3Hzq4Mu29HaDPs7vLQotVmB94mcZsleJfEN5steJvEbdbgbRK32YO3SdxmEd4m8SDx5MRtVuFtErcZkbdJnM2ZnTibMztxNmdy4nunm/N1TxXdO92cL0y8g8359/uUXnqWjwjepaeeZ+TSW+/Txz3vuaNpHo5rp3larl7658+w2tf7vvTtvi99v+tLL8Mg/NL9HgpVhpG8U/OeyDs170LejfP+7BfbyhDknZr3TN6peSufxf0eelYG5QHh91CoMiivHse8laeaYd4j+zLzoVBlZF/m5s2+zM2bfdk478/PgyP78ptP7Cojk/HbEbICMx8KVUZWYG7erMDcvFmBmQ+FKhMrMDdvVmBu3qzAxnl/vkomVuA3n9hVpiDC70bIsMt8KFSZWIG5ebMCc/NmBWY+FKpMrMDUvAsrMDdvVmDjvD9fJYUV+M0ndpXCsPt2hOES4U3+OLcUmx14m8RtluBtErfZgrdJ3GYN3iZxmz14l8TDZhHeJnGbTXibxG1W4W0StxmRt0k8SDw5cTZnduJszuzEO92cL3toT4lON+cLE+9gc/71Pmfppef4BK6310nk2ZFLb73PHnpW5uTRtB+hT8vDi6k9w+r8g7bx7cba59/Ny37cHYvyeIt2fHLtvo5HDff14Vba86aU8y7d41d+2pNpXc/vhuu2XZSqZQMjF+OynA3crzDu83q8z/2Xq8f52dVbOdlsa/xy9d/vdO7mnS7dvNO1m3e6ubzTt4VYzt9qHKZt+fhe937e6zL4vNelDOd7XR7PUU+v7/vn7jKacn/4nbiz41NH77V09F7D572uy3S+12148n3a5vT4D96rzfnxH7xXmxPkP3ivRmfIy/dqdIa8eq+r0Rny8r0anZsu36vRuenyvRqdmy7fa3T0Xjs6N60dnZvWjs5Na0fnprWjc9PW0blp6+jctHV0bto6OjclfwD3a99rR+emraNz09bRuWnr6Ny0dXRu2js6N+0dnZv2js5Ne0fnpuRPs33te+3o3LR3dG7aOzo37R2dm/Z+zk0x9HNuiqGfc1MM/ZybYujn3BRDdPRe+zk3xdDPuSmGfs5NMfRzboqho3PT2NG5aezo3DR2dG4aOzo3ZX8G4Evfa0fnprGjc9PY0blp7OjcNHZ0bpo6OjdNHZ2bpo7OTVNH56bsj9h66Xvt6Nw0dXRumjo6N00dnZumjs5NpaNzU+no3FQ6OjeVjs5N2Z9g89L32tG5qXR0biodnZtKR+em0tG5KTo6N0VH56bkT6TYzqcIT3u5eq9/PW/8fPHL1dVljuPBoGWe319IeZ7L+cjZcZh/+cp/p1JI5UkqQSpPUpmFU5m282G5sewXV799wen82sv4cPWzXOZpP66eyy+5lB+5LL3msi7vuSwXV8dwPv0whocmTvuPEFdC/AchjtPxut9u7u4fQtw6DfH9wepzmYerEOP8KNmIh5PF9OwJmGUdtzOQJR4v/jvxncRbJ77F8ULK9jHx5M9UIPFI/kgFEo9Zeat4Jq68gzwTDxJPTrzX/fa6xHtdhq9LvNcZ+brEbTZnGdbzjQ77epXhfgYej69jf0Ynzmu3x2uHrw/O2WZwisT9ebsXm7V5j7htpuY94rbZmfeI22Zk3iPuIO7MuG3m5T3ittmW94jbZljeI25W5WXcy3DcOV7KfBH3dv7q1bY9uIRl+JE2o7Jp2vtyfGri/vgPYXka3B7H7/OUfXn/ytOzj3mOspy/RFG28njxXxxX1qoHR2awB0f2tQdHhrsHx4CjBUdUgwdHHIYHR+SIB0esiwdHfI4Fxw2f48ERn+PBEZ/jwRGf48Ex4GjBEZ/jwRGf48ERn+PBEZ/jwRGfY8Fxx+d4cMTneHDE53hwxOd4cAw4WnDE53hwxOd4cMTneHDE53hwxOc4cJwHfI4HR3yOB0d8jgdHfI4Hx4CjBUd8jgdHfI4HR3yOB0d8jgdHfI4FxxGf48ERn+PBEZ/jwRGf48Ex4GjBEZ/jwRGf48ERn+PBEZ/jwRGf05TjGGU8X/O8XJCcYynny9iWz0m+gTyDXh6xz88uLsP52UpljMeL/8I+oX+6xI4t6hI7cqlL7LgoT+zvr6NErB+wB9h7xI7pMsV+fqBNiYdPtHl68bSv71i2/eLiiGN0TrGsn1/8/v7i8ev+WJETdo7uvap7GEW698XubcdXnuZh/073sKB071Xdw9zSva91b52O6KZ1iYuLh3IUaRrm8o2iFlwzRb1FUbHjFPVPFnXZzqLu43eKis+nqLcoKncgKGoZxnJGN1185amsZ1HLPj1e/HehgkJRqC8VqploLNxgoXuv6h43WOjeq7rHDRa698XutZLchRssdO9V3eMGC937Wvfm/fyZu0zD7+M1uBFCoZoWihsWFKppobixQKGaFoobABTqa4X6yp2qcdvOOPbhw92CCNpH+17WPu4X0L4/1752v/cU3FygqLcoKnciKOotisptC4r6J4va6hf0gnscFPUORZ25d0JR3/I6n4AwTt9b5zP3TihU00Jx74RCfalQ7fbGzG0Wuveq7gXdo3sv6h63WOjeF7vXbJFy14Tuvap73Ajx7N4cZxpvkC/q9KU/AP/872pnblhQqBc9wG/mHgTde1H3Fm4r0L1XdY87EHTvRQ+PXLhZQfde1T1uVtC9r3Xv8z8yWoJCUaiWheK2AoVqWijuFVCopoXiBgCF+nNPgL34VbeFuwW073Xt434B7bvD5wms3FygqLcoKnciKOotisptC4p6hw++WLnHQVFvUdSgqN0X9UUPll+5zUL3XtU97sjQvRc9WH7l5g3de1X3uHVD9+7wCLWVuzwU9Q5F3bjLQ1Hv8Ai1jbs8FPUWReUuD0Vt+Wi2jbsxFKppoYJCUajXPPNq464J3XtV97hrQvde1T3umtC9Fz1vbeOuCd17Vfe4EdK2e9twfOFxm8ZfuvdX3js+PzdvtHRu3tjV3LyRj38u7zE+5h3knZo3Pio3bxxMbt54h9y82dq5ebMvM8+Dy8C+zM2bfZmbN/syN2/2ZW7eQd6pebMvc/NmX+bmzb7MzZt9mZs3+zI175F9mfa7Cn/nzb7MzZt9mZs3+zI37yDv1LzZl5d5r+evyW3jcJH324HvYPP4S3Lj+iNt1mVm2mzLzLRZlplpsysT055YlZlpsykz02ZRZqbNnsxMO0g7MW22ZGbabMnMtNmSmWmzJTPTZksmpl3YkplpsyUz02ZLZqbNlsxMO0g7MW22ZGbabMnMtNmSmWmzJTPTZksmph1sycy02ZKZabMlM9NmS2amHaSdmDZbMjNttmRm2mzJzLTZkplpsyUT057ZkplpsyUz02ZLZqbNlsxMO0g7MW22ZGbabMnMtNmSmWmzJTPTZksmpr2wJTPTZktmps2WzEybLZmZdpB2Ytpsycy02ZKZabMlM9NmS2amzZZMTHtlS2amzZbMTJstmZk2WzIz7SDtxLTZkplpsyUv097242Xsl08pnpb5/Q2e15ZnnxY/D0cWc5k+v7RscbyEsv36df+GyEQ1gMjyNYDIoL4/xI2dbgCR+W8AEatgABFZYQAxgHh/iKgVA4gYGwOIGBsDiBgbA4gYm/tD3DE2BhAxNgYQMTYGEDE2BhADiPeHiLExgIixMYCIsTGAiLExgIixuT3EdcDYGEDE2BhAxNgYQMTYGEAMIN4fIsbGACLGxgAixsYAIsbGACLG5v4QR4yNAUSMjQFEjI0BRIyNAcQA4v0hYmwMIGJsDCBibAwgYmwMIGJs7g9xwtgYQMTYGEDE2BhAxNgYQAwg3h8ixsYAIsbGACLGxgAixsYAIsbm/hALxsYAIsbGACLGxgAixsYAYgDx/hAxNgYQMTYGEDE2BhAxNgYQMTb3hxgYGwOIGJsbQIxhOT7JNMZp+fzicZ+PIMZ9+0gcvdMbcVxQb8QD4p0RxzL1Rhwl1Rtx/FVvxJFdvRHHjHVGfEaj9UYc59YbcZxbb8Rxbr0RD4h3Rhzn1htxnFtvxHFuvRHHufVGHOfWGfEF59YbcZxbb8Rxbr0Rx7n1Rjwg3hlxnFtvxHFuvRHHufVGHOfWG3GcW2fEV5xbb8Rxbr0Rx7n1Rhzn1hvxgLg+8XnYj/c2jw+5HRDRaAYQMWMGEJFdBhDxVwYQUVL3h7hhmQwgIo4MIOKCDCCidwwgBhDvDxFjYwARY2MAEWNjABFjYwARY3N/iDvGxgAixsYAIsbGACLGxgBiAPH+EDE2BhAxNgYQMTYGEDE2BhAxNreHuA0YGwOIGBsDiBgbA4gYGwOIAcT7Q8TYGEDE2BhAxNgYQMTYGEDE2Nwf4oixMYCIsTGAiLExgIixMYAYQLw/RIyNAUSMjQFEjI0BRIyNAUSMzf0hThgbA4gYGwOIGBsDiBgbA4gBxPtDxNgYQMTYGEDE2BhAxNgYQMTY3B9iwdgYQMTYGEDE2BhAxNgYQAwg3h8ixsYAIsbGACLGxgAixuYOEMv5iZlz2ZcPEDE294cYGBsDiBgbA4gYGwOIGBsDiAHE+0PE2BhAxNgYQMTYGEDE2BhAxNjcH+KMsTGAiLExgIixMYCIsTGAGEC8P0SMjQFEjI0BRIyNAUSMjQFEjM39IS4YGwOIGBsDiBgbA4gYGwOIAcT7Q8TYGEDE2BhAxNgYQMTYGEDE2Nwf4oqxMYCIsTGAiLExgIixMYAYQLw/RIyNAUSMjQFEjI0BRIyNAUSMzf0hbhgbA4gYGwOIGBsDiBgbA4gBxPtDxNgYQMTYGEDE2BhAxNgYQMTY3B/ijrExgIixMYCIsTGAiLExgBhAvD9EjI0BRIyNAUSMjQFEjI0BRIzN7SHuA8bGACLGxgAixuYGEJehHDyWYZ8+QMTYGEAMIN4fIsbGACLGxgAixsYAIsbGACLG5v4QR4yNAUSMjQFEjI0BRIyNAcQA4v0hYmwMIGJsDCBibAwgYmwMIGJs7g9xwtgYQMTYGEDE2BhAxNgYQAwg3h8ixsYAIsbGACLGxgAixsYAIsbm/hALxsYAIsbGACLGxgAixsYAYgDx/hAxNgYQMTYGEDE2BhAxNgYQMTb3hxgYGwOIGBsDiBgbA4gYmztALMNyQCylfIAYQLw/RIyNAUSMjQFEjI0BRIyNAUSMzf0hzhgbA4gYGwOIGBsDiBgbA4gBxPtDxNgYQMTYGEDE2BhAxNgYQMTY3B/igrExgIixMYCIsTGAiLExgBhAvD9EjI0BRIyNAUSMjQFEjI0BRIzN/SGuGBsDiBgbA4gYGwOIGBsDiAHE+0PE2BhAxNgYQMTYGEDE2BhAxNjcH+KGsTGAiLExgIixMYCIsTGAGEC8P0SMjQFEjI0BRIyNAUSMjQFEjM39Ie4YGwOIGBsDiBgbA4gYGwOIAcT7Q8TYGEDE2BhAxNgYQMTYGEDE2NwB4rLEAXHZ598gvr0SlI0DRZyNA0WkzR0orsN+UFzL/vnF2zQfyLfpgcjzi5cjtO3XS3+0AxtEO+rtCNpBO6rtwF/Rjno7EGO0o94OjBvtqLcDlUc76u3AEdKOajtG3CPtqLcDp0k76u3AldKOejtwpbSj3o6gHbSj2g5cKe2otwNXSjvq7cCV0o56O3CltKPeDlwp7ai2Y8KV0o56O3CltKPeDlwp7ai3A1dKO+rtCNpBO6rtwJXSjno7cKW0o94OXCntqLcDV0o76u3AldKOajsKrpR21NuBK6Ud9XbgSmlHvR24UtpRb0fQDtpRbQeulHbU24ErpR31duBKaUe9HbhS2lFvB66UdlTbEbhS2lFvB66UdtTbgSulHfV24EppR70dQTtoR7UduFLaUW8HrpR21NuBK6Ud9XbgSmlHvR24UtpRbceMK6Ud9XbgSmlHvR24UtpRbweulHbU2xG0g3ZU24ErpR31duBKaUe9HbhS2lFvB66UdtTbgSulHdV2LLhS2lFvB66UdtTbgSulHfV24EppR70dQTtoR7UduFLaUW8HrpR21NuBK6Ud9XbgSmlHvR24UtpRbceKK6Ud9XbgSmlHvR24UtpRbweulHbU2xG0g3ZU24ErpR31duBKaUe9HbhS2lFvB66UdtTbgSulHdV2bLhS2lFvB66UdtTbgSulHfV24EppR70dQTtoR7UduFLaUW8HrpR21NuBK6Ud9XbgSmlHvR24UtpRbceOK6Ud9XbgSmlHvR24UtpRbweulHbU2xG0g3ZU24ErpR31duBKaUe9HbhS2lFvB66UdtTbgSulHbV2vL1F2kE7qu3AldKOejtwpbSj3g5cKe2otyNoB+2otgNXSjvq7cCV0o56O3CltKPeDlwp7ai3A1dKO6rtGHGltKPeDlypXzvKfLZjWz4iR4B2hxyr2R3yAHlvyPGP3SFHKnaHHFPYHXL0X3fIcXq9IZ8Qdd0hx77ZIS/rcfEWY3x+8Vtq5Uxte//K0/IstHE+3l2Ma3m8+EeZ8HqUqVmZMIaUqVmZgjJRplZlwnJSpmZlwp9SpmZlwsxSpmZlwvlSpmZlwiZTplZlKnhqytSsTBhwytSsTBhwytSsTBhwytSsTEGZKFOrMmHAKVOzMmHAKVOzMmHAKVOzMmHAKVOzMmHAKVOrMgUGnDI1KxMGnDI1KxMGnDI1KxMGnDI1K1NQJsrUqkwYcMrUrEwYcMrUrEwYcMrUrEwYcMrUrEwYcMrUqkwzBpwyNSsTBpwyNSsTBpwyNSsTBpwyNStTUCbK1KpMGHDK1KxMGHDK1KxMGHDK1KxMGHDK1KxMGHDK1KpMCwacMjUrEwacMjUrEwacMjUrEwacMjUrU1AmytSqTBhwytSsTBhwytSsTBhwytSsTBhwytSsTBhwytSqTCsGnDI1KxMGnDI1KxMGnDI1KxMGnDI1K1NQJsrUqkwYcMrUrEwYcMrUrEydGvB1Pt7gus0XZSp7HHTKvswXgZezTlG2J4F3aolfF3inJvVlgW+d2sbXBd6pkXtd4J1aq9cF3qnZeV3gQeC5gXdqCF4XeKcr+nWBszSTA2dpJgfO0swNfGdpJgfO0kwOnKWZHDhLMznwIPDcwFmayYGzNJMDZ2kmB87STA6cpZka+DSwNJMDZ2kmB87STA6cpZkceBB4buAszeTAWZrJgbM0kwNnaSYHztLMDXxkaSYHztJMDpylmRw4SzM58CDw3MBZmsmBszSTA2dpJgfO0kwOnKWZG/jE0kwOnKWZHDhLMzlwlmZy4EHguYGzNJMD73Vp7scL2cr4S+A/YvHZg+NyvOYy/tKt7z4Eao7z2u3x2qdhrON2prG8P4Fpip95+8xBjby3OP8xbM/y9lmDt8i7+IzBe+TtswXvkbfPFLxH3j5L8B55B3mn5u2zA++Rt88MvEfe7MvLvJdh+XntcvmQ4W05rt22hzm/DD/jZl42jXtf4ue1++M/hWX407qqsFs9QAaD2AQkS9sEJBPeBCRuwARkANIDJDbDBCSaxAQk/sUEJGbHBCRmxwPkjNkxAYnZMQGJ2TEBidkxARmA9ACJ2TEBidkxAYnZMQGJ2TEBidnxALlgdkxAYnZMQGJ2TEBidkxABiA9QGJ2TEBidkxAYnZMQGJ2TEBidjxArpgdE5CYHROQmB0TkJgdE5ABSA+QmB0TkJgdE5CYHROQmB0TkJgdD5AbZscEJGbHBCRmxwQkZscEZADSAyRmxwQkZscEJGbHBCRmpynIMcp4vuZ5uUA5x1LOl7Etn6N8I3kGvTxyn59dXIbzg5nKGI8X/+COCOqS+4436pM7mqlP7lgpT+7vr6NErB+5I7H65B5w9+R+fhJOiYePwnl68bSv71i2/eLiiGN7TrGsn1/8/v7i8ev+HJM7no7yvax8uEXK98XybcdXnuZh/1b58KGU72Xlw+FSvq+Vb52O6KZ1iYuLh3JAmYa5fKupWGeaeoemlgFPTlP/ZFOX7WzqPn6rqZh9mnqPpnIvgqa+fb86XsZbIS6+8lTWs6llnx4v/tEo7nLQqK81qplwLENQPsr3qvJxq4Xyvax83GqhfF8sXyvbXQZutVC+l5WPWy2U72vlm/fzx+4yDR8nLLdEaFTTRo3cuqBRbRvFLQYa1bZR3AqgUV9r1FduWo3bdsaxDx/vG4zcN6B+L6xfUD/q98fq1/DXoEZuM9DUezSVexI09R5N5QYGTf2TTW32C3sjdzto6j2ayl0Umvp2L+18NsI4fXOjT9xFoVFtG8VdFBr1pUY1HB0TN1wo38vKx+0Wyvey8gXlo3xfK1+zXTpx/4Tyvax83BLxLN8c03HxPF/8Jc/X/jL84u9tJ25d0KgXPeCvTNyNoHwvKx83GCjfq8pXuBdB+V70dMlSuG1B+V5WPm5bUL6vle/iL48K9yJoVNtGBY2iUU0bxV0DGtW2UdwKoFF/7iGxV7/6VrhvQP1eWD/uHFC/W3zsQOE2A029RVODexI09R5N5QYGTb3FB2QEdzto6j2ayl0Umvqqx89HUD7K96rycW+G8r3q8fPBbRzK97LycROH8t3iCWvB/R6aeo+mcr+Hpt7iCWsz93to6j2ayv0emtr0yW0z92VoVNtGcf+ERr3qiVhzUD7K96rycf+E8r2sfNw/oXyvehzbzP0Tyvey8nFLpG35tuH4wuM2jb+U70fgmP3cwBcEdXLgeNbkwNGQfy7wMZ4EjqVLDjwIPDdwbExy4BiI5MBZ3cmnFJZmcuAszdzAV5ZmcuAszeTAWZrJgbM0kwMPAs8NnKWZHDhLMzlwlmZy4CzNtBvqPwJnaeYGvrE0kwNnaSYHztJMDpyleRn4ev5C1zYOF4Evw37Aefx1rnH9GXcQd2bcrMzUuNmYqXGzMFPjZl+mxs26zIx7Z1umxs2yTI2bXZkaN6syNe4g7sy4WZWpcbMqU+NmVabGzapMjZtVmRh3DKzK1LhZlalxsypT42ZVpsYdxJ0ZN6syNW5WZWrcrMrUuFmVqXGzKjPjHlmVqXGzKlPjZlWmxs2qTI07iPsq7m0/XsZ++Rve0zK/v8Hz2vLskZDzcGQxl+nzS8sW5yd7bL9+3R8UGasOFNnADhSZ1g4UWewOFBEBBhQn/IIDRbSFA0VsiANFJIsDxYCiAUXcjQNF3I0DRdyNA0XcjQNF3I0BxYK7caCIu3GgiLtxoIi7caAYUDSgiLtxoIi7caCIu3GgiLtxoIi7MaAYuBsHirgbB4q4GweKuBsHigFFA4q4GweKuBsHirgbB4q4GweKuBsDijPuxoEi7saBIu7GgSLuxoFiQNGAIu7GgSLuxoEi7saBIu7GgSLuxoDigrtxoIi7caCIu3GgiLtxoBhQNKCIu3GgiLtxoIi7caCIu3GgiLsxoLjibhwo4m4cKOJuHCjibhwoBhQNKOJuHCjibhwo4m4cKOJuHCjibm5AMYbl+CzUGKfl84vHfT4+ZHXct4/IN0RPd8ixQt0hRyF1hxzf1B3yAHlvyDFZ3SFHe3WHHEfWHXKEWnfIsW+9Id+xb90hx751hxz71h1y7Ft3yAPkvSHHvnWHHPvWHXLsW3fIsW/dIce+dYZ8HrBv3SHHvnWHHPvWHXLsW3fIA+S9Ice+dYcc+9Ydcuxbd8ixb90hx771hnzEvnWHHPvWHXLs2w2Qv/38PSjO40NuJ0WEmgPFgKIBRbSXA0VMlgNF5JQDRXyTA0UUkgHFCSvkQBHR40ARd+NAEXfjQDGgaEARd+NAEXfjQBF340ARd+NAEXdjQLHgbhwo4m4cKOJuHCjibhwoBhQNKOJuHCjibhwo4m4cKOJuHCjibgwoBu7GgSLuxoEi7saBIu7GgWJA0YAi7saBIu7GgSLuxoEi7saBIu7GgOKMu3GgiLtxoIi7caCIu3GgGFA0oIi7caCIu3GgiLtxoIi7caCIuzGguOBuHCjibhwo4m4cKOJuHCgGFA0o4m4cKOJuHCjibhwo4m4cKOJuDCiuuBsHirgbB4q4GweKuBsHigFFA4q4GweKuJs7UCznR27OZV8+UsTdOFDE3ThQxN0YUNxwNw4UcTcOFHE3DhRxNw4UA4oGFHE3DhRxNw4UcTcOFHE3DhRxNwYUd9yNA0XcjQNF3I0DRdyNA8WAogFF3I0DRdyNA0XcjQNF3I0DRdzN/SkuA+7GgSLuxoEi7saBIu7GgWJA0YAi7saBIu7GgSLuxoEi7saBIu7GgOKIu3GgiLtxoIi7caCIu3GgGFA0oIi7caCIu3GgiLtxoIi7caCIuzGgOOFuHCjibhwo4m4cKOJuHCgGFA0o4m4cKOJuHCjibhwo4m4cKOJuDCgW3I0DRdyNA0XcjQNF3I0DxYCiAUXcjQNF3I0DRdyNA0XcjQNF3I0BxcDd3IDiMpTjvS3DPn2kiLtxoIi7caCIu3GgGFA0oIi7caCIu3GgiLtxoIi7caCIuzGgOONuHCjibhwo4m4cKOJuHCgGFA0o4m4cKOJuHCjibhwo4m4cKOJuDCguuBsHirgbB4q4GweKuBsHigFFA4q4GweKuBsHirgbB4q4GweKuBsDiivuxoEi7saBIu7GgSLuxoFiQNGAIu7GgSLuxoEi7saBIu7GgSLuxoDihrtxoIi7uQPFMiwHxVLKR4q4GweKuBsHigFFA4q4GweKuBsHirgbB4q4GweKuBsDijvuxoEi7saBIu7GgSLuxoFiQNGAIu7GgSLuxoEi7saBIu7GgSLu5v4U1wF340ARd+NAEXfjQBF340AxoGhAEXfjQBF340ARd+NAEXfjQBF3Y0BxxN04UMTdOFDE3ThQxN04UAwoGlDE3ThQxN04UMTdOFDE3ThQxN0YUJxwNw4UcTcOFHE3DhRxNw4UA4oGFHE3DhRxNw4UcTcOFHE3DhRxNwYUC+7GgSLuxoEi7saBIu7GgWJA0YAi7saBIu7GgSLu5g4UlyUOiss+f6SIu3GgiLsxoBi4mztQXIf9oPj2D+/zi7dpPpBv0wOR5xcv03Htr5f+aAdOiHbU24Froh31duCwaEe9HUE7aEe1HTg32lFvBy6PdtTbgSOkHfV24B5pR70dOE3aUW3HjCulHfV24EppR70duFLaUW8HrpR21NsRtIN2VNuBK6Ud9XbgSmlHvR24UtpRbweulHbU24ErpR3Vdiy4UtpRbweulHbU24ErpR31duBKaUe9HUE7aEe1HbhS2lFvB66UdtTbgSulHfV24EppR70duFLaUW3HiiulHfV24EppR70duFLaUW8HrpR21NsRtIN2VNuBK6Ud9XbgSmlHvR24UtpRbweulHbU24ErpR3Vdmy4UtpRbweulHbU24ErpR31duBKaUe9HUE7aEe1HbhS2lFvB66UdtTbgSulHfV24EppR70duFLaUW3HjiulHfV24EppR70duFLaUW8HrpR21NsRtIN2VNuBK6Ud9XbgSmlHvR24UtpRbweulHbU24ErpR21dmwDrpR21NuBK6Ud9XbgSmlHvR24UtpRb0fQDtpRbQeulHbU24ErpR31duBKaUe9HbhS2lFvB66UdlTbMeJKaUe9HbhS2lFvB66UdtTbgSulHfV2BO2gHdV24EppR70duFLaUW8HrpR21NuBK6Ud9XbgSmlHtR0TrpR21NuBK6Ud9XbgSmlHvR24UtpRb0fQDtpRbQeulHbU24ErpR31duBKaUe9HbhS2lFvB66UdlTbUXCltKPeDlwp7ai3A1dKO+rtwJXSjno7gnbQjmo7cKW0o94OXCntqLcDV0o76u3AldKOejtwpbSj2o7AldKOejtwpbSj3g5cKe2otwNXSjvq7QjaQTuq7cCV0o56O3CltKPeDlwp7ai3A1dKO+rtwJX6taPMZzu25QPyGQFqh7ysx8VvBjM+v7gM6/HmyrC9f+VpeRbaOB/vLsa1PF78o0z4UsrUrEzoVcrUrEzYWMrUrExBmShTqzLheilTszKhhilTszJhkilTszIhnilTszLhqSlTqzItGHDK1KxMGHDK1KxMGHDK1KxMGHDK1KxMQZkoU6syYcApU7MyYcApU7MyYcApU7MyYcApU7MyYcApU6syrRhwytSsTBhwytSsTBhwytSsTBhwytSsTEGZKFOrMmHAKVOzMmHAKVOzMmHAKVOzMmHAKVOzMmHAKVOrMm0YcMrUrEwYcMrUrEwYcMrUrEwYcMrUrExBmShTqzJhwClTszJhwClTszJhwClTszJhwClTszJhwClTqzLtGHDK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ULS7aYGi3U0LFO1uWqAYUmyAot1NCxTtblqgaHfTAkW7m3egWLrLY5tKKbcU7W4aoDjZ3bRA0e6mBYp2Ny1QtLtpgWJIsQGKdjctULS7aYGi3U0LFO1uWqBod9MAxdnupgWKdjctULS7aYGi3U0LFEOKDVC0u2mBot1NCxTtblqgaHfTAkW7mwYoLnY3LVC0u2mBot1NCxTtblqgGFJsgKLdTQsU7W5aoGh30wJFu5sWKNrdNEBxtbtpgaLdTQsU7W5aoGh30wLFkGIDFO1uWqBod9MCRbubFija3bRA0e7m/SnOnd1NCxTtblqgaHfTAkW7mxYohhQboGh30wJFu5sWKNrdtEDR7qYFinY3DVDs7W5aoGh30wJFu5sWKNrdtEAxpPgGFKcpLhSndbylaHfTAkW7mxYo2t28A8UPr79QnD/x2Dx4GcYL8mX4RGT74Gm4HPvrod+3w07I7djfDrsmt2N3OwY7LLdjfzvsxtyO/e2wc3M79rfDLs/t2N+OcDvcjt3tsHt0O/a3w07T7djfDrtSt2N/O+xK3Y797bArdTt2t6PYlbod+9thV+p27G+HXanbsb8ddqVux/52hNvhduxuh12p27G/HXalbsf+dtiVuh3722FX6nbsb4ddqduxux1hV+p27G+HXanbsb8ddqVux/522JW6HfvbEW6H27G7HXalbsf+dtiVuh3722FX6nbsb4ddqduxvx12pW7H7naMdqVux/522JW6HfvbYVfqduxvh12p27G/HeF2uB2722FX6nbsb4ddqduxvx12pW7H/nbYlbod+9thV+p27G7HZFfqduxvh12p27G/HXalbsf+dtiVuh372xFuh9uxux12pW7H/nbYlbod+9thV+p27G+HXanbsb8ddqVux+52zHalbsf+dtiVuh3722FX6nbsb4ddqduxvx3hdrgdu9thV+p27G+HXanbsb8ddqVux/522JW6HfvbYVfqduxux2JX6nbsb4ddqduxvx12pW7H/nbYlbod+9sRbofbsbsddqVux/522JW6HfvbYVfqduxvh12p27G/HXalbsfudqx2pW7H/nbYlbod+9thV+p27G+HXanbsb8d4Xa4HbvbYVfqduxvh12p27G/HXalbsf+dtiVuh3722FX6nbsbcfS2ZW6HfvbYVfqduxvh12p27G/HXalbsf+doTb4Xbsbodd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","brillig_names":["get_public_keys_and_partial_address","unsafe_rand","decompose_hint","notify_created_note","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log","notify_created_note","build_msg_block_iter","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"get_escrow_class_id","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM6AAAACEMAAAABHgAAAAQeAAAABTEAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ7AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDsBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAAgqAAgDIAAlCgAEAwgHIQAALgAHIAAoKgEEBwAABAcCBgAABAYIBSoBBQQqAAQDIyoBBAccAAcDBgAABwUGCS0AAAAACQAAAAYkAAQBCgwABAMKCyEAADYACzsBAAArAAAHCAMlAAQAAggEIgAAAEUrAAgFAAkAAAQJAgsAAAQLAwoqAgYKJAAEAQYAAAQDBgcOAAQDBwshAABCAAs7AQAAKgIJBCoABwMgACUrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=","debug_symbols":"1ZrbbsIwDIbfJddcOHHi1LzKNE1lg6lSVRCHSRPi3deyNisUpQIGim9QA3/ij5x+J+pefcxnu8+3olosN2r6slfl8j3fFsuqLu0PEzVbF2VZfL71v1bQfGRH+WaVV01ps83XWzXV3tiJmlcfzSPauoFFUc7V1MNhMhAz+lbLzgepdnRBa4GzVmw19NTmUstEQK2ayJgT9etE8d3oGnQQQ0/8BHgN93e8x67jeazjtbGhYQQYYfesuVV7piG7/kf2uuNP4ZsA5tEB8NEB7KMDuLsDOIRO7NCMzgnH0M0J0jiYE3QlT1PH31Anu6EOX1/HXFyfhNBtAYSWRnYXykwI0N8vmmDD0aCs61/nQY+MhrO2a7t+HIyG0aLpjWh6FE1vRdM70fQkmt6Lps9E07NkehTttSjaa1G016Jor8XUd0ziQO/hnN6mvmozF+hZD+ifv2op8HhNI/SaMZz+2PZO4GyP9EY0PYqmTz1Li6/axPccZ8KOWV9KDOgTz9Ic+Bh96lka2z96HFGzgXD9aJDO/6sT7Q4u9ZwuTp96ThenTz2ni9Nb0fSp35/E6VN35jh96qeBOH3q9ydx+tSdOUpPor2WRHstifZaEu21JNprSbTXkmCvPdTFr3xd5LNy3r4gs9hV7733Zbbfq99favEP","brillig_names":["get_escrow_class_id"],"assert_messages":{"53":"Array index out of bounds","65":"attempt to add with overflow","14":"Not initialized","19":"Function get_escrow_class_id can only be called statically"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"get_participant_escrows","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"participant","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"page_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"kind":"array","length":10,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"kind":"boolean"}],"kind":"tuple"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_participant_escrows"]},{"name":"register_escrow","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"escrow_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3bjuS2tYbfZa59wcPiKa+yMQicxAkGMOwgdjawYfjdd3XPiKVuqUqjLrK0+Ou/CaZjUVxcn6RFfZRUf3z6x09/+++//vrll3/++tunv/zPH59+/vXvP/7+5ddfLn/98cnK6//3279//OXlz99+//E/v3/6i01Ofvj00y//ePmnlz9/+PTPLz//9Okvyfz5w2JjV2z8trErPteNraxt7UNJ37b28WV/d7e2JiUzRWJSvoZiS1rbPkc7bZ7zde8vY1hubE0dpQ1+vvHnHz7ZwMzcyExkZm5kJjEzNzKTH86Mz9ZNY80yy4wNrz2U3j0483AP1vmJrnXJXnsIcWXr4lL5tnVxJb6JZ+XIcWLDdOg4EVnEbweP363F7+z1hLEzaKvxFzcd0GUevfdrYw31XCmzY6GsjjRkP+04its4r0qoGTfmurErr6P0pxilPDzKy/WmHovW+I1xXq6lU+gS7u84linwZOfpe72QuTBq4HHUwNOogefNwNNG4M7X09P5nN70sNw6pen6WWyZXZvXU+K9r+enl/S8uYArzMtaXrxhXlbzYp+cF2tiul4u8pvMvMTjlMXjlcUjyuIJyuKJyuJJyuLJyuIpuuIRoyye51+f3XU6F90iHqcsnqdfn2OqvNJ8urta2aVOdyVc57BO1vZcpN5ZhvBm25dxyknGGU4yzogzzmiqEVmOM51knPkk4yw448x1nKW8H2cwJxmnPck4HVBdua4zGbMYKM6E6DK8q+V2shipnGakOJOirZECTYtmp6lb1NGgfF5UpsXFUMLWQFNdWiwpzva86i59nvYsfsNcuosJrQOMW5rT19V6Kzb++YATDcrncqdmo3z+qYJNSlMGXcp5I93t1hKi8jnzqdkon+c3YvMy0ufP9MPsIZ+wMdJUV8tTvO7Zmfgaux84dhk49jBw7HHg2NPAseeBYy/jxp7MwLHbgWMfuK6mgetqGriupoHrahq4rqaB62oauK6mgetqHriu5oHrah64ruaB62oeuK7mgetqHriu5oHrah64ruaB62oZuK6WgetqGbiuloHrahm4rpaB62oZuK6WgetqGbiuloHrqjUDF1ZrBq6s1gxcWq0ZuLZelvhHDn7g6mrNwOXVmoHrqzUDF1hrRq6wduQKa0eusHbkCmtHrrB25AprR66wduQKa0eusHbkCmtHrrBu5ArrRq6wbuQK63RX2BynjXMqy+B1V9iN4HVX2BKnON6+G2rWPjkosX6jSpK5vot345ODaK9EWKd7wkGWe1jqnn+R5R6WuqejZLmHpe7ZOVnuYOl136yQ5R6Wuu/dyHIPS923smS5h6XuO3uy3MNSyBKGJb0PDkt6HxyW9D44LOl9cFjS+8CwFHofHJb0Pjgs6X1wWNL74LAUsoRhSe+Dw5LeB4clvQ8OS3ofHJb0PjAsA70PDkt6HxyW9D44LOl9cFgKWcKwpPfBYUnvg8OS3geHJb0PDkt6HxiWkd4HhyW9Dw5Leh8clvQ+OCyFLGFY0vvgsKT3wWFJ74PDkt4HhyW9DwxL5b+sTJZ7WNL74LCk98FhSe+Dw1LIEoYlvQ8OS3ofHJb0Pjgs6X1wWNL7wLDM9D44LOl9cFjS++CwpPfBYSlkCcOS3geHJb0PDkt6HxyW9D44LOl9YFgWeh8clvQ+OCzpfXBY0vvgsBSyhGFJ74PDkt4HhyW9Dw5Leh8clvQ+KCydoffBYUnvg8OS3geHJb0PDkshSxiW9D44LOl9cFjS++CwpPfBYUnvA8PS0vvgsKT3wWFJ74PDkt4Hh6WQJQxLeh8clvQ+OCzpfXBY0vvgsKT3gWHp6H1wWNL74LCk98FhSe+Dw1LIEoYlvQ8OS3ofHJb0Pjgs6X1wWNL7wLD09D44LOl9cFjS++CwpPfBYSlkCcOS3geHJb0PDkt6HxyW9D44LOl9YFgKvQ8OS3ofHJb0Pjgs6X1wWApZwrCk98FhSe+Dw5LeB4clvQ8OS3ofGJaB3geHJb0PDkt6HxyW9D44LIUsYVjS++CwpPfBYUnvg8OS3geHJb0PDMtI74PDkt4HhyW9Dw5Leh8clkKWMCzpfXBY0vvgsKT3wWFJ74PDkt4HhmWi98FhSe+Dw5LeB4clvQ8OSyFLGJb0Pjgs6X1wWNL74LCk98FhSe8DwzLT++CwpPfBYUnvg8OS3geHpZAlDEt6HxyW9D44LOl9cFjS++CwpPeBYVnofXBY0vvgsKT3wWFJ74PDUsgShiW9Dw5Leh8clvQ+OCzpfXBY0vugsPSG3geHJb0PDkt6HxyW9D44LIUsYVjS++CwpPfBYUnvg8OS3geHJb0PDEtL74PDkt4HhyW9Dw5Leh8clkKWMCzpfXBY0vvgsKT3wWFJ74PDkt4HhqWj98FhSe+Dw5LeB4clvQ8OSyFLGJb0Pjgs6X1wWD7d+4SSb7F8DejZ8sJd5n/Xre3GwWWdq+l0M6rOl5Wtg0T/besgOV63XjsUfQzp28Y+xmtmXFjb2Jspjf6yQDLf+DWLhVl8PIveMIsNsmiZxQZZdMzi92RR/FQbvUhaZNEziw2yKMzid2WxzkS9zKJe3diVNO3ZlVw2NvZ11noZlFvwCeRzLB+ROp2/3GHc3/g6PpnvN35FGYkSBWUiShSUvEk9GmWuqQ6mPIKSd8ooKIW36wejDKVeYKMz76elQhGgmw8Vg24+lBe6+Qj5HMsnuapFUpT7G1+WzuoqWjELhyJ0KEAwaVEGgumMr6k2syXrD9wRULmckzv9zDm5U+YMxT3myr3YB7gHmp9zcqdRas7dGzuF4Y3b2PPGQnSgUTqYT7Mlr0D5BINSiPJglK2WvAItFQxKOqqDUd63+4EuSTcfOh/dfOhmVPOJdCgH82m44BUpRoBg0qIMBLPdakakcjkndyH3U3KnzBmKe6tVrEjzc07uNEoduJf65rJ1D867aZR086FROpZPu6lPonyCQUn1BIOS4gkGJV3S0Shb3TYkIUoUlDQ+34UyyBS1D2Hj0beWH1JKNDMH82n20GOibIFBSS8Dg5IK52iUrZ5fzVQ4MCipcA5Gef9RvUwvo5sPZYtuPkI+qvlQixzMp+HTq5kOBQgmLcpAMNstH2Uql3Nyp585JfdCmTMU91YLkoXm55zcaZSac2/5IaVCo3Qwn2ZLXkWIEgUlPdXRKFsteRVaKhiUdFQHo7xv9wtdkm4+dD6a+Yihm9HNhw7lYD7tFrzEUIwAwaRFGQhms9UMMULup+ROP3NO7pQ5Q3FvtIolhubnnNxplDpwb/ahHjE0Sqr5WBqlY/m0m/pYyicYlFRPMCgpnmBQClEejLLVbYOlHoJB+XTjI7aGLtmNgtKbKWrvrSzuAxKz2CCLmVlskMXCLD6eRWeYxe/6VqCvVUskLbJomcUGWXTMYuvvVjb82KE4Tz7H8mn1YoI4IUoUlIEoUVDyJvVolI3eMRHHO2UYlLxdPxjl/cfpHUWAaj6eikE3H8oL3XyoRQ7m0/ANE0+HAgRTCHMcmO0e8fBULufkTj9zTu6UOUNxb/XQkKf5OSd3GqXm3Bt+7FCERulgPs2WvITyCQYlPdXRKFsteQktFQxKIcpjUd63+0KXpJsPnY9uPnQzuvnQoRzMp+GCl1CM4MAMtCgDwWy3mhGoXM7JnX7mnNwpc4bi3moVKwi5n5I7jVIH7u0+phdolHTzoVE6lk/DqQ/lEwxKqicUlJHiCQYlXdLRKFvdNkTqIRiUND7fhbLfj7Tff341Cvkcy6fZQ4+RsgUGJb0MDEoqnKNRtnp+NVLhwKCkwjkY5f1H9RK9jG4+lC26+dCg6OZDLXIwn4ZPryYhTByYtCgDwWy3fJSoXM7JnX7mnNwpc4bi3mpBMtH8nJJ7plFqzr3lh5QyjdLBfJoteWXKJxiU9FRHo2y15JWFKFFQ0lEdjPK+3c90Sbr50Pno5kM3o5sPHcrBfBoueBWKESCYtCgDwWy3mlGoXM7JnX7mnNyF3Efi3moVq9D8nJM7jVIH7u0+1FNolHTzoVE6lk/DqQ/lEwjKYKieYFBSPMGgpEs6GmWj24ZgqIdgUMqzUUZbt46+vEH5GlDQFtDT75FDLjUgMcuAkraAnn4XlLyvtiStBFSUBWSNtoCstoAazA6Cq4dpCHYjoOBSvepfr7a2yNdwvK5wRFc4QVc4UVc4SVc4WVc4RVU4zugK58Z1udQXoS7xzMN5bbR+7YzR1qpd0v0xWKkb2+BnE2zJayMuxVznqnE2irS2b+Prtf/yb0lb2+drLDlfS8VqOq01da5vZ/en/ls+PVNzKzXyeGqC1OhD8hupiX7ac5odw5d9fA0n6AonPjmcC35Xj4SQ3wS0chWpz/yHMrunK6trGCGGGkeWN1u/DjWdZ6j5PEMtQEOt9582Wr8YqjfnGao9z1AdzlBj1Zc2+rwcqj/PUOU8Qw1IxUauQy3LoeqeLUWZbp/i/AsBq0MtyU51taToNybkvl7DxG9Mxy/aq778knLemLs3nOh73fO7VnBeh/r8+Z2pRcwUszHUJNMpl+avz5uvSzG+DBy8mJGDtyMH70YO3o8cvIwcfBg5+Dhy8Gnk4EeusDJyhQ0jV9gwcoUNI1fYMHKFDSNX2DByhQ0jV9gwcoUNI1fYMHKFjSNX2DhyhY0jV9g4coWNI1fYOHKFjSNX2DhyhY0jV9iou8LmulCUU1kEn3RX2I3gdVfYUn+1+9LOvIl+ubHE+tVsSWb+HGI6xZpY0j3hIMs9LHXPv8hyD0shSxiWumfnZLmHpe6bFbLcw1L3vRtZ7mGp+1aWLPew1H1nT5Y7WGbdooMs97Ck98FhSe+Dw5LeB4elkCUMS3ofHJb0Pjgs6X1wWNL74LCk94FhWeh9cFjS++CwpPfBYUnvg8NSyBKGJb0PDkt6HxyW9D44LOl9cFjS+6CwjIbeB4clvQ8OS3ofHJb0PjgshSxhWNL74LCk98FhSe+Dw5LeB4clvQ8MS0vvg8OS3geHJb0PDkt6HxyWQpYwLOl9cFjS++CwpPfBYUnvg8OS3geGpaP3wWFJ74PDkt4HhyW9Dw5LIUsYlvQ+OCzpfXBY0vvgsKT3wWFJ7wPD0tP74LCk98FhSe+Dw5LeB4elkCUMS3ofHJb0Pjgs6X1wWNL74LCk94FhKfQ+OCzpfXBY0vvgsKT3wWEpZAnDkt4HhyW9Dw5Leh8clvQ+OCzpfWBYBnofHJb0Pjgs6X1wWNL74LAUsoRhSe+Dw5LeB4clvQ8OS3ofHJb0PjAsI70PDkt6HxyW9D44LOl9cFgKWcKwpPfBYUnvg8OS3geHJb0PDkt6HxiWid4HhyW9Dw5Leh8cls/2PiWEWyhf45FnH1uS6+ES/EpA6zfgF0hTQNnFjYCMrQGZ4K5dpPS1i/h4Fy5MG9vLsfSmi7UDyNZjohR7PUVu7Pu6tcvXU8RZt7L1pWp/2zinMNvWrybGleu56k3ZOKGsL2naXGx87MBPTPrzk55Pm3Tvr9cAL2kr6S0v8YVJf3rSs9GddDtLetlKug2u5jH5tLX1kWm3z057kjpxM2Yz7T7UoQY3m5ta0ZZIx0S2SaRvm8jZzcE0f8yy2kWutx+uuHy/C+fDdF11Ps/yszrkVO+Zip1NH4LRlvvAxKwnJj45MZdJZ51z2ujepOY1oKQtoPzsgC53JLXGGr9x8IifrggSZtdKWfUhMh03l3vvN9u+DrScZKDFnGWgFmeg0VTdtjJQd5aB+rMMVHAGmutAS1kONJxloPEsA01A5cXUeel8AWUaKc7U6DK+Ok02TpZDxZkcbQw1GZzp0eZQgSZIs1PVheVIlc+QyhRHKGFrpN2WXi+33nWAceu+ut1iyCU9hKN1XTwZIRy9cJTPnhvBeR3q8+fPoaY++bAx1CSTRUtxti5k4tfg08jB55GDLwMHb83IwduRg3cjB+9HDl5GDj6MHPzIFdaOXGHtyBXWjlxh3cgV1o1cYd3IFdaNXGHdyBXWjVxh3cgV1o1cYd3IFdaNXGH9yBXWj1xh/cgV1o9cYf3IFdaPXGH9yBXWj1xh/cgV1o9cYWXkCisjV1gZucLKyBVWRq6wMnKFlZErrIxcYWXkCisjV9gwcoUNI1fYMHKFDSNX2DByhQ0jV9gwcoUNI1fYMHKFDSNX2DhyhY0jV9g4coWNI1fYOHKFjSNX2DhyhY26K2yO08Y5lWXwuivsRvC6Kyw/9/hm4/tvTiTdEw6y3MNS9/yLLPew1D0dJcs9LHXPzslyD0shSxiWuu/dyHIPS923smS5h6XuO3uy3MNSt+ggyz0s6X1gWGZ6HxyW9D44LOl9cFjS++CwFLKEYUnvg8OS3geHJb0PDkt6HxyW9D4wLAu9Dw5Leh8clvQ+OCzpfXBYClnCsKT3wWFJ74PDkt4HhyW9Dw5Leh8UltnQ++CwpPfBYUnvg8OS3geHpZAlDEt6HxyW9D44LOl9cFjS++CwpPeBYan8p1PJcg9Leh8clvQ+OCzpfXBYClnCsKT3wWFJ74PDkt4HhyW9Dw5Leh8Ylo7eB4clvQ8OS3ofHJb0PjgshSxhWNL74LCk98FhSe+Dw5LeB4clvQ8MS0/vg8OS3geHJb0PDkt6HxyWQpYwLOl9cFjS++CwpPfBYUnvg8OS3geGpdD74LCk98FhSe+Dw5LeB4elkCUMS3ofHJb0Pjgs6X1wWNL74LCk94FhGeh9cFjS++CwpPfBYUnvg8NSyBKGJb0PDkt6HxyW9D44LOl9cFjS+8CwjPQ+OCzpfXBY0vvgsKT3wWEpZAnDkt4HhyW9Dw5Leh8clvQ+OCzpfWBYJnofHJb0Pjgs6X1wWNL74LAUsoRhSe+Dw5LeB4clvQ8OS3ofHJb0PjAsM70PDkt6HxyW9D44LOl9cFgKWcKwpPfBYUnvg8OS3geHJb0PDkt6HxiWhd4HhyW9Dw5Leh8clvQ+OCyFLGFY0vvgsKT3wWFJ74PDkt4HhyW9DwrLYuh9cFjS++CwpPfBYUnvg8NSyBKGJb0PDkt6HxyW9D44LOl9cFjS+8CwtPQ+OCzpfXBY0vvgsKT3wWEpZAnDkt4HhyW9Dw5Leh8clvQ+OCzpfWBYOnofHJb0Pjgs6X1wWNL74LAUsoRhSe+Dw5LeB4clvQ8OS3ofHJb0PjAsPb0PDkt6HxyW9D44LOl9cFgKWcKwpPfBYUnvg8OS3geHJb0PDkt6HxiWQu+Dw5LeB4clvQ8OS3ofHJZCljAs6X1wWNL74LCk98FhSe+Dw5LeB4ZloPfBYUnvg8OS3geHJb0PDkshSxiW9D44LOl9cFjS++CwpPfBYUnvA8My0vvgsKT3wWFJ74PDkt4Hh6WQJQxLeh8clvQ+OCzpfXBY0vvgsKT3gWGZ6H1wWD7d+4SSb7F8DejZ8sJ5565b242DyzpX0+lmVJ0vK1sHif7b1kFyvG69dij6GNK3jX2M18y4sLaxN1Mavbcy3/g1i55ZbJBFYRYbZDEwiw2yGJnF78mi+Kk2epG0yGJiFhtkMTOL35XFOhP1Mot6dWN3OTZr9nLZ2NjXWetlUG7Bp5DPsXxE6nT+codxf+Pr+GS+3/iKMhuiREFpiRIFJW9Sj0aZpz27YMojKHmnDINSiPJYlKHUC2x05v20NFME6OZDxaCbD+WFbj7UIgfzSa5qkRTl/saXpbO6ilbMwqFkOhQcmIUWZSCYzviaajNbst5/R1CoXM7JnX7mnNwpc4biHnPlXuwj3IXcT8mdRqk5d2/sFIY3bmPPGwvRhUbpYD7NlrwK5RMMSnqqo1G2WvIqtFQgKF/eVSDLY1ne1fsXQLRJygFR+ygHRD+jHJAQ0LGA2q16XWhSjyDRpEwZiGazRY0LeKqXk4KnqDkpeGqdocA3Ws+yxtIBnRQ83VIH8KW+xWzdg7NvS7ekHBDd0rGAGs5/rJAlDEtKKByWVFA4LGmVjmbZ7u6BogiHJd3Pd7EMMkXtQ9h4HK7hx5WscXQ0BwNq9STkhSW1Cw5LGhoclpQ5R7Ns9lyrE7KEYUmZczDLjQf4HA2NckDULsoB0aUoB0RBcjCglk+1etoUJJr0KQPRbLia5ClfTgqepuak4IXgRwLfbIHS0wGdFDzdUnPwDb+2dAFEt3QwoHYrYJ4aCocljdXRLJutgAl9FQ5L2qqDWW6ofqFVUg6I9kc5ICEg3YBoUw4G1HL9S6hIkGjSpwxEs+HahlC+nBQ8Tc05wQdqnaHAN1vUCnRAJwVPt9QBfMMP+gS6JeWAhIAOBdRy/kMNhcOSEgqHJRUUDktapaNZtrt7oCiCYRmf7n7E1tglu1FYejNF7b2Vxe1AtExjizQ6prFFGj3T2CKNwjR+15cFfS1dImmZxsA0tkhjZBpbf+ey6bcRYyKgYwG1e2shZrKEYVnIEoVl4u3q0SybvYGSeM+Mw5I37gez3HjUPlEJKAckBKQbEDWGckAUJAcDavn+SaJNQaJJnzIQzYbPfSTKl3OCzzQ1JwVPrTMU+GaPEmU6oJOCp1tqDr7ptxGzENCxgNqtgGVqKByWNFZHs2y2Apbpq3BY0lYdzHJD9WdaJd2ACu2PckC0NMoB0aYcDKjl+lehIkGiKaQ5Ds2GaxuF8uWk4GlqTgqeWmco8M0WtQod0EnB0y11AN/u03vW0C0pB0S3dCygdvMfa6ihcFhSQuGwFLKEYUmrdDTLVncP1lAU4bCk+/kulv1+7P3+c63W0NEcDKjZs5AX70KWKCwtDQ0OS8qco1m2eq7VWsocHJaUOQezvP8An7VCQLoBUbsoB0SXohwQBcnBgBo+1WotbQoSTfqUgWg2XE1ylC8nBU9Tc1Lw1DpDgW+2QOnogE4KXgi+NfiWX1yyjm7pYEDtVsAcNRQOSxqro1k2WwFz9FU4LGmrDma5ofo9rZJyQLQ/ygHR0igHRJtyMKCW619eSBOIJn3KQDQbrm14ypeTgqepOSl4ap2hwDdb1PJ0QOcEL3RLHcA3/KCP0C0pB0S3dCyghvMfoYbCYSlkCcOSCgqHJa3S0Szb3T1QFOGwfLr7ibZuHX15w/JrREVbROHpd8vhuusoZiUiqy6ip98PJe+rOklrEXl1EYm6iIK6iNbnCSXWTkp5E9HXVqsVydtUVZyz5v44LhfdesPv8vXSfuntaxe5fxelexfR9O/C9u/CPd6Fl6mSX9Y/zLyLlaPW5foci5sdfmVtjmBtPXusLbMJhV3duoS6dZltvb7rbKa6b7Ob1X35lhfPvKzmRZiX1byEs+bFxZqX2Yyv5iUyL6t5SczLal7ySfOSYt04z+4Kal4KTF7cdVn3osLcY9fdZJiX1bxY5mU1Lzjz3Z15uX/dTTjz3bZ5EeZlNS848919edmo0wlqvntV47Mlq/LNdyeoKez9oeLMSi8LHtVIWrO1661qijQrbZiXjDQrbZkXpFnprrzcr6YZaVbaMi9Is9KWeZGT5mVj9pWhLGy+5qUspiQZc6K5OlSciaaz17cULmtvD1ZToFlp07wAzUpb5qUAzUr35eV+NS1As9KmeQGalTbNC9CsdFdeNmZfRTCnJHEphAroRHNtqM+eaPrZBxN92BiqcaWeq8bPJo+2pNVISo1E7DU1q0/YvfxQdc3jzAr66XhPzMyNzGRm5kZmCjOzmhlnDDNzIzOWmbmRGcfM3MiMZ2ZuZEaYmRuZCczMjcxwDnwrM5wD38oM58C3MsM58I3MWM6Bb2VG9xzY13fxLv+WtJWZHOtLWXkWyccyo3sOfGRm9MyBv8YjDeKpvtaK2YjH+lCTGebfjLaiDlVgam6lpsXc08YbqfnaxfYkbracuNpF9tMHGvIsPavXBF8m3yzzT0qIXdm2JDtBLWkmp9fz7qv3nu/5xtvTqZ6rKecNRE15rs8LXZgG6r3Z4plCPRxTvFbWNHWxPsHy9eMM3stWF1Hq2RTL9VpmV7/8kUqlb68f3ChrRKW+FCUznkke3NTU40RMuOJ05WtG1n9XFjoj1k2VS2wqy4xYHiPvMuJ4jLzLiOcx8i4jwmPkXUbC2TLiU/2Eln/zpeFv1Xf9Jxc7ZiRf77ONlHlKvsaTDoxn/kzJFE9+cjzW1N87taak+8dMCGaa64Vgr1eAy1xubRp5mbbWB2hefurxzfZfh1tONdz131q73BnXcybMjtH14ZpQzPUIsrMBW/etF9ugl1g/Knf5d7IrvbgWveRrL8mlN72sbF/C7GvJobQg4iFGIQeMIpm6fSnWvY3q8tff/vPl55+//OuvP//69x9///LrL7+9tDYv/7M+mYz1Y4PJX2/bbHwd4/ps634T2d8k7G8S9zdJ+5vk/U3K7ibrl6f7TVavNan+0nrKyyZufxO/v4nsb7JKP8ukh3IIiyZxf5O0v0ne32SVfo6TfcnJv2+y/mMN95vY/U3c/iar9HOeUOayQLn+ee77TcL+JnF/k3S/STHL4ef9TcruJusfHy3VjRa3OMbWvw56v4nb38Tvb7JKv8hVU8+M7UubH/Zs/NJB6N1B7N1B6t1B7t1B6dzB+jcsW3Zge3fgenfge3fQ+0yOvc/k2PtMjr3P5Nj7TI69z+TU+0xOvc/k1PtMTr3P5NT7TE6Pnweh3h2E+SfsbXrdf+67//z4MRTNZIaiiYv9u8779533L533v7cSvLSJH2iT9rcp0vfYK49XwVi/ExadX+w/dt5/6rz/3Hn/pe/+rTENTp5SO5BlB7Z3B653B753B9K7g9C7g9i7g9T3Gm9N7t1B6dyBNb07sL07cL078L07kN4dhN4dxN4d9D6Tbe8z2fY+k13vM9n1PpNd1zP58pd92XL9imdD/TKDDWn2MNJaL9cf2c1l4zfPvLk+2Gve/pDZ2vM/9cFUsbOFi+lXz0YN3I0auB81cBk18DBq4HHUwNOoged+gb/svnTdvTN9d/94rSj1w1xl/l2uzlSdGzVwP2rgMmrgYdTA46iBp1EDz/0C/3zr2bhmu/em7+5t3927vrv3fXcvfXcf+u4+9t196rp7efzAvCwkyNUe+PcduN4dPI7Xuvrb7dYl976D3HsEpXMHoQWDfH2FoaT3HfjeHUjvDkLvDmLvDlKDDtL1fYKS33eQe3dQOncQTe8ObO8OXO8OfO8OGpzJ1488X5Zd7PsOQu8OYu8OUu8Ocu8OSucOkundQYMz2ea6qmLL+4lXcr076D0vSrF3B6l3B7lzB9n07sD27sD17sD37kC6dnD5w71sur7kmeJ0jUl5Q8WIvX5GyP75LGuzvuCpP2w3Zth+zLBlzLDDmGHHMcNOY4ade4X9+dYCZ6OdO9Nz5w/XhfqJOYnvS7JzPXfue+5ceu784etV/cyIlAXQ2HPnqefOHz1DQ/0WR5h9ttfdWVZqtHNveu7c9tz5o4di8JOPDn6x89hz548CjfULuTGadzsX03Pn0jEt8jDQWkTDy1Ohb3cee+489dx57rnz0nHnwfTcue25c9du5+n9Q1nB99z5w2doqGdoXuz84TNU0u2dx547Tz13/ugZGu0044p2sWZWOu48mp47tz13/ugZGk19s9F+3wpTq51Lz52HnjuPPXeeeu4899x5abdz9/44T6bnzh8+Q+vH+qJf7PzhGlrk9s59z51Lz50/fIbemZ+n2HPnqefOc8+d97zhyj1vuLLtuXPXbeeXP/zLhjfespt/XDfG+528/JDRtLG490LqxitO+zqoH6K2kjc2VvU+FNoo4ylGmU4xynyKUZYzjNKZU4zSnmKUTskoP998V+6YWERRLE+u9qpef0MbZTrFKPMpRlnOMEpvTjFKe4pROiWj/HzzDc1jYhFFsWip9p9vvih6TCxaKufnWz+VcVAsWqrQ51sPmxwUi5Yr+uebL/x2i2Xj5d2oKponH7/3X70ITlNuglcVzdOPmw+8PHxUNFlVNEVTNNGoisY+O5oPvB19VDReVTSiKpqgKpqoKpqkKppnX4s/8mL5QdEkoyoaqyoapyoaryoaURXNs6/F9z9bEFVFo+p+KhtV0VhV0XhV0YiqaIKqaKKqaJKeaC5/yMum609LOFuf1XM2Xx8JtEluP3yw1ch/pJF8pFH4SKP4kUbpI43yRxqVDzRaXwK8bFkbOe/fNFoeRKFMb27Pnw1d39aWUB/xLPMDrtx5jfS4cJyucLyucERXOEFXOFFXOElXOFlXOEVVOKLrqiy6rsqi66osuq7KouuqLLquyqLrqiy6rsrhySf63d+UDU5TME8+bu7+blpImoLJmoIpioKJXav451vrnS07cL07aFA7Y5k2TiYsOpDeHYTeHTS48qT6LZ5UtkuEuZYIG96XiJh0hZN1hVOeHY6v6wVFFvU8GV3hWF3huGeHM5t8xcWxk7yucERXOEFXOPHAcJYT95R0hZN1hdPgqpztNNMrIX9428+3lk2PCsZqCsZpCsZrCkY0BRM0BRM1BZM0BZM1BaPpClw0XYGLpitw0XQFLpquwEXTFbhougIXTVfgoukKXDRdga158oXmrk63xqmK5skn1F1tbE1UFU1SFU1WFU3Xac1LD9Z078F27yFpOtfts48ge/0qq19GUzRF44yqaKyqaJyqaPyzr4OlRiPLaERVNEFVNFFVNElVNFlVNEVTNN5omul4qyoapyoaryoaURWNqjsrr+rOyqu6s/Kq7qx80RSNqLoWi6prsai6Fouqa7GouhaLqmuxPPm50ftWQJ794Ojdu7tgVEVjVUXjVEXz5Jc/7t8zBFEVTVAVTVQVTVIVTVYVTdEUTXz2tfhu1YxWVTROVTReVTSiKpqgKhpNb1PZqOl1Khs1vU9lo6YXqmxSdS1Oeq7Fl7/Cy5brvx4WY/111TK/afuGeH+TtL9J3t+k7G6yvn55p8nlr/iy5fpSo/ipoeTrQ+UvX1H5fOsLN/eb+P1NZH+TsL9J3N8k7W+S9zcpu5usr5uEMN3FhbhsYvc3cfub+P1NVumHWE1GiosmYX+TuL9J2t9klX4o9dw0ZtGk7G6ybmrvN7H7m7itJnnRxO9vIvubrF//69sxcfYm09Qk7m+S9jfJ+5usX/9TLYKpvG+y7s3uN7H7m7j9TVbpx/rjwcn4RRPZ3yTsbxL3N0kbTaxdNMn7m5TdTW78xH39HF6Ki/Plxg/X323i9jfx+5us0k/154LSsvDd+EH4u03i/iZpf5P1H3wuU7HIZlEsbvzQ+r0mN34+/W4Tu7+J22hiZdHE728i+5us0s9xuijluLgorb/Der9J2t8k72+ySj+n6dzPeTH89bcq7zex+5u4/U1W6ecynfvFLIa//rbf/SZhf5O4v0naaGLTokne36TsbrL+Rlep31IuZVHF1t+7ut/E7W/idza5/JVetlyXQLGahfkU43ICvbTLL1vemMunOmec32TEdGcuf7vJ5a/y2tf6x2pN/ZqJtW4+PHf7NmCrUflAoxu/WHWv0Z8/vP6M/R+3DEe978zzluml5eXP//3xP19+/NvPP/12afLyX//7y99///LrL9/+/P3//v31v1w2/n8=","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_nullifier_membership_witness","get_contract_instance_internal","get_public_keys_and_partial_address","unsafe_rand","notify_created_note","pack_arguments","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000b3dd3286"},{"kind":"string","value":"ParticipantNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"escrow_contract_id","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"managed_escrows","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"participants","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"participant_escrows","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"contract_registration","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"escrow_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ZImburseContractRegistry::get_contract_registration_status_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"ZImburseContractRegistry::get_contract_registration_status_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"contract_class_id","type":{"kind":"field"}}],"kind":"struct","path":"ZImburseContractRegistry::constructor_parameters"}}],"kind":"struct","path":"ZImburseContractRegistry::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"escrow_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ZImburseContractRegistry::set_contract_registered_parameters"}}],"kind":"struct","path":"ZImburseContractRegistry::set_contract_registered_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"escrow_contract","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ZImburseContractRegistry::register_escrow_parameters"}}],"kind":"struct","path":"ZImburseContractRegistry::register_escrow_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"participant","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"participant_name","type":{"kind":"string","length":60}},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"escrow","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ZImburseContractRegistry::check_and_register_participant_parameters"}}],"kind":"struct","path":"ZImburseContractRegistry::check_and_register_participant_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"participant","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"participant_name","type":{"kind":"string","length":60}},{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"escrow","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ZImburseContractRegistry::register_participant_parameters"}}],"kind":"struct","path":"ZImburseContractRegistry::register_participant_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"ZImburseContractRegistry::get_escrow_class_id_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"ZImburseContractRegistry::get_escrow_class_id_abi"}]}},"file_map":{"100":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"103":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let N: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> [u8; M] where Note: NoteInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    encrypted_bytes[64] = num_public_values; // TODO(#8558): This can be just a single bit if we store info about partial fields in ABI\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[65 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[97 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[145 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[193 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 337;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[337 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // num_public_values (1 byte)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 0;\n\n        let log: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        assert_eq(encrypted_note_log_from_typescript, log);\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_of_finalized_partial_note_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note_public_value1 = 0x14172339287e8d281545c177313f02b6aa2fedfd628cfd8b7f11a136fd0d6557;\n        let note_public_value2 = 0x0834d81e3f73c7e2809b08ae38600ffc76a2554473eeab6de7bff4b33a84feac;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 2;\n\n        // First we compute the encrypted log without the public values\n        let log_without_public_values: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // Then we \"append\" the public values to the log by copying both the original log and the current log into a new byte array\n        let mut log: [u8; 513] = [0; 513];\n        for i in 0..449 {\n            log[i] = log_without_public_values[i];\n        }\n        let note_public_value1_bytes: [u8; 32] = note_public_value1.to_be_bytes();\n        let note_public_value2_bytes: [u8; 32] = note_public_value2.to_be_bytes();\n        for i in 0..32 {\n            log[449 + i] = note_public_value1_bytes[i];\n            log[481 + i] = note_public_value2_bytes[i];\n        }\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_of_finalized_partial_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38, 20, 23, 35, 57, 40, 126, 141, 40, 21, 69, 193, 119, 49, 63, 2, 182, 170, 47, 237, 253, 98, 140, 253, 139, 127, 17, 161, 54, 253, 13, 101, 87, 8, 52, 216, 30, 63, 115, 199, 226, 128, 155, 8, 174, 56, 96, 15, 252, 118, 162, 85, 68, 115, 238, 171, 109, 231, 191, 244, 179, 58, 132, 254, 172\n        ];\n        assert_eq(encrypted_note_log_of_finalized_partial_from_typescript, log);\n    }\n}\n"},"104":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\npub struct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{address::AztecAddress, scalar::Scalar};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    #[test]\n    unconstrained fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"107":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\npub struct EncryptedLogIncomingBody<let N: u32> {\n    plaintext: [u8; N * 32 + 64]\n}\n\nimpl<let N: u32> EncryptedLogIncomingBody<N> {\n    pub fn from_note<T>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T>(event: T, randomness: Field) -> Self where T: EventInterface<N> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: u32 = 3;\n\n    impl NullifiableNote for AddressNote {\n        fn compute_nullifier(\n            _self: Self,\n            _context: &mut PrivateContext,\n            _note_hash_for_nullify: Field\n        ) -> Field {\n            1\n        }\n\n        unconstrained fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n    }\n\n    struct AddressNoteHidingPoint {\n        inner: Point\n    }\n\n    impl NoteInterface<ADDRESS_NOTE_LEN> for AddressNote {\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader {\n            self.header\n        }\n\n        fn set_header(&mut self, header: NoteHeader) {\n            self.header = header;\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] {\n            [self.address.to_field(), self.owner.to_field(), self.randomness]\n        }\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote {\n                address: AztecAddress::from_field(fields[0]),\n                owner: AztecAddress::from_field(fields[1]),\n                randomness: fields[2],\n                header: NoteHeader::empty()\n            }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_LEN * 32 + 64] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_LEN * 32 + 64] = [0; ADDRESS_NOTE_LEN * 32 + 64];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n\n        fn compute_note_hash(_self: Self) -> Field {\n            crate::generators::Ga1.x\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: u32 = 3;\n\n    impl EventInterface<TEST_EVENT_LEN> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime\n            {\n                EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n            }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_LEN * 32 + 64] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 64] = [0; TEST_EVENT_LEN * 32 + 64];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_LEN * 32 + 32] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 32] = [0; TEST_EVENT_LEN * 32 + 32];\n\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 201, 247, 40, 80, 60, 188, 158, 251, 242, 103, 197, 79, 165, 195, 10, 160, 255, 35, 167, 152, 25, 233, 77, 145, 214, 243, 210, 119, 0, 20, 29, 95, 15, 63, 33, 190, 184, 67, 254, 96, 128, 243, 220, 228, 201, 130, 86, 163, 52, 127, 111, 10, 212, 7, 160, 16, 87, 13, 39, 11, 5, 1, 164, 65, 8, 56, 82, 245, 13, 68, 176, 90, 100, 69, 243, 78, 117, 188, 221, 34, 178, 31, 155, 89, 143, 176, 129, 118, 36, 236, 64, 179, 52, 239, 184, 51, 51, 199, 221, 49, 81, 197, 17, 199, 192, 99, 49, 168, 157, 164, 190, 33, 240, 182, 214, 173, 7, 156, 102, 95, 65, 217, 225, 123, 42, 21, 124, 144\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"},"108":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::{get_public_keys, get_ovsk_app}, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note,\n        num_public_values\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient, num_public_values)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, iv, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Note: We could save a lot of gates by obtaining the following keys in an unconstrained context but this\n        // function is currently not used anywhere so we are not optimizing it.\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        // See the comment in `encode_and_encrypt_note_with_keys_unconstrained` for why having note hash counter\n        // and log hash unconstrained here is fine.\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, iv, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Number of public values is always 0 here because `encode_and_encrypt_note_with_keys_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n"},"109":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"112":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(self.args_hash == packed_args_hash);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        let packed_args_hash = unsafe {\n            pack_arguments(self.args)\n        };\n        assert(args_hash == packed_args_hash);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"113":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"115":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"116":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"120":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\nuse crate::hash::ArgsHasher;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"133":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"134":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"139":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"140":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"148":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr","source":"use dep::protocol_types::{\n    header::Header, address::AztecAddress, hash::compute_siloed_nullifier,\n    constants::DEPLOYER_CONTRACT_ADDRESS\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for Header {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier = compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for Header {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier = compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for Header {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: Header, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for Header {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n"},"150":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"154":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use dep::protocol_types::merkle_tree::root::root_from_sibling_path;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::{NoteInterface, NullifiableNote}}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n\n        // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n        // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n        // care about is showing that the tree contains an entry with the expected nullifier.\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(\n        self,\n        note: Note,\n        context: &mut PrivateContext\n    ) where Note: NoteInterface<N> + NullifiableNote {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"156":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"159":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr","source":"struct ComparatorEnum {\n    EQ: u8,\n    NEQ: u8,\n    LT: u8,\n    LTE: u8,\n    GT: u8,\n    GTE: u8,\n}\n\nglobal Comparator = ComparatorEnum {\n    EQ: 1,\n    NEQ: 2,\n    LT: 3,\n    LTE: 4,\n    GT: 5,\n    GTE: 6,\n};\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::compare;\n    use super::Comparator;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GTE, rhs), \"Expected lhs to be greater than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GTE, rhs), \"Expected lhs to be greater than or equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LTE, rhs), \"Expected lhs to not be less than or equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.GTE, rhs), \"Expected lhs to not be greater than or equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.GTE, rhs), \"Expected lhs to not be greater than or equal to rhs\");\n    }\n}\n"},"160":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"161":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr","source":"// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"},"165":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"166":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"167":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"169":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"171":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"172":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n"},"173":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"174":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 24;\n\npub struct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"177":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"180":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"181":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"182":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call.\n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments\n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call.\n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments\n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"194":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"196":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"197":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"206":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"212":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"213":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"214":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"216":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"217":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"219":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"239":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"241":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"244":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"270":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"291":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"295":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\npub struct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"314":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"336":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/compressed-string/src/compressed_string.nr","source":"use dep::aztec::protocol_types::{utils::field::field_from_bytes, traits::{Serialize, Deserialize}};\n\n// The general Compressed String.\n// Compresses M bytes into N fields.\n// Can be used for longer strings that don't fit in a single field.\n// Each field can store 31 characters, so N should be M/31 rounded up.\npub struct CompressedString<let N: u32, let M: u32> {\n  value: [Field; N]\n}\n\nimpl<let N: u32, let M: u32> CompressedString<N, M> {\n    pub fn from_string(input_string: str<M>) -> Self {\n        let mut fields = [0; N];\n        let byts = input_string.as_bytes();\n\n        let mut r_index = 0 as u32;\n\n        for i in 0..N {\n            let mut temp = [0 as u8; 31];\n            for j in 0..31 {\n                if r_index < M {\n                    temp[j] = byts[r_index];\n                    r_index += 1;\n                }\n            }\n\n            fields[i] = field_from_bytes(temp, true);\n        }\n\n        Self { value: fields }\n    }\n\n    pub fn to_bytes(self) -> [u8; M] {\n        let mut result = [0; M];\n        let mut w_index = 0 as u32;\n        for i in 0..N {\n            let bytes: [u8; 31] = self.value[i].to_be_bytes();\n            for j in 0..31 {\n                if w_index < M {\n                    result[w_index] = bytes[j];\n                    w_index += 1;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let M: u32> Eq for CompressedString<N, M> {\n    fn eq(self, other: CompressedString<N, M>) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Serialize<N> for CompressedString<N, M> {\n    fn serialize(self) -> [Field; N] {\n        self.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Deserialize<N> for CompressedString<N, M> {\n    fn deserialize(input: [Field; N]) -> Self {\n        Self { value: input }\n    }\n}\n\n#[test]\nunconstrained fn test_short_string() {\n    let i = \"Hello world\";\n    let b = i.as_bytes();\n    let name: CompressedString<1,11> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<4,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string_work_with_too_many_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<5,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_serde() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let name: CompressedString<5,118> = CompressedString::from_string(i);\n\n    assert_eq(name, CompressedString::deserialize(name.serialize()));\n}\n\n#[test(should_fail)]\nunconstrained fn test_long_string_fail_with_too_few_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<3,118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    crate::sha256::digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u64, msg_start: u32) -> ([u8; 64], u64) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            msg_block[msg_byte_ptr] = msg[k];\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u64,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u64 {\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    let mut extra_bytes = 0;\n    if msg_end > N {\n        msg_end = N;\n        extra_bytes = msg_end - N;\n    }\n\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if msg_byte_ptr == 64 {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE as u64 {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64) -> ([u8; 64], u64) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        if msg_byte_ptr < 64 {\n            for _ in 57..64 {\n                if msg_byte_ptr <= 63 {\n                    msg_block[msg_byte_ptr] = 0;\n                    msg_byte_ptr += 1;\n                }\n            }\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64, message_size: u64) -> [u8; 64] {\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for _i in 0..64 {\n        // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n        if msg_byte_ptr < 56 {\n            msg_block[msg_byte_ptr] = 0;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        } else if msg_byte_ptr < 64 {\n            for j in 0..8 {\n                msg_block[msg_byte_ptr + j] = len_bytes[j];\n            }\n            msg_byte_ptr += 8;\n        }\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; 64], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/home/jpag/Workground/aztec/zimburse/z-imburse/contracts/z_imburse_contract_registry/src/main.nr","source":"use dep::aztec::macros::aztec;\n\nmod types;\n\n#[aztec]\ncontract ZImburseContractRegistry {\n    use dep::aztec::prelude::{AztecAddress, PrivateImmutable, PrivateSet, SharedImmutable, Map};\n    use dep::aztec::macros::{storage::storage, functions::{private, public, view, initializer}};\n    use dep::aztec::note::{note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions, note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE};\n    use dep::aztec::oracle::{get_contract_instance::get_contract_instance, header::get_header_at_oracle};\n    use dep::aztec::keys::getters::get_public_keys;\n    use dep::aztec::utils::comparison::Comparator;\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::address_note::address_note::AddressNote;\n    use crate::types::participant_note::{ParticipantNote, NAME_LENGTH};\n    // use dep::z_imburse_escrow::ZImburseEscrow;\n\n    #[storage]\n    struct Storage<Context> {\n        escrow_contract_id: SharedImmutable<Field, Context>,\n        managed_escrows: PrivateSet<AddressNote, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: PrivateSet<AddressNote, Context>,\n        contract_registration: Map<AztecAddress, SharedImmutable<bool, Context>, Context>\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract by setting the class ID of the escrow contract\n     *\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     */\n    #[public]\n    #[initializer]\n    fn constructor(contract_class_id: Field) {\n        storage.escrow_contract_id.initialize(contract_class_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check that the contract has not already been registered\n        let registration_status = storage.contract_registration.at(escrow_contract).read_private();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        // check that the contract admin is the sender of the message\n        // let escrow_admin = ZImburseEscrow::at(escrow_contract).get_admin().call(&mut context);\n        // assert(escrow_admin == context.msg_sender(), \"Escrow contract admin does not match sender of message\");\n\n        // check that the contract has been deployed\n        let header = context.historical_header;\n        header.prove_contract_initialization(escrow_contract);\n\n        // check the contract class ID\n        let contract_class_id = get_contract_instance(escrow_contract).contract_class_id.to_field();\n        let expected_class_id = storage.escrow_contract_id.read_private();\n        assert(\n            contract_class_id == expected_class_id, \"Escrow contract class ID does not match expected class ID\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let npk_m_hash = get_public_keys(context.msg_sender()).npk_m.hash();\n        let mut escrow_note = AddressNote::new(escrow_contract, npk_m_hash);\n        storage.managed_escrows.insert(&mut escrow_note);\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseContractRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.contract_registration.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n   fn check_and_register_participant(\n        participant: AztecAddress,\n        participant_name: str<60>,\n        admin: AztecAddress,\n        escrow: AztecAddress\n    ) {\n        // check that the escrow address is registered\n        let registration_status = storage.contract_registration.at(escrow).read_private();\n        assert(registration_status, \"Escrow contract has not been registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new()\n            .select(AddressNote::properties().address, Comparator.EQ, participant)\n            .set_limit(1);\n        let participant_exists = storage.participants.at(escrow).get_notes(options).len() == 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        if participant_exists {\n            ZImburseContractRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, context.msg_sender()).call(&mut context);\n        }\n    }\n\n       #[private]\n       #[interal]\n       fn register_participant(\n            participant: AztecAddress,\n            participant_name: str<60>,\n            admin: AztecAddress,\n            escrow: AztecAddress\n        ) {\n            // add escrow to the participant's set of escrows\n            let mut escrow_note = AddressNote::new(escrow, get_public_keys(participant).npk_m.hash());\n            storage.participant_escrows.insert(&mut escrow_note).emit(\n                encode_and_encrypt_note(&mut context, admin, participant)\n            );\n            // add the participant to the admin set of participants\n            let mut participant_note = ParticipantNote::new(participant, participant_name, get_public_keys(participant).npk_m.hash());\n            storage.participants.at(escrow).insert(&mut participant_note).emit(\n                encode_and_encrypt_note(&mut context, admin, admin)\n            )\n       }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /** Get the class ID that all escrow contracts must match */\n    #[public]\n    #[view]\n    fn get_escrow_class_id() -> pub Field {\n        storage.escrow_contract_id.read_public()\n    }\n\n    /** Get the registration status of an escrow contract */\n    #[public]\n    #[view]\n    fn get_contract_registration_status(escrow_contract: AztecAddress) -> pub bool {\n        storage.contract_registration.at(escrow_contract).read_public()\n    }\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param page_index - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_managed_escrows(\n        admin: AztecAddress,\n        page_index: u32\n    ) -> pub ([AztecAddress; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.managed_escrows.view_notes(options.set_offset(offset));\n        let mut managed_escrows: [AztecAddress; MAX_NOTES_PER_PAGE] = [AztecAddress::from_field(0); MAX_NOTES_PER_PAGE];\n        for i in 0..notes.len() {\n            if i < notes.len() {\n                managed_escrows[i] = notes.get_unchecked(i).address;\n            }\n        }\n        let page_limit_reached = notes.len() == options.limit;\n        (managed_escrows, page_limit_reached)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param admin - the address of the participant\n     * @param page_index - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participant_escrows(\n        participant: AztecAddress,\n        page_index: u32\n    ) -> pub ([AztecAddress; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.managed_escrows.view_notes(options.set_offset(offset));\n        let mut participant_escrows: [AztecAddress; MAX_NOTES_PER_PAGE] = [AztecAddress::from_field(0); MAX_NOTES_PER_PAGE];\n        for i in 0..notes.len() {\n            if i < notes.len() {\n                participant_escrows[i] = notes.get_unchecked(i).address;\n            }\n        }\n        let page_limit_reached = notes.len() == options.limit;\n        (participant_escrows, page_limit_reached)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param page_index - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        page_index: u32\n    ) -> pub ([AztecAddress; MAX_NOTES_PER_PAGE], [[u8; NAME_LENGTH]; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.participants.at(escrow).view_notes(options.set_offset(offset));\n        let mut participants: [AztecAddress; MAX_NOTES_PER_PAGE] = [AztecAddress::from_field(0); MAX_NOTES_PER_PAGE];\n        let mut participant_names: [[u8; NAME_LENGTH]; MAX_NOTES_PER_PAGE] = [[0; NAME_LENGTH]; MAX_NOTES_PER_PAGE];\n        for i in 0..notes.len() {\n            if i < notes.len() {\n                let participant_note = notes.get_unchecked(i);\n                participants[i] = participant_note.address;\n                participant_names[i] = participant_note.get_name();\n            }\n        }\n        let page_limit_reached = notes.len() == options.limit;\n        (participants, participant_names, page_limit_reached)\n    }\n}\n\n"},"72":{"path":"/home/jpag/Workground/aztec/zimburse/z-imburse/contracts/z_imburse_contract_registry/src/types/participant_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    \n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n"},"74":{"path":"/home/jpag/Workground/aztec/zimburse/z-imburse/contracts/address_note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"88":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"89":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_getter_options.nr","source":"use std::option::Option;\nuse dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::ToField};\nuse crate::note::note_interface::NoteInterface;\n\npub struct PropertySelector {\n    index: u8, // index of the field in the serialized note array\n    offset: u8, // offset in the byte representation of the field (selected with index above) from which to reading\n    length: u8, // number of bytes to read after the offset\n}\n\npub struct Select {\n    property_selector: PropertySelector,\n    comparator: u8,\n    value: Field,\n}\n\nimpl Select {\n    // The selected property will be the left hand side and value the right hand side of the operation, so e.g. the\n    // object created by new(property, Comparator.GT, value) represents 'property > value'.\n    pub fn new(property_selector: PropertySelector, comparator: u8, value: Field) -> Self {\n        Select { property_selector, comparator, value }\n    }\n}\n\npub struct SortOrderEnum {\n    DESC: u8,\n    ASC: u8,\n}\n\nglobal SortOrder = SortOrderEnum {\n    DESC: 1,\n    ASC: 2,\n};\n\npub struct Sort {\n    property_selector: PropertySelector,\n    order: u8,\n}\n\nimpl Sort {\n    pub fn new(property_selector: PropertySelector, order: u8) -> Self {\n        Sort { property_selector, order }\n    }\n}\n\npub struct NoteStatusEnum {\n    ACTIVE: u8,\n    ACTIVE_OR_NULLIFIED: u8,\n}\n\nglobal NoteStatus = NoteStatusEnum {\n    ACTIVE: 1,\n    ACTIVE_OR_NULLIFIED: 2,\n    // TODO 4217: add 'NULLIFIED'\n};\n\n// This is the default filter and preprocessor, which does nothing\nfn return_all_notes<Note>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    _p: Field\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    notes\n}\n\n// docs:start:NoteGetterOptions\npub struct NoteGetterOptions<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS> {\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n    limit: u32,\n    offset: u32,\n    // Preprocessor and filter functions are used to filter notes. The preprocessor is applied before the filter and\n    // unlike filter it is applied in an unconstrained context.\n    preprocessor: fn ([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n    filter: fn ([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], FILTER_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    filter_args: FILTER_ARGS,\n    status: u8,\n}\n// docs:end:NoteGetterOptions\n\n// When retrieving notes using the NoteGetterOptions, the configurations are applied in a specific sequence to ensure\n// precise and controlled data retrieval.\n// The database-level configurations are applied first:\n// `selects` to specify fields, `sorts` to establish sorting criteria, `offset` to skip items, and `limit` to cap\n// the result size.\n// And finally, a custom preprocessor and filter to refine the outcome further.\nimpl<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS> NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS> {\n    // This method adds a `Select` criterion to the options.\n    // It takes a property_selector indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from `utils::comparison`)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T\n    ) -> Self where T: ToField {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    // This method adds a `Sort` criterion to the options.\n    // It takes a field_index indicating which field to sort by and an order (SortOrder) to determine the sorting direction.\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    // This method lets you set a limit for the maximum number of notes to be retrieved in a single query result.\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        assert_constant(limit);\n\n        self.limit = limit;\n        *self\n    }\n\n    // This method sets the offset value, which determines where to start retrieving notes in the query results.\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n\nimpl<Note, let N: u32> NoteGetterOptions<Note, N, Field, Field> where Note: NoteInterface<N> {\n    // This function initializes a NoteGetterOptions that simply returns the maximum number of notes allowed in a call.\n    pub fn new() -> Self {\n        Self {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32,\n            offset: 0,\n            preprocessor: return_all_notes,\n            preprocessor_args: 0,\n            filter: return_all_notes,\n            filter_args: 0,\n            status: NoteStatus.ACTIVE\n        }\n    }\n}\n\nimpl<Note, let N: u32, PREPROCESSOR_ARGS> NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, Field> where Note: NoteInterface<N> {\n    // This function initializes a NoteGetterOptions with a preprocessor, which takes the notes returned from\n    // the database and preprocessor_args as its parameters.\n    // `preprocessor_args` allows you to provide additional data or context to the custom preprocessor.\n    pub fn with_preprocessor(\n        preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n        preprocessor_args: PREPROCESSOR_ARGS\n    ) -> Self {\n        Self {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32,\n            offset: 0,\n            preprocessor,\n            preprocessor_args,\n            filter: return_all_notes,\n            filter_args: 0,\n            status: NoteStatus.ACTIVE\n        }\n    }\n}\n\nimpl<Note, let N: u32, FILTER_ARGS> NoteGetterOptions<Note, N, Field, FILTER_ARGS> where Note: NoteInterface<N> {\n    // This function initializes a NoteGetterOptions with a filter, which takes\n    // the notes returned from the database and filter_args as its parameters.\n    // `filter_args` allows you to provide additional data or context to the custom filter.\n    pub fn with_filter(\n        filter: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], FILTER_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n        filter_args: FILTER_ARGS\n    ) -> Self {\n        Self {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTE_HASH_READ_REQUESTS_PER_CALL as u32,\n            offset: 0,\n            preprocessor: return_all_notes,\n            preprocessor_args: 0,\n            filter,\n            filter_args,\n            status: NoteStatus.ACTIVE\n        }\n    }\n}\n"},"90":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"91":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n"},"94":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"96":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"98":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"}}}