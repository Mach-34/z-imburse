{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "ZImburseRegistry",
  "functions": [
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 20,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgIEASYCAwQAHxgAAwACgEMtCIBDAAEkAAAAQCcCAAEEgEQmAgIEADoNAAEAAiQAABe5KAIAAgDewPQwCjgBAgMmAgQEACYCBgQDADgEBgUsCAECABABBQEmAwIEAQAoAgIFLA4EBQAoBQIFLA4EBSYCBQQDADgCBQQmAgQAOyYCBQEBJgIGADgmAgcANCYCCAAAJgIJAAQmAgoEASYCCwABJgIMAAcmAg0ABScCAA4A3q0mAg8BACYCEAA2JgIRADomAhIACCYCEwAGJgIUBAAmAhUEBCMCAAMAAAD1IgAABtsmAhcECiwIARgmAhkECwAQARkBJgMYBAEAKBgCGR88AAoAFwAZLA0YGQAoGQIZLA4ZGCwNGBkAKBkCGSwOGRgsDRgZACgZAhksDhkYLAgBGQAAAQIBLA4YGSwIARgAAAECASwOFBgmAhsEHCwIABwsDBkdLAwYHgAQABsAJAAAF+IsBAAALAwdGiYCHAQdLAgAHSwMCR4sDBofABAAHAAkAAAYXSwEAAAsDB4bJgIcBB0sCAAdLAwZHiwMGB8AEAAcACQAABfiLAQAACwMHhomAh0EHiwIAB4sDBMfLAwaIAAQAB0AJAAAGF0sBAAALAwfHCYCHQQeLAgAHiwMGR8sDBggLAwSIQAQAB0AJAAAGL4sBAAALAwfGiwNGh0AKB0CHSwOHRomAh4EHywIAB8sDBkgLAwYISwMEiIAEAAeACQAABi+LAQAACwMIB0sDR0YACgYAhgsDhgdLAgBGAAAAQIBLA4PGCwIARkAAAECASwOCBksCAEeAAABAgEmAh8AhiwOHx4eAgAfADU4AB8AIAAhACMCACEAAAKjIgAAApYsDA8DLAwIFiIAAAKwLAwFAywMIBYiAAACsCMCAAMAAALBJgIiBAA7CQEiNTgAHwADACICIwIAIgAAAuQiAAAC1ywMDyAsDAghIgAAAvEsDAUgLAwDISIAAALxIwIAIAAAAwImAh8EADsJAR8sCAEfJgIgBAIAEAEgASYDHwQBACgfAiAfPAAUAAoAICwNHyAAKCACICwOIB8AKB8CIgA4IhQjLA0jIBwMICIEHAwiHwAsCAEgJgIiBAsAEAEiASYDIAQBACggAiIfPAAKABcAIiwNICIAKCICIiwOIiAmAiIALCwIASMmAiQEDAAQASQBJgMjBAEAKCMCJCYCJQQLADglJCUsDCQmDDgmJScWDCcnIwIAJwAAA74sDiImACgmAiYiAAADnywIASIAAAECASwOIyIsDBQDIgAAA9QMOAMXIyMCACMAABcvIgAAA+YsDSIXLA0XIAAoIAIgLA4gFyoCACAAAAAAAAAAAAsAAAAAAAAAACYCJgQnLAgAJywMICgAEAAmACQAABo/LAQAACwMKCIsDCkjLAwqJCwMKyUsDSIgACggAiAsDiAiLAgBIAAAAQIBLA4iICwNIyIAKCICIiwOIiMsCAEiAAABAgEsDiMiLAgBIwAAAQIBLA4kIywIASQAAAECASwOJSQmAiUECywMFAMiAAAEkww4AyUmIwIAJgAAFq0iAAAEpSYCJQQmLAgAJiwMICcsDCIoLAwjKSwMJCoAEAAlACQAABrmLAQAACwMJxcmAiAADSwIASImAiMEBAAQASMBJgMiBAEAKCICIywMIyQsDiAkACgkAiQsDh8kACgkAiQsDhckLA0iFwAoFwIXLA4XIioCABcAAAAAAAAAAAMAAAAAAAAAACYCJQQmLAgAJiwMFycAEAAlACQAABo/LAQAACwMJx8sDCggLAwpIywMKiQsDR8XACgXAhcsDhcfLAgBFwAAAQIBLA4fFywNIB8AKB8CHywOHyAsCAEfAAABAgEsDiAfLAgBIAAAAQIBLA4jICwIASMAAAECASwOJCMmAiQEAywMFAMiAAAFsAw4AyQlIwIAJQAAFisiAAAFwiYCJQQmLAgAJiwMFycsDB8oLAwgKSwMIyoAEAAlACQAABrmLAQAACwMJyIKOCEiFyMCABcAAAX/JAAAG2oKOBYIFx4CAB8BCjgWHyASOBcgFiMCABYAAAYgJAAAG3weAgAWASgCABcAO5rKAS4MABcAHwo4HwggIwIAIAAABkYkAAAbji8MAA4AFywIARcmAh8EBAAQAR8BJgMXBAEAKBcCHywMHyAsDhYgACggAiAsDhsgACggAiAsDhwgLAwUAyIAAAaHDDgDJBYjAgAWAAAV1iIAAAaZLAwUAyIAAAaiDDgDFRYjAgAWAAAUtiIAAAa0HgIAAwAzAgADACgCAhcsDRcWJgIYBAIAOBcYAzoNAAMAFiIAAAbbKAIAAwCy0e84CjgBAxYsDQIDACgDAgMsDgMCIwIAFgAABwMiAAAIoyYCFgQILAgBFyYCGAQJABABGAEmAxcEAQAoFwIYHzwACgAWABgsDRcWACgWAhYsDhYXLA0XFgAoFgIWLA4WFywNFxYAKBYCFiwOFhcsCAEWAAABAgEsDhcWLAgBFwAAAQIBLA4UFyYCGQQaLAgAGiwMFhssDBccLAwSHQAQABkAJAAAG6AsBAAALAwbGCwNGBkAKBkCGSwOGRgmAhoEGywIABssDBYcLAwXHSwMEh4AEAAaACQAABugLAQAACwMHBksDRkWACgWAhYsDhYZLAgBFgAAAQIBLA4PFiwIARcAAAECASwOCBcsCAEaAAABAgEmAhsAfSwOGxomAhsEHCwIABwsDBYdLAwXHiwMGh8AEAAbACQAAB0hLAQAACYCHgQfLAgAHywMFiAsDBchLAwaIiwMCyMAEAAeACQAAB1LLAQAACwMIBssDCEcLAwiHR4CAB4BCjgbHh8jAgAfAAAIaiQAAB5zLAwUAyIAAAhzDDgDFRsjAgAbAAATliIAAAiFACgCAhYsDRYVJgIXBAIAOBYXAzoNAAMAFSIAAAijKAIAAwABeHp8CjgBAxUsDQIDACgDAgMsDgMCIwIAFQAACMsiAAAK4iYCAwQCLAgBFSYCFgQDABABFgEmAxUEAQAoFQIWHzwACgADABYsDRUDACgDAgMsDgMVLA0VAwAoAwIDLA4DFSwNFQMAKAMCAywOAxUsCAEDAAABAgEsDhUDLAgBFQAAAQIBLA4UFSYCFwQYLAgAGCwMAxksDBUaLAwTGwAQABcAJAAAHoUsBAAALAwZFiYCGAQZLAgAGSwMAxosDBUbLAwTHAAQABgAJAAAHoUsBAAALAwaFywIAQMAAAECASwODwMsCAEVAAABAgEsDggVLAgBGAAAAQIBJgIZAGssDhkYJgIZBBosCAAaLAwDGywMFRwsDBgdABAAGQAkAAAdISwEAAAmAhwEHSwIAB0sDAMeLAwVHywMGCAsDAshABAAHAAkAAAdSywEAAAsDB4ZLAwfGiwMIBseAgAcAQo4GRwdIwIAHQAAChgkAAAfHyYCGQQcLAgAHCwMAx0sDBUeLAwYHywMAyAsDBUhLAwYIiwMCyMsDAMkLAwVJSwMGCYsDAknLAwHKCwMAyksDBUqLAwYKywMDSwsDBAtLAwDLiwMFS8sDBgwLAwTMSwMBjIsDAMzLAwVNCwMGDUsDAw2LAwRNywMAzgsDBU5LAwYOiwMEjssDAQ8LAwXPSwMFj4AEAAZACQAAB8xLAQAACwNAgMAKAMCAywOAwIAKAICBiwNBgQmAgwEAgA4BgwDOg0AAwAEIgAACuIoAgADAMEQqIoKOAEDBCMCAAQAAAr9IgAADOIsCAEDJgIEBAIAEAEEASYDAwQBACgDAgQfPAAKAAoABCwNAwQAKAQCBCwOBAMsDQMEACgEAgQsDgQDLA0DBAAoBAIELA4EAywIAQQAAAECASwOAwQsCAEDAAABAgEsDhQDJgIMBBUsCAAVLAwEFiwMAxcAEAAMACQAACJOLAQAACwMFgYmAgQEFSwIABUsDAkWLAwGFwAQAAQAJAAAGF0sBAAALAwWAywIAQQAAAECASwODwQsCAEGAAABAgEsDggGLAgBDAAAAQIBJgIRAGIsDhEMJgIRBBUsCAAVLAwEFiwMBhcsDAwYABAAEQAkAAAdISwEAAAeAgARAR4CABIACjgREhUjAgAVAAAMDyQAACLJLAgBESYCEgQDABABEgEmAxEEAQAoEQISLAwSFSwOCRUAKBUCFSwOAxUmAhIEFSwIABUsDBEWABAAEgAkAAAi2ywEAAAsDBYDJgIXBBgsCAAYLAwHGSwMBBosDAYbLAwMHCwMAx0AEAAXACQAACRGLAQAACwMGREsDBoSLAwbFSwMHBYoAgADADuaygAAOAMWBC4MAAQAAwo4AwgGIwIABgAADLgkAAAbji8MAA4ABC8MAAsAFgAoAgIGLA0GBCYCDAQCADgGDAM6DQADAAQiAAAM4igCAAIAppiSlQo4AQIDIwIAAwAADP0iAAAPFywIAQImAgMEAgAQAQMBJgMCBAEAKAICAx88AAoACgADLA0CAwAoAwIDLA4DAiwNAgMAKAMCAywOAwIsDQIDACgDAgMsDgMCLAgBAwAAAQIBLA4CAywIAQIAAAECASwOFAImAgYEFSwIABUsDAMWLAwCFwAQAAYAJAAAIk4sBAAALAwWBCYCAwQVLAgAFSwMExYsDAQXABAAAwAkAAAYXSwEAAAsDBYCLAgBAwAAAQIBLA4PAywIAQQAAAECASwOCAQsCAEGAAABAgEmAgwAWywODAYmAgwEFSwIABUsDAMWLAwEFywMBhgAEAAMACQAAB0hLAQAAB4CAAwJCjgMCw4jAgAOAAAOCiQAACXkLAgBDCYCDgQDABABDgEmAwwEAQAoDAIOLAwOESwODREAKBECESwOAhEmAg0EFSwIABUsDAwWABAADQAkAAAi2ywEAAAsDBYCJgISBBUsCAAVLAwQFiwMAxcsDAQYLAwGGSwMAhoAEAASACQAACRGLAQAACwMFgwsDBcNLAwYDiwMGREmAgMEFSwIABUsDAwWLAwNFywMDhgsDBEZABAAAwAkAAAl9iwEAAAsDBYCJgIEBAEmAgwEAwA4BAwGLAgBAwAQAQYBJgMDBAEAKAMCBiwOBAYAKAYCBiwOBAYmAgYEAwA4AwYELAwEBiwOAgYAKAMCBiwNBgQmAgwEAgA4BgwCOg0AAgAEIgAADxcoAgACANFSbU0KOAECAyMCAAMAAA8yIgAAECosCAECAAABAgEsDg8CLAgBAwAAAQIBLA4IAywIAQQAAAECASYCBgBOLA4GBCYCBgQVLAgAFSwMAhYsDAMXLAwEGAAQAAYAJAAAHSEsBAAAHgIABgkKOAYLDCMCAAwAAA+YJAAAJgYmAg4EFSwIABUsDAIWLAwDFywMBBgsDAsZABAADgAkAAAdSywEAAAsDBYGLAwXDCwMGA0mAgMEASYCDgQDADgDDgQsCAECABABBAEmAwIEAQAoAgIELA4DBAAoBAIELA4DBCYCBAQDADgCBAMsDAMELA4NBAAoAgINLA0NBCYCDgQCADgNDgM6DQADAAQiAAAQKigCAAIArb4D6Ao4AQIDIwIAAwAAEEUiAAASRCwIAQEmAgIEAgAQAQIBJgMBBAEAKAECAh88AAoACgACLA0BAgAoAgICLA4CASwNAQIAKAICAiwOAgEsDQECACgCAgIsDgIBLAgBAgAAAQIBLA4BAiwIAQEAAAECASwOFAEmAgQEFSwIABUsDAIWLAwBFwAQAAQAJAAAIk4sBAAALAwWAyYCAgQVLAgAFSwMCRYsDAMXABAAAgAkAAAYXSwEAAAsDBYBLAgBAgAAAQIBLA4PAiwIAQMAAAECASwOCAMsCAEEAAABAgEmAgYAHywOBgQmAgYEFSwIABUsDAIWLAwDFywMBBgAEAAGACQAAB0hLAQAAB4CAAYJCjgGCwgjAgAIAAARUiQAACYYLAgBBiYCCAQDABABCAEmAwYEAQAoBgIILAwICywOCQsAKAsCCywOAQsmAggEFSwIABUsDAYWABAACAAkAAAi2ywEAAAsDBYBJgIMBBUsCAAVLAwHFiwMAhcsDAMYLAwEGSwMARoAEAAMACQAACRGLAQAACwMFgYsDBcILAwYCSwMGQsuDAALAAEcDAEDARwMAwIAJgIDBAEmAgcEAwA4AwcELAgBAQAQAQQBJgMBBAEAKAECBCwOAwQAKAQCBCwOAwQmAgQEAwA4AQQDLAwDBCwOAgQAKAECBCwNBAMmAgcEAgA4BAcCOg0AAgADIgAAEkQmAgECYyYCAgJzJgIDAm8mAgQCVSYCBgJ0JgIHAmUmAggCdyYCCQJuJgIKAnImAgsCbCYCDAIgJgINAmssCAEOJgIQBBEAEAEQASYDDgQBACgOAhAsDBARLA4EEQAoEQIRLA4JEQAoEQIRLA4NEQAoEQIRLA4JEQAoEQIRLA4DEQAoEQIRLA4IEQAoEQIRLA4JEQAoEQIRLA4MEQAoEQIRLA4CEQAoEQIRLA4HEQAoEQIRLA4LEQAoEQIRLA4HEQAoEQIRLA4BEQAoEQIRLA4GEQAoEQIRLA4DEQAoEQIRLA4KEQo4DwUBIwIAAQAAE5UmAgIEEiwIAQMmAgQEEgAQAQQBLAwDBCkDAAQF5Y+YWQcxYpAAKAQCBAAoDgIGJgIHBBAtBAAGgAMtBAAEgAQtBAAHgAUkAAAmKiYCBgQQADgEBgQsDhQEACgEAgQ7DQMCJSYCHAQEDDgDHB0jAgAdAAATrSQAACZwACgYAhwAOBwDHSwNHRsKOBsIHCMCABwAABSWIgAAE80mAh0EBAw4Ax0eIwIAHgAAE+QkAAAmcAAoGQIdADgdAx4sDR4cJgIdBB4sCAAeLAwWHywMFyAsDBohLAwWIiwMFyMsDBokLAwLJSwMFiYsDBcnLAwaKCwMCSksDAcqLAwWKywMFywsDBotLAwNLiwMEC8sDBYwLAwXMSwMGjIsDBMzLAwGNCwMFjUsDBc2LAwaNywMDDgsDBE5LAwWOiwMFzssDBo8LAwSPSwMBD4sDBw/LAwbQAAQAB0AJAAAHzEsBAAAIgAAFJYAOAMKGw44AxscIwIAHAAAFK0kAAAmgiwMGwMiAAAIcyYCFwQEDDgDFxsjAgAbAAAUzSQAACZwACgaAhcAOBcDGywNGxYKOBYIFyMCABcAABW2IgAAFO0mAhsEBAw4AxscIwIAHAAAFQQkAAAmcAAoHQIbADgbAxwsDRwXJgIbBB8sCAAfLAwYICwMGSEsDB4iLAwYIywMGSQsDB4lLAwLJiwMGCcsDBkoLAweKSwMCSosDAcrLAwYLCwMGS0sDB4uLAwNLywMEDAsDBgxLAwZMiwMHjMsDBM0LAwGNSwMGDYsDBk3LAweOCwMDDksDBE6LAwYOywMGTwsDB49LAwSPiwMBD8sDBdALAwWQQAQABsAJAAAHzEsBAAAIgAAFbYAOAMKFg44AxYXIwIAFwAAFc0kAAAmgiwMFgMiAAAGohwMAxYAADgLFhsmAhwEAww4AxwfIwIAHwAAFfckAAAmcAAoFwIcADgcAx8sDR8WLwwAFgAbADgDChYOOAMWGyMCABsAABYiJAAAJoIsDBYDIgAABocjAgAlAAAWOCIAABaNJgImBAMMOAMmJyMCACcAABZPJAAAJnAAKCICJgA4JgMnLA0nJSYCJgQnLAgAJywMFygsDB8pLAwgKiwMIyssDCUsABAAJgAkAAAmlCwEAAAiAAAWjQA4AwolDjgDJSYjAgAmAAAWpCQAACaCLAwlAyIAAAWwIwIAJgAAFroiAAAXDyYCJwQLDDgDJygjAgAoAAAW0SQAACZwACgXAicAOCcDKCwNKCYmAicEKCwIACgsDCApLAwiKiwMIyssDCQsLAwmLQAQACcAJAAAJpQsBAAAIgAAFw8AOAMKJg44AyYnIwIAJwAAFyYkAAAmgiwMJgMiAAAEkywNIiMAOAMKJA44AyQlIwIAJQAAF0okAAAmgiYCJgQKDDgDJicjAgAnAAAXYSQAACZwACggAiYAOCYDJywNJyUmAicECww4JCcoIwIAKAAAF4YkAAAmcC0EACOAAycAgAQEAAwkAAAnxS0IgAUAJgAoJgInADgnJCgsDiUoLA4mIiwMJAMiAAAD1CcAgAQEeAANAAAAgASAAyMAgAMAABfhKQEAAQX3ofOvpa3UyjsBAQIlJAAAF7ksDQEDLA0CBCYCBgQKDDgEBgcjAgAHAAAYBiQAACZwACgDAgYAOAYEBywNBwUsCAEGJgIHBAIAEAEHASYDBgQBACgGAgcsDAcILA4FCCYCBQQBADgEBQcOOAQHCCMCAAgAABhQJAAAJoIsDgMBLA4HAiwMBgElJAAAF7kmAgQABAo4AQQFJgIEBAAAKAICBwA4BwQILA0IBiMCAAUAABiwIgAAGIwmAgIABgo4AQIEIwIABAAAGKcmAgUEADsJAQUsDAYDIgAAGLksDAYDIgAAGLksDAMBJSQAABe5JgIFAAAsCAEGJgIHBAUAEAEHASYDBgQBACgGAgcsDAcILA4FCAAoCAIILA4FCAAoCAIILA4FCAAoCAIILA4FCCwIAQUAAAECASwOBgUmAgYEBCYCBwQBJgIIBAAsDAgEIgAAGSgMOAQGAyMCAAMAABmWIgAAGTosDQEDLA0CBAA4BAYHDjgEBwgjAgAIAAAZWSQAACaCLA4DASwOBwIsDQUBJgIDBAQsCAAELAwBBQAQAAMAJAAAKFMsBAAALAwFAiwNAgEAKAECASwOAQIsDAIBJSwNBQMsDQEILA0CCQA4CQQKDjgJCgsjAgALAAAZuSQAACaCJgILBAoMOAoLDCMCAAwAABnQJAAAJnAAKAgCCwA4CwoMLA0MCSYCCgQEDDgECgsjAgALAAAZ9SQAACZwLQQAA4ADJwCABAQABSQAACfFLQiABQAIACgIAgoAOAoECywOCQsAOAQHAw44BAMJIwIACQAAGjIkAAAmgiwOCAUsDAMEIgAAGSgkAAAXuSYCAgAALAgBAyYCBAQEABABBAEmAwMEAQAoAwIELAwEBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUsDQMEACgEAgQsDgQDLAgBBCYCBQQFABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAQYmAgEEACYCAgEALAwCBSwMAQYsDAQCLAwFBCwMAwEsDAYDJSQAABe5LA0EBSYCBgEACjgFBgcjAgAHAAAbCiYCCAQAOwkBCCYCBQQGLAgABiwMAQcsDAIILAwDCSwMBAoAEAAFACQAACoOLAQAACwNAQUsDQIGLA0DBywOBQEsDgYCLA4HAyYCAQEBLA4BBCYCAQQAACgGAgMAOAMBBCwNBAIsDAIBJSkBAAEF9IABplnTJ0I7AQECJSkBAAEFHwBQEkAkIu47AQECJSkBAAEFHwotJ9yCh6I7AQECJSQAABe5JgIFAAAsCAEGJgIHBAUAEAEHASYDBgQBACgGAgcsDAcILA4FCAAoCAIILA4FCAAoCAIILA4FCAAoCAIILA4FCCwIAQUAAAECASwOBgUmAgYEBCYCBwQBJgIIBAAsDAgEIgAAHAoMOAQGAyMCAAMAABx4IgAAHBwsDQEDLA0CBAA4BAYHDjgEBwgjAgAIAAAcOyQAACaCLA4DASwOBwIsDQUBJgIDBAQsCAAELAwBBQAQAAMAJAAAKFMsBAAALAwFAiwNAgEAKAECASwOAQIsDAIBJSwNBQMsDQEILA0CCQA4CQQKDjgJCgsjAgALAAAcmyQAACaCJgILBAgMOAoLDCMCAAwAAByyJAAAJnAAKAgCCwA4CwoMLA0MCSYCCgQEDDgECgsjAgALAAAc1yQAACZwLQQAA4ADJwCABAQABSQAACfFLQiABQAIACgIAgoAOAoECywOCQsAOAQHAw44BAMJIwIACQAAHRQkAAAmgiwOCAUsDAMEIgAAHAokAAAXuR4CAAQAHgIABQAyOAAEAAUABiYCBAEBIwIABgAAHUokAAArfyUkAAAXuSYCBgAALAgBByYCCAQEABABCAEmAwcEAQAoBwIILAwICSwOBgkAKAkCCSwOBgkAKAkCCSwOBgksCAEGAAABAgEsDgcGJgIHBAMmAggEASYCCQQALAwJBSIAAB2sDDgFBwEjAgABAAAd/iIAAB2+LA0GAQAoAQIDADgDCQQsDQQCACgBAgQAOAQIBSwNBQMmAgQEAgAoAQIGADgGBAcsDQcFLAwCASwMAwIsDAUDJSwNBgEcDAUCAAA4BAIDLgwAAwACJgIKBAMMOAUKCyMCAAsAAB4pJAAAJnAtBAABgAMnAIAEBAAEJAAAJ8UtCIAFAAMAKAMCCgA4CgULLA4CCwA4BQgBDjgFAQIjAgACAAAeZiQAACaCLA4DBiwMAQUiAAAdrCkBAAEF8E0P+B39nfc7AQECJSQAABe5LA0BBCwNAgUmAgcEAgw4BQcIIwIACAAAHqkkAAAmcAAoBAIHADgHBQgsDQgGLAgBByYCCAQCABABCAEmAwcEAQAoBwIILAwICSwOBgkmAgYEAQA4BQYIDjgFCAkjAgAJAAAe8yQAACaCLA4EASwOCAImAgIECCwIAAgsDAMJLAwHCgAQAAIAJAAAGF0sBAAALAwJASUpAQABBbQLkMnY3UskOwEBAiUkAAAXuSwIASQmAiUEAwAQASUBJgMkBAEAKCQCJSwMJSYsDhAmACgmAiYsDiEmJgIlBCYsCAAmLAwkJwAQACUAJAAAItssBAAALAwnECYCKQQqLAgAKiwMESssDA0sLAwOLSwMDy4sDBAvABAAKQAkAAAkRiwEAAAsDCslLAwsJiwMLScsDC4oJgIpBCosCAAqLAwlKywMJiwsDCctLAwoLgAQACkAJAAAJfYsBAAALAwrECYCJQAACjgQJSYjAgAmAAAf+yQAACuRLA0kEAAoEAIQLA4QJCYCJgQnLAgAJywMJCgAEAAmACQAACLbLAQAACwMKBAmAikEKiwIACosDBErLAwNLCwMDi0sDA8uLAwQLwAQACkAJAAAJEYsBAAALAwrJCwMLCYsDC0nLAwuKCgCAA0AO5rKAAA4DSgOLgwADgANCjgNJQ8jAgAPAAAgiCQAABuOJwIADQDerS8MAA0ADi8MACIAKCwIAQ0mAg4EBAAQAQ4BJgMNBAEAKA0CDiwMDg8sDiUPACgPAg8sDiUPACgPAg8sDiUPKAIADgBUqmZoLAgBDyYCEAQEABABEAEmAw8EAQAoDwIQLAwQESwOIREAKBECESwOIhEAKBECESwODhEsDQ0OACgOAg4sDg4NLAgBDgAAAQIBLA4NDiYCDQQDJgIQBAEmAhEEACwMESMiAAAhOgw4Iw0BIwIAAQAAIcQiAAAhTCwNDgEmAgQEAwYoBAICJgIGBAMAOAQGBSwIAQMAEAEFASYDAwQBACgDAgUsDgQFACgFAgUsDgQFJgIGBAMAOAMGBQAoAQIGLQQABoADLQQABYAELQQABIAFJAAAJioAKAMCBSwNBQQmAgYEAgA4BQYBNg0AAQAEJSYCAgQDDDgjAgMjAgADAAAh2yQAACZwACgPAgIAOAIjAywNAwEsDQ4CJgIEBAMMOCMEBSMCAAUAACIEJAAAJnAtBAACgAMnAIAEBAAEJAAAJ8UtCIAFAAMAKAMCBAA4BCMFLA4BBQA4IxABDjgjAQIjAgACAAAiQSQAACaCLA4DDiwMASMiAAAhOiQAABe5LA0BAywNAgQmAgYEAQw4BAYHIwIABwAAInIkAAAmcAAoAwIGADgGBAcsDQcFLAgBBiYCBwQCABABBwEmAwYEAQAoBgIHLAwHCCwOBQgmAgUEAQA4BAUHDjgEBwgjAgAIAAAivCQAACaCLA4DASwOBwIsDAYBJSkBAAEFxaW46E1CRQU7AQECJSQAABe5KgIAAwAAAAAAAAAAAgAAAAAAAAAAJgIIBAksCAAJLAwDCgAQAAgAJAAAGj8sBAAALAwKBCwMCwUsDAwGLAwNBywNBAMAKAMCAywOAwQsCAEDAAABAgEsDgQDLA0FBAAoBAIELA4EBSwIAQQAAAECASwOBQQsCAEFAAABAgEsDgYFLAgBBgAAAQIBLA4HBiYCBwQCJgIIBAAmAgkEASwMCAIiAAAjhgw4AgcIIwIACAAAI8QiAAAjmCYCAgQHLAgABywMAwgsDAQJLAwFCiwMBgsAEAACACQAABrmLAQAACwMCAElIwIACAAAI9EiAAAkJiYCCgQCDDgCCgsjAgALAAAj6CQAACZwACgBAgoAOAoCCywNCwgmAgoECywIAAssDAMMLAwEDSwMBQ4sDAYPLAwIEAAQAAoAJAAAJpQsBAAAIgAAJCYAOAIJCA44AggKIwIACgAAJD0kAAAmgiwMCAIiAAAjhiQAABe5JgIKADQKOAEKCyYCCgAACjgFCgwmAgoBACMCAAsAACWsIgAAJHEmAhAANgo4ARARIwIAEQAAJXAiAAAkiCYCFAA4CjgBFBUjAgAVAAAlNCIAACSfJgIYADoKOAEYGSMCABkAACT4IgAAJLYmAhgAOwo4ARgZIwIAGQAAJNEmAhoEADsJARoKOAwKASMCAAEAACTjJAAAK6MsDAIULAwDFSwMBBYsDAUXIgAAJR8KOAwKASMCAAEAACUKJAAAK6MsDAIULAwDFSwMBBYsDAUXIgAAJR8sDBQQLAwVESwMFhIsDBcTIgAAJVsKOAwKASMCAAEAACVGJAAAK6MsDAIQLAwDESwMBBIsDAUTIgAAJVssDBALLAwRDSwMEg4sDBMPIgAAJZcKOAwKASMCAAEAACWCJAAAK6MsDAILLAwDDSwMBA4sDAUPIgAAJZcsDAsGLAwNBywMDggsDA8JIgAAJdMKOAwKASMCAAEAACW+JAAAK6MsDAIGLAwDBywMBAgsDAUJIgAAJdMsDAcCLAwIAywMBgEsDAkEJSkBAAEF7YjgAbo3Cok7AQECJSQAABe5LgwABAAFLAwFASUpAQABBVJV8p1zRZqsOwEBAiUpAQABBUr3/oThq6BFOwEBAiUBAIADgAWABy0AgAOACC0AgASACQsAgAiAB4AKIwCACgAAJm8tAYAIgAYtAoAGgAkBAIAIAAKACAEAgAkAAoAJIgAAJj4lKQEAAQXonQn+oREtDjsBAQIlKQEAAQVFp8pxGUHkFTsBAQIlJAAAF7ksDQMGLA0EByYCCAEACjgHCAkjAgAJAAAmvCYCCgQAOwkBCiYCBwQDCjgGBwgmAgYEASMCAAgAACdRIgAAJtgsDQEHLA0CCCwNAwksDQQKJgIMBAMMOAkMDSMCAA0AACb/JAAAJnAtBAAHgAMnAIAEBAAEJAAAJ8UtCIAFAAsAKAsCDAA4DAkNLA4FDQA4CQYFDjgJBQcjAgAHAAAnPCQAACaCLA4LASwOCAIsDgUDLA4KBCIAACfEJgIHBAgsCAAILAwBCSwMAgosDAMLLAwEDAAQAAcAJAAAKg4sBAAALA0BBywNAggsDQQJJgIKBAAtBAAHgAMnAIAEBAAEJAAAJ8UtCIAFAAsAKAsCDAA4DAoNLA4FDSwOCwEsDggCLA4GAywOCQQiAAAnxCUtAYADgAYLAIAGAAKAByMAgAcAACfgIgAAJ+stAIADgAUiAAAoUi0AAAGABQEAAAGABAABAQCAA4AEgAktAIADgAotAIAFgAsLAIAKgAmADCMAgAwAACg+LQGACoAILQKACIALAQCACgACgAoBAIALAAKACyIAACgNJwGABQQAAQMAgAYAAoAGIgAAKFIlJAAAF7ksDQEDACgDAgMsDgMBLA0BAwAoAwIDLA4DASwIAQMAAAECASwOAQMsCAEBAAABAgEmAgQEACwOBAEmAgUAACwIAQYmAgcEBQAQAQcBJgMGBAEAKAYCBywMBwgsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUILA0GBQAoBQIFLA4FBiwIAQUAAAECASwOBgUmAgYABiYCBwQBJgIIBAQsDAQCIgAAKQMMOAIIBCMCAAQAACkaIgAAKRUsDQUBJSwNBQQsDQMJLA0BCiYCDAQEDDgKDA0jAgANAAApPSQAACZwACgJAgwAOAwKDSwNDQssCAEMJgINBAIAEAENASYDDAQBACgMAg0sDA0OLA4LDgA4CgcLDjgKCw0jAgANAAApgiQAACaCLA4JAywOCwEmAgoEDSwIAA0sDAYOLAwMDwAQAAoAJAAAGF0sBAAALAwOCSYCCwQEDDgCCwwjAgAMAAApxCQAACZwLQQABIADJwCABAQABSQAACfFLQiABQAKACgKAgsAOAsCDCwOCQwAOAIHBA44AgQJIwIACQAAKgEkAAAmgiwOCgUsDAQCIgAAKQMkAAAXuSYCBgQAJgIHBAEmAggEAywMBgUiAAAqKww4BQgGIwIABgAAKpgiAAAqPSwNAQUsDQIGLA0DBywNBAgmAgkEBCwIAQomAgsEBQAQAQsBJgMKBAEAKAYCCyYCDAQEACgKAg0+DwALAA0sDQoGACgGAgYsDgYKLA4FASwOCgIsDgcDLA4IBCUsDQMGDDgFBgkjAgAJAAAqriIAACtfLA0BBiwNAgksDQMKLA0ECyYCDQQEDDgFDQ4jAgAOAAAq1SQAACZwACgJAg0AOA0FDiwNDgwmAg4EAww4BQ4PIwIADwAAKvokAAAmcAAoBgIOADgOBQ8sDQ8NADgMDQ4mAg0EBAw4BQ0PIwIADwAAKyQkAAAmcC0EAAmAAycAgAQEAAUkAAAnxS0IgAUADAAoDAINADgNBQ8sDg4PLA4GASwODAIsDgoDLA4LBCIAACtfADgFBwYOOAUGCSMCAAkAACt2JAAAJoIsDAYFIgAAKispAQABBb4eP/8+pPb6OwEBAiUpAQABBV4sb3JUmazLOwEBAiUpAQABBQLcbieAdhKdOwEBAiUtABjKGMo=",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "register_dkim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim"
      ]
    },
    {
      "name": "get_managed_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_managed_escrows"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "ndLNCoQgFAXgd7nrFl2131eJIawsBLEwGxiidx+LZmiGNrq5eMTvujkrdKJZhlrqfpyhrFZQY8utHLVL6xZBY6RScqiv1xDvA/F4P09c73G23FgoEWkEQnfuRND5XioBJcvY9ogAiT+h/oT5k8SbkNtfClqkpykYoV+EGB8oCUFpCMpCUB6A6G0PCpYnH5TE7BdtLj65kbxR4uxZv+j2Ujv7msRfAycztqJbjNi7eKmhmxVmESFurVv9Bg==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "check_and_register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12235207718074526931": {
            "error_kind": "string",
            "string": "Escrow contract is not registered"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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XK592NrG4YPLNsZ4/uHj8RPDXx8+ti99b7v8l396oHne2uKLcd3/+pd0ufYR6q1orn0weiuaax933oomQNNCc+3D1FvRXPvs9VY01z5uvBXNtR32W9Fc2ze/E82KG26iwQ030eCGm2hww000AZoWGtxwEw1uuIkGN9xEgxtuosENt9BsuOEmGtxwEw1uuIkGN9xEE6BpocENN9HghptocMNNNLjhJhrccAvNjhtuosENN9HghptocMNNNAGaFhrccBMNbriJBjfcRIMbbqLBDbfQHLjhJhrccBMNbriJBjfcRBOgaaHBDTfR4IabaHDDTTS44SYa3HADzT7ghptocMNNNLjhJhrccBNNgKaFBjfcRIMbbqLBDTfR4IabaHDDLTQjbriJBjfcRIMbbqLBDTfRBGhaaHDDTTS44SYa3HATDW64iQY33EJz8dLut6LBDTfR4IabaHDDTTQBmhYa3HATDW64iQY33ESDG26iwQ230Fy8jvKtaHDDTTS44SYa3HATTYCmhQY33ESDG26iwQ030eCGm2hwwy00F686fCsa3HATDW64iQY33EQToGmhwQ030eCGm2hww000uOEmGtxwCw1ddG00uOEmGtxwEw1uuIkmQNNCgxtuosENN9HghptocMNNNHQ4/7jDedetdQ8Uw8flbMOQQBzn4WPScZ6/QPx3mfv3b8GxjB/fgmPdf/ot0N1ydxpguvsAqVNchr//e/jnfy3+1/5ry//af03ffR9H6o//2jFGRnn8+FdpnMbks/MyfvyT5+WYvihyiE/vx7w/r2P5/GfPw6yuY9k+/tnjcnyqPX0IshnNuheaddw+7o/jeCzfZz18Zm30R9WcdTSadSo06/z8Zz/uuvvXWcVNd3zec+fhO5YZLApLgEVhWcCisFTyeB2xVLKDHbFUco4dsVQymf2w7JX8aEcslaxrRyy4XIkFlyuxBFgUFlyuxILLlVhwuRILLldiweUqLAcuV2LB5UosuFyJxdblPic8tu+/1B22LvccCy5X/kuEy5VYcLkSCy5XYsHlCizHgMuVWHC5EgsuV2Ihy5VYAiwKCy5XYsHlSiy4XIkFlyux4HIVlhGXK7HgciUWXK7EgsuVWAIsCgsuV2LB5UosuFyJBZcrseByFZbJ1eWOw/S5Mb4t38G4+twUjKvTTcG4et0UTBQCE8P2cSEx7N9nrWRh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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_notes_internal",
        "get_collapse_hints",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "pack_arguments_oracle_wrapper",
        "pack_returns_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_escrow_registry_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_escrow_registry_status"
      ]
    },
    {
      "name": "check_dkim_key_hash_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "check_dkim_key_hash_public"
      ]
    },
    {
      "name": "get_participants",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "name",
                            "type": {
                              "kind": "array",
                              "length": 2,
                              "type": {
                                "kind": "field"
                              }
                            }
                          },
                          {
                            "name": "npk_m_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "randomness",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "header",
                            "type": {
                              "fields": [
                                {
                                  "name": "contract_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "nonce",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "storage_slot",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "note_hash_counter",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::note::note_header::NoteHeader"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::participant_note::ParticipantNote"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bbhzHskT/Rc9+qFvWZf/Kxobh2zYECJYh2wc4MPzvZ8TmXHSma5LqKaEjqvPFkORuMiPYzJU1ZMb8/e7nX37869fv3//2349/vPvXv/9+9+HjTz/8+f7jb6e//f3Pd+9+/PT+w4f3v35/+8/v3Of/SKovN/zx+w+/ff77H3/+8OnPd//yubnv3v3y28+nPxbnTh/iv+8//PLuX6mkf767u7q6+npxDflybV27VIK8Xipy/bDeyT//+e5UTBtQjLRzMdU/LibF86Up17tixD1fTHP59eIW3ONisjs7k29MvBTjBxST0rkYKUox9fxxbz/spZiwWkzy7fwc+BRCUMop3p8/R7i6X/LKpSHncz3hVNr14qWciFVOwipHsMrJWOUUrHIqVjkNqpzssMrxWOVgdeWM1ZUzVlfOWF05Y3XljNWVM1ZXzlhduWB15YLVlQtWVy5YXblgdeWC1ZULVlcuWF25YHXlgtWVK1ZXrlhduWJ15YrVlStWV65YXblideWK1ZUrVleuWF25YXXlhtWVG1ZXblhduWF15YbVlRtWV25YXblhdeUG1ZWzg+rK2UF15eygunJ2UF05O6iufPohMlY5UF05O6iunB1UV84Oqyt7rK7ssbqyx+rKHqsre6yu7LG6ssfqyh6rK3usruyxunL4tl355VP4b/8pwrf/FGM6Yjr/imLJ+amvW8IqR7DKyVjlFKxyKlY5Daqc6LDK8VjlBKxysLpyxOrKEasrR6yuHLG6csTqyhGrKyesrpywunLC6soJqysnrK6csLpywurKCasrJ6yunLC6smB1ZcHqyoLVlQWrKwtWVxasrixYXVmwurJgdWXB6soZqytnrK6csbpyxurKGasrZ6yunLG6csbqyhmrK2esrlywunLB6soFqysXrK5csLpywerKBasrF6yuXL5tV375FO2bf4rqvv2neEtHjPGLT/FyX9h4X9x4X9p4n2y8L2+8r2y8r268r227701LPGv3bXxe2sbnpW18XtrG56VtfF7axuelbXxe2sbnpW17XopzG+/zG+8LG++LG+9LG++TjffljfeVjffVjfdtfF78xuel9xvKIcfrfTUryPMunoPovKtyudpnv3Z1PQfcnaq7XBtqWSoKcBVFuIoSXEUCV1GGq6jAVVThKmpoFfV+eXnHivbo2XKuKLjwRUX319aQzoXU0K55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",
      "brillig_names": [
        "get_participants"
      ]
    },
    {
      "name": "check_dkim_key_hash_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5886526716701834683": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_private can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_returns_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7921989071249124615": {
            "error_kind": "string",
            "string": "Function register_participant can only be called internally"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7V3bjuy2sf0XP+8HXoq3/EpgBE7iExgw7MBxDnAQ5N+PZnrE1t6iVG4OW71YZB6Csa1qrrVKqlqkJOo/3/39x7/++x9/+emX//n1X9/96c//+e7nX//2w+8//frL8k//+S7Y93/3r3/+8MvbP/7r9x9++/27P2mf1Jfvfvzl78ufQan/fvnuf376+cfv/kSB/vtld7SJNn4cbaK/H60pFY62TqePo61Lhjk6pvzbMTmdj7bKFo7WNv+2tjbmo40vHayMXw9WwW0P/v7Ld4GmMGVh3BSmLIyfwpSFCVOYsjBxClMWJk1hisJENYUpC6OnMGVhzBSmLMx0vgfC0BSmLMx0vgfCTOd7IMx0vgfCTOd7IMx0vmVh0nS+B8JM53sgzHS+B8JM53sgDE1hysJM53sgzHS+B8JM53sgzHS+B8JM51sWRqtpfY+Umd73SJlpfo+Ume73SBmayhwoM/3vkTLTAB8pMx3wkTLTAh8pMz3wgTJ6euAjZaYHPlJmeuAjZaYHPlKGpjIHykwPfKTM9MBHykwPfKTM9MBHykwPfKCMmR74SJnpgY+UmR74SJnpgY+UoanMgTLTAx8pMz3wkTLTAx8pMz3wkTLTAx8oY6cHPlJmeuAjZaYHPlJmeuAjZWgqc6DM9MBHykwPfKTM9MBHykwPfKTM9MAHytD0wEfKTA98pMz0wEfKTA98pAxNZQ6UmR74SJnpgY+UmR74SJnpgY+UmR74QBk3PfCRMtMDHykzPfCRMtMDHylDU5kDZaYHPlIG3gMHl5WJiVMmRLvijsp8Thl4D/wyZRp4YFJuRU8q3c/4+DFEevoQvoErW27x0/1KTJuMxcLRabm0P45OycctoMKpY2xcf9sY0naHX3eO/2GH8x5V7P7JBrMis4lY1uZeP8Md2GItbmPQBWO4C8bwF4wRLhgjNhiDdFjHoM25+zZGqW7n0mFiuJcOk0q/bZVZkdj3KydXYl2q206vlXgZRTF1OxrKR5vEOQPr1rpNRp3XeGPSKrqxmmsIDR2HTzObcrIZ1MymoGzqmU1B2TQzm4KyaWc2BWWTZjYFZdPNbArKpp/ZFJTNMLMpKJtzLUhSNudakKBsxrkWJCmbcy1IUjbnWpCkbM61oCdkM2TNTSDm4JbPU8S5FiQpm9evBSWV86O8ZbI5fH78zA90fsLMD3R+Ll+BsVrf+4/zTH4MUTZlFMP9t0MJSIyZa1KbR4/ijWuSxDXlpq9TiFuu+4PJr6ApbWRJ77IkJUgWo9T6VKNRhj4ji5Yki85lzujto6G3KyMZSVyXo9eDTbTnp4C28Y5auZ0wdgpTFoaGFcbZ3H3dBkdFhXFTw09r6MfVML8xol36lAEIU8NPa3i9j1aJ7hoGRkOirDgt/zvX0IZM1cbNux7Lwe9ckySuMa2G0aYdV6PUQFz1QFzNQFztQFxpIK5uIK5+IK5hIK6ifBPD9bW+yXN3BrUidV8q1udcnc4/7Yymb7lqNRBXPRBXMxBXK4mrIZ+5er/jSgNxdQNx9QNxDZK4+rB6CRc0YzyCt6swwced8dBxClMWRpQjizoLE535lDBGlH17TJi0og5B650worxeS2FaGMPzrWOMsReMQaImpPl5JRtd2OVM1gLSOdcmRkipI67vY5QNiKNVoeQ2UQdj6PsYWt/vu5cfz6X8rBtZ2hxb+mVxD6+Z8mf8EiWX9d6UwAO9k1o39dNJ3z0leXUbo2wRltK5juEVe94om28zqrh5lsLr4k3JrOZWnxiGyGn5M3tT76fprafel+ptpt6X6m0b6K197slGB07vkB9B1VujfJTLjESr7SMoS+d6x0+d43ed4/ed4w8sfp1Yj5TxG6XVV2MUaoi6l5D75ehTcQE+5vU895X1KhQbk1csrAl3yOaDZ5TC0+YH2KxNfsczjZFPUmPkk/Qg+TSD5NMOkk8aJJ9ukHz6QfI5iB+iQfwQifFDpw/dG3e9H0omTyyIIbrcTlxh2A10fVtDdZd7HK3cHXwgJkshL7kv68X36VnVlzCMMyORtdhkY1jhe7V57bVINsSUr+vtvRRzY0osUwoM0/vNJru55f62ZrU/1IVc3T3dl8DSreo5B4XGX4vGu9wR/KbzpeL5stzvzYsv1qpPn/FhEK7LP/z1t59+/vmnf/zl51//9sPvP/36y7/egtXb/5XvHC/3INf14O2qtL5dQf7xkPB4SHw8JD0cUr5JdR6iHw8xj4fYx0OKhc3lpX3n9yHu8RD/eEh4PKSY/aXl5Y6XdiHp4ZDy0tR5iH48pJh9lzYNbRdiHw+hx0Pc4yGeCdk+T/QREh4PiY+HFLN/f8LQR/VtSNmIn4fox0PM4yHF7Pu43ir0m+db1hB6PMQ9HuIfDylmP6jVoQUddyHx8ZD0cEj5O4PnIZoJMX4XYh4PsY+HFLMf8tMzUe3yUv7Q3XmIfzwkPB5SzH7M9GMhL+nhkPL3sc5D9OMhxezHvGVG3DjwNcQ+HkKPh7jHQzwT4nZ1rLzF/3lIfDykvG6UH2ZM++vlYEfs0xD9eIh5POTgudg8JaFd4zvapfQsxD0e4h8POZhf+Ty92tOPj4ekh0MOtkk7DdFMSNjVsYOduE5D7OMhxewvSyv3Z8f97oopb1fEBfmaoPBw0PJP+u1YfcBM3x+SsLvNrFxFjK+ICRUxsSImPR5TfuGDidGPx9gDZ0PZP5lvI+zDEWVfk7tBoG83wCtPaINdl2mC/3YzyfJ89jSibGryomNI4duI+HBE2dLkB+S+atDxeC673NjIndN/G1E2NHlJK+5QlWey94j0TQaXfzAn17LOz7wvf8Y/do1pyg9Mas/sNxbvdSaq8PVOT8s/2Hdo5aWZcF9n2YigboH0dqQ9+BR6TqqOZhN6u4FC6uGg5Z/c27EHezXleWSKu6VufbDn0XmMrogxFTG2IoYqYlxFjK+ICRUxsSKm4jzQFeeBrjgPdMV5oCvOA11xHuiK80BXnAcH7y7nje/SpqDkmFgRkx6POXgZ9DxGV8SYihj7YMzyT/69MJZf9NOU06Td5qH2VH4SIBUaa/lQt87f4gbR7f5ZKt9NeQ0UjwMl4ECJOFASDJTyXbDXQLn0XLH3bUPt9s6Nvc2t1bVY7m/U+s37ix9Y9KexpPw2wtanf+hetvYNf98++fc/3wS+eiBl83pv8eBHHgg7PvYduesWue8WeegWeewWeeoVuVPdItfdIjfdIrfdIu+2h7pue6jrtoe6bnuo67aHum57qO+2h/pue6jvtof6bnuo77aHepge+o4Gpi++o4Hpde9oYPrXOxqYnvSGJsD0mXc0ML3jHQ1MP3hHA1Pj39HA1O13NFC1OEDV4gBViwNULQ5QtThC1eIIVYsjVC2OULU4QtXiCFWLI1QtjlC1OELV4ghVixNULU5QtThB1eIEVYsTVC1OULU4QdXiBFWLE1QtTki1WCuFVIwXOEjVeIGDVI4XOEj1eIGDVJAXOEgVeYGDVJK10lgXukZqEVoZLHXMU8vgbQjz/CHs84doUIJ03ntP68Dkzbj85Kdxmy3nU2kre0/5lQFPPjAHh/zNkOXPtD34xtQNw9QPwzQMwzQOwzSNwrTBqxq9MNXDMDXDMLXDMKVhmA7jkewwHskO45HsMB7JDuORaBiPRII8Ut7VZ/nT7ZkK8kgMU0EeiWFKwzAV5JH8namnPVNBHolhKsgjMUwFeSSGqSCPdM7UCfJIDFNBHolhKsgjMUwFeSSGKQ3DdBiP5IbxSG4Yj+SG8UhuGI/kh/FIfhiP5AXV3hgy0xj3TOVcpynkg7fbgK5MQ6fX6Q18p5feDXynM44b+E4nETfw1DN4bKuf9wT1FPcdJGB3EAY8tiFnwGN7bAY8djs+Bx+xOywDHrvDMuChO6xT2YK6zZbFGTx0h+XAQ3dYDjx0h+XAQ3dYDjx0h+XAQ3dYDjx0h2XAJ+gOy4HHLpWUvxvsaP9sRsK+YPPX/7yL+wfAEs4Fe8ODcw1+//7hI5zL6obnai/q8wcojA/p/GRzyz24j4Od+tqL7g8O0eQP90Vr9kzNMEztMExpGKZuGKZ+GKZBDNOUVsxR6Xh+sDV2tRDWbGAY/SFLnLKUZElTloIsWk1ZSrLI8XVNZZFjApvKIscxNpWFpiwlWeR40YdksW59983a5PeyyDGuTWUZ1OXavGdRWZZBXa7Ni59lWQZ1uYwsZlCXy8kyqMvlZBHjcqOy+dvMypvzg8nqteSSDTofrMOHLGJcbltZaMpSkkWMy20rixiX21YWMS63rSxiXG5bWcS43KayWDEut60sYlxuW1mmyy3KMl1uURaaspRkmS63KMt0uUVZpsstyjJdblGW6XJLstB0uUVZpsstyjJdblGWQV0u3WVZ/reVpXCbIPj1l23Udq8hTQ0/reGg/rmphoOa7aYaDurMm2o4qI1vquGgnr+lhm7QCUJTDQedTTTVcNCpR1MN5zzl8xrS1PDTGs55yuc1nPMUXsNINmvowl7DOU/5vIZznvJ5Dec85Q9o6PMrDDH4nYZ+zlM+r+Gcp3xewzlP+QMa5vcLbFJur+Gcp3xeQ5oaflrDOU95TMPCPMXPecrnNZzzlM9rCD1PMVkWZ7zdHnwDDz1BYMAHaGfOgYe2xBx4aC/KgYc2gRx46hk8tO3hwEP7DQ48dKM3+ZedMcxb4S7v2uI2k+SkPnhiN+N2PLH7djOeEbvFt+OJ7Qba8cQ2Du14YnuMdjxpEJ7YzqUdT2yT047nIH4oDuKH4iB+KA3ih5IYP+RV/tCUKvAU44cYnmL8EMOTBuEpxg8xPMX4IYanGD/E8BTjhxieYvzQKU+jxPghhucYfshgf76oIc8x/JBRNAjPMfyQwf5sUUOeY/ghg/0Vood42szTFnjK8UOnPLG/E9SQpxw/dM5Tjh865ynHD53zpEF4yvFD5zzl+KFznnL80DnPQfwQ9gdo2vHE/qJMQ56D+CHsb7405DmIH8L+KktDnnL6p18/yuT9nif2tw0e4Rni+nxCNHrPU0y9ZXiKqbcMTzH1luEppt4yPMXMPxmeYuafDE8x/ZPhKWb+yfAUM/8854m9C35DnoP4Iex96h/hGe16bPRhz1OMH2J40iA8xfghhqcYP8TwFOOHGJ5i/BDDU4wfOueJvel3Q55i/BDDcxA/hL3BdUOeNAjPQfwQ9mbODXkO4oewN0VuyHMQP4S9uXBDnhL90NfvLRcQB58Rhw1iFz5EkWiePi2KRKf1aVFoirIXRaKH+7QoEg0fK0pU6+53OpqwF0WiO/y0KBKt5KdFkeg7PysK+D67LxJlSEfLiTKko+VEGdLRcqLQFGUvypCOlhNlOtqCKNPRFkSZjrYgynS0e1HkbCvdUpTpaAuiTEdbEGVMn+Iy4uhoL8qY3cenLEoonCmddp938L1utnsD32k1v4GHrro2L8E7G9MePPR8nwNPPYOH7ksceOh5Lgceej7KgYfu3Bx46A57Dt5ib9/KgYfusFbrDD4x38OMxqnV8S209kyx23FLpti9uyVTGoYptitoyRTbQrRkiu03WjLFNictmWI7mYZMsXdpbcp0GI+EvVNrU6bDeCTs3VqbMpXjkazJGzjYzb2LzFSOR+KYyvFIHFM5HoljKscjMUyxd25tylSOR+KYyvFIHFM5HoljSsMwHcYjmWE8Eva+vE2ZDuORzDAeCXu35aZMh/FI2DsuP8bUmczU2T1TQR6JYUrDMBXkkRimgjwSw1SQR2KYCvJIDFNBHumcKfYOzE2ZCvJIDNNhPBL2PsxNmdIwTIfxSNi7MTdlOoxHwt6RuSVT7D18H2MaQmYa9k8yY+/6+hBTMuvnyZY/C0zl1F6OqZzaSz4/u0Ip7pnKqb0cUzm1l2MqZ37KMMXeAbYpUzn9lGMqZ37KMZUzP+WY0jBMBXkkhukwHgl7B9SmTIfxSNh7lbZkir0BaVOmw3gk7K1CmzIdxiNhb+rZlGmnHukGvlPbcwPfqZO5gYc2J5SfTFv+3D+Zhr2TJAMee8dHDjy0K+DAQzd6Djx07+bAQ7djDjx0h+XAQ3dYDjx0h+XA99xhsXfLZMBj75bJge+5w2LvlsmB77nDYu+WyYHH7rCOMnjn9uCxOywDHrvDMuCxO2xyK3inC+c8doc9BU/Yu2Vy4LE7LAMeu8My4LE7LAMeu8My4LE7LAMeu8My4LE7LAO+4w5L2Ls4MuCxN/Fz9g7eFsBDVxtHMYMPbg8eutp4lZX3pdMGutpw4KGrDQceutow4LG3OOPAQ7tK71IGH9QePHa1ifkmclBxDx662oT8UpULwe7BQ1cbDjx0tWHAY28WxIGHXj0IKS+0RmP24KFdJQceus5z4Kln8NB+ngMP3WE58NAdNplszJLdz6SwN7HhwEN3WAY89lYzHHjoDsuBh+6wyWU/n+J+JoW9xwsHHrrDcuCR67xXdm1SXtF+DuuQq82yeKAz+LCfwwLtrXHDg1NAbnhwasINz9WXecrvX1il1PnJFpRZJ49BbSaPy4ilo51fr6vgDX119I2rG4irH4hrGIhrHIhrGofr5buFvJKrHoirGYirlcPVW5W5Bs0crdP6YKXZPI5rSH/oQlOXoi6C/FhTXQR5t6a6CPJ5TXUR5Amb6iLIP7bUJQjymk116caXRscwpXzXnTaq3Jl240o/zbQbT/pppjQM025846eZduMEP820G2/3aabduLVPM+3Gf32WaezGUX2a6TAeKQrySEpnpvYrpvtjo6EVczTprotVJRzWrUuCtBHD+BI/k1EYo9P5wc6uIJyl7aG31AgyddJSQzM1qKkRZJulpUaQz5eWGkETE2mpETSTkpYaQVM/YalJguaq0lIjaHItLTVzNQA2NXM1ADY1NFPzutT49dugzsd9auZqAGxq5moAbGrmasDrUuPzsf7rQ2+pmasBsKmZqwGgqXFqrgbApmauBsCmZq4GwKZmrgbApoZmalBTM1cDYFMzVwNgUzNXA2BTM1cDYFMzVwNQU6PnagBsauZqwFWpuek9p/jX6j3n7dfqTVPvS/WeM+xr9Z7T5mv1nnPha/WeE9xr9Z6z1kv1NnMqeq3ec355rd5zfnmt3nN+ea3eNPW+VO85v7xW7zm/vFbvOb+8Vu85v7xUbzv9YGO96a63M3u9Z79sq3cw67EmUP3Bt+TM5vq65GgfVjG0j3GfnNmJgZMz2zZwcuYaMm5yaC44vzA5IWblotq7NZqr08DJmVMX4OTMdW/g5NBMDm5y5goBcHLmCgFwcuYKAXBy5goBcHLmCgFuctxcIQBOzlwhAE7OXCEATs5cIQBODs3k4CZnrhAAJ2euELwwOUmnVblkC8mZKwTAyZkrBMDJuXiFYMlIzMnZfCexmJzoolsl9M4zyYkxZyfGbz7e/c7Vq6u5psxVGzrnSnE9luL9cU5t9Qd23TF20zF22zF26hi76xi77xh76Bh77Bh76hd76Livho77aui4r4aO+2rouK+Gjvtq6LivRuRrdfPVLfIF7MjnTIx50pdcAfvl50zYYHfn2G3Kv2yT3k7O4wf60DX62DX61DP6pLpGr7tGb7pGb7tGT12jd12j77rXpq57beq616aee61XPfdar3rutV713Gu9wq73yWX0yRfQI9ccUmr98iqpr26pruifWnPeh3ju9w9uQ+jnD0E9n6Qa+RIjpSmfpF/t4rOiR7ZUPHpkS8Wjxy5vHHpkS7VUZJvR20JjNMiWikePbKl49MiWikePvHzBo0futTx67F7LocfutYydNdi9lkPf9VTCYPdaBr3F7rUceuxey6HH7rUceuxey6HH7rUceuxey6HvutfarnstIT+u5+L67oaLOh+6Ps7hCflxPQ479CNADHbkx/W8XY/1m52Z79ipY+zIj15x2JEf1+OwIz8Gz2FHfgyew478GDyD3SH3VQ47dH1X61K3V76AHbnORLX21Ugl7Mh1hsOOXGfOHwv2DrnOMNihX2PlsCP7dw47sn/nsCPXdw47dYy931cnPPRrrBx26L7KYO+4r0K/xspgh36NlcPecV+Ffo2Vw95xX4V+nXI7Xy3MPUIv6zMl7L2sz5Sw97I+U8AeoddnwvrDPoYCduj1GQY79bHGoUvYof27ydhtCTu0f2ewQ/t3Bju0f2ewQ/v3c+wJ2r8z2KH9O4Md2r+b0zXsBO3fz9ffr3/VuSH2ju/ZpI7v2STo3sRgh+5Np9iDuvhaFb8HrtXrDxtr9Pbgm95zK/Vr9Z67o1+r99zw/Fq95x7m1+o9P1x2qd56fovsWr3n58Xa6m1Synp/tdNKSTmVP6CgVXD75MzPiwEnZ35e7IXJ0aSyci7uk0MzObjJmXNi4OTMCTRwcuZs+5XJCSYrl/aGwMypywuTQ/ll4+XP/ZVj5jwHODlzngOcnDnPAU4OzeS8LjnOZrfmXNgnZ85zgJMz5znAyZnzHODkzFuQwMmZ9ytxk2PnCgFwcuYKAXBy5goBcHLmCgFwcmgmBzc5c4UAODlzhQA4OXOFADg5c4UAODlzheCVyQkpy5zSLjk0VwiAkzNXCICTM1cIgJNDMzmvS47VOTnW7p8hoDkJBU7OnIQCJ2dOQoGTMyehwMmZk1Dc5Lg5CQVOzpyEAidnTkKBkzNvUwMnh2ZycJMzVwiAkzNXCF6ZHEc5OX5/s83NFQLg5MwVAuDkzBUC3OT4uUIAnJy5QgCcnLlCAJycuUKA+6r71V9fnMl5JDlzhQA4OXOFADg5cxJ6VXJues955aV6hzlVvFbvOfu7Vm+6WG+vMh4f0rneXtmVqFf0VXJu4F3P4D00eB8y+BD24EPP4GPP4FPH4K/+dOyD4PN3nr3eWN0MXvcM3vQM3vYMHrvDMuCxOywDHrvDMuCxOywDHrvDMuCxO+w5+NRzh009d9iE3WGdvhuzAnjsDsuAx+6wDHjsDsuAx+6wDHjsDsuAx+6wDHjsDnsKPirsDsuAx+6wDPiOO2xUHXfYqDrusFF13GGj6rjDRtVxh40auc4779aDnQ9qDx65zrPgkeu882ld4nZBhT145DrPgkeu8yx45DrPgkeu8y5oncFT4YJFrvMseOSZFAseeSbFgTfQHZYDD91hOfDQHZYDj91h4x38fpU4Xv7Fs6bgsTssAx66w3LgoTssBx66w3LgoTssA95iz2EZ8NhzWAY89hyWAd9zh738iyFNwffcYW3PHdb23GFtzx2WoOu8s24F7+x+3Yag6zwHHrrOO08ZfKA9eOg6z4GHrvMceOg6z4GHrvMuxAw+2T146DrPgYeeSTHgHfRMigOP3WEZ8NgdlgGP3WEZ8Ngdlu7gg9uDx+6wDHjsDsuAx+6wDHjsDsuAx+6w5+A9dodlwGN3WAY8dodlwGN3WAZ8zx3W99xhfc8d1vfcYX3PHdb33GEDdJ2396c+bDLnBy+r9evTdMufac8Uuik8xJQyjGWhfL+cBb1/S1um0O2mKVPo3tSUKXQja8oUuus1ZQrdIlsyhd7N5sF+mlRmqvaPXEJvfdOWqSCPxDCV45E4pjQMUzkeiWMqxyNxTOV4JI6pHI/EMZXjkRim0PsRtWU6jEeC3umoLdNhPBL0HkptmQ7jkaB3Z2rLVNA6EunMlPaP7ELv+9SWqaB1pFOmCXpHqbZM5XgksubONO6ZyvFIHFNB99oYpjQMU0H32himgu61MUwFeSSGqSCPZCgzNWnPVJBHOmeKvRtbU6aCPBLDVJBHYpgK8kgMUxqGqSCPxDAV5JEYpoI8EsN0GI+EvUVeS6bYu7qZ/MvOmMgwtfnBq+Dvh6oS4ugy4ujuD2m58CEKdOt9mihRZVFi2IsC3aVfJQp0Q3+VKNC9/1WiQNuEV4kC7SheJQq0+XiRKNi7Er5KFOhln1eJMqajZUSZjrYgCg0pik9ZlFAQZUxHy4gypqNlRBnT0TKijOloGVHGdLTnotCYjpYRZUxHy4gypqNlRBnT0TKi0BRlL8p0tAVRpqMtiDIdbUGU6WgLokxHuxcFe9fdR0TxeT9w778S5cZTjPXwaeUZlNvzpEF4ijEIDE8xPZ/hKaaNMzzFdGaGp5hme84Tezfjh3jmr/f4t5G/5SlmkYfhKccPnfOU44fOedIgPOX4oXOecvzQOU85fuicpxw/dM5Tjh865RkG8UNhED+EvZd4Q56D+CHsfcQb8hzED2HvId6Qpxg/FKxf1xPI7HmK8UMMTzF+6Jwn9t7hDXmK8UPBhMzT7nmK8UMMTzF+iOFJg/AU44cYnmL8EMNTjh865ynHD+n1h4OhPU85fuiUJ/Y+4Q15yvFD5zzl+KFznnL80DlPGoSnHD90zlOOHzrnKccPnfMcxA9h7wreiqdRl+8f7dT6y8aROofuHeVnah19+6HZBbyFBu9tBh/jHjz1DN71DN73DD5Ag0/rjsneK9qDjz2DTx2Dv3xf46bgdc/gsTssAx67wzLgsTus8/c6n/bgsTssAx67wzLgsTssAx67wzLgsTvsOXiD3WEZ8NgdlgGP3WEZ8NgdlgHfc4c1PXdY03OHNT13WNNzhzU9d1gLXeeJ1nVWTz4wB4e4PnSw/Llf5LHQTeEhplHlOVrUes8Uuo49xtTmg+Pum5QLU+ii15QpdIVsyhS6nLZkStCzm6ZMoadCTZnK6adbpm7vHEhQP2WY0jBMoadvTZnK9EglpjI9UompTI9UYirTIxWYOpkeqcRUpkcqMR3GIzlBHun+Km+MZs9UkHNgmApyDgxTQc6BYSrIOTBM5TiH5PKDrMnva6+X4xw4pnKcA8dUjnPgmMpxDhxTGoapHI/EMZXjkRLlR8eT299r83I8EsdUjkfimArySOdMgyCPxDAV5JEYpoI8EsNUkEdimNIwTAV5JIbpMB4pDOORwjAeKQzjkeIwHikO45GiII8U8sEp7p9HioI8EsO0QT9dbk2uBy/z3fODnY4fxzpz30aB/McmEC02c2sJJ2LBSVBwWuxg1hKOxoJjsOBYLDiEBcdhwcGqygmrKiesqpygqrJWUFVZK6iqrBVUVdYKqiprBVWVtYKqylpBVWWtoKqyVlBVWSusqqyxqrLGqsoaqyprrKqssaqyxqo7BuvKMlhXlsG6sgzWlWWwOroBu7KwOrrB6ugWq+5YrLpjseqOxao7FqujW6x5lsWqyharKlusqmyxqjJhVWXCqsqEVZUJqyoTVlUmrKpMWFWZsKoyYVVlwqrKDqsqO6yq7LCqssOqyg6r7jisuuOw6o7Dqjseq+54rLrjseqOx6o7Ld6wbAkHyw16rKrssaqyx6rKHqsqB6yqHLCqcsCqygGrKgesqhywqnLAqsoBqyoHrKocsKpyxKrKEasqR6yqHLGqcsSqyhGrKmO9Y6Ox3rHRWO/YaKx3bDTWOzYa6x0bjfWOjcZ6x0ZjvWOjsd6x0Vjv2Gisd2w01js2GusdG4P1jo3BesfGqM/XnZi/QR/JnB9qXXAfxy5/3ndVsx9gHBIYjwQmIIGJSGASEJgGb440BKORwBgkMBYJDFIF1kgVWCNVYI1UgTVSBdZIFdggVWCDVIENUgU2SBXYXFuBfd4/yHrtN2AKP+vWD37G7X5A+gP3xcU6URn3DYxHAhOQwEQkMAkIjFVAYMoPuJPJlyCZYHOQTqW5Nqn1U8SODG0Pvg1Bzx/CPX8I//whwvOHiM8fIj19iPLD2idD3KJ0VZSpiSrfyKewXooU741Nq4+ggxvKSufCoOx9MUvHjyhTFWWroqgqylVF+aqoUBUVa6LKN1PeNvb4iFoWI+7rlCbRRxjVhbm6MF8XFurCYl1Yqgmz5UVuPkzXhRk2zNhCmK0LK58lxq6L4G/94quwgk1I+YPyMem7UbDafgzirhjEXzFIuGKQeMUg6YJByku2rQfRVwxirhjEXjHIFVe8bnLFW5UH2fTF+yC+9SCpMEi4YpB4xSDpgkFMkyueXB5ks/32fRB9xSDmikHsFYPQFYM0uOKDDev99ECucMUbf8Ug4YpB4gWD2AZyJaXXK3750xcGaVBWks4fhEs6FpjQw2XlFqbrwkxdWPlidnad3i1/OkYJ79SaU78E/vd0AWOpUXnpfUnEdua4P3iZwa8HLxNsf35wVC7XebVfeLDlxTaZVMuFzbk8sXLecleqX0/vEO4njv8YwLNaRiqcbeXrzqtM3Vu1DysvavFhui7M1oU1KVxkcuGiuK8pLlwxSLxikHTBIF41HsQV5g1eXzGIuWIQe8Ug/opBmpxdPuZBAu0HCeqKQVqcXffP2aS3JfX9INRiEJ1zorUtDNIkJ8nlQUzB2UV1xSD6ikFaXPHahjwIFXIS7RWD0BWDuCsGaVG7tL9fJ77QtJK9YHKS6IpB3BWD+CsGCVcMEq8Y5IKpL6kL3Aop+/z2S4quGMRdMYi/YpBwxSDxgkHKN0+WmXmeeFPavGmzRtmqKKqKclVRvioqVEXFqqhUE1VexGejdFVU1blhqs4NU3VumKpzw1SdG6bq3DBV54apOjds1blhq86N8t7pS1lZVwI36xRLGy0tGwa/utBlprFZ3AsfI9inj0BPH8E9fQT/9BHC00eITx8hPXuE8l2QpiPop4/w9Guann5N09Ovafr8NR3zN6yX+XzYj+CfPkJ4+gjx6SN8/pqOeYnCxuB3Izj19BH000cwTx/h89d0TPnNoGUOvB+Bnj6Ce/oI/ukjhKYjFCqfi08fIT17hINbZSnmEdJXI9yCdE2QqQmyNUFUE+RqgnxNUKgJijVBqSIo1JwRoeaMKO+aSvkVg2XaVwiyNUFUE+RqgnxNUKgJijVBqSKofHONC9I1QTVnRKw5I2LNGRFrzohYc0bEmjMi1pwRseaMKN+rWmz0GuR9IagsRFiDnKZCUFEIR/ltuFgKijVB6fEgV37fhgvSNUGmJsjWBFFNkKsJKp4R3qx3mfw3p9He3mjv1tvp2m/uqppQOjiGvF9WTOH84Levwq73FbQx24Nv2EPH2GPH2FO/2MvvGHWCXXeM3XSM3XaMnTrG7jrG3nFf1R33Vd1xX9Ud91WD3FetXVfr3l672WNH7qscduS+ymFH7qscduS+ymFH7qscduS+ymFH7qscduS+ymFH7qsMdttxX7Ud91XbcV+1HfdV23FftR33VdtxX7Ud91XbcV+1HfdV6rivUsd9lTruq9RxX6WO+yp13Fep475KHfdV6rivUsd91XXcV13HfdUh91Uy60OIZvssU8aO3Fc57MB91Ya8ZZYNzp4f7GK+wbP8ub/B44CbcFuiwB27LVHg9t6WKLAXaEsU2Dg0JeqBXcZDRP2yaLhidi7siQJbkrZEgf1LW6LAZqctURqFqBRnxBKV4oz8QiUTjXFPVIozYolKcUYsUSnOiCMa5DijDdG0X/AIYvqo15moL6wwBDF9lCMqpo9yRMX0UY6omD7KERXTXu4wFsy0IxrlVF2GqJRrdDl2/eWgUoFon9foDXuf9vWGvc+S8Y499Wkyb9j7XFG7Ye9zkeyGHbpz+JSxF+YaCdqCM9ihXTWDHbgJk/brDXnScb9YloD7Ktm4XqtEeu8JEnBfZbB7BVzfiUhl7KT32IFrJIsduEZSyBvaU4zE/LL1lL+wbX0we6rAJbU1VeQK3JgqcsF+iKpRbi2Ry9+xcK0i1/fHqGpFmarefHAyUwWeZjWmiry1TWuqyE2+MVXgOV9rqsj2pzFVGoeqGLe0UDUbqtxv359hoxgC99sUff5tp9JeRjFO7LUyynF5L5VRkoN8oYyS3OkTZQzuVEbkzad6klGSq36hjJIc+wtllDQbeJ6MbrPW43xBRpoytpBxzmKayDhnMX9Ixvyyr357pJc7fPGZ+XDDauJU/kjA8vf+OX+PvE/dTNKapDkD6yBJc36HnyTkLRZnktYkzblpB0maM98OkjTn1R0kiWaS8JM01wQAkmTjJklxn6S54vCUJKl7ksL+pj/ylryCVZ9rAq9QfU7yX6A68gbOglWf0/BXqD7n1a9QfU6UX6E6TdX/iOopv81ivtmRonC4dWl90VLbZd66V31OZV+h+pybvkL1OTd9hepzbvoK1efc9Amqe7dRPezfr0T+CIJg1efc9BWqz7npM1RnXlZH/mSGYNVpqv4C1efc9BWqz7npK1Sfc9NXqD7npq9Qfc5NX6A68qdzBKs+56Z/RHVv7++E+sITd8hfCepJxjl7bCIjTRlbyChnfqdifmLYqLR//RX5C0qtqQraTpGjKmf6wFKV49k5qshfUmpNVY47ZanKcZAsVTkuj6VK41Adxy0hfyfrhOoNe5/254a9Tz9zw45sUJJaf5mS2d9Kj8iOg8OObCE47MiegMOO3OQ57Mhdm8OO3IY57Mh9lcMO3FedohWGU4VHpZA/V8dhR/5smlN5m12n9f4VcOTPprHYges7ix24vrPYges7ix24vrPYoes7gx26vjPYgedNDPaggOdNLPZ++2pQ/fbVgPypPWfsen91+dPssSP3Jg47cm9a7m+t2K3hflm5zHT5m9KeKnIra0wVufM1porcKNtSRf6gXGuqyG24MVXkrt2YKnSTb0uVxqEKbX8eoepSyndAvTJqT1WMW+KpinFLPFUxbomnKsYtLfTSnSrtqSJ/9ulBqjrfY1/+9m5PVUxf9fr+DIo3ivZUxfRVnqqYvspTFdNXeapi+uqCme5Und9TFdNXeapy+ipHFfnzLK2pilmF4KnKcUssVTluiaVKcqjev2Tozf5LhgH54w+tqcpxSyxVQW5pM181V38bJSB/iqAvIQU5vZcKifzBgL6EFORSXyukIA/8WiEFOezXCklTyDZCCpodPFfI88+3BeQt8p8t5OmHMgLyNvYvVmbguQejzMCTiXNlkLdsf7EyA9t9RpmB/TujzMCGnFGG5CijNzcDTIGqIA/MURXkUjmqgmwnR1WQj+SoCjKGDFXkDZBbUxVk3TiqgrwYR1WQueKo0jhUx3FLyLvgPko13XFYvX9SGnkX3NZUBbkljqogt8RQRd4FtzVVORbC3j8L6sns38JH3hq2NVU5FZjMHQfZsKOKvH/kg1T9hqp3+vzwRZf1biyZYO8cUwkIqQyEDG0PvokoZ870QhHllNIXiiinSL9QRJoifl5EOXPTF4ooZ9b7QhHluLkXiihnpv5CEeWsAbxOxDRnLA1EnDOWBiLOGUsDEeeMpYGINEX8vIhzxtJAxDljaSDinLE0EHHOWBqIOGcsnxYxQu81342Ic8byrYg3XeYkpKzLnFeUdaERdLlRHcLQ36gOYbtvVAVZkvtPL3/bHVU52677oPMG3QvTuKfaZ7m+Ye+zpN6w91kjb9iRi54NKttZ6/bYkaf4lPdjcBRi9cE3osjT8KZEkftSS6IGeTrblCjylLMpUWSf8QhRvbjD7DOWv82eKrLPaEyVxqGK7GIaU0U2PY2pSvFIf4CqFJf0B6hK8Uk8Veht6BtTleKV/gDVcdwS9Db0janSOFTHcUvQ29A3pjqOW4LeKL4xVTluSQebf9qo3XcUIvRm642pynFLLFU5bomlKsctsVRpHKpy3BJLVY5bYqnKcUssVTluiaU6jluC3ny6MVU5Fdj4cKfq93fioLcPfYyq3WTVxn1WoffUbJtV6D01H8yq2mRV75/Og95TszFVOXafpUrjUJXTbFiqcuw+S1WO3WepCrIQW6pG7anKsftW3X/aWnt+eNMXq6B36+xGREkO72UiSvKOLxNRkit9mYg0Rfy8iJKcdBsRb7pIst0tdZHk0VvqIsnQH+pyozqEoX+nCr3xdmOqgsxxSJtFbdpTFWRhOaqCjCZHlcahKsi0cVQF+TCOqiBrxVGVdAf1nCr0Jq4PUnX3O6jW7e+gQm9w2fa+OPQ2lI2pSqrADFVJFfiUaoLe7q5pWUrQm9J9ptkUqEqd2RSoSp3ZFKhK6qsMVUF9Nd1/mpTZUxXUVzmqgvoqR1XQzIajKmgdmKGqBbkljqogt8RRleSWzu0+9M6NjanSOFSHWYVI0NtINqY6ziqEmH0n/wBVQW6JoSpm78k/QFXS2hJDdRy3JGj/SZYqjUN1HLckaP9Jluo4bgl6p8IHP6qQfMYRlN5TFfQhIY6qoG8DcVQFfe6Ho4rcVxtTFfQFH46qoC/4cFQFfd6SoyroI5QcVTnfZQpm+7GisKMKvVNhY6py3BJLVdDXtjiqctxS8HSnGtWeKo1DVY5bYqnKcUssVTluiaUqxy2xVAW5JYYq9E6Fj1GN6k41arunKsctsVTluCWWqhy3xFIlOWUpbanSnqogt8RRFeSWOKqC3BJHVZBb4qgKcksMVehtcRtTFeSWbLxTpf2CC/S2uI2pCnJLHFUah6octxTNlur+RTHobXEbU5XjlliqctwSS1WOW+KoQm9e25iqILfEURXklu4/7WPc3zWH3q61MVUah6ogt8RRFeSW/Jbq/qVO6A1KG1MV5JY4qoLcEkMVes/RxlQFuSWOqiC3xFEV9NwS3R/RionZIlrbEPPTlzYkt1eGRlUmqjyZsNHsV5mhdzR9rTKCbgs2VkbQXcTGygi66dhYGUH3KNsqkwTd0mysjKCn6xsrI+hh/AeVMeGujPV7ZYb1wF+dMyVlaCpzoMz0wEfKTA98pMy4HpjSXRm/n2uncT0wp8y4HvhUGaugN0V/rTLjemBOmXE9MKfMuB6YU4amMgfKjOuB/cbpha+gfP+uzLgeeHvOlJSZHvhImemBj5SZHvhAGeit7p+rTFJZmaT8XplxPTCnzLgemFNmXA/MKUNTmQNlxvXAnDLjemBOmXE9MKfMsB44qbvTSzrulRnXA2/PmYIy0B8weK0y0wMfKTM98JEygjyw3m7ZWKBK41AV5FI5qoJsJ0dVkI/kqAoyhhxVQU6PoSroGxksVUFejKMqyFxxVMdxS4K+kcFSHcctCfpGBkt1HLck6BsZHFVBX1Mgc8dBu08MLFTl9NX7p9aWv73aU5XTV1mqcvoqS1VOX2WpyumrLFU5fZWlKqevslTlrEJwVAV9TYGlKsgtcVTHcUuCvqbAUqVxqI7jlgR9TYGlOo5bQt5334b8rq4Njrlr7n1aH87xQRWIAnfVtkSBe2pbosAd9TGikdZL2ke3Xz5D3m+/LVHgbtqWKHAvbUsUuJO2JQq86tCWKPCaQ1OiyHvstyUqp49ql4kauycqpeoGlTGHxe/tiUqpuixRKVV3OdZkoon2RKVUXY4o8l7dbYlKmY+yRKXMR1miUvooS5RGISplPsoSleOMGKJynBFDdBRnhLz/dFOiyNtJtyU6ijNC3uy5LdFRnBHytrr1a0aFiTfyLrltiYpc1y0RFbmuuyeqkbekfZBo/tC8TyrtiYq5m5byh1N9Ir8nKqbqckTFVF2OqJiqyxEVU3UZosibILYlKuY5I44oiSEa7300uj1ROauAm7tpRHuiIu+PloiKvD9aIipnFZAhKmcV8Jwo8kZqbYnKWQVkiMpZBWSIylkFpJCJFlYYkPcsa/n4jUbesawt0UGeHNPIu5W1JSrSGZWIinRGBaLI+5S1JSrSGZWIinRGJaLFPkrZZdA3RG9BxZ7k9BrkrC0EhZqgWBOUKoJI1QTpmiBTE1R0sBRykKZCENUEuZogXxMUaoJiTVCqCCrv+8AF6ZogUxNUc0a4mjPC1ZwRruaMcDVnhKs5I8qvqsaw7iYW46bumfQRZGuCqCbI1QQVJU9+fZV1u8J8Dwo1QbEmKFUElV+F4oJ0TZCpCbI1QVQT5GqCas6IUHNGhJozovxqydLr1qcolr6ivwor3EJx2Q15ZzdHlw62Ju+hZ822zcbCwSbmg03c3IUqHhyVWzfOjyrYLYx3quWXS2RSLV4TOur8ZYGo0/5kKD/az4e5ujBfFxbYMFOozOVHovmwVBVWflyXD9N1YaZKyVR3lqS6syTVnSWp7ixJoS4s1oWlmjCjdFVY+XZXyA++BbfZLsPfYsr3GVL+eGXaTkzXGFsRQxUxriKmfFook4u5Cm4fFaqiYlVUqokqr2OxUboqylRF2aooqopyVVFV54atOjds1blhq84Nqjo3qOrcKC92nNeY8lpHyttDJ1uICRUxsSImPR5TXn1gYvTjtcxV1GZXUZtdRW12FbW5vO7AxISKmIMJz3qOppD2MenxGK8qYnRFjKmIsRUxVBHDnQelmIrzwFecBwdLIecx6fGYg4WQ85iKehAq6kGoqAehoh6EinpwsARyHlNxHoSK8yBUnAex4jyIFTmNFTmNFTmNFTktT5SCyne69D1mWcK4xaSHY2z5fZ1g7RpDaR+jyzH55T1v9zGmIqbskeKqW9jcRswxVBFTXonOBi5SQTdfjlnXmKLz+5hQXvFeNYglbPE8JhVyWv68fbRuPRGi9ff7BcvNxI8wWxdGdWGuLqysu80JjqR0ISzUhcW6sFQVVn76lA/TdWGmLszWhVFdmKsLqztLTN1ZYurOElN3lpRn30uNMvdy5Qph5dHI5TC3+RZuDivPbtnRyg8AxPu9gEibonoPK59c5PNqPIWCJOWJMR/m6sJ8XVg4SEC8h5UkiXVhqSqsPCXnw3RdmKkLs3VhxIbFQt7cwVniwj3MF8IOzpL88enleguFsMCNVrxMXay6ul1dUfCqLkzXhZm6MFsXVl6mJKPyTYPl79374LY8SebjyhPY5a7p/VNotCRqH2cq42xlHFXGuco4XxkXKuNiZVyqizu8W679Js7v43RlnKmMs5VxVBnnHo/77/JP//vDbz/98Neff/zXEvX2H//9y99+/+nXXz7+8ff/++f6X/76208///zTP/7yz99+/duPf//3bz/+5edf//b2375Tb//3/iq11uaL1uH75XCd/+WSUKve/pXZ/yt7D6UvOr39K3r7V2/imfDFhoXb+38m84Xef9et/zmGLyn/Z738or79pP+A9Ofl/p37stxa89+/o/nzYuWWYUnb79/H/fMyBfySjFl/YrmtaJfDbXz7Fx/Hmy/L/9Gi06LV/wM=",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_participant_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjuTG0YTfZa91Uaesg1/FMARJlo0FFpIhyT/ww9C7m8MZdve6WZ0z7NpmBDtvhJXEGmbEkPFlzU5l/+fT33/+8d///P7zL//49fdPf/nrfz59+fWnH/74/Osv07/958/vPv342+cvXz7/8/vL//zJvfwjxPn63//1wy8v//r7Hz/89senv/jc3Heffv7l79Mfi3PTV/jH5y8/f/pLKunP766urq6+XVxDPl1b1y6VIG+Xipy/rHfy59+++xTSgFqkLbVUf7uWFJdLU65Xtcj9tTSX3y5uwd2uJbvFl3xh4VJLHlBLSkstUpRa6vJ1L7/sUktZrSUGX5ZiYkheqaZ4v9winK0veeXSkPNSTpgqO188V1OhqmlI1UQHVY2HqiZAVROhqklQ1QhUNRmqGqgsjlBZHKGyOEFlcYLK4gSVxQkqixNUFieoLE5QWZygsjhBZXGCymKBymKBymKBymKBymKBymKBymKBymKBymKBymKByuIMlcUZKoszVBZnqCzOUFmcobI4Q2VxhsriDJXFGSqLC1QWl2+bxS93CN/8DvGb32FMDqblL8JKzvd8zwSqmgxVTYGqpkJV05CqqQ6qGg9VTYCqJkJVA5XFFSqLK1QWV6gsrlBZXKGyuEFlcYPK4gaVxQ0qixtUFjeoLG5QWdygsrhBZXGDymLvoMLYO6g09g4qjr2DymPvoALZO6hE9g4qkr2DymTvoELZu2+byi+38O7b38J/+1u8JxElfHWLeV3cuC5tXCcb1+WN68rGdXXjurZtXXAb1/mN6zY+L2Hj8xI2Pi9h4/MSNj4vYePzEjY+L2Hj8xI3Pi9x4/MSNz4vcePzEjc+L3Hj8xI3Pi9x4/MSNz4vcePzkjY+L2nj89L9ReMaTuuiDwryps56Oao1dSZyutpnv3Z1XY6A+Xb+y7tQX1uJ7i8b71dRgqtI4CrKcBUVuIoqXEUNraLuLyLvV5GHq2iPzJalouDCVxVdX1tDim8X19DO26Xo4srV8fSV08WB4LC6Bw1u+bWPEHy7fbHEpQiJ6fLS2cJoFt5rYTIL77VQzMJ7Lcxm4b0WFrPwXgurWXivhc0svNPC7MzCey30ZuG9Ftru5G4LbXfyHgvz8qNNuRhVtViYzMJ7LbTdyd0W2u7kHRbm07X560tnC213creFtju520LbndxrYbHdyd0W2u7kbgttd3K3hbY7udvCZBbea6HtTu620HYnd1tou5O7LbTdyd0W2u7kXgur7U6uLJx9sS3Hui+2j1j3xTYH674k82XVF2vj132x3nzdF2u4132xLnrdF2uNV31p1u+u+2L97rov1u+u+2L97rovyXxZ9cX63XVfrN9d98X63TVfgnve3E1nXy4OdC++PO17VMKpipK2Xzyb+LQv3UdM9LmcPms113pl4tPuSEea+LTb14Em+qfd64408Wk3xh8ysdSliumvFK/o7J92Fz3SxKdt/UaamMzE+0182s38SBNtxzLARNuxDDDRdiwDTLQdy/0mBtuxDDDRdiwDTLQdywATbccywMRkJt5vou1YBphoO5YBJtqOZYCJtmN5j4nNL5/I4Fu8NtF2LPebGG3HMsDEMTsWf/qkFj/9YEgzsZx+z8IX79VvUD1d7S5GE09LXxUEegWRXkGiV7ChS53X5Y3rysZ1deO6tm1dchvX+Y3r3vM2x6x8t1MqdUlT8fmr7/b11a2cZp+3GuPp6hJWH6Qm5fwkSb28fFYQ6RUkegWCr6DFs4KWrhRkegWFXkGlV9DYFbzrwzmwFXh6BQRMVhQQMFlRQMBkRQE9k4WeyULPZKFnssAzefqR2EnB9OcrBRmeyaoCeCarCuCZrCqAZ7KqAJ7JqgJ4JqsK4JmsKoBnsqoAnsmqAnomF3omF3omF3omFwImlwsF5VoBAZMVBQRMVhQQMFlRQMBkRQEBkxUFBEy+raASMFlRQMBkRQEBkxUF9Ex+1yBSbAX0TK70TK74TJ5+3ntSMP3LlQJ8JmsK8JmsKGj4TNYU4DNZU4DPZE0BPpM1BfhM1hTgM1lTgM9kTQE9kxs9kxs7k6NjZ3J0BEwWd1Yg/koBAZMVBQRMVhQQMFlRQMBkRQEBkxUFBExWFBAwWVFAwOTbCjwBkxUF9Ez29Ez29Ex+19BCaAWB4E0u6ayglisF+E9RqWcF5eIU+aIA/ynSFOB3dpoC/M5OU4Df2WkK8Ds7TQF+Z6coiPg80BTgd3aaAvzOTlNAz+R3zazAVkDP5EjP5IjP5BpOpUx/jlcK8JmsKcBnsqIg4TNZU4DPZE0BPpM1BfhM1hTgM1lTgM9kTQE+kzUF9EzGnzyjKqBnMv7kGVUBAZPPE/+mP1/97Bp/8oyqgIDJigICJisKCJisKCBgsqKAgMmKAgImKwoImHxbAcHkGU0BPZMJJs9oCuiZTDB5RlNAwOTzHK/pz+lKAQGTFQUETFYUEDBZUUDA5NsKCCbPaAoImKwoIGCyooCAyYoCAiYrCuiZTDB5RlNAz2SCyTOKAoKpJ83nk4IWrn5jFn/iRghy+jyWEPL19wA+i1QF8FmkKoDPIlUBfBapCuD3B5oC/IkbqgJ4HqgK4PcHqgL4/YGqAIvJc0lYkJ1LwqLmXBIWBueSsLg2l4QFqqmkBDZXYi4JCyVzSVhsmEvCCvu5JLj0TmDDFuaS4NI7gY1DmEuCS+8ENrDgpSSwCQRzSXjpDTYjYC4JL73BTvHPJeGlt8dLb4+X3h4vvT1eeoNNnZhLwkvvgJfeYMM25pLw0htsHMZcEl56gw2smEvCS2+wkRIvJYHNiJhLwktvsCkOc0l46Q02Z2EuCS+9wSYhzCXhpTfYrIK5JLz0BpsmMJeEl95g5/3nkvDSG+xE/lwSXnqDnZmfS8JL711OtddcTyXVcFVSgytpl3PnSkker6SAV1LEKynhlSR4JWW8kgpeSXjpLXjpnfHSO+Old8ZL74yX3hkvvTNeeme89M546Z3x0jvjpXfBS++Cl94FL70LXnoXvPQueOld8NK74KV3wUvvgpfeFS+9K156V7z0rnjpXfHSu+Kld8VL74qX3hUvvSteeje89G546d3w0rvhpXfDS++Gl94NL70bXno3vPRucOktDi69xcGltzi49BYHl97i4NJbHFx6i4NLb3Fw6S0OLr3F4aW3x0tvj5feHi+9PV56e7z09njp7fHS2+Olt8dLb4+X3gEvvQNeege89A546R3w0jvgpXfAS++Al94BL70DXnpHvPSOeOkd8dI74qV3xEvviJfeES+9I156R7z0jnjpnfDSO+Gld8JL74SX3gkvvRNeeie89E546Y131lLwzloK3llLwTtrKXhnLQXvrKXgnbUUvLOWgnfWUvDOWgreWUvBO2speGctBe+speCdtRS8s5aCd9ZS8M5aCt5ZS8E7ayl4Zy0F76yl4J21FLyzloJ31lLwzloK3llLwTtrKXhnLQXvrKXgnbUUvLOWgnfWUvDOWgreWUvBO2speGctBe+speCdtRS8s5aCd9ZS8M5aCt5ZS8E7ayl4Zy0F76yl4J21FLyzloJ31lLwzloK3llLwTtrmfHOWma8s5YZ76xlxjtrmR1ceme8s5YZ76xlxjtrmfHOWma8s5YZ76xlxjtrmfHOWuZdzlq2KEtJ7eJrLyUlvJIEr6SMV1LBK6nildTgStrlrKVSkscrKeCVhJfeAS+9A156B7z03uOspXcuLh+u4504d1nU9eWhnBRMf7xQ8Cqgsgto5AL2OPU5VoBnFxDYBUR4AamUuHzxenGx9+5VQuKXIPwSMr8EfCKrEvCZnKpvb1eLb/KVhOurJS2FS6rna0N+lYtP8JFyEz7vh8rF7w4+JjeKX97e2Fy4ensTfjcxWDBB9zFWcHo2wQSdzVjBBH3QWMEEXdNYwUfrsVTBR+uyNMFytD5LFfxsnZY8W6clz9Zp7TFJYV/Bz9ZpybN1WvJsnZZwd1qzBO7e6UVC5u6GZgn4/Y0EXxYJIeRrCfgdiyoBvwdRJSQuCTFeS8DvE1QJ+ORXJeCzXEI9S2gr7wI+nVUJ+HTWJBSCUI1++Q0Eiem6zSv4r3N2yb1dnV1O1xLQXue5KLQXdC4K7ZV7Karu0uJOYDgXlbRf45n68Lerw1Tv+eJXAZ5dQGAXENkFJHYBwi4gswso7AIqu4BGLqCxk7ixk7ixk7ixk3iPYShjBbCTuLGTuLGTuLGTuJGTuDhyEhdHTuLiyElcHDmJiyMncXHkJC6OnMTFkZO4OHISF8dOYs9OYs9OYs9OYs9O4j2GFI0VwE5iz05iz05iz05iz07iwE7iwE7iwE7iwE7iPQZOjRXATuLATuLATuLATuLATuLITuLITuLITuLITuJ9Bl+NFMBO4shO4shO4shO4shO4sRO4sRO4sRO4sRO4n3GOo0UwE7ixE7ixE7ixE7ixE5iYSexsJNY2Eks7CTeZ+zPSAHsJBZ2Egs7iYWdxMJO4sxO4sxO4sxO4sxO4n1G5YwUwE7izE7izE7izE7izE7iwk7iwk7iwk7iwk7iwk7iwk7iwk7iwk7iwk7iwk5i9hlbhX3GVmGfsVXYZ2wV9hlbhX3GVmGfsVXYZ2wV9hlbhX3GVmGfsVXYZ2wV9hlbhX3GVmGfsVXYZ2wV9hlbhX3GVmGfsVXYZ2xV9hlblX3GVmWfsVXZZ2xVR07iyj5jq7LP2KrsM7Yq+4ytyj5jq7LP2KrsM7Yq+4ytyj5jq7LP2KrsM7Yq+4ytyj5jq7LP2KrsM7Yq+4ytyj5jq7LP2KrsM7Yq+4ytCjdjay4Kja5zUWjEnItCo+BcFBrZXoqCm0M1F4VGoLkoNKrMRaGRYi5qn0iQei6qyP8Wtc+YlxzOReVYr4ryiEVteNDndXHjurRxXYfRKfrTupSqYt7tPqA3lmPoPcoD7lEfcI/27e/RGxEx9B7+AfcID7hHfMA90gPu8YD3XB7wnssD3nN5wHsuD3jP8wPe8/yA9zw/4D3PD3jP8wPe8/yA9zw/4D3PD3jP8wPe8/yA97xseM/ndX7jurBxXdy4Lm1cJxvX5Y3rysZ1ddu63lmkVNx5XfXX63p+tnxaJ8Fdr5ON6zp+SkundTmU63UdXyScfbncOXc2dl6W8pK/3NK+3qN9+3v0ftV+6D38A+4RHnCP+IB7pAfcQx5wj/yAe5QH3OMB73n79u95c+4B9/APuEd4wD3ix1ny4XukB9xDRtwjV7/8mC5Pf8Xxv/fID7hHecA96ph75Hi6R736frRvf4/erwkOvYd/wD3CA+4RH3CP9IB7yAPukR9wj/KAezzgPfcPeM/DA97z8ID3PDzgPQ9j3vOp91juMb1y/3uP9IB7bNvjtpA3risb19Vt63b6rYDalq/usotnz8NrUQGxqIhYVEIsShCLyohFFcSiKmJRDbConT7lSCkKMdETYqInxERPiImeEBM9ISZ6Qkz0hJjoCTHRBTHRBTHRBTHRBTHRBTHRBTHRBTHRBTHRBTHRBTHRM2KiZ8REz4iJnhETPSMmekZM9IyY6Bkx0TNiomfERC+IiV4QE70gJnpBTPSCmOgFMdELYqIXxEQviIleEBO9IiZ6RUz0ipjoFTHRK2KiV8REr4iJXhETvSImekVM9IaY6A0x0RtiojfERG+Iid4QE70hJnpDTPSGmOgNMNG9c4CRPlUFmOlTVYChPlUFmOpTVYCxPlUFmOtTVYDBPlUFmOxTVYDRPlUFme0eMts9ZLZ7yGz3kNnuIbPdQ2a7h8x2D5ntHjLbPWS2B8hsD5DZHiCzfZ+5yTcGWn7w8lcR+QgiCryIm0fuJwWVXkFjVxDRpuauKbhxuHdSgDZi9+MKAr2CSK8g0SvAJ7OmAB/LmgIGJt9WwMDk2woYmHxTAdwk+48roGdyomdyomfyPsePhyqgZ3KiZ3KiZ3KiZ3KiZ7LQM1nomSz0TBZ6Ju9zgHyoAnomCz2ThZ7JQs9koWdypmdypmdypmdypmfyPiMAhiqgZ3KmZ3KmZ3KmZ3KmZ3KhZ3KhZ3KhZ3KhZ/I+QxyGKqBncqFncqFncqFncqFncqVncqVncqVncqVn8j5jOIYqoGdypWdypWdypWdypWdyo2dyo2dyo2dyo2fyPoNUhiqgZ3KjZ3KjZ3KjZ3JjZ7J37Ez2jp3J3rEz2Tt2JnvHzmTv2JnsHTuTvWNnsnfsTPaOnsmensmensmensmensn7TC8aqoCeyZ6eyZ6eyZ6eyZ6eyYGeyYGeyYGeyYGeyYGeyQTTvDQF9EymmON1WwE9kynmeN1UQD/Hy9PP8fL0c7w8/RwvTz/Hy9PP8fL0c7w8/RwvTz/HyzPM8WruNFuz+SsFDHO8FAUETFYUEDBZUUDAZEUBAZMVBWhEe60KjVKvVaGR57UqNJrMVe0z0cjFfKpKnLv9ZkiU5WqJ+Tw/evqb2TcNgq8hn66WnMuKhnwADeUAGuoBNDR+DftM1hmswR9AAwEfVA2RQIOPtzWkA2hg4LSmgYHTmgYGTre0aCg+rmhg4LSmgYHTiobCwGlNAwOnNQ0MnNY0MHBa00DA6SL1pKGsaSDgtKqBgNOqBgJOqxoIOF3EnzWkFQ0EnNY0VAJOqxoIOK1qIOC0qoGA06oGCk4rGig4fdZQ/YoGCk4rGig4rWgg4HSNp16jykqvUQk4rWloBJxWNRBwWtVAwOnq01nD13xYKcUtAZD8xc8EQ37TS8D0oXoJ+D9UL0GvMFQvQV+xVW+oK3oJepChehn6lZF6GXqbcXqDY+iDPqJXzg14zit6GXqmkXqP1l9peo/WX2l605PpPVp/pek9Wn+l6T1afyUiJ72yovdo/ZWm92j9laLXH6+/uq33yfor/2T9lX+y/mqfaVw76n2y/so/WX/lj9df3db7ZP2Vf7L+KjxZfxWO11/d1vtk/VV4sv5qn8lqO+p9sv4qPFl/FZ6svwrH669u6yXor1osi4Qm4Su9s4aI3zNll9zb1dnltKIBvw/SNeD3NroG/H5F15AOoAG/r9A14PcKugZ8/usa8Jmua8DntKohHYDT6QCcTgfgdDoAp/eZLjdYwwE4nQ7A6XQATqcDcDodgNNyAE7LAThNMGNR13AATssBOE0w61LXcABOE8y61DUcgNMEsy5VDQSzLnUNB+A0waxLXcMBOE0w61LXcABOE8y61DUcgNMEsy51DQfgNMGsS13DAThNMOtS13AAThPMutQ1HIDTBLMudQ0H4DTBrEtdwwE4TTDrUtdwAE4TzLrUNRyA0wSzLnUNB+A0waxLXcMBOE0w61LXcABOE8y61DUcgNMEsy51DQfgNMFMSl3DAThNMDtS13AAThPMeNQ18HM6Esxi1DXwczoSzEzUNfBzOjp+TkeCeYW6Bn5OR4K5groGfk5Hgvl/qgaCmX66hgNwmmD2nq7hAJwmmJGnazgApwlm2ekaDsBpgplzuoYDcJpgNpyu4QCcJpjhpms4AKcJZq3pGg7AaYKZaLqGA3CaYHaZruEAnD7APLJ4gHlk8QDzyOIB5pHFA8wjiweYRxYPMI8sHmAeWTzAPLJ4gHlk8QDzyOIB5pHFA8wjiweYRxYPMI8sHmAeWTzAPLJ4gHlk8QDzyOIB5pHFA8wjiweYRxYPMI8sHmAeWTzAPLJ4gFle8QCzvOIBZnnFA8zyinvMkGqlLhJajfG2Au9bakspvkm9ffn0F1vL157+biWcL36TG59LbjqY3EnkInfacl3IXanan6xJvsiVNWLW9KzJZk3PmmLW9KypZk3PmmbWdKzZY0YZizXerOlZc7SudaA1R+twB1qTzJqeNdYNd62xbrhrjXXDXWusG+5aY91wz5pq3XDXGuuGu9ZYN9y1xrrhrjXJrOlZY91w1xrrhrvWWDfctca64a411g33rGnWDXetsW64a411w11rrBvuWpPMmp411g13rbFuuGuNdcNda6wb7lpj3XDHmuSsG+5aY91w1xrrhrvWWDfctSaZNT1rrBvuWmPdcNca64a71lg33LXGuuGeNd664a411g13rbFuuGuNdcNda5JZ07PGuuGuNdYNd62xbrhrjXXDXWusG+5ZE6wb7lpj3XDXGuuGu9YQ9DUlna2p+fLyVwnw/UdwLi6lBBf8tQT4PkGXAM9zXQI8d1UJEZ6PugR4jukS4HmjS4D/KYkuIfFLgKezLoGfzpGfzpGfzpGAzlVOEryLVxISAZ01CQR01iQQ0FmTQEBnTQIBnTUJBHTWJBDQWZNAQGdNAgGdNQn8dBZ+Ogs/nQWfzj7Xs4SVH0gKPp1VCfh0ViXg01mVgE9nVQI+nVUJ+HRWJeDTWZOQ8emsSsCnsyqBn874k/F1Cfx0xp9KH4L4k4Rw8ZESJwn4dFYl4NNZlYBPZ1UCPp01CfjTzXUJ+HRWJeDTWZWAT2dVAj6dVQn8dMafZq1L4Ecb/ghkVQL+qGJdAj/aCIa4Bn+SMGkIty+//XlmiWAw61C5+EeIPiZ33C9oEwxb3c0a/CNEu1mDf4RoL2sIhq3uZg3+EaLdrME/QrSbNfgH6nezJpk1PWuO1uEOtMa64a411g13rbFuuGuNdcMda4Rg2Opu1lg33LXGuuGuNdYNd61JZk3PGuuGu9ZYN9y1xrrhrjXWDXetsW64Zw3BsNXdrLFuuGuNdcNda6wb7lqTzJqeNdYNd62xbrhrjXXDXWusG+5aY91wzxqCYau7WWPdcNca64a71lg33LUmmTU9a6wb7lpj3XDXGuuGu9ZYN9y1xrrhnjX4o5X3s8a64a411g13rbFuuGtNMmt61lg33LXGuuGuNdYNd62xbrhrjXXDPWvwR5nvZ411w11rrBvuWmPdcNeaZNb0rLFuuGuNdcNda6wb7lpj3XDXGuuGe9bgf3TAftZYN9y1xrrhrjXWDXetSWZNzxrrhrvWEPQ1sZ6tka+seZVA0H8oEvA/xMBHdyplqkuuJRDwPJ8/Sz20di2BgLuaBAI+ahIIOKZJIOCNJoHgpySaBIKfZmgSCOisSSCgsyIB/0MMdAn8dMb/EANdAj+d8T/EwMcs5061XXeq+B9ioEvAp7MqAZ/OqgR8OqsS8OmsScD/HAZdAj6dVQn4dFYl4NNZlcBPZ4JPuFAl8NOZ4NMlUj7/QDK165+pEnwKhCoBn86aBIJPVVAl4NNZlYBPZ1UCPp1VCfh0ViXg01mVgE9nVQI/nQmm0qsS6OmcCaa8T3+9f5IwbQ6uJeDTWZWAT2dVAj6dVQn4dFYl4NNZlYBPZ1UCPp1VCfh0ViXg01mTQDB1WpXAT2eCKc6qBHw65xhPEvL15zxngqnIqgR8OqsS8OmsSsCnsyoBn86qBHw6axIIpuCqEvDprErAp7MqgZ/OBFNaVQn4dC6+nCSUry9/lYBPZ1UCPp1VCfh0ViXg01mTQDB6UpWAjzZVAj7aVAn4aFMlvOd19kGR4F08/c6Qu/ghw9TMr119OnUa3Pkrh7p2RLWGtLC5huZPV0cXV66O5/OswZ2/cl65NES/fOEQg7+8eDbmXcPKntIYb8asGxPMmHVjohmzbkwyY9aNETNm3Zj8rMaE1k7GXAhcvdi7kE/6LuZanFws5uIAF6u5+A4XfXKnDlzqtYtP24CPdFGetlsf6uLTtvZDXXzafcDHXCzn3z9t13SRp20BP+Ricqef7yS38ixavzjCResXR7ho/eIIF61ffI+LEk+MFilXLmbrF0e4aP3iCBetXxzh4tP+kHmoi8lcHOCi7V1GuGh7lxEu2t5lhIu2dxnhou1dBrhYbO8ywkXbu4xw0fYuI1y0vcsIF5O5+B4Xy+lAqFwM8T25aHuXES7a3mWEi7Z3GeGidd3vcTH6drbj+u9dqnXdI1y0rnuEi9Z1j3DRuu4RLiZzcYCL1nWPcNG67hEuWtc9wkX7G4MRLtreZYCLzfYuI1y0vcu7XJR0siNf/5S22d5lhIu2dxnhYjIXB7hoe5cRLtreZYSLtncZ4aLtXQac1Gi2d7nfxeJs7zLCRdu7jHDRuu4rF1+NSWbMujHWG3eMsXZ33Zj1yY4lLTco4q7XrD5lLS03annlPnnDmrJhTd2wZr1zuj2PpnQm9mmr/KZVYdOquGlV2rRKNq3Km1aVTavqplWbng3Z9GzIpmdDNj0bsunZkE3PxvpUiNsZsz4DoXm/vMfxes36KWtljd+wJmxYEzesSR/Psrwhm/OGbM4bsjlvyOb1Mzy316yfWFHWrD8HeXlGW2nXa8KGNXHDmrRhjWxYkzesKRvWaM/B2poNz0Hd8Bys/8agsiZsWBM3rNmQB3VDHtQNeVA35EHdkAd1w3PQNjwHbcNz0DY8B23Dc9A2fE/bhu9p2/A9bR//nlbX0VOXzVYTd/6UDO/dn3/7c/rX//vht88//Pjl59+nRS//99+//PTH519/efvXP/7/X8v/+fG3z1++fP7n9//67deffv77v3/7+fsvv/708v8+ubd//NVXn7/zNZapoJfvyLRjbN/54ttLgfMFJbjpPwR5+Q9+XuH8tMLFqZapnv8C",
      "brillig_names": [
        "get_participant_escrows"
      ]
    },
    {
      "name": "set_contract_registered",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_contract_registered"
      ]
    },
    {
      "name": "register_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10966310306735189739": {
            "error_kind": "string",
            "string": "Escrow contract USDC does not match registry USDC"
          },
          "12806906349574299095": {
            "error_kind": "string",
            "string": "Escrow contract has already been registered"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14827131733433028185": {
            "error_kind": "string",
            "string": "Escrow contract registry does not match this contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17408225848945384450": {
            "error_kind": "string",
            "string": "Proving nullifier inclusion failed"
          },
          "17540660350934727925": {
            "error_kind": "string",
            "string": "Nullifier does not match value in witness"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089479698890196495": {
            "error_kind": "string",
            "string": "Escrow contract admin does not match sender of message"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6337220856976823863": {
            "error_kind": "string",
            "string": "Escrow contract class ID does not match expected class ID"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_contract_instance_internal",
        "get_nullifier_membership_witness",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "unpack_returns",
        "get_public_keys_and_partial_address",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "pack_arguments_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_escrow_class_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAGEHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAAGtHgIAAgkmAgMAAQo4AgMEIwIABAAAAIUkAAABvyYCAgAALAgBBCYCBQQEABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYsCAECAAABAgEsDgQCJgIEBAEmAgUEACYCBgQDLAwFASIAAADhDDgBBgUjAgAFAAABDyIAAADzLA0CASYCAgQCACgBAgQAOAQCBSwNBQMsDAMBJSwNAgUcDAEHAAA4AwcILgwACAAHJgIJBAMMOAEJCiMCAAoAAAE6JAAAAdEtBAAFgAMnAIAEBAAEJAAAAeMtCIAFAAgAKAgCCQA4CQEKLA4HCgA4AQQFDjgBBQcjAgAHAAABdyQAAAJxLA4IAiwMBQEiAAAA4ScAgAQEeAANAAAAgASAAyMAgAMAAAGsKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVSVfKdc0WarDsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAB/iIAAAIJLQCAA4AFIgAAAnAtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAACXC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAACKycBgAUEAAEDAIAGAAKABiIAAAJwJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "1ZrbjuIwDIbfpde9iHOyzausRqMCZVSpKqjASivEu2+KaKdb2FTDMDPxDWrQn/qrk7qxk1O2LpfHt9eq2Wz32eLXKau3q+JQbZvQOp3zbNlWdV29vY7/zlT34/mi3++KpmvuD0V7yBbgWeVZ2azDJSoV7rCp6jJbWLTn/FatlOvVSrtBDZbuqK0huqqtYRzU5O6ICUx/awIHY/FLnqF9BjzpXh3ovxH+KZ63MHjez3kenOnhwbGNw7PW/a1ZezuBJ3wuPKh/4YMJ1l9uIkzcb7DhPm/D42DDo5ubdsT9jCYGNxm5wPhRnksv90gv/ZAtTY/0MuZuL7AGh+Gxfs7TGqiXhxdgFA4831GjBn9VozYz4+KJ+nAQLv10XAzJ5rdaOD/K5nfC/e+E+98L97/3svlRCed3wvlZNj9Z4fzC1w8sPH6y7O+X1snHH4Y+rwmXZspvk1//M/HAz+6G/0fmj4KB3+k4P7Lp08pRncQ6vuD/zPLzefiyve9lex9BduxJfu2GaihForI3sYdSXzuj0irGn77/Fb7z+7g4lKTRDGVdVjefak7/dYl+6jj5VDPKb5Rs/xuVfKoW5wcrm18nX6qY4U8+1Ynzm+RTzRn+5FP9OL/wVM1Y4f5Pf6tghl94/El/qyDOn36pfYY//VLX//nPofW7aKtiWZfX4z2bY7ManfY5/NmVk4M/u3a7KtfHtuyOAL2f/unGMeyqA8BLd1IhtNDlpLpGt8QNz0ccDAajfwE=",
      "brillig_names": [
        "get_escrow_class_id"
      ]
    },
    {
      "name": "register_dkim_bulk",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim_bulk"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "usdc",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "register_participant_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2564696720034330091": {
            "error_kind": "string",
            "string": "Function register_participant_escrow can only be called internally"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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T+RLX97kS1/e5Etf3uRL1zw/GbxdeZMvfXmTL315ky99z5fkS1/e5EtX3jP50pc3+dKXN/nSlzf50pe3wduVN/nSlzf50pc3+dI1z8/kS1/e5EtX3gv50pc3+dL1fLmQL315ky99eRu8XXmTL315ky99eZMvfXmTL315ky9dea/kS1/e5EvXPL+SL315ky99eRu8XXmTL33Pl+RLX97kS1/e5Etf3uRLT96pI1/68iZf+vImX/ryJl/68jZ4u/ImX3rm+dSRL315ky99eZMvfXmTL13Plz350pc3+dKXN/nSlzf50pe3wduVN/nSlzf50pc3+dKXN/nSlzf50jXPJ/KlL2/ypS9v8qUvb/Kl6/kyGbxdeZMvfXmTL315ky99eZMvfXmTL115D+RLX97kS1/e5Etf3uRL1zw/GLxdeZMvfXmTL315ky99z5fkS1/e5EtX3ka+9OVNvvTlTb705U2+9OVt8HblTb705U2+9OVNvnTN80a+9OVNvnTlPZIvfXmTL13PlyP50pc3+dKXt8HblTf50pc3+dKXN/nSlzf50pc3+dKV90S+9OVNvnTN8xP50pc3+dKXt8HblTf50vd8Sb705U2+9OVNvvTlTb505T2TL315ky99eZMvfXmTL315G7xdeZMvXfP8TL705U2+9OVNvvTlTb50PV8u5Etf3uRLX97kS1/e5Etf3gZvV97kS1/e5Etf3uRLX97kS1/e5EvXPL+SL315ky99eZMvfXmTL13Pl6vB25U3+dKXN/nSlzf50pc3+dKXN/nSk/fQkS99eZMvfXmTL315ky898/zQGbxdeZMvfXmTL315ky99z5fkS1/e5EtX3j350pc3+dKXN/nSlzf50pe3wduVN/nSlzf50pc3+dI1z/fkS1/e5EtX3ol86cubfOl6vkzkS1/e5Etf3gZvV97kS1/e5Etf3uRLX97kS1/e5EtX3gP50pc3+dI1zw/kS1/e5Etf3gZvV97kS9/zJfnSlzf50pc3+dKXN/nSlbeRL315ky99eZMvfXmTL315G7xdeZMvXfO8kS99eZMvfXmTL315ky9dz5cj+dKXN/nSlzf50pc3+dKXt8HblTf50pc3+dKXN/nSlzf50pc3+dI1z0/kS1/e5Etf3uRLX97kS9fz5WTwduVNvvTlTb705U2+9OVNvvTlTb505T2TL315ky99eZMv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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000b3dd3286"
            },
            {
              "kind": "string",
              "value": "ParticipantNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "name",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseEscrow"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "entitlements",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "escrow_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "dkim_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "managed_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participants",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participant_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "dkim_key_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "verifier_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::DKIMKeyHashRegistered"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_class_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_class_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::set_contract_registered_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::set_contract_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_and_register_participant_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_and_register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "usdc",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow_contract_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_bulk_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_bulk_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_registry_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_registry_status_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "105": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "107": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "108": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "109": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "110": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "112": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "113": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "114": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "119": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "120": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "122": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\n\npub struct NullifierMembershipWitness {\n    pub index: Field,\n    pub leaf_preimage: NullifierLeafPreimage,\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let serialized_leaf_preimage = array::subarray(fields, 1);\n\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"
    },
    "125": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "126": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "129": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "131": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 bytes.\n//\n// Each 31 byte chunk is converted into a Field as if the chunk was the Field's big endian representation. If the last chunk\n// is less than 31 bytes long, then only the relevant bytes are conisdered.\n// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\npub fn bytes_to_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut dst = [0; (N + 30) / 31];\n\n    for dst_index in 0..((N + 30) / 31) {\n        let mut field_value = 0;\n\n        for i in 0..31 {\n            let byte_index = dst_index * 31 + i;\n            if byte_index < N {\n                // Shift the existing value left by 8 bits and add the new byte\n                field_value = field_value * 256 + input[byte_index] as Field;\n            }\n        }\n\n        dst[dst_index] = field_value;\n    }\n\n    dst\n}\n\n// Converts an input array of fields into bytes. Each field of input has to contain only 31 bytes.\n// TODO(#8618): Optimize for public use.\npub fn fields_to_bytes<let N: u32, let M: u32>(input: [Field; M]) -> [u8; N] {\n    let mut dst = [0; N];\n\n    for src_index in 0..M {\n        let field = input[src_index];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let src: [u8; 31] = field.to_be_bytes();\n\n        // Since some of the bytes might not be occupied (if the source value requiring less than 31 bytes),\n        // we have to compute the start index from which to copy.\n        let remaining_bytes = N - src_index * 31;\n        let src_start_index = if remaining_bytes < 31 {\n            // If the remaining bytes are less than 31, we only copy the remaining bytes\n            31 - remaining_bytes\n        } else {\n            0\n        };\n\n        // Note: I tried combining this check with `assert_max_bit_size` above but `assert_max_bit_size` expects\n        // the argument to be a constant. Using comptime block to derive the number of bits also does not work\n        // because comptime is evaluated before generics.\n        for i in 0..src_start_index {\n            assert(src[i] == 0, \"Field does not fit into remaining bytes\");\n        }\n\n        for i in 0..31 {\n            let byte_index = src_index * 31 + i;\n            if byte_index < N {\n                dst[byte_index] = src[src_start_index + i];\n            }\n        }\n    }\n\n    dst\n}\n\nmod test {\n    use crate::utils::bytes::{bytes_to_fields, fields_to_bytes};\n\n    #[test]\n    fn test_bytes_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_bytes() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_bytes(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_less_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_bytes(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_bytes_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_bytes() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_input_to_fields_and_back(input: [u8; 128]) {\n        let output = bytes_to_fields(input);\n        let input_back: [u8; 128] = fields_to_bytes(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_bytes(input);\n        let input_back = bytes_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"Field does not fit into remaining bytes\")]\n    fn test_too_few_destination_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_bytes(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_bytes_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_bytes(input);\n    }\n\n    #[test]\n    fn test_fields_to_bytes_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_bytes(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "145": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::DEPLOYER_CONTRACT_ADDRESS,\n    hash::compute_siloed_nullifier,\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for BlockHeader {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for BlockHeader {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for BlockHeader {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for BlockHeader {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n"
    },
    "146": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr",
      "source": "use dep::protocol_types::block_header::BlockHeader;\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{\n    context::PrivateContext,\n    note::{note_interface::{NoteInterface, NullifiableNote}, utils::compute_siloed_nullifier},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: BlockHeader, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for BlockHeader {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving nullifier inclusion failed\",\n            );\n\n            // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n            // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n            // care about is showing that the tree contains an entry with the expected nullifier.\n            assert(\n                witness.leaf_preimage.nullifier == nullifier,\n                \"Nullifier does not match value in witness\",\n            );\n        }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(\n        header: BlockHeader,\n        note: Note,\n        context: &mut PrivateContext,\n    )\n    where\n        Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for BlockHeader {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(self, note: Note, context: &mut PrivateContext)\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"
    },
    "148": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "149": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "150": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "153": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "154": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "161": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "197": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr",
      "source": "pub global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable},\n    hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct NullifierLeafPreimage {\n    pub nullifier: Field,\n    pub next_nullifier: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<Field> for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_key: Field, next_index: u32) -> Self {\n        Self { nullifier: self.nullifier, next_nullifier: next_key, next_index }\n    }\n\n    fn update_value(self, _nullifier: Field) -> Self {\n        assert(false, \"Tried to update a nullifier\");\n        Self::empty()\n    }\n\n    fn build_insertion_leaf(nullifier: Field, low_leaf: Self) -> Self {\n        Self { nullifier, next_nullifier: low_leaf.next_nullifier, next_index: low_leaf.next_index }\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value =\n            compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(\n            self.nullifier,\n            siloed_value,\n            \"Value of the nullifier leaf does not match read request\",\n        );\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"
    },
    "205": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "212": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "241": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n"
    },
    "252": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "267": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "268": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "284": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "287": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "289": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "290": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "293": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "294": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "296": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "297": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "301": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "302": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "303": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "304": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "307": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "313": {
      "path": "/Users/ianbrighton/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "321": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_escrow/src/types/entitlement_note.nr",
      "source": "use aztec::{\n    encrypted_logs::encrypted_event_emission::encode_and_encrypt_event,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::{note, note_custom_interface},\n    note::utils::compute_note_hash_for_nullify,\n    oracle::{random::random, notes::check_nullifier_exists, debug_log::debug_log_format},\n    prelude::{NoteHeader, NullifiableNote, NoteInterface, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        traits::{Serialize, Deserialize},\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::{poseidon2_hash_with_separator, poseidon2_hash_bytes},\n        utils::field::field_from_bytes,\n    },\n};\nuse compressed_string::CompressedString;\nuse generators::GENERATORS;\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\nuse crate::{ZERO_DESTINATION, ZImburseEscrow::{SpotReimbursementClaimed, RecurringReimbursementClaimed, EntitlementNullified}};\n\nglobal ENTITLEMENT_NOTE_LENGTH: u32 = 8;\n\n#[note_custom_interface]\npub struct EntitlementNote {\n    // the user that is allowed to use this entitlement\n    recipient: AztecAddress,\n    // the type of receipt verifier that this entitlement can be used for\n    verifier_id: u8,\n    // the maximum value that can be withdrawn from the escrow using this entitlement\n    max_value: U128,\n    // date range that verified emails can be used for\n    date_start: u32,\n    date_end: u32,\n    // destination if used for travel\n    destination: Field,\n    // whether or not the entitlement is a spot entitlement\n    spot: bool,\n    // blinding factor & nullifier secret for the note\n    randomness: Field,\n}\n\nimpl NoteInterface<ENTITLEMENT_NOTE_LENGTH> for EntitlementNote {\n\n    fn serialize_content(self) -> [Field; ENTITLEMENT_NOTE_LENGTH] {\n\n        [\n            self.recipient.to_field(),\n            self.verifier_id as Field,\n            self.max_value.to_integer(),\n            self.date_start as Field,\n            self.date_end as Field,\n            self.destination,\n            self.spot as Field,\n            self.randomness\n        ]\n    }\n\n    fn deserialize_content(serialized_note: [Field; ENTITLEMENT_NOTE_LENGTH]) -> EntitlementNote {\n        EntitlementNote {\n            recipient: AztecAddress::from_field(serialized_note[0]),\n            verifier_id: serialized_note[1] as u8,\n            max_value: U128::from_integer(serialized_note[2]),\n            date_start: serialized_note[3] as u32,\n            date_end: serialized_note[4] as u32,\n            destination: serialized_note[5],\n            spot: serialized_note[6] as bool,\n            randomness: serialized_note[7],\n            header: NoteHeader::empty()\n        }\n    }\n\n    fn to_be_bytes(self, storage_slot: Field) -> [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] {\n        let serialized_note = self.serialize_content();\n        let mut buffer: [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] = [0; ENTITLEMENT_NOTE_LENGTH * 32 + 64];\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = EntitlementNote::get_note_type_id().to_be_bytes();\n        for i in 0..32 {\n            buffer[i] = storage_slot_bytes[i];\n            buffer[32 + i] = note_type_id_bytes[i];\n        }\n        for i in 0..serialized_note.len() {\n            let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n            for j in 0..32 {\n                buffer[64 + i * 32 + j] = bytes[j];\n            }\n        }\n        buffer\n    }\n\n    fn get_note_type_id() -> Field {\n        comptime\n        {\n            let bytes = \"EntitlementNote\".as_bytes();\n            let hash = poseidon2_hash_bytes(bytes);\n            let hash_bytes = hash.to_be_bytes::<4>();\n            field_from_bytes(hash_bytes, true)\n        }\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn compute_note_hash(self) -> Field {\n        let serialized = self.serialize_content();\n        let generators = [\n            GENERATORS[0],\n            GENERATORS[1],\n            GENERATORS[2],\n            GENERATORS[3],\n            GENERATORS[4],\n            GENERATORS[5],\n            GENERATORS[6],\n            GENERATORS[7],\n            GENERATORS[8]\n        ];\n        let data = [\n            from_field_unsafe(serialized[0]),\n            from_field_unsafe(serialized[1]),\n            from_field_unsafe(serialized[2]),\n            from_field_unsafe(serialized[3]),\n            from_field_unsafe(serialized[4]),\n            from_field_unsafe(serialized[5]),\n            from_field_unsafe(serialized[6]),\n            from_field_unsafe(serialized[7]),\n            from_field_unsafe(self.get_header().storage_slot)\n        ];\n        std::embedded_curve_ops::multi_scalar_mul(generators, data).x\n    }\n}\n\nimpl NullifiableNote for EntitlementNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = self.randomness; // use as nullifier_secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = self.randomness; // use as nullifier secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for EntitlementNote {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient)\n            & (self.date_start == other.date_start)\n            & (self.date_end == other.date_end)\n            & (self.destination == other.destination)\n            & (self.max_value == other.max_value)\n            & (self.randomness == other.randomness)\n            & (self.spot == other.spot)\n            & (self.verifier_id == other.verifier_id)\n    }\n}\n\nimpl EntitlementNote {\n    \n    /**\n     * EntitlementNote constructor\n     *\n     * @param recipient - the address of the recipient of the entitlement (NOT THE OWNER OF THE NOTE)\n     * @param verifier_id - the type of verifier that the entitlement can be used for\n     * @param max_value - the maximum value that can be withdrawn from the escrow using the entitlement\n     * @param date_start - the start of the date range that the entitlement can be used for (0 for recurring)\n     * @param date_end - the end of the date range that the entitlement can be used for (0 for recurring)\n     * @param destination - the destination of the entitlement (ZERO_DESTINATION for recurring)\n     * @param randomness - blinding factor for the note (inputted since must be same between the two notes)\n     */\n    fn new(\n        recipient: AztecAddress,\n        verifier_id: u8,\n        max_value: U128,\n        date_start: u32,\n        date_end: u32,\n        destination: str<31>,\n        spot: bool,\n        randomness: Field\n    ) -> Self {\n        let destination_compressed: CompressedString<1, 31> = CompressedString::from_string(destination);\n\n        // assert destination \n        if spot == false {\n            assert(date_end == 0, \"Date end must be zero if entitlement is recurring.\");\n            assert(date_start == 0, \"Date start must be zero if entitlement is recurring.\");\n            assert(destination == ZERO_DESTINATION, \"Destination must be empty if entitlement is recurring.\");\n        }\n\n        Self {\n            recipient,\n            verifier_id,\n            max_value,\n            date_start,\n            date_end,\n            destination: destination_compressed.value[0],\n            spot,\n            randomness,\n            header: NoteHeader::empty()\n        }\n    }\n\n    /**\n     * Return the destination of the entitlement\n     *\n     * @return the utf8 bytes of the destination\n     */\n    fn destination(self) -> [u8; 31] {\n        CompressedString::<1, 31> { value: [self.destination] }.to_bytes()\n    } \n\n    /**\n     * Constrain a given timestamp to be within the date range of the entitlement\n     *\n     * @param timestamp - the timestamp to check\n     */\n    fn check_date_range(self, timestamp: u32) {\n        debug_log_format(\"\\n\\n\\n\\nChecking date range:\\nStart: {0}\\nTimestamp:{1}\\nEnd:{2}\", [\n            self.date_start as Field,\n            timestamp as Field,\n            self.date_end as Field\n        ]);\n        assert(\n            (timestamp >= self.date_start) & (timestamp <= self.date_end),\n            \"Receipt is out of entitlement date range\"\n        );\n    }\n\n    /**\n     * Determine the amount to reimburse for a given claimed amount (lesser of the two)\n     *\n     * @param claimed - the amount claimed by the user\n     * @return the amount to reimburse\n     */\n    fn amount_to_reimburse(self, claimed: U128) -> Field {\n        if self.max_value >= claimed {\n            claimed.to_field()\n        } else {\n            self.max_value.to_field()\n        }\n    }\n\n    fn derive_shared_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            self.serialize_content(),\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Derives the nullifier for recurring notes\n     * @dev recurring notes are nullified for a scope (month) without destroying the ntoe\n     *      prove nullifier non-inclusion to use\n     *\n     * @param timestamp - the timestamp (month/ year) from the email receipt verifier\n     * @return - the month nullifier for the note\n     */\n    fn derive_recurring_nullifier(self, timestamp: Field) -> Field {\n        let serialized = self.serialize_content();\n        let mut inputs: [Field; ENTITLEMENT_NOTE_LENGTH + 1] = [0; ENTITLEMENT_NOTE_LENGTH + 1];\n        for i in 0..ENTITLEMENT_NOTE_LENGTH {\n            inputs[i] = serialized[i];\n        }\n        inputs[ENTITLEMENT_NOTE_LENGTH] = timestamp;\n        poseidon2_hash_with_separator(\n            inputs,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Assert that a recurring nullifier has not been used before and emits it\n     * @dev uses oracle check_nullifier_exists which is technically unsafe but will be caught by kernel\n     *\n     * @param context - the private context to use for the oracle call\n     * @param timestamp - the timestamp to check\n     */\n    fn check_and_emit_recurring_nullifier(self, context: &mut PrivateContext, timestamp: Field) {\n        // derive recurring nullifier for the month\n        let recurring_nullifier = self.derive_recurring_nullifier(timestamp);\n        // check the nullifier has not been emitted via oracle call (rely on kernel to actually constrain)\n        let recurring_nullifier_exists = unsafe { check_nullifier_exists(recurring_nullifier) };\n        assert(!recurring_nullifier_exists, \"Entitlement has already been claimed for this month\");\n        // emit the nullifier\n        context.push_nullifier(recurring_nullifier);\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a recurring claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     * @param timestamp - the timestamp of the claim\n     */\n    fn emit_recurring_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field, timestamp: Field) {\n        RecurringReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n            timestamp\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a spot claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     */\n    fn emit_spot_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field) {\n        SpotReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Admin or recipient notifies counterparty that note has been nullified\n     * @dev admin emits event when revoking entitlement, recipient emits when claiming spot\n     * @dev clients must scan for these events to prune notes that are no longer valid\n     *\n     * @param context - the private execution context\n     * @param to - the address of the counterparty to notify\n     * @param from - the address of the notifier who nullified the entitlement note\n     */\n    fn emit_nullified(self, context: &mut PrivateContext, to: AztecAddress, from: AztecAddress) {\n        EntitlementNullified { randomness: self.randomness }.emit(\n            encode_and_encrypt_event(\n                context,\n                to,\n                to\n            )\n        );\n    }\n}\n"
    },
    "364": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "459": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/registry_definition.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\n\nglobal REGISTRY_DEFINITION_LENGTH: u32 = 3;\n\npub struct RegistryDefinition {\n    admin: AztecAddress,\n    usdc: AztecAddress,\n    escrow_contract_id: Field\n}\n\nimpl Serialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn serialize(self: Self) -> [Field; REGISTRY_DEFINITION_LENGTH] {\n        [self.admin.to_field(), self.usdc.to_field(), self.escrow_contract_id]\n    }\n}\n\nimpl Deserialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn deserialize(fields: [Field; REGISTRY_DEFINITION_LENGTH]) -> Self {\n        RegistryDefinition {\n            admin: AztecAddress::from_field(fields[0]),\n            usdc: AztecAddress::from_field(fields[1]),\n            escrow_contract_id: fields[2]\n        }\n    }\n}\n\nimpl RegistryDefinition {\n    /**\n     * Create a new definition for a Z-Imburse escrow registry contract\n     *\n     * @param admin - The address that can add dkim keys to the registry\n     * @param usdc The address of the USDC token\n     * @param escrow_contract_id The ID of the escrow contract\n     * @return The new escrow registry definition\n     */\n    pub fn new(admin: AztecAddress, usdc: AztecAddress, escrow_contract_id: Field) -> Self {\n        RegistryDefinition { admin, usdc, escrow_contract_id }\n    }\n}\n"
    },
    "460": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/participant_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}\n},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n"
    },
    "473": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/library_methods/dkim.nr",
      "source": "use aztec::{context::public_context::PublicContext, unencrypted_logs::unencrypted_event_emission::emit};\nuse crate::{\n    BULK_KEY_LENGTH,\n    ZImburseRegistry::{DKIMKeyHashRegistered, Storage}\n};\n\n/**\n * Register a single DKIM key\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hash - the hash of the DKIM key to add to the registry\n * @param verifier_id - the verifier ID to register the DKIM key to\n*/\n\npub fn register_dkim_key(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hash: Field, verifier_id: Field) {\n    let stored_id = storage.dkim_registry.at(dkim_key_hash).read();\n    assert(stored_id == 0, \"DKIM key has already been registered\");\n    storage.dkim_registry.at(dkim_key_hash).initialize(verifier_id);\n    emit(\n        context,\n        DKIMKeyHashRegistered { dkim_key_hash, verifier_id }\n    );\n}\n\n/**\n * Register multiple DKIM keys\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n * @param verifier_ids - the verifier IDs to register the DKIM keys to\n */\npub fn register_dkim_keys_bulk(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hashes: [Field; BULK_KEY_LENGTH], verifier_ids: [Field; BULK_KEY_LENGTH]) {\n    for i in 0..BULK_KEY_LENGTH {\n        if (verifier_ids[i] != 0) {\n            register_dkim_key(context, storage, dkim_key_hashes[i], verifier_ids[i]);\n        }\n    }\n}"
    },
    "474": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\nmod library_methods;\nmod test;\nmod types;\n\npub global BULK_KEY_LENGTH: u32 = 4;\n\n#[aztec]\ncontract ZImburseRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, PrivateSet, PublicImmutable, Map},\n        macros::{storage::storage, events::event, functions::{private, public, view, initializer, internal}},\n        note::{\n            note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions,\n            note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE\n        },\n        protocol_types::{\n            contract_instance::ContractInstance, address::partial_address::PartialAddress,\n            contract_class_id::ContractClassId, abis::function_selector::FunctionSelector, traits::Serialize\n        },\n        oracle::get_contract_instance::get_contract_instance,\n        keys::getters::get_public_keys, utils::comparison::Comparator,\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt_note_unconstrained, encode_and_encrypt_note},\n        unencrypted_logs::unencrypted_event_emission::emit\n    };\n    use std::{meta::derive, collections::bounded_vec::BoundedVec};\n    use dep::address_note::address_note::AddressNote;\n    use dep::zimburse_verifiers::constants::verifier_ids;\n    use dep::z_imburse_escrow::ZImburseEscrow;\n    use crate::{\n        library_methods::dkim::{register_dkim_key, register_dkim_keys_bulk},\n        types::{registry_definition::RegistryDefinition, participant_note::{ParticipantNote, NAME_LENGTH}},\n        BULK_KEY_LENGTH\n    };\n\n    #[derive(Serialize)]\n    #[event]\n    struct DKIMKeyHashRegistered {\n        dkim_key_hash: Field,\n        verifier_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        definition: PublicImmutable<RegistryDefinition, Context>,\n        escrow_registry: Map<AztecAddress, PublicImmutable<bool, Context>, Context>,\n        dkim_registry: Map<Field, PublicImmutable<Field, Context>, Context>,\n        managed_escrows: Map<AztecAddress, PrivateSet<AddressNote, Context>, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: Map<AztecAddress, PrivateSet<AddressNote, Context>, Context>,\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract\n     *\n     * @param usdc - The address of the USDC token\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n     */\n    #[public]\n    #[initializer]\n    fn constructor(\n        usdc: AztecAddress,\n        escrow_contract_id: Field,\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // initialize the registry definition\n        let definition = RegistryDefinition::new(context.msg_sender(), usdc, escrow_contract_id);\n        storage.definition.initialize(definition);\n        // add any DKIM key hashes that were passed in at initialization\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Bulk registration of DKIM keys\n     *\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys\n     */\n    #[public]\n    fn register_dkim_bulk(\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        // bulk insert up to 50 dkim key hashes\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Register a DKIM key hash for email verifiers to anchor trust to\n     *\n     * @param verifier_id - the ID of the verifier\n     * @param dkim_key_hash - the hash of the DKIM key\n     */\n    #[public]\n    fn register_dkim(verifier_id: Field, dkim_key_hash: Field) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not registry admin\");\n        // ensure that the dkim key has not already been registered\n        register_dkim_key(&mut context, storage, dkim_key_hash, verifier_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     * @param escrow_contract - the address of the escrow contract to register\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check the contract class ID by recomputing the contract address\n        let definition = storage.definition.read();\n        let contract_instance: ContractInstance = unsafe {\n            get_contract_instance(escrow_contract)\n        };\n        let computed_escrow_address = AztecAddress::compute(\n            contract_instance.public_keys,\n            PartialAddress::compute(\n                ContractClassId::from_field(definition.escrow_contract_id), // constrained here\n                contract_instance.salt,\n                contract_instance.initialization_hash,\n                contract_instance.deployer\n            )\n        );\n        assert(\n            computed_escrow_address == escrow_contract, \"Escrow contract class ID does not match expected class ID\"\n        );\n        // check that the contract has been deployed\n        // annoying that we can't use this in the deploy tx\n        context.historical_header.prove_contract_initialization(escrow_contract);\n\n        // check that the contract has not already been registered\n        let registration_status = storage.escrow_registry.at(escrow_contract).read();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        let escrow_params = ZImburseEscrow::at(escrow_contract).get_registration_params().view(&mut context);\n        assert(\n            escrow_params[0] == context.this_address(), \"Escrow contract registry does not match this contract\"\n        );\n        assert(escrow_params[1] == definition.usdc, \"Escrow contract USDC does not match registry USDC\");\n        assert(\n            escrow_params[2] == context.msg_sender(), \"Escrow contract admin does not match sender of message\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let admin_keys = get_public_keys(context.msg_sender());\n        let mut escrow_note = AddressNote::new(escrow_contract, admin_keys.npk_m.hash());\n\n        // use unconstrained - why would you lie here\n        storage.managed_escrows.at(context.msg_sender()).insert(&mut escrow_note).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender()\n            )\n        );\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.escrow_registry.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n    fn check_and_register_participant(participant: AztecAddress, participant_name: str<60>, escrow: AztecAddress) -> bool {\n        // todo: switch to check that the sender is an escrow\n        // check that sender is admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        let is_registered = storage.escrow_registry.at(escrow).read();\n        assert(is_registered, \"Escrow contract is not registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new().select(AddressNote::properties().address, Comparator.EQ, participant).set_limit(1);\n        let participant_exists = storage.participants.at(escrow).get_notes(options).len() == 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        let mut registered = false;\n        if participant_exists == false {\n            registered = true;\n            ZImburseRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, escrow).call(&mut context);\n        }\n        // add escrow to participants private set\n        ZImburseRegistry::at(context.this_address()).register_participant_escrow(participant, escrow).call(&mut context);\n        registered\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant(participant: AztecAddress, participant_name: str<60>, admin: AztecAddress, escrow: AztecAddress) {\n        let admin_keys = get_public_keys(admin);\n        // add the participant to the admin set of participants\n        let mut participant_note = ParticipantNote::new(participant, participant_name, admin_keys.npk_m.hash());\n        storage.participants.at(escrow).insert(&mut participant_note).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, admin, admin)\n        );\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant_escrow(participant: AztecAddress, escrow: AztecAddress) {\n        let participant_keys = get_public_keys(participant);\n        // add escrow to the participant's set of escrows\n        let mut escrow_note = AddressNote::new(escrow, participant_keys.npk_m.hash());\n        storage.participant_escrows.at(participant).insert(&mut escrow_note).emit(\n            encode_and_encrypt_note(\n                &mut context,\n                participant,\n                participant\n            )\n        );\n    }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the public context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[public]\n    #[view]\n    fn check_dkim_key_hash_public(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the private context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[private]\n    #[view]\n    fn check_dkim_key_hash_private(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /** Get the class ID that all escrow contracts must match */\n    #[public]\n    #[view]\n    fn get_escrow_class_id() -> Field {\n        storage.definition.read().escrow_contract_id\n    }\n\n    /** Get the registration status of an escrow contract */\n    #[public]\n    #[view]\n    fn get_escrow_registry_status(escrow_contract: AztecAddress) -> bool {\n        storage.escrow_registry.at(escrow_contract).read()\n    }\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param offset - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_managed_escrows(admin: AztecAddress, offset: u32) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.managed_escrows.at(admin).view_notes(options);\n        let mut managed_escrows = BoundedVec::new();\n        for i in 0..notes.len() {\n            managed_escrows.push(notes.get_unchecked(i).address);\n        }\n        (managed_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param participant - the address of the participant\n     * @param offset - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_participant_escrows(\n        participant: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participant_escrows.at(participant).view_notes(options);\n        let mut participant_escrows: BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE> = BoundedVec::new();\n        for i in 0..notes.len() {\n            participant_escrows.push(notes.get_unchecked(i).address);\n        }\n        (participant_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param offset - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<ParticipantNote, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participants.at(escrow).view_notes(options);\n        (notes, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n}\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "60": {
      "path": "std/uint128.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"
    },
    "63": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/address_note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "69": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "72": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "75": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "76": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "79": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "83": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "90": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "91": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "93": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
