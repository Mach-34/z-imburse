{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "ZImburseRegistry",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7V3bziS3jX6XufaFDqRI5lUWi8BJvMEAhh04zgKLIO++9R+qumda1XKzimpWtW6MGU+xv08fqbNE/fvL3376y7/+/uevv/zPr//88qf/+veXn3/964+/f/31l+lv//7PD1/+8tvXn3/++vc/X//vL+HtP0Xev//nP3785e2v//z9x99+//KnGPMPX3765W/Tn1Kc7P/n688/ffkTEPznv3/4QvywCefHTR5HkcdR5HGUGJLChh63iQqcqMBJUWFTHrfJQWGDD9skeNDmh9tvQ5Dl6xAzLN8zvkNgsIcAewgxhyj2pSj2pSD7UvDjlT3x45UwSVTYbK5QHOjzW860fJv48/fF9PdzAOPff7wTyYrGPSsa96xo3HN6vNHNisY9Z1DYKLSGrLChzTETZYkZuIkZTMa/X2x/vwTj3wfj3xfb3ydj/o8Owh/9fU62bSaT7e8/2s89/Pto/Pu2fSIY94kQjPnHbPz7tu0/pGT8+7btP+Rg/Ptg/Pu27T+AMX+wbf8Bbdt/QNv2H0o0/n00/n3j9nOH8cn93zfmz8btPz8+1wJJCpvH5/AYgsIGFDaPz7UwZoWNAiclhY1Ca8W8FhWLlpgfX4dHUPgUFFqjQmtUaF0UWheF1qTAIYXWio0SVKwDoqKtwu3zo1gkzB9TCLcIaIxQQjBHAHMEtkbYPlNqIpA1QormCMUaIZuXIZvWuMrXSPMUIqLI8nUErnwNmfnz62n2dRlxTRsgtclJxnl0FjFef/xWUgidS1pSmr8uBRslTTnMX6eMl7lVTKH221TK/Nscyzdfv5WV+YllpdQoK5WZB9GF++SxN+pSjkqdQjwu9d7NAIUlgKmEVuVgnr9OAtKoHCkuqxQpcvi+chDmZ5aVtripxONSL4elTr17Dk7LT3Nu9pEMc7gDF77fR7bOFNAOxxaOU1Z5nbLyC/mVX8iv8jp+5ZAOWtZ38uXA5GM8Mnl0TV7CQl7STcwn32OPBvlDK++8F+FwIY/3W9Yi8zyRwtW2bUwf5+yddyH7FbS7R+FS0AKNgmLAORynXbRGQR8k0upZIQ9lVpThoUxdGRwxs6bMiJkVZcqImRVlKL6EMu9FxZcpKofXKSq8aNXOeSGSIV5vZUhtkxKWlWbGcFmWziHXflvC8tsSLzs8aZrlvov+qiPaZ4our9qJPVX0Vx1TPVH06V+H6P1FH5HeX/Q4Iv0Joo9I7y96GpH+BNFpiN5d9JyG6P1FL0P07qJvvzg6RH9c9DF66S/6y246PVX0Een9RS9j9PIE0cc4vb/oL7JJ1lt0wUV0KTeij/V0A9EhLPkhIKTwvegxhNGob1X9Q8cxy9xFx/gap07sdXyNIy2bdcR40RFDozXltPw2J4mtDg/n637wTctb+TSlED+/TSnK9cfv3hxrWGfyJow27kzeHC3tmbw5zq+dyJs7PD8wvOnHm6NunsibL3vz4pzeHOvUJ/Lmi9z9eRVvjhnKmbw5RkEn8iaPUdCZvDn2ME/kTRl7o2fy5thDOY83YxgzlDN5c8xQzuTNMUM5kTcjDG+eyJtjhnIib6YxQzmTN8ceyom8mccM5UzeHDOUE3kTxgWfM3kThjdP5M0xQzmRN8f1+DN5c5wLOpY34eJNTDfeHLlaD+VNSsuTgwThxpv9310a3jT05hgFncebadyyP5U3x0mSE3kzjrWgM3kThjdP5M0xQzmRN9Oom2fy5pihnMib3VNT05INbvImNbyZqMxpzBJLbny9b4q0lGlIsyJN90w2B5KmDGlWpMERNavSjKhZk6aMqFmVBoc0a9LIkGZFGoIhzZo0PKRZkab7hfUDSfMiE4X3wsqLdMcfhX2RYdlbYXMIJyrsIc5V5XSmynQQyc9UpY8heR4NS3fJYUjeW/IzzTiPITmMKO8u+ZlmyMeQHM+0RXcQyccgsbfkZQwSu0s+us/uko/us7fkdKaF64NIfqYF8WNIzmMlsbvkY5DYW3IZg8TuksOQvLfkYyWxs+QQxiCxu+RjkNhb8jhWErtLPgaJvSVPY5DYXfIzHUQ+iORjkNhb8jwGid0lH+vlvSUfe58Gkt9NyAanupFxiHvPQKP77C35qW6QHETyscbSW/JT3Y85iORj9tld8tF9dpYcAwzJe0s+ory35HEMErtL3v35KV6+lli+EfGdUP/XzRqEul9gaxLqPeIR4oWQNHOwFZmJIAW+BNxk+U6/9zM804rX/NMp5NigD4jz19Ni2OXrago5TiEttTbS9ccfRcXeRb2s7oXcaqFiyHN7FgOlW09h6B5odKEPt5GP6IxQyd4IbV4yT4IzoSSFG1/vWl22H9bOl2wdU89ZWmoiLxWgxEsFmHxS+ZpSnHtSSpnuF5UuRChAuf9xDExLGYOEcqMMp6HMijLcWZmyVI9YCn6jzDshyb4IlRC9ESqdCXFaxi+M0ArmUuY+lArnRjBf0qoQRmgFs/Dc/sUYUv4+mEvsXc15GatNQ01pKiOzjkSxoQykWUXIlx8G/IyBWF6lpCm+TElfxqf5ZXyaX8an26elhykpvExJ5VVKivllSsqvUlJy3ss8Mk7Oy7rF9Ee+Gfhuf/guxzzTySm0li1ipmXhP8v1qstHOkTqfXIfFzGRWyuskJkvcdOYbnPMc0l5Wu3/XnnqnYQQlxgrEVsFTXGpICk3lgokp/mXJSPeFnT72mGAZXl1+nO6WYygHbYK2hjQAUPsMaBDOR5dL343ejQxyoeRKIweXe/8MGKF0Q6HZEK49A7Tjgp8LzbvkEG2jQEdMMQeI3YoR+xQjtShHI8+UvRhVBRGjz5s82G0uWqVZTe/XO/C8QwgxgAI1gCKJouLxu2FFEakcTspupZpY19jBBojjeSSNUYKySUkjZGiTksMGiPQGCkkl5Q1RhokTTMqmmZUQCM5oMZIMeoS1DhX04SJpgmTopGcNJJrmjDRNGGiacJE04SJaCRXNGFvJ20sJ84fEGgOYfsO9gcE2EOwOUTK9hBkDpHtgzYXcwiwLwXYVz20r3poX/XQvuqVZA9hH7RkH7RkXwrevktalgPpuYBUINAeQswhdjgG1oQga4i4w9mxJoS5u2MM9hAdSmEetDFlewj7oN3hdM60oTlDUGh9veMZ6In89gM3heBCPt/qA9EeQswhth+9z7Ts1edpPa/VNd7fMk5xhyTMjQ2tCaPYY0jogGG+GZtSsC/H1Cg/vnKQUtAYocZIFEaPbjC/G+3wuntjIyjt8Ux6E6OEDhhoj0EdykEdysEdyqFYaJxqVtIYKRYa8/Yx+N3tuQkAjQG2j79bAIomKyv2a1JW7NdMRhq356gxKgojxX5Nevj1vQ8jRX+UUSM5apyr2K+ZjDSSk0Zy0khOGslZg6RpRrOmGc2aZhRC1BihxkghOcSsMVJIDpomDDRNGNjvNkA2X6cHCPYQYA9hvk4PmO0hzLfIoNgHrf1uA9jvNgDZVz22r3psX/XYvupJsocwD1q0P1KBwb4U22c7MM0U5wXl64zBFwi0hxBziO27DW0IMofYPshpQ9i7G+yDFjqUwj5o0T5o0T5oyw5By0sOuhyg9fWOW2S4ffg0TWfoQr7c6kPRHkLMIbaPbQDiAgGMFQgxh9h+kqINQdYQO2ThaUOgPYS5u0vM9hD27k727k727k727s727s727gZ7d4O9u8He3WjvbrR3d7F3d7F3d7F3N9m7m+zdzfbuZnt32w/Viv1QrdgP1ch+qEb2QzWyH6qR/VCN7IdqZD9UI/uhGtkP1XbIPNKGsC8FKLY/CRTbn4RJY2R/wpNK7IBhf8KTKHTA6FAOVhwheTily5sR7/DARus4He/wokQTY4dHItoYHcqRO5QjdygHaIJRcxqMFbf3E2+/pMhLIj2+SnA+H0Dk7VcUWwBkDKBIgpI0SVCSJglK0iRBSZokKEmTBCVpkqAk0ZxI0yRBSbJ9S5qjLNEDN9Ej2zekWwBiDLB9M7oFQMYA2/uSFoB1CbavorYA0LYVle13+lsAYA1g3FWKdVcp1l2lkHUJtt/jbwDYn6sT+3N1wmIOIdkewvpIaw4h2UMUcwjzVEUTBJpDJPtSJLCHEHOInO0h7KueeaqibJ+qKNunKpogOpSi84O+Ox56y6FAZ/L7JZmfyNs3F2Tf6LF9N8qbWyQqef54WoOXFqGwOC4Gvn6rLda+Xo58Rrl62JXpg7zEI5MvxyW/Q5qmZ5I/svLxyMpvH+4+k7wcmPz2IfozybNr8kuqiGlEdUt++7TimeR9Dw/ukwffTWWDvO9O6j55PLLy6LuTapDv3UnFEi4/Td+Qfye0fRq5NyF2Rmj76v7ehIozQtt3D/Ym5C2o2VtQS/ZGyJlCKTir9ik4q/YpOqv2KTqr9inuG9RMLUIY5hy50zApXxGSD0KJnBHKqTchnjfCJy+lbwhVfjvFeTRHKTfWvOnyti4FaDxOOo0k6XKCUsL3Z4AnZXrHTsElmEvBW1dBdkZo51nMDoRKZ0Kc5i2Zt0f7WsH80PvMUBYiGKEVzMLzXlWMIeWbYC69q7nhy9U7K7M9F1TjOkFOlDtgkD3GDvttbYwO5ZDHjyHnaUNTYZTMMzJPGGKPsccb102MDuWADuWADuVATTCWqDEqCiOyPXWb8/bDBS0AMQbgrNCVNW5XZPSdjBRuhxA0RqgxEoWRIqNv1mT0zZBsT/5nML67kHfIFNwCQGsAMQbY3pe0AKxLgNkawPbkfwbjuwt5h8zADQDrrhKsu0qw7ip3yAjcAmBjAPNswNk+G3C2zwY8QaA9hPnRVzR/YHmCYHOIlOwhzM/7Y7YvRbaveva3FtD+1sIO2YCbEOZPHmRE+6At9kFb7Eth++TB7deFYF73K4StGxIsy/UOifif71ZYkOwrNdtXaravcbK9swuUL8td155b+36/s7MofGT6JeRj0z+2+vHY6sdjq79Hzqln0i+Hpr/DW2JPpY/O6d89x1x2eAPtqfTh2PS9N5z36aP3bqtB/9jqF+/dVoN+/26rccyzUPRHCf1REneUOPujRO4oib/wFnfhTSH4o+RQJXeNAEV3jQBFd43ADknx96e0d3jTt5TeQXLoAQI9QLgDCKQeIKUDCPZwPPYI4dKjJKVHCBfFYTiirDHSIGnOVJLmTCVpzlSSIid15pA0RorTmxyjxkhxepNT0BipkBTnRDnbX9fgbH/thCF1wLC/rsHYoRxF0XQwaeqmmKdu5B22ZJsQ5hvLErI9hPkhCInJHsL8qILYJ8mVZH7+SLJ9KTLYQ9hXPbCvemBf9TDaQ9gHbbEP2tKhFJ1T/e55FkzsU9kK2Vdqtq9xO5xzjxmXBBFxmslUQMgcBMIOZ93/AAj2AJEOIDus4f4BkB6OT6kHSI+S5B4hnHuEcO4RwopnSCcjVhihBgk1SCVpjEhhRBok0iBx1BgVhZEEjdHjy1QQFRenJyPQGJmvO0GMuQMG2WOk1AGjQzmyoumIigeWIRbzdCcThthj7DDgb2N0KAd3KAd3KIdi5wSS4jVPSIqdE9ghEePd+8OwQ2LFFoAYAyTFmOfhbInvRjlpjDRuh6AxQo2RKIw0w8ykGWbukF3ubh6JCYCMAShaA6A1gBgD7JCFoQFgXQLJ1gC26U4gh2QNUIwBrLvKbN1VZuuuMifrEiQ2BjDPuTBBFHMI85wLEwTaQ4g5xPYnsNsQbA5R7IPWPOcCZLIvBdlXPbavemxf9di+6pk/h/321Kg1BJg/hz1B2JciHjfdyUTevFJDivYQ5jUOdjjgE5HmacTbHQtsfb/ftfeJPh+a/g4Hk55K/9jq47HVx2Orv8MA9an0y6Hp73DH/Kn00Tn9e0kHpnYzHJs+HJu+94bzPn3x3m016B9afQzeu60G/f7d1v1714Ax+qOE/iiJO0op+6NE7ihlf+Gd/YU3BH+UHKrkrxFAf40A+msEir9GoOwd3qmVgSXF5bHUlBw/lgq4++x4d22WM7KUMLW0udLxMiKU8FnW8jpl1Ry2R81hexQNkuKVMiiaw/ZF8UoZlKhBiiokxQHB8uhBkw8jxQHBkrPGSIMESWO0Qz6jxiH8ssNl5DYG2mPskcyoidGhHKRpOjTNYdE0h0XTHBZNc0iaY/KkOSZPUYMUNUhJg5Q0SFmDpDltTprT5qQ5bf5w5rUPIw1S0SA9munsw0jRmWgyl01GiksLxEljpAkjTcNCmkuNrBlncQCNkWL0w4rXYCcjRRhxShojRRixpjViTWvEmtaINa0Ra+6+MGrCSHP3RZM4bDLSOFdzxZo1wxzWDHOYNc7VXLF+OL3Zh5EijHZIQUbzqburdJrTnPzj19ny17ef6Lv369sP8939dbT89e1pwO7+ui13sfz17ZkW7/46Wf56MeVeTLmTaTtDpjHDpvEupnVVDLljCMH018H018Xy17df0ssk/PlxZmru7UBYToRAuj7VnT8JiTNCyZtC2+/07U2InBECbwqBN4W2r4FvIYS3hEr3ak9LFrJpPHRLiMAbIW8KMTkjJMkbIWcKxeBMobj9TOejhJabehFjviUUozdC6I2QOCO0/Szn3oTIGaHsLaizt6DO3oIavAU1eAtq9BbU6C2o0VtQF29BXbwFNXkLavIW1OQtqNlbULO3oBZvQS3eglqcBXUKzoI6BWdBnbxNFJO3iWLyNlFM3iaKydtEMXmbKCZvE8XkbaKYvE0Uk7eJYvI2UUzobNEzFW8KUfBGyFs7xN4U2p6ZZF9CO2RoztPC6UwoBW4Sur/nmncYwu5LKHpTaPvbpnsTQmeEsjeFsjuF5JmEbrc4M3av9vf3XHdIr7w3IW8KETojxMEbIW8KiTeFtr/8/iihxnhIxBch2GGNcWdC5IzQDmuMOxNCb4S8BXXyFtTJW1Bnb0GdvQV19hbU4C2owVtQo7egRm9Bjd6CungL6uItqMlbUJO3oCZvQc3egpq9BbV4C2rxFtTeJorobaKI3iaK6G2iiN4miuhtoojeJorobaKI3iaK6G2iiN4mitPEzBshbwptf/loZ0LepkFYvCm0PcvwzoR22Ou45JzOIZcWIZblpyXK8vVK0uNSZvpU+EK/nvQYlscQCcM3GZI/ioonKuqyY1Qragkn8ioGWIoa821RT+TVRlHj63g18ssUdYfB+2GK+jpeza/j1R1S9vjpV0u+FBXufxyD8DzgiDGkW2XgREGwrsxHUU9UtRtFxdfx6g6H+Y9S1B1ew3zonfdIspz15HL1MBFw5etEZXkrZtKo8TXjQpunFebl68kDta8TLF8niY2v8/Kw4vWR2benGG5J54VGylfyTR+/S77DC55D8gclH1HeWXLa4anRIfljku/wlOqQ/EHJR5T3ljyNKO8uOQ7J95Y8iSySX72COEu+/ZbakPxRyWFI3lvyMS7vLfn2xN5D8kclH4PE3pLj6D67Sz66z+6Sy5C8s+RlRHlvyWmsl3eXfIzLe0vOI8p7Sy5jJbGz5Bx7Nyy8FHSSHBoiYsCZPQa+ZCSpn4N5iEjOC5EMMVwRkcOuC3PKw5sn8uaomyfyZi7Dm+fxJsThzRN5c9TNE3kTR908kzdxePNA3mzMN0sY3jyRN2F480TeHPPNE3mT0vDmibw5Zign8iaPUdCZvAnDmyfypgxvnsebMurmebwpYexvnsmbY755Im/GUTdP5M009lBO5M089lD+kDcvuVkYA7X8I8vpwemP5Up0/lR9zCT2Vx1CnLOATX+UW9W35+sdqitUH7H+BNW3v8M5VH9c9TJ2VixUT3lRPaeK6iPWn6D62EV8hupjf+gpqo9Z0hNUlxHrz1B9xPozVB+zJAvVl9S+kwPC96qXEGCo/gTVR6w/QfU4ZklPUD2NWdIzVB/7x09QfewlPUN1GLOkZ6g+Tl0/QfVxf/Mpqo9Yf4Lq4z7kE1SP9ZezcXlGC69e8UkMH0b15Doto+p8rMRZqXL1FtFilJPGSIMEqDCq53JtGWmQigapfil1Wt6fja7i52LECqN6IsSWkQaJNUisQZKkMar2HWU5wFYo3RilEDVGGqSoQaq3EQ2jBBojVhhh1U8J4twcJbhOpiDh04xUZkWHVlRouX5wjuPcF3GGbwSpdFw4H81DvG0icv2M2J4AbAxQf/xvTwDrEhTrEhTrEtTPRuwJUIwBOFoDoDFAffd4TwDrpkKMGzsI2RqAjAGicUUD2B5Fd6cBsENrencEBiVZA2xui+4PaICiNYB1CRisAcQYQLI1ANkCYH1Swct6AGeqGBWFUQwaI9AYicIoaZDqM5GGUX21omWkkRw0zkXjth0RrAHYGGB75zFNzJclGawAkDEAWZeAgzXA5pHy/WUx3D5SbgEYl6BsH8i2ANgYIFqXIFqXIBmPM0siY4BsXYIdJhMNADQGwGgNYDwdKjssLjUAxBiAwBrAugRs7QO2jiIxLgGFaA1QjAHq0wzM824tXgOUTxt53CZnhQ0/bgMKHFDgoAKnvndz36ZEhU153IaCwgYVNvXYWV5mwmmL/3ublc3T+zb8uE1967SEOFegby4Tf9qUh214ZeP0vo0CJypwogInBYUNKGzkcZt6u9Ow4cdtICls6HGb+hNridK8qpYIwq1V/czv1L98WsWpM/7eSkJQWamwVrJPtaxYY7Vy2n9qZ2YrDunWijRWOaqsUGUlGqt6j9m0UqmBKuVRhVVUyheV8kWlPKmUJ5UarFKDVWqs3AhuWVV7hCjLWDdKrljJ41a0dqOwZaXCItvdVQqcrAGKMYBEawDjEsQQrQGsSxCDNQBYA4gxQMrWAGwMkJM1gHFjF8G6ogEaA6B1RSPb7UaKYrsoRSkEa4DNbdHdYwwTgBgDROsSbN8oagGQMUCO1gBoDfD4wZFpQRc0RqwwwqQxIoVR0SCVojCioDHSSE4a57Jx254kWQMUW4AcbE96TABoDBCtS7DDKYP7AMn2nMQEwMYA2boE2weyLYBiDIDWJUDrEhTjcWYuaAxA1iUgNgYwPmUwAYgxgPV0CIxPGdAeF0DuA8RkDWBdgmTtg2QdRdm6BNm4osEOtz7vA6wkBg9hXm+JIV1GO/WUC5B5xpgUuYBUUy5wzPNPc8R4/fEHofpeT1hGwNOybepJaCWddIC4KFRaCkXMM6GIAvcJTZu1809LKnBDaCXT8hWhGL4l9GGGKrP6gbKWGdaXm1Lkea43FfLKjaWWQWNa8pnXCqaFgYYbp13v2Y3TH8v3qmF9eeqJhOrb/88kxM4IJW8KJW8KZW8K1TdDnkioPud8JqHijFB9c+aZhNAbIW9dR/FW7Yu3hlG61zJZEsS8nez7nlCJ3cdDwrIQErwltIvLloObb1sjLULzE0UULvoAygeffTr7Hfk406d+jsGQzzT0n79FrvAhX3zAmT779POP8JEl3eDVBHnhg9EZH2f6FGf6EDvrwTh1JjQ1g7i0iHDbgzF1J7RsAVYJSX+Flq3ziVC5//G0hEbLaeQgodzyZ19jFArZGyFvCsXijFCK3giRM0IZvBESZ4QAnRHqv0TSIuROIW8xVLzVsuJNIfLWMHYfYDYIcTQ+ecg7ZKZpABgfJ+IcrQGsS7B9h70FIMYAaF0CtC6BceqbCcD4rAzvkFe5AWBdArYuAVuXQKI1gPHlB9nhHHcDwLoE0boEO5zjvg+QsjWA8SWglfwL929ZiCK5KQkEjRFojBSXdWTlwYGGkQZJc1lnJWdAWQKhwNU2EOXqkl6+HNO7eusollj7muewiXKVIYTpkw74oiOO6PBK+oTn0fGlTvSlTr2TeBqd+jTveXTIFZ16d2VIZ+k903VKloVOcUUHgi864IuOuKKDvtRBdkWnbG8GY1mynKVI39D5gCBzCIr2EGgPIeYQ9Vtu+0LYu1vs3S3FGmIlV9O+EGgPYR60MWZ7CPOgjanl7vItxIdRURjloDECjRErjCBpjDRCoEZy1CAVjeT17dBCy3qnpIqRKIxIg1RffG4ZVSsS5eVYZuk5j4n1nuJ5dIonOiv5rQzp3B2Lpnpv9Tw64opOvRd8Hh12RSf5UieRKzp5ezPYGN6kXMwhINhDgD0Em0PUE6LtC2Hv7mLv7oLmEGRfCrIPWrIPWrYPWrYPWmm5m6UFgWG+cxYR8xWEfEKINUQOsB1iOSE4aeP3ggWvZLl7qKwFL+88XKcdmeWMaA7RHP/sAMGbIaYqOEMwQisoSlkubpWrg5QrF//K7GbCCK2gkG8y1+SboMj4OmWFuL2sy7W5t1cIPJd1Jevr7Cq+SkxUL2teGp8cLlPqabT+AbCSjHBHgGIMUKxLUKxLQNYlqO8F7QkgxgArT8zvCMDGACtvKu4IsLmpwDSPshDlBgBCMQZYe1l+PwA0BkjWJUjWJcjWJchgDcDGAJCtAaxr8loC+v0AtjcVS/LFEss3ALffMsXldxvTq0xLWsQ8jRiXj6d58AfzEg7LHA/LXI7KnPJhmfNBmWNw27ZM2ygzc76ayy3ME3hlLsty1jROrTF/UrRI+P5CLa+kq3wSF0e6gCNdwJEuOwx29uNCfrgUR7oUR7psX43ZkUvxw4WDIy7oh4s40kX86FKCn3pUgp/2pUQ//fRK/lYzLsuGnVwtYFZHpAJLljwBvNkEXUn0egTidFDiOR2V+FEVB7fTRcZlis5XaWvn6WIBtws6LeZ4WM2fNZzfgTkdlTkdVnM6rOYc3TKXZRHtmsSFudsF+sbyXxG3myJN5kfVfCVt8SGYu91aaDGPbnv/FvPktlVsMne7ndNint32/k3mbnv/FnM4rOZw2DjHw7Ytfo+htJiXw/ZEfg9ztJjXr4LfTY7MVL+w3TJaSXNxJ78tcwgaIw3SWv6K+0asMEoapKRBqnfWd3O18kre6IZR/XpCy0iDhBok1CDVT8W1jKpt2N28o5ORKIxIg0QapJVkQfeN6k/6tIzK40ayck4nwfJKVJLL49S52qTmBWJan75AlMqn6fJUVUpX92imj9/prKwDP4vOyuLu0+j4ctbKAvLT6JArOuRLnZWDIc+is3I25Gl0fFV09lXRxVcoi6dQlrBybOVpdNAXHU89uqykjH4eHU8VXVZSRj+PjqceXVZSRj+Pjq+KDp56dFlJGf08Or4q+sobFU+j46uiF18Vvfga70jvmgUXOlevW3/SibFznzXtP850CMItHXJFJ0VfdNAXHXFFJ2dfdHyFMviq6OBLHfRV0UvnmpXj/MMpp3hDh8AXHV/qMLmi03u5qUXHlTopuFInhd6DU5GFTrwZDaYYfdFBX3TEFZ2UfdEhV3Syr1DOvkK5+3JTg44vdbpvXDfo+Gp3ii91uu8U36WT6/tZkZZVoUjxQgeo9lawwHycTfDbbKkfEMUaYiXv3WMQMfDydbh6XmQy/QCp577bG4Q7gNSrxN4g0gGkflFtX5CVxEx7g3SQC3MPuRis6zuymEMIWUOs3ODeF8JcqILmQlF96pDikpN/2rrwm5NfuH4pNYZlVS0Gwu+7Zq5fCG1a1T0eYcmGH6/vzX5a1bd5mlYaLKlnW2lZ1Xd+mlb1sUekS151udFQ6vsoLauV6gxLKE1/vGVY3ytuWdWzljWtisaqfro7Yl6UR6RbK9RYkQqrnq2yZVV/PLZpJRqr+im2+1YxrJw2a5uRymylijXNdGhJV7akUzLr0LKozFaaAiRZzEQqZqwyW2kMmmZFZbZSsfPyOOi0s8m3Zis1u2kGOjNWmdUfbWqbFZWZ6CQRlQNiCDoz0JmpHLByvqNttuIAXN6FyuW2mq6cl2ibkcosg85MVGaAKjMMOjMlmjw+IJnMStaZkcqsnvGzZbbyvhRME6Nl7e5qXvR2zfR2anH3PteEUb+2uDMG2WPUL0Xew/i0Q51dPcr/gB0o7VhnVw/0P2BHOjtS+qF+36htx0q8+tQYElzWxQtU7Oo97h+wA6WdqOwggNJOiReVePUbDW27+tWDP2BHOrv66P8P2BWdHQSlHSrtVvxOsNgJN9roe19/oNTPke+Owj1QSuqCUnqgrLTaO6PIDjH25t5l8RLK7UgAI+2BUi47FBQqKCn1KEsqe6BcrS1fvVz5hnL7NS/zJM7Q+PZuEpKJfQ6HZg+e2d/NRvLGXo7MHg6tPaZDs6cjsy+H1r4cWvs9RhGG7f29ZEJv7PHI7Nl3X9tif2jt5dDay7G1dz3OabAvIbtu7++vuZbAR2YfD619ct3XNtm7nte22Pue1zbZQ3f2yz4X51or+IS5aoMRZHeMyBsjjO4YFW+MijuNCrpjJB3WawtBF5QuZeEeK9xFUhcU7oBCAXugxNAFpfRA2Wd82UTpUpbcxS+5S4xBl7JAl1qJuQdKfX2Dlg1xwu/TkbzdT6pSE5iH4VJSxYgURvWK1jJCjVH9qNzd2yCT2cqhw6YZq8zqI++2mQ4NdWioQys6tKJDI53fSIfGurLVhzJNM4k6M9SZqSqOBHi84ZH6mprE5ZHlXDGqd6MNo3qv2DICjZGmTPX0XfebOAFFC7xyE6phVL/S1DJSNNsrF5paRiqkapxLmQN2+uDWqH5Xt2WkQarfp71r9HbbR2OkQYoapPpg/spPNSPFkCGu3HpqGGUNUn05r2FUP/HRMMKgMSKFUUkaI1YYUdYYaZBYUybWhJFo/CSKiIgha4wU6sWoQXq05v5n+tv//vjb1x//8vNP/5ws3v7xX7/89fevv/7y+dff/+8f87/85bevP//89e9//sdvv/71p7/967ef/vzzr399+7cv4fM//5Vigh9SBJzovPFPU737IQWE9xZ2+h8xcfxh+k955/v2RU7hh+k/aeIy8fl/",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_participant_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_participant_escrows"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 20,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "register_dkim_bulk",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim_bulk"
      ]
    },
    {
      "name": "get_escrow_registry_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_escrow_registry_status"
      ]
    },
    {
      "name": "register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7921989071249124615": {
            "error_kind": "string",
            "string": "Function register_participant can only be called internally"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "register_participant_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2564696720034330091": {
            "error_kind": "string",
            "string": "Function register_participant_escrow can only be called internally"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3drutKcqX7LnW9L8hk8M+vcrBh2G53o4CCq2G7D3DQ8LsfrR9xaq0IiRbFOZQz8uuLxtou5ZT0jUExxmBK/L9/+R//+s//53/941//7X/+/T/+8g//z//9y9/+/i//9J9//fu/Xf7r//6lH77/3/7jf//Tv337z//4z3/69//8yz/009r98Zd//bf/cfnn3HX/9cdf/udf//avf/kHm+2//nCPLsuw/Hx0WaaPR/e2Bo8exn79+ehhXMvOo5d1Hn8+elmXdXv00A3Bo/t5Ga6ve+k+/naZogd3Zbo+uJvH2wf/+cdfegNMDGYETAxmeh2MdeP1xVu39tujlx/PMH/6MyyvP0M/dHZ99DCsN3ItwaPXdex/Pnpdp+X29QS+KcNy/dulWD/8/vLXL/3yS/fsy/+2qI8WrUt/9fW6WL/7nsu6vef542X14/D9KcrnP8Xw+U9hn/8U4+c/xXTCU1g/X5/Cbkz77SmiD+vtE6Ms88ffLmv0t4eulOuH9fdDZvv47aMP63F73Zdn6XY+rJdi26PLzWdX/OhhvH5YW+kef7CXsl6Zl6HfOwsM/YdAw/LKKaPMiJlHzAUx84i5ImYaMYcOMfOI2SNmHjELYuYRc0DMPGIaYuYRc0TMPGLSACUSkwYokZg0QInEpAHKI6bRACUSkwboE8ScN+Rltp0Hn7hrwmiAEompb4DWbpOnm4YdMVuXx5CnZnnkLc3Q9x8fbuO0I08x2873tswff3uOXsiybG917W62sSzf3+qU6a2u2wmlX+fl9q36B9t0fdG23lBZv1OZE1EpXXfdGVe6Yi9QWTJR6beXXfrb3YU/Dos101u9PPr64LIMjw3QD8vHq+7G37iMHVxCLn2zXMZhO+2ON6/j6U+XsYDwVYRDuwi37xr04/rCmX80EL6KUD89d6t9IJx3EJptwO3y/x4jHObtnQ7LzfcELg/+9lanTG91Wa9z4rD6tzq381aXdt7q2sxbnbp23mrfzlst7bzVoZ23au281VTT0uO3+t5padq7wtR31n2Uwv3jtzr2258eS2+/v9W5nbe6tPNW12be6txleqvFpu2tTtPvb7Vv562Wdt7q0M5btUxvdZqvI8Q49zvzxjwNVy7ztPw+b8wjXEIuqeawpd+4LGN5iUuqoe05Luv1Vc9z3//OJdWEdyKXM8bBxz8ysnSf/xS5yqJtK9KwjPNvgi25yqKHb/WU8afr7r3Vb09h4VOs2/6udb35iL3zFP3HU/T9x1X1eFOnbXvYbLCbx4Zb2LJtSlviaWYdPn72apn2cM/Txy9Y3Sg6/RA0ngvW9eNVdWX3Kbphu4zYLTf7JKY+vOi4sbyls8xNKDrDW8p7gbeU9wpvJe+1O4N3/3GKKP28x3ve9pb2twPyPS2X7dHd7RaTy9D+7fX3X/z1ly/++ocv/vpt//Xb7utft9dfur775TmCz5Du4yPk43Cc1nC4vz7Ubr5RMYWfNWWrKYYyf+xNLj/e5pjlbQ7b9rRhWKff3+bUhppzG2oubai5NqHm5V00IWff9Y3oWbK8z4f7dS9hQv8+17L9bdt5o5frE9cyZ7h57Zfn+P7iTf7i+278ePWzPX7147yVeZdLVB+j37FfkO/Gpt7tVPm7Xebr65+6m6/Lhe92Xtbt0L7tacuPt/rfmHimdeetDvP2pYmbkvlbJPbs+/LxTb+b0LzGn0rbS7fy+KHDtGWXYeo/tAm/Ij1eP5WWmy9trD8/fBeA/ApkBcgvQPquYiC/fI7cXFQIH/zEqdzKhsTK/Mu3jILPJ+u2HTJ2+yXn9QfAHoCvASwAfA3gAMDXABoAXwM4AvA1gBMAXwNY8+T/JQDWnBS+BMCak8VXAFhIIi8CJIm8CJAk8iJAksiLAA2ArwEkibwIkCTyIkCSyIsASSIvAiSJvAZwIIm8CJAk8iJAksiLAEkiLwI0AL4GkCTyIkCSyIsASSIvAiSJvAiQJPIaQCOJvAiQJPIiQJLIiwBJIi8CtBYBTt11U7xNN98KvzJpMlzsMGkyL+wwaTIC7DBpcqqftvuX2TR7Jk0O6o+ZjE3O3jtMmhynd5g0OSHvMGly6H183hmZYz0T5ljPhDnWM2lzjn38Gcsc65kwxzomE3OsZ8Ic65kwx3ombc6xj5kYTByTNufYx0zanGMfM6GP9UzanGMfM2lzjn3IZG5zjn3MhDnWM2GO9UyYYz0Tg4ljwhzrmTDHeib0sZ4JfaxnQh/rmCz0sZ5Jm3Psw9l+aXOOfcyEfQWeicHEMWGO9UyYYz0T5ljPhDnWM2GOdUxW5ljPhD7WM6GP9UzoYz0Tg4ljwv5Yz4T9sZ4J+wo8E/YVeCbMsb8zKR1zrGfCHOuZMMd6JsyxnonBxDGhj/VM6GM9E/pYz4Q+1jNhf6xj0uadHHeYsK/AM2FfgWfCHOuZGEwcE+ZYz4Q51jNhjvVMmGM9E/pYx6TN+wDuMKGP9UzoYz0T9sd6JgYTx4R9BZ4J+wo8E+ZYz4Q51jNhjnVM2ryL3A4T5ljPhDnWM6GP9UwMJo4JfaxnQh/rmbA/1jNhf6xnwr4Cx6TNe5DtMGGO9UyYYz0T5ljPxGDimDDHeibMsZ4JfaxnQh/rmdDHOibczytgwv5Yz4T9sZ4J+wo8E4OJY8Ic65kwx3omzLGeCXOsZ8Ic65hwP6+ACX2sZ0If65nQx3omBhPHhP2xngn7Yz0T9hV4Juwr8EyYYx2TRu/n9ZgJc6xnwhzrmTDHeiYGE8eEPtYzoY/1TOhjPRP6WM+E/bGOSaP383rMhH0Fngn7CjwT5ljPxGDimDDHeibMsZ4Jc6xnwhzrmdDHOibczytgQh/rmdDHeibsj/VMDCaOCfsKPBP2FXgmzLGeCXOsZ8Ic+zuTgft5BUyYYz0T5ljPhD7WMzGYOCb0sZ4Jfaxnwv5Yz4T9sZ4J+wocE+7nFTBhjvVMmGM9E+ZYz8Rg4pgwx3omzLGeCX2sZ0If65nQxzom3M8rYML+WM+E/bGeCfsKPBODiWPCHOuZMMd6JsyxnglzrGfCHOuYcD+vgAl9rGdCH+uZ0Md6JgYTx4T9sZ4J+2M9E/YVeCbsK/BMmGMdk0bv5/WYCXOsZ8Ic65kwx3omBhPHhD7WM6GP9UzoYz0T+ljPhP2xjkmj9/N6zIR9BZ4J+wo8E+ZYz8Rg4pgwx3omzLGeCXOsZ8Ic65nQxzom3M8rYEIf65nQx3om7I/1TAwmjgn7CjwT9hV4JsyxnglzrGfCHOuYcD+vgAlzrGfCHOuZ0Md6JgYTx4Q+1jOhj/VM2B/rmbA/1jNhX4Fjwv28AibMsZ4Jc6xnwhzrmRhMHBPmWM+EOdYzoY/1TOhjPRP6WMeE+3kFTNgf65mwP9YzYV+BZ2IwcUyYYz0T5ljPhDnWM2GO9UyYY39nYtzPK2BCH+uZ0Md6JvSxnonBxDFhf6xnwv5Yz4R9BZ4J+wo8E+ZYx6TR+3k9ZsIc65kwx3omzLGeicHEMaGP9UzoYz0T+ljPhD7WM2F/rGPS6P28HjNhX4Fnwr4Cz4Q51jMxmDgmzLGeCXOsZ8Ic65kwx3om9LGOCffzCpjQx3om9LGeCftjPRODiWPCvgLPhH0FnglzrGfCHOuZMMc6JtzPK2DCHOuZMMd6JvSxnonBxDGhj/VM6GM9E/bHeibsj/VM2FfgmHA/r4AJc6xnwhzrmTDHeiYGE8eEOdYzYY71TOhjPRP6WM+EPtYx4X5eARP2x3om7I/1TNhX4JkYTBwT5ljPhDnWM2GO9UyYYz0T5ljHhPt5BUzoYz0T+ljPhD7WMzGYOCbsj/VM2B/rmbCvwDNhX4FnwhzrmDR6P6/HTJhjPRPmWM+EOdYzMZg4JvSxngl9rGdCH+uZ0Md6JuyPdUwavZ/XYybsK/BM2FfgmTDHeiYGE8eEOdYzYY71TJhjPRPmWM+EPvZ3JiP38wqY0Md6JvSxngn7Yz0Tg4ljwr4Cz4R9BZ4Jc6xnwhzrmTDHOibczytgwhzrmTDHeib0sZ6JwcQxoY/1TOhjPRP2x3om7I/1TNhX4JhwP6+ACXOsZ8Ic65kwx3omBhPHhDnWM2GO9UzoYz0T+ljPhD7WMeF+XgET9sd6JuyP9UzYV+CZGEwcE+ZYz4Q51jNhjvVMmGM9E+ZYx4T7eQVM6GM9E/pYz4Q+1jMxmDgm7I/1TNgf65mwr8AzYY71TNhX4JhwP6+ACX2sZ8Ic65nQx3omBhPHhDnWM2GO9UzoYz0T5ljPhD7WMeF+XgET+ljPhDnWM6GP9UwMJo5Jk3PsvPTXx843r/jKpMk5tozz9bFl/oWJf/DlUumVxeVqmDmATQ69ZwJsckI+E2CT4/SJANu8B9mZAJsc1M8E2ORUfybAJiPAmQANgK8BbDJcnAmQJPIiQJLIiwBJIi8CJIm8BrDNu8idCZAk8iJAksiLAEkiLwI0AL4GkCTyIkCSyIsASSIvAiSJvAiQJPIawDbvA3gmQJLIiwBJIi8CJIm8CNAA+BpAksiLAEkiLwIkibwIkCTyIkCSyEsAp0bv5Pjom1ZTo3dyfMyEX1z0TPiGr2difDPCMeEXFz0TfnHRM+Ebvp4J3/D1TPilGsek0Ts5PmbCHOuZMMd6JnzD1zMxmDgmzLGeCXOsZ8Ic65kwx3om/FKNY9LonRwfM+GXajwTfqnGM6GP9UwMJo4Jv7jomfCLi54Jc6xnwhzrmTDHOibcyTFgwhzrmTDHeib0sZ6JwcQxoY/1TOhjPRPugOOZtDnHPmbCvgLHpNE7OT5mwhzrmTDHeibMsZ6JwcQxYY71TJhjPRP6WM+EPtYzoY91TBq9k+NjJuyP9UzYH+uZsK/AMzGYOCbMsZ4Jc6xnwhzrmTDHeibMsY4Jd3IMmNDHeib0sZ4JfaxnYjBxTNgf65mwP9YzYV+BZ8K+As+EOdYxafOuiDtMmGM9E+ZYz4Q51jMxmDgm9LGeCX2sZ0If65nQx3om7I91TNq8p94OE/YVeCbsK/BMmGM9E4OJY8Ic65kwx3omzLGeCXOsZ0If65i0eUe2HSb0sZ4Jfaxnwv5Yz8Rg4piwr8AzYV+BZ8Ic65kwx3omzLG/M5kbvZ/XYybMsZ4Jc6xnQh/rmRhMHBP6WM+EPtYzYX+sZ8L+WM+EfQWOCffzCpgwx3omzLGeCXOsZ2IwcUyYYz0T5ljPhD7WM6GP9UzoYx0T7ucVMGF/rGfC/ljPhH0FnonBxDFhjvVMmGM9E+ZYz4Q51jNhjnVMuJ9XwIQ+1jOhj/VM6GM9E4OJY8L+WM+E/bGeCfsKPBP2FXgmzLGOSaP383rMhDnWM2GO9UyYYz0Tg4ljQh/rmdDHeib0sZ4Jfaxnwv5Yx6TR+3k9ZsK+As+EfQWeCXOsZ2IwcUyYYz0T5ljPhDnWM2GO9UzoYx0T7ucVMKGP9UzoYz0T9sd6JgYTx4R9BZ4J+wo8E+ZYz4Q51jNhjnVMuJ9XwIQ51jNhjvVM6GM9E4OJY0If65nQx3om7I/1TNgf65mwr8Ax4X5eARPmWM+EOdYzYY71TAwmjglzrGfCHOuZ0Md6JvSxngl9rGPC/bwCJuyP9UzYH+uZsK/AMzGYOCbMsZ4Jc6xnwhzrmTDHeibMsb8zWbifV8CEPtYzoY/1TOhjPRODiWPC/ljPhP2xngn7CjwT9hV4Jsyxjkmj9/N6zIQ51jNhjvVMmGM9E4OJY0If65nQx3om9LGeCX2sZ8L+WMek0ft5PWbCvgLPhH0FnglzrGdiMHFMmGM9E+ZYz4Q51jNhjvVM6GMdE+7nFTChj/VM6GM9E/bHeiYGE8eEfQWeCfsKPBPmWM+EOdYzYY51TLifV8CEOdYzYY71TOhjPRODiWNCH+uZ0Md6JuyP9UzYH+uZsK/AMeF+XgET5ljPhDnWM2GO9UwMJo4Jc6xnwhzrmdDHeib0sZ4Jfaxjwv28Aibsj/VM2B/rmbCvwDMxmDgmzLGeCXOsZ8Ic65kwx3omzLGOCffzCpjQx3om9LGeCX2sZ2IwcUzYH+uZsD/WM2FfgWfCvgLPhDnWMWn0fl6PmTDHeibMsZ4Jc6xnYjBxTOhjPRP6WM+EPtYzoY/1TNgf65g0ej+vx0zYV+CZsK/AM2GO9UwMJo4Jc6xnwhzrmTDHeibMsZ4JfezvTFbu5xUwoY/1TOhjPRP2x3omBhPHhH0Fngn7CjwT5ljPhDnWM2GOdUy4n1fAhDnWM2GO9UzoYz0Tg4ljQh/rmdDHeibsj/VM2B/rmbCvwDHhfl4BE+ZYz4Q51jNhjvVMDCaOCXOsZ8Ic65nQx3om9LGeCX2sY8L9vAIm7I/1TNgf65mwr8AzMZg4JsyxnglzrGfCHOuZMMd6Jsyxjgn38wqY0Md6JvSxngl9rGdiMHFM2B/rmbA/1jNhX4Fnwr4Cz4Q51jFp9H5ej5kwx3omzLGeCXOsZ2IwcUzoYz0T+ljPhD7WM6GP9UzYH+uYNHo/r8dM2FfgmbCvwDNhjvVMDCaOCXOsZ8Ic65kwx3omzLGeCX2sY8L9vAIm9LGeCX2sZ8L+WM/EYOKYsK/AM2FfgWfCHOuZMMd6Jsyxjgn38wqYMMd6Jsyxngl9rGdiMHFM6GM9E/pYz4T9sZ4J+2M9E/YVOCbczytgwhzrmTDHeibMsZ6JwcQxYY71TJhjPRP6WM+EPtYzoY/9ncnlHVPIBlDYIRtAYYtsAIW9BQEU4zPFQ2F3QQCF7QUBFHrZAAoDbQCFZtZDafTWXjtQmGgDKEy0ARTa2QCKAcVDoZ8NoFDQBlBoaAMoTLQBFDpaD6XRm3ztQGlyop2X/vrY+eYVb1CanGjLOF8fW+ZfoPgHj9ZdWYxWzBNscvw9laBB8EWCTQ7WpxJscgo/lWCTI/upBJuc708l2GQYOJNgm7dVO5VgkzHjVIJkklcJkkleJWgQfJEgmeRVgmSSVwmSSV4lSCZ5lSCZ5EWCbd4i71SCZJJXCZJJXiVIJnmVoEHwRYJkklcJkkleJUgmeZUgmeRVgmSSFwm2ebvDUwmSSV4lSCZ5lSCZ5FWCBsEXCZJJXiXId4L9budG7wG5A4Ufawyg8J1gD6XR20A+/gZFo/eB3IHCDzYGUPhOcADFgOKh8Cs3ARQm2gAKE20AhYk2gMJ3gj0UbggZQWGiDaAw0QZQmGgDKAYUD4VfuQmg8Cs3ARR+5SaAwq/cBFDoaD2URm8NuQOF320MoPC7jQEUJtoAigHFQ2GiDaAw0QZQmGgDKEy0ARQ6Wg+l0ZtE7kChow2g0NEGULi3TgDFgOKhsOsggMKugwAKE20AhYk2gMJE66D03C0ygsJEG0Bhog2g0NEGUAwoHgodbQCFjjaAwj7aAAr7aAMo7DrwULhbZASFiTaAwkQbQGGiDaAYUDwUJtoAChNtAIWONoBCRxtAoaP1ULhbZASFfbQBFPbRBlDYdRBAMaB4KEy0ARQm2gAKE20AhYk2gMJE66G0eRfDPSh0tAEUOtoACh1tAMWA4qGwjzaAwj7aAAq7DgIo7DoIoDDReiht3gNvDwoTbQCFiTaAwkQbQDGgeCh0tAEUOtoACh1tAIWONoDCPloPpc07qO1BYddBAIVdBwEUJtoAigHFQ2GiDaAw0QZQmGgDKEy0ARQ6Wg+Fe4ZFUOhoAyh0tAEU9tEGUAwoHgq7DgIo7DoIoDDRBlCYaAMoTLQeCvcMi6Aw0QZQmGgDKHS0ARQDiodCRxtAoaMNoLCPNoDCPtoACrsOPBTuGRZBYaINoDDRBlCYaAMoBhQPhYk2gMJEG0Chow2g0NEGUOhoPRTuGRZBYR9tAIV9tAEUdh0EUAwoHgoTbQCFiTaAwkQbQGGiDaAw0ToohXuGRVDoaAModLQBFDraAIoBxUNhH20AhX20ARR2HQRQ2HUQQGGi9VAavWfYDhQm2gAKE20AhYk2gGJA8VDoaAModLQBFDraAAodbQCFfbQeSqP3DNuBwq6DAAq7DgIoTLQBFAOKh8JEG0Bhog2gMNEGUJhoAyh0tB4K9wyLoNDRBlDoaAMo7KMNoBhQPBR2HQRQ2HUQQGGiDaAw0QZQmGg9FO4ZFkFhog2gMNEGUOhoAygGFA+FjjaAQkcbQGEfbQCFfbQBFHYdeCjcMyyCwkQbQGGiDaAw0QZQDCgeChNtAIWJNoBCRxtAoaMNoNDReijcMyyCwj7aAAr7aAMo7DoIoBhQPBQm2gAKE20AhYk2gMJEG0BhovVQuGdYBIWONoBCRxtAoaMNoBhQPBT20QZQ2EcbQGHXQQCFXQcBFCZaD6XRe4btQGGiDaAw0QZQmGgDKAYUD4WONoBCRxtAoaMNoNDRBlDYR+uhNHrPsB0o7DoIoLDrIIDCRBtAMaB4KEy0ARQm2gAKE20AhYk2gEJH66AM3DMsgkJHG0Chow2gsI82gGJA8VDYdRBAYddBAIWJNoDCRBtAYaL1ULhnWASFiTaAwkQbQKGjDaAYUDwUOtoACh1tAIV9tAEU9tEGUNh14KFwz7AIChNtAIWJNoDCRBtAMaB4KEy0ARQm2gAKHW0AhY42gEJH66Fwz7AICvtoAyjsow2gsOsggGJA8VCYaAMoTLQBFCbaAAoTbQCFidZD4Z5hERQ62gAKHW0AhY42gGJA8VDYRxtAYR9tAIVdBwEUdh0EUJhoPZRG7xm2A4WJNoDCRBtAYaINoBhQPBQ62gAKHW0AhY42gEJHG0BhH62H0ug9w3agsOsggMKugwAKE20AxYDioTDRBlCYaAMoTLQBFCbaAAodrYfCPcMiKHS0ARQ62gAK+2gDKAYUD4VdBwEUdh0EUJhoAyhMtAEUJloPhXuGRVCYaAMoTLQBFDraAIoBxUOhow2g0NEGUNhHG0BhH20AhV0HHgr3DIugMNEGUJhoAyhMtAEUA4qHwkQbQGGiDaDQ0QZQ6GgDKHS0Dopxz7AICvtoAyjsow2gsOsggGJA8VCYaAMoTLQBFCbaAAoTbQCFidZD4Z5hERQ62gAKHW0AhY42gGJA8VDYRxtAYR9tAIVdBwEUdh0EUJhoPZRG7xm2A4WJNoDCRBtAYaINoBhQPBQ62gAKHW0AhY42gEJHG0BhH62H0ug9w3agsOsggMKugwAKE20AxYDioTDRBlCYaAMoTLQBFCbaAAodrYfCPcMiKHS0ARQ62gAK+2gDKAYUD4VdBwEUdh0EUJhoAyhMtAEUJloPhXuGRVCYaAMoTLQBFDraAIoBxUOhow2g0NEGUNhHG0BhH20AhV0HHkqj9wx7/JnCPcMip7DrIIBCRxtAMT5TPBQ62gAKHW0AhYk2gMJEG0Cho/VQuGdYBIWONoBCRxtAoaMNoBhQPBQ62gAKHW0ApcmJdl7662Pnm1e8QWlyoi3jfH1smX+B4h88WndlMVoxT7DJ8fdMgm3ejexUgk0O1qcSbHIKP5VgkyP7qQQNgi8SbDIMnEqwyeRwKsEmY8apBMkkrxIkk7xIsM37yZ1KkEzyKkEyyasEySSvEjQIvkiQTPIqQTLJqwTJJK8SJJO8SpBM8hrBsc07Ap5KkEzyKkEyyasEySSvEjQIvkiQTPIqQTLJqwTJJK8SJJO8SpBM8iLBNu/peCpBMsmrBPlOcOeh8J3gAIoBxUPhO8EBFL5BEUDhdxsDKPxuYwCF7wR7KNwtMoLCr9wEUJhoAyhMtAEUA4qHwneCAyhMtAEUJtoAChNtAIWJ1kNp9G6RO1D4lZsACr9yE0DhV24CKAYUD4WONoDC7zYGUPjdxgAKv9sYQGGi9VC4W2QEhYk2gMJEG0Bhog2gGFA8FDraAAodbQCFjjaAQkcbQOHeOh5Ko3eL3IHCroMACrsOAihMtAEUA4qHwkQbQGGiDaAw0QZQmGgDKHS0Hgp3i4yg0NEGUOhoAyjsow2gGFA8FHYdBFDYdRBAYaINoDDRBlCYaD0U7hYZQWGiDaAw0QZQ6GgDKAYUD4WONoBCRxtAYR9tAIV9tAEUdh14KG3e03EPChNtAIWJNoDCRBtAMaB4KEy0ARQm2gAKHW0AhY42gEJH66G0eUfAPSjsow2gsI82gMKugwCKAcVDYaINoDDRBlCYaAMoTLQBFCZaB2Vq835ye1DoaAModLQBFDraAIoBxUNhH20AhX20ARR2HQRQ2HUQQGGi9VDavBvZHhQm2gAKE20AhYk2gGJA8VDoaAModLQBFDraAAodbQCFfbQeSqP3DNuBwq6DAAq7DgIoTLQBFAOKh8JEG0Bhog2gMNEGUJhoAyh0tB4K9wyLoNDRBlDoaAMo7KMNoBhQPBR2HQRQ2HUQQGGiDaAw0QZQmGg9FO4ZFkFhog2gMNEGUOhoAygGFA+FjjaAQkcbQGEfbQCFfbQBFHYdeCjcMyyCwkQbQGGiDaAw0QZQDCgeChNtAIWJNoBCRxtAoaMNoNDReijcMyyCwj7aAAr7aAMo7DoIoBhQPBQm2gAKE20AhYk2gMJEG0BhovVQuGdYBIWONoBCRxtAoaMNoBhQPBT20QZQ2EcbQGHXQQCFXQcBFCZaD6XRe4btQGGiDaAw0QZQmGgDKAYUD4WONoBCRxtAoaMNoNDRBlDYR+uhNHrPsB0o7DoIoLDrIIDCRBtAMaB4KEy0ARQm2gAKE20AhYk2gEJH66DM3DMsgkJHG0Chow2gsI82gGJA8VDYdRBAYddBAIWJNoDCRBtAYaL1ULhnWASFiTaAwkQbQKGjDaAYUDwUOtoACh1tAIV9tAEU9tEGUNh14KFwz7AIChNtAIWJNoDCRBtAMaB4KEy0ARQm2gAKHW0AhY42gEJH66Fwz7AICvtoAyjsow2gsOsggGJA8VCYaAMoTLQBFCbaAAoTbQCFidZD4Z5hERQ62gAKHW0AhY42gGJA8VDYRxtAYR9tAIVdBwEUdh0EUJhoPZRG7xm2A4WJNoDCRBtAYaINoBhQPBQ62gAKHW0AhY42gEJHG0BhH62H0ug9w3agsOsggMKugwAKE20AxYDioTDRBlCYaAMoTLQBFCbaAAodrYfCPcMiKHS0ARQ62gAK+2gDKAYUD4VdBwEUdh0EUJhoAyhMtAEUJloPhXuGRVCYaAMoTLQBFDraAIoBxUOhow2g0NEGUNhHG0BhH20AhV0HHgr3DIugMNEGUJhoAyhMtAEUA4qHwkQbQGGiDaDQ0QZQ6GgDKHS0DsrCPcMiKOyjDaCwjzaAwq6DAIoBxUNhog2gMNEGUJhoAyhMtAEUJloPhXuGRVDoaAModLQBFDraAIoBxUNhH20AhX20ARR2HQRQ2HUQQGGi9VAavWfYDhQm2gAKE20AhYk2gGJA8VDoaAModLQBFDraAAodbQCFfbQeSqP3DNuBwq6DAAq7DgIoTLQBFAOKh8JEG0Bhog2gMNEGUJhoAyh0tB4K9wyLoNDRBlDoaAMo7KMNoBhQPBR2HQRQ2HUQQGGiDaAw0QZQmGg9FO4ZFkFhog2gMNEGUOhoAygGFA+FjjaAQkcbQGEfbQCFfbQBFHYdeCjcMyyCwkQbQGGiDaAw0QZQDCgeChNtAIWJNoBCRxtAoaMNoNDReijcMyyCwj7aAAr7aAMo7DoIoBhQPBQm2gAKE20AhYk2gMJEG0BhovVQuGdYBIWONoBCRxtAoaMNoBhQPBT20QZQ2EcbQGHXQQCFXQcBFCZaD6XRe4btQGGiDaAw0QZQmGgDKAYUD4WONoBCRxtAoaMNoNDRBlDYR+ugrI3eM2wHCrsOAijsOgigMNEGUAwoHgoTbQCFiTaAwkQbQGGiDaDQ0Xoo3DMsgkJHG0Chow2gsI82gGJA8VDYdRBAYaINoLDrIIDCroMACh2th8I9w4LPlEbvGbbjFDraAAoTbQDFgOKh0NEGUJhoAyh0tAEUOtoACh2th9LoPcN2oNDRBlDoaAMoTU6089JfHzvfvOINitUMpe+uD+77eQdKGbvrOy2jfWBZIyyT2frzwdPFLLcP/oGl6pn2fViqnmrfh6XqufZ9WKqebN+HperZ9m1Y6r5/2PuwVD3fvg9L1RPu+7BUPeO+D4uBJcLClBtiYcoNsTDlhliYckMsTLkRlrrvKfY+LEy5IRam3BALU26IxcASYWHKDbEw5YZYmHJDLEy5IRam3AhL3fcZex8WptwQC1NuiIUpN8RiYImwMOWGWJhyQyxMuSEWptwQC1NuhKXue4+9DwtTboiFKTfEwpQbYjGwRFiYckMsTLkhFqbcEAtTboiFKTfCUvf9yN6HhSk3xMKUG2Jhyg2xGFgiLEy5IRam3BALU26IhSk3xMKUG2Gp+x5l78PClBtiYcoNsTDlhlgMLBEWptwQC1NuiIUpN8TClBtiYcr1WEpX933L3oeFKTfEwpQbYmHKDbEYWCIsTLkhFqbcEAtTboiFKTfEwpQbYan7Xmbvw8KUG2Jhyg2xMOWGWAwsERam3BALU26IhSk3xMKUG2Jhyo2w1H1/s/dhYcoNsTDlhliYckMsBpYIC1NuiIUpN8TClBtiYcoNsTDlRljqvufZ+7Aw5YZYmHJDLEy5IRYDS4SFKTfEwpQbYmHKDbEw5YZYmHIjLNz7LMbClBtiYcoNsTDlhlgMLBEWptwQC1NuiIUpN8TClBtiYcqNsHDvsxgLU26IhSk3xMKUG2IxsERYmHJDLEy5IRam3BALU26IhSk3wsK9z2IsTLkhFqbcEAtTbojFwBJhYcoNsTDlhliYckMsTLkhFqbcCAv3PouxMOWGWJhyQyxMuSEWA0uEhSk3xMKUG2Jhyg2xMOWGWJhyIyzc+yzGwpQbYmHKDbEw5YZYDCwRFqbcEAtTboiFKTfEwpQbYmHKjbBw77MYC1NuiIUpN8TClBtiMbBEWJhyQyxMuSEWptwQC1NuiIUpN8DSc++zGAtTboiFKTfEwpQbYjGwRFiYckMsTLkhFqbcEAtTboiFKTfCwr3PYixMuSEWptwQC1NuiMXAEmFhyg2xMOWGWJhyQyxMuSEWptwIC/c+i7Ew5YZYmHJDLEy5IRYDS4SFKTfEwpQbYmHKDbEw5YZYmHIjLNz7LMbClBtiYcoNsTDlhlgMLBEWptwQC1NuiIUpN8TClBtiYcqNsHDvsxgLU26IhSk3xMKUG2IxsERYmHJDLEy5IRam3BALU26IhSk3wsK9z2IsTLkhFqbcEAtTbojFwBJhYcoNsTDlhliYckMsTLkhFqbcCAv3PouxMOWGWJhyQyxMuSEWA0uEhSk3xMKUG2Jhyg2xMOWGWJhyIyzc+yzGwpQbYmHKDbEw5YZYDCwRFqbcEAtTboiFKTfEwpQbYmHKjbBw77MYC1NuiIUpN8TClBtiMbBEWJhyQyxMuSEWptwQC1NuiIUpN8LCvc9iLEy5IRam3BALU26IxcASYWHKDbEw5YZYmHJDLEy5IRam3ABL4d5nMRam3BALU26IhSk3xGJgibAw5YZYmHJDLEy5IRam3BALU26EhXufxViYckMsTLkhFqbcEIuBJcLClBtiYcoNsTDlhliYckMsTLkRFu59FmNhyg2xMOWGWJhyQywGlggLU26IhSk3xMKUG2Jhyg2xMOVGWLj3WYyFKTfEwpQbYmHKDbEYWCIsTLkhFqbcEAtTboiFKTfEwpQbYeHeZzEWptwQC1NuiIUpN8RiYImwMOWGWJhyQyxMuSEWptwQC1NuhIV7n8VYmHJDLEy5IRam3BCLgSXCwpQbYmHKDbEw5YZYmHJDLEy5ERbufRZjYcoNsTDlhliYckMsBpYIC1NuiIUpN8TClBtiYcoNsTDlRli491mMhSk3xMKUG2Jhyg2xGFgiLEy5IRam3BALU26IhSk3xMKUG2Hh3mcxFqbcEAtTboiFKTfEYmCJsDDlhliYckMsTLkhFqbcEAtTboSFe5/FWJhyQyxMuSEWptwQi4ElwsKUG2Jhyg2xMOWGWJhyQyxMuQGWgXufxViYckMsTLkhFqbcEIuBJcLClBtiYcoNsTDlhliYckMsTLkRFu59FmNhyg2xMOWGWJhyQywGlggLU26IhSk3xMKUG2Jhyg2xMOVGWLj3WYyFKTfEwpQbYmHKDbEYWCIsTLkhFqbcEAtTboiFKTfEwpQbYeHeZzEWptwQC1NuiIUpN8RiYImwMOWGWJhyQyxMuSEWptwQC1NuhIV7n8VYmHJDLEy5IRam3BCLgSXCwpQbYmHKDbEw5YZYmHJDLEy5ERbufRZjYcoNsTDlhliYckMsBpYIC1NuiIUpN8TClBtiYcoNsTDlRli491mMhSk3xMKUG2Jhyg2xGFgiLEy5IZY8U+7UXd9pmeb1MZaxG8efDx67xR4/eF6K/XzwvAzFM8wzEn8ew3W9mnbp+uXxg4cL0yuMcvMySv8TeJ5huxLglyuAVxjDOnngecb4TwO+dMO8AZ/K4web9VcYdvl/24P7OQQ3zRu5frh98Hd1Et1j7iuqs2wH2rBG6uQJNRnVyZOtMqqTJ+JlVMdQp2J18gTejOqQu2tWh0RfszrE/5rVabQrKBvwsUzD4weX/uMv9zflTFkjGIuNVxrLePPoof9ZQCa6/ebnIS/D9f2VYvMe8rXbkK99+QV5JNDWVy5mJRCo0Q6gHoH2jqBGa4CvcwQ12gR8HYEMgeoWqNE+4OsI1Ggl8HUEarQV+DoCNVoMfJ0xm26g7iMo0S2Ocx5BiW62nPQIokmoXCCahMoFMgSq+xxEk1D5EUSTULlANAmVC0STULlANAlVDwmW6DbyKY8gS3RD+6QC0SRULhBNQuXnIEOguo8gmoTKjyCahMqPIJqEyo8gmoTKjyCahLoF6mkSKheIJqHuc1BPk1D5EUSTUPkRZAhU9xFEk1D5EUSTUPkRRJNQuUA0CZULRJNQ9zmo0CTUfQQVmoTKBaJJqPwjjiah8iPIEKjuI4gmofIjiCah8iOIJqHyI4gmoXKBaBLqFmigSahcIJqEygWiSah7ihtoEio/ggyB6haIJqFygWgSKj8H0SRUfgTRJFR+BNEk1H0EGU1C5QLRJFQuEE1C5QLRJNQ9JJghUN1HEE1C5UcQTULlRxBNQuUC0SRU/hFHk1D3ETTSJFQuEE1C5QLRJFQuEE1C5QIZAtUtEE1C5QLRJFQuEE1C3UF1pEmo/AiiSahboIkmoe6PuIkmofIjiCahcoFoEioXyBCo7nMQTULlRxBNQuVHEE1C5UcQTULlAtEk1P0RN9Mk1H0EzTQJlR9BNAmVH0E0CZUfQYZAdR9BNAmVC0STULlANAmVC0STULlANAl1T3ELTULdR9BCk1C5QDQJlX/E0SRUfgQZAtUtEE1C5QLRJFQuEE1C5QLRJFQuEE1C3WP2SpNQ9xG00iRULhBNQuUC0SRULpAhUN1DAk1C5UcQTULlAtEkVP4RR5NQ+RFEk1D1ETR2NAlVH0FjR5NQuUA0CZV/xNEkVH4EGQLVfQTRJFR+BNEkVC4QTULlH3E0CZUfQTQJdR9BPU1C3UdQT5NQuUA0CZV/xNEkVH4EGQLVLRBNQuUC0SRULhBNQuUC0SRULhBNQt0CFZqEunNQoUmo/AiiSaj8CKJJqPwIMgSqWyCahMoFokmoXCCahMoFokmoXCCahLoFGmgS6s5BA01C5UcQTULlAtEkVP4RZwhU9xFEk1C5QDQJlX/E0SRUfgTRJFR+BNEk1H0EGU1C5QLRJFQuEE1C5QLRJFQukCFQ1VOc0SRUfgTRJFQuEE1C5R9xNAmVH0E0CXUfQSNNQt1H0EiTUPkRRJNQ+RFEk1C5QIZAdX/E0SRUfgTRJFQuEE1C5QLRJFR+DqJJqPsImmgSKheIJqHuj7iJJqHyI4gmoXKBDIHqFogmoXKBaBIqF4gmoXKBaBIqH7NpEuo+gmaahLqPoJkmofIjiCahcoFoEioXyBCo7nMQTULlRxBNQuVHEE1C5UcQTULlRxBNQt1H0EKTUPcRtNAkVH4E0SRUfgTRJFR+BBkC1S0QTULlH3E0CZUfQTQJlQtEk1C5QDQJdQu00iRULhBNQt1T3EqTUPkRRJNQuUCGQHULRJNQ+TmIJqHyI4gmoXKBaBIqF4gmoWqBpo4moXKBaBKqnuKmjiah8iOIJqHyI8gQqO4jiCah8iOIJqHyI4gmofIjiCah8iOIJqFugXqahMoFokmo+xzU0yRUfgTRJFR+BBkC1X0E0SRULhBNQuUfcTQJlR9BNAmVH0E0CXUfQYUmoe4jqNAkVH4E0SRULhBNQuUCGQLVfQ6iSaj8CKJJqFwgmoTKP+JoEio/gmgS6j6CBpqEuo+ggSah8iOIJqHyI4gmoXKBDIHqFogmoXKBaBIqF4gmofIpjiah8iOIJqFugYwmoXKBaBLqPgcZTULlRxBNQuUCGQLVLRBNQuUC0SRUPiTQJFR+BNEkVC4QTULdH3EjTULdR9BIk1C5QDQJlQtEk1C5QIZAdQtEk1D5FEeTUPkRRJNQ+RFEk1D5EUSTUPcRNNEk1H0ETTQJlR9BNAmVH0E0CZUfQYZAdR9BNAmVC0STULlANAmVC0STULlANAl1T3EzTULdR9BMk1D5EUSTUPkRRJNQ+RFkCFT3EUSTUPkRRJNQ+RFEk1D5EUSTUPkRRJNQt0ALTULdH3ELTULlRxBNQuUC0SRU/hFnCFT3EUSTUPkRRJNQ+RFEk1C5QDQJlQtEk1D3OWilSaj7CFppEioXiCahcoFoEio/BxkC1X0E0SRUfgTRJFR+BNEkVH4E0SRUfgTRJFR9BM0dTULVR9Dc0SRUfgTRJJwu0NBtAg1jgJxu4FORrwFyA/m5yNduWn4+eu2+4XLIye9y5CRyOXIythw5qVmOnBysRt6TbOXIyapy5KRPOXLSpxy5gVyNnPQpR076lCMnfcqRkz7lyEmfauSF9ClHTvqUIyd9ypGTPuXIDeRq5KRPOXLSpxw56VOOnPQpR076VCMfSJ9nI/940Zd/BhvkBtKnHDnpU46c9ClHbiA/+/S5jhvyMgXISZ9y5KRP+ZBI+pQjJ33KkZM+1ciN9ClHTvqUIyd9ypGTPuXIDeRq5KRPOXLSpxw56VOOnPQpR076VCMfSZ9y5KRPOXLSpxw56VOO3ECuRk76lCMnfcqRkz7lyEmfcuSkTzXyifQpR076VO9JnEifcuSkTzlyA7kaOelTvfN2In3KkZM+5UMi6VOOnPSpRj6TPuXISZ9y5KRPOXLSpxy5gVyNnPQpR076lCMnfcqRkz7lyEmfauQL6VOOnPQpR076lCMnfcqRG8jVyEmfcuSkTzly0qccOelTjpz0qUa+kj7lyEmf6g1yK+lTjpz0KUduIFcjJ32qt4GupE85ctKnfEgkfcqRkz7FyJeO9ClHTvqUIyd9ypGTPuXIDeRq5KRPOXLSpxw56VOOnPQpR076VCPvSZ9y5KRPOXLSpxw56VOO3ECuRk76lCMnfcqRkz7lyEmfcuSkTzXyQvoU79ZaCulTjpz0KUdO+pQjN5Br9yQuhfQpR076lA+JpE85ctKnHDnpU418IH3KkZM+5chJn3LkpE85cgO5GjnpU46c9ClHTvqUIyd9ypGTPtXIjfQpR076lCMnfcqRkz7lyA3kauSkTzly0qccOelTjpz0qd46ZKRPNfKR9ClHTvqUIyd9qjfIjaRPOXIDuXhIHEmfcuSkTzly0qccOelTjpz0qUY+kT7lyEmfcuSkTzly0qccuYFcjZz0KUdO+pQjJ33KkZM+5chJn2rkM+lTjpz0KUdO+pQjJ33KkRvI1chJn+p9LDPpU46c9ClHTvqUIyd9qndrLaRPOXLSp3pIXEifcuSkTzlyA7kaOelTjpz0KUdO+pQjJ33KkZM+1chX0qccOelTjpz0KUdO+pQjN5CrkZM+5chJn3LkpE85ctKnHDnpU4x87UifcuSkT/GmirUjfcqRkz7lyA3kauSkT/HWocvpFeRq5KRP+ZBI+pQjJ32qkfekTzly0qccOelTjpz0KUduIFcjJ33KkZM+5chJn3LkpE85ctKnGnkhfcqRkz7lyEmfcuSkTzlyA7kaOelTjpz0qb7CX0ifcuSkTzly0qca+UD6VO9jGUifcuSkT/WQOJA+5cgN5GrkpE85ctKnHDnpU46c9ClHTvpUIzfSpxw56VOOnPQpR076lCM3kKuRkz7lyEmfcuSkTzly0qccOelTjXwkfaovN4+kTzly0qccOelTjtxALt5UMZI+5chJn/IhkfQpR076lCMnfaqRT6RPOXLSpxw56VOOnPQpR24gVyMnfcqRkz7lyEmfcuSkTzly0qca+Uz6lCMnfcqRkz7lyEmf6mufs4FcjZz0KUdO+pQjJ32qr/DPpE85ctKnekhcSJ9y5KRPOXLSpxw56VOO3ECuRk76lCMnfcqRkz7lyEmfcuSkTzXylfQpR076lCMnfcqRkz7lyA3kauSkT/WFuJX0KUdO+pQjJ33KkZM+tZebh64jfcqRkz61Q+IFOelTjpz0KUduIFcjJ33KkZM+5chJn3LkpE85ctKnGnlP+pQjJ33KkZM+5chJn3LkBnI1ctKnHDnpU3tV6IKc9ClHTvqUIyd9qpEX0qf62mchfcqRkz7VQ2IhfcqRG8jVyEmfcuSkTzly0qccOelTjpz0qUY+kD7lyEmfcuSkTzly0qccuYFcjZz0KUdO+lRfohhIn3LkpE85ctKnGrmRPtUX4oz0KUdO+lQPiUb6lCM3kKuRkz7lyEmfcuSkTzly0qccOelTjXwkfcqRkz7lyEmfcuSkTzlyA7kaOelT3ZePpE85ctKnHDnpU46c9Km+KjSRPuXISZ/qIXEifcqRkz7lyA3kauSkTzly0qccOelTjpz0KUdO+lQjn0mfcuSkTzly0qccOelTXd7OBnI1ctKnHDnpU46c9Km+RDGTPuXISZ/qIXEhfcqRkz7lyEmfcuSkTzlyA7kaOelTjpz0KUdO+pQjJ33KkZM+1chX0qe6SVxJn3LkpE85ctKnHLmBXNyXr6RPOXLSp3xIJH3KkZM+5chJn2LkF6AgVyMnfcqRkz7lyEmfcuQGcjVy0qccOelTXGv1HelTjpz0KUdO+lQj70mf4vK270mfcuSkT/WQ2JM+5cgN5GrkpE85ctKnHDnpU46c9ClHTvpUIy+kTzly0qe6YymkTzly0qccuYFcjZz0qW4SC+lTjpz0KR8SSZ9y5KRPNfKB9ClHTvqUIyd9ypGTPuXIDeRq5KRPdeAfSJ9y5KRPOXLSpxw56VNdaxnpU46c9KkeEo30KUdO+pQjN5CrkZM+5chJn3LkpE85ctKnOn0a6VONfCR9ypGTPuXISZ/qjmUkfcqRG8jFQ+JI+pQjJ33KkZM+5chJn3LkpE818on0qY5CE+lTjpz0KUdO+pQjN5CLA/9E+pQjJ33Kh0TSpxw56VOOnPSpRj6TPuXISZ/quXwmfcqRkz7lyA3kauSkT3X6nEmfcuSkT/mQSPqUIyd9qpEvpE85ctKnekhcSJ9y5KRPOXIDuRo56VMdhRbSpxw56VM+JJI+5chJn2rkK+lTPbGspE85ctKnHDnpU47cQC6ey1fSpxw56VM+JJI+5chJn/LTJ+lTjLx0pE85ctKnHDnpUzwklo70KUduINcOiaUjfco/y0mfcuSkTzly0qccOelTPbH0pE85ctKn+oOlJ33KkZM+5cgN5GrkpE/56ZP0KUdO+txHPg799S+Pw7iDfBq7a601XRZuj+7XiFwpV32GMny8jn6JXscyb69jmefbB//QklibR0vychotC0E8j5Yk/K+j5bra9cFdP3otqQ7yaEkn8WW0HLrhQ0tbd4T/eBllLN3jB/fLsum9doN3ieESXNKv47i55AZ0+GCbruhsHW7f3g9DURJhqFMNRQWGoU41FAUfhvqH0nXbO+yKvWQoWkYMdaqhqDox1EWK/kOVYXXRbaBExSX7LqGexSX7LqH4xSX7LqFSxiXfNtlc//Il+uy8jH5Yrux66/xVisGwFJY611I00FjqSUuNw6bKOE6vZPeBuhr3vc99dNu4733uowjHfc+6b96u643rS9f1Blpz3Pc29xltfFb3fRhq9/x44jYFo7jHUKcaio4fQ525TcG4HIChTjWUYaichprK9hXtaRx3Tnk7/b7R7+OSfZfQw+OSM8tNo1rHUKcairYcQ51qKApwDHVmpz3SaWOoUw1Fp/11DHXhcX1wX8a9xug93+Uc6bQx1KmGotPGUGd22qNhKAx1pqGov7Ma6pl9ATu/6zRSf+OSUwcj6m8MdaqhqL8x1KmGov7GUGdO2hP1N4Y61VDU3xhq91c2JjptXLLvEopqXLLvEsMluOTUn1eZ6J+x1MmWoqzGUm/71YqJZhv3vc991OC4733uozPHfW/7zZSZgh33vc99tPFJ3Xfm94hn2nhcsu8S2nhccuZgPhuGwlBnGoraHkOdaihKewx1ah6jh8dQpxqKav2/Yahx+8vjzYNjQ83TtamZ53l77PQTN12yEvdCeSrFTVsoxU3t9twwsNgvuH9ApJXahzh14/aXhy6AaEB8HSLtwwkQW03c218eLxcIdx48XGGM80e9sXZhhrn+2cFucsYYU9uSxrD0N1Fj/ilNq9n1C0jTagqsQJplvQ4owxpJ02pirF+atdV0+QWkaTWJfgFpWk2tX0CaVrPwF5DGkKZWaVrN7V9AGtqAaqWhDThTmrIumzTrjjTLfFVmWW62t5Sfl4RXyoB3KbNO19e7LuMvyvjHWhm3C/tl/uXKfvB6rdtesN3+QM9Vc1qG1jQfOuqL9jSnF2lPcwqX9jSnyWlPc0Pz5jSne2pPc0qt9jSnLWtPc3q49jSnh2tO854erj3N6eHa05werj3N6eHa09zQvDnN6eHa05werj3N6eHa05werj3N6eGa07zQw7WnOT1ce5rTw7WnOT1ce5obmjenOT1ce5rTw7WnOT1ce5rTw7WnOT1cc5oP9HDtaU4P157m9HDtaU4P9yU0n7rr787bVDovoyFjBhlpy1LISAGWQkY6ra8h4zhuMs6BjNRUKWSkecogo1EmpZCRfiiFjFQ+GSZVo8VJIaMhYwYZaXFSyEiLk2LEocVJISMtTgoZaXEyyDjS4qSQkRYnhYy0OClkpMVJIaMhYwYZaXFSyEiLk6GMG2lxUshIi5NCRlqcDDJOtDgZRpyJFieFjLQ4KWSkxUkhoyFjBhlpcVLISIuTQkZanBQy0uKkkJEWJ4OMMy1OhjJupsVJISMtTgoZaXFSyGjImGHEocVJISMtTgoZaXFSyEiLk0JGWpwMMi60OClkpMVJISMtTgoZaXFSyGjImKCMW2hxUshIi5NCRlqcFDLS4qQYcWhxMsi40uKkkJEWJ4WMtDgpZKTFSSGjIWMGGWlxUshIi5NCRlqcFDLS4mQo41ZanAQyWkeLk0JGWpwUMtLiJBhxrKPFSSGjIWMGGWlxUshIi5NCRlqcFDLS4qSQkRYng4w9LU4KGWlxUshIi5OhjOtpcVLIaMiYQUZanBQy0uKkGHFocVLISIuTQkZanAwyFlqcFDLS4qSQkRYnhYy0OClkNGTMICMtTgoZaXEylHGFFieFjLQ4KWSkxckg40CLk2HEGWhxUshIi5NCRlqcFDIaMmaQkRYnhYy0OClkpMVJISMtTgoZaXEyyGi0OBnKOKPFSSEjLU4KGWlxUshoyJhhxKHFSSEjLU4KGWlxUshIi5NCRlqcDDKOtDgpZKTFSSEjLU4KGWlxUshoyJigjBtpcVLISIuTQkZanBQy0uKkGHFocTLIONHipJCRFieFjLQ4KWSkxUkhoyFjBhlpcVLISIuTQkZanBQy0uJkKOMmWpwMMs60OClkpMVJISMtToYRZ6bFSSGjIWMGGWlxUshIi5NCRlqcFDLS4qSQkRYng4wLLU4KGWlxUshIi5OhjFtocVLIaMiYQUZanBQy0uKkGHFocVLISIuTQkZanAwyrrQ4KWSkxUkhIy1OChlpcVLIaMiYQUZanBQy0uJkKONWWpwUMtLipJCRFieBjGNHi5NgxBk7WpwUMtLipJCRFieFjIaMGWSkxUkhIy1OChlpcVLISIuTQkZanAwy9rQ4Gcq4nhYnhYy0OClkpMVJIaMhY4YRhxYnhYy0OClkpMVJISMtTgoZaXEyyFhocVLISIuTQkZanBQy0uKkkNGQMUEZV2hxUshIi5NCRlqcFDLS4qQYcWhxMsg40OKkkJEWJ4WMtDgpZKTFSSGjIWMGGWlxUshIi5NCRlqcFDLS4mQo4wZanAwyGi1OChlpcVLISIuTYcQxWpwUMhoyZpCRFieFjLQ4KWSkxUkhIy1OChlpcTLIONLipJCRFieFjLQ4Gcq4kRYnhYyGjBlkpMVJISMtTooRhxYnhYy0OClkpMXJIONEi5NCRlqcFDLS4qSQkRYnhYyGjBlkpMVJISMtToYybqLFSSEjLU4KGWlxMsg40+JkGHFmWpwUMtLipJCRFieFjIaMGWSkxUkhIy1OChlpcVLISIuTQkZanAwyLrQ4Gcq4hRYnhYy0OClkpMVJIaMhY4YRhxYnhYy0OClkpMVJISMtTgoZaXEyyLjS4qSQkRYnhYy0OClkpMVJIaMhY4IybqXFSSEjLU4KGWlxUshIi5NixKHFSSDj1NHipJCRFieFjLQ4KWSkxUkhoyFjBhlpcVLISIuTQkZanBQy0uIkKOMubx0ZE8jY0+KkkJEWJ4WMtDgZRpyeFieFjIaMGWSkxUkhIy1OChlpcVLISIuTQkZanAwyFlqcFDLS4qSQkRYnQxlXaHFSyGjImEFGWpwUMtLipBhxaHFSyEiLk0JGWpwMMg60OClkpMVJISMtTgoZaXFSyGjImEFGWpwUMtLiZCjjBlqcFDLS4qSQkRYng4xGi5NhxDFanBQy0uKkkJEWJ4WMhowZZKTFSSEjLU4KGWlxUshIi5NCRlqcDDKOtDgZyriRFieFjLQ4KWSkxUkhoyFjhhGHFieFjLQ4KWSkxUkhIy1OChlpcTLIONHipJCRFieFjLQ4KWSkxUkhoyFjgjJuosVJISMtTgoZaXFSyEiLk2LEocXJIONMi5NCRlqcFDLS4qSQkRYnhYyGjBlkpMVJISMtTgoZaXFSyEiLk6GMm2lxMsi40OKkkJEWJ4WMtDgZRpyFFieFjIaMGWSkxUkhIy1OChlpcVLISIuTQkZanAwyrrQ4KWSkxUkhIy1OhjJupcVJIaMhYwYZaXFSyEiLk2LEocVJISMtTgoZaXESyDh3tDgpZKTFSSEjLU4KGWlxUshoyJhBRlqcFDLS4iQo4+aOFieFjLQ4KWSkxckgY0+Lk2HE6WlxUshIi5NCRlqcFDIaMmaQkRYnhYy0OClkpMVJISMtTgoZaXEyyFhocTKUcYUWJ4WMtDgpZKTFSSGjIWOGEYcWJ4WMtDgpZKTFSSEjLU4KGWlxMsg40OKkkJEWJ4WMtDgpZKTFSSGjIWOCMm6gxUkhIy1OChlpcVKcG2lxUhyNtDgZZDRanBQy0uJkODcaLU6Ko5EWJ4WMhowZZKTFSSEjLU6KEYcWJ4WMtDgpZKTFySDjSIuTQkZanBQy0uKkkJEWJ4WMhoxfQcZ56a8yzjeMNxlpcd4lY2/b3+1t6neEnMbu+qencehvhQwEKeV68A5luFF9iV7zMl8tcvnnfPvgHxahIcIiOxahfcIiOxah2cIiOxahNWveIut6vVo1dP3oLDLRyGGRHYvQ9rVukaEbPixy+6pDP328jDLeXiCPHtyvWyvSrzf6hQ++9CbX6L365D1RZ+LTr+BT+lp8+lk+LV23RYKu2Es+NXyKT7+AT2nc8elTPjXbfDpOO+f9Zdne4doNPhzR5WO+TzPfiUMnFxTw6VfwKVc18OlX8CmXVvDpZ/n0xHA0c30Hn34Fn3KRCZ9+mk/7/kPsYXUhfubKEeZ7m/m4HIT53mY+w3yY77PMVz4eXJadl9EPy7zh6PwupJmrPDj1aziVS0I4tQ6njsMm9u5f3snnXD/C1OlMzcUmTJ3O1FyZwtSVmHreLreO60uXWxcuY2HqdKbmmhemfsbUUykb5XF8raVYuOaF+d5mPq55Yb5PM995WWoxfIpPv4BPuTiGT7+CT7k0hk8/z6fnJXOuduHTr+BTLmA179ML5uuD+zLu1aLP/OTJzlefFy40Yb5PM995X9VbuXaET7+CT7kchE+/gk+5coRPP8unJ36ldOUiEz79Cj41fIpPP8unO18AXLlyhPneZj4uB2G+t5mPazyY79PMd+YXSleu8uDUr+FULgnh1DqcetqmpaXj+hGmTmdqLjZh6nSm5soUpq7E1Gft8Vs6LmNh6nSmNkyNqZ8x9Vt+5n/puDyGT7+CT7mShk8/y6fn7XVZOi664dOv4FMuueHTZ3x64q+jLB1X0TDfu8zXc7UL832a+c7r+nsuYOHTr+BTrknh06/gUy4z4dPP8+lpV456w6f49Av4lCtHb/PpsvmjX8r0i09/aMPVknq14QpBvdrQiterDaVxFdr0q9em0KnWqw09Yr3a0J1Ve74p9EX1amNoU6029AL1akMvUK829AL1akMvUK829ALVajPQC9SrDb1AvdrQC9SrDb1AtX3aYGhTrTb0AvVqQy9wpjZjf904M95u9blo84M2SV9Jm+yupE0aF9I28rWSNolZSZsMrKRNqlXSNmgLaZM8lbTJkkraZEklbbKkkjZZUkh7JEsqaZMllbTJkkraZEklbYO2kDZZUkmbLKmkTZZU0iZLKmmTJYW0J7KkkjZZUkmbLKmkTZZU0jZoC2mTJZW0yZJK2mRJJW2ypJI2WVJIeyZLKmmTJZW0yZJK2mRJJW2DtpA2WVJJmyyppE2WVNImSyppkyWFtBeypJI2WVJJmyyppE2WVNI2aAtpkyWVtMmSStpkSSVtsqSSNllSSHslSyppkyWVtMmSStpkSSVtg7aQNllSSZsseSbtqdjPh07T9Avt4N1N43Zn5Wn6eA1ljh68bIz7ZZ0fP3iYt/tMD/M43D74h+hE2gZFJ1k3KDoBvznR146eoUHRqTsaFJ3WpUHRKX8aFN0QvT3RqcIaFJ1GLqHoa399GcM6948fvMzLlduy9IFDqO9wyGOH0PW17pCpXN/eMtm08zJs3M5Jl38X84aiR8RQZxqqp6PkHPbwHNZTaOKQxw6h/eSkdOpJiWYVQ51qKMNQnMMensOoeHHIY4fQB7fuEJv6q0Ps25v63SH0wXyGPP4MoQ/GIY8dQsFL9Dkz+hQKXgx1qqHogzmHPTyHFfpgHPLYIRS8nJROPSkZhsJQZxqKPphz2ONzGH0wDnnsEPpgrhg8vGJQ6IP5DHn8GUIfjEMeOmSg4CX6nBl9BgpeDHWqoeiDOYc9PofRB+OQxw4xHMJJ6cyTEgUvhjrVUPTBnMMen8Pog3HIY4fQB3PF4OEVg4E+mM+Qh58hRh+MQx47hIKX6HNm9DEKXgx1qqHogzmHPT6HGQ7BIQ8dQsHLSenUkxIFL4Y61VD0wZzDHp/D6INxyGOH0AdzxeDhFYORPpjPkIefISN9MA557BAKXqLPmdFnpODFUKcayjAU57CH5zD6YBzy2CEUvJyUTj0pUfBiqFMNRR/MOezxOYw+GIc8dMhEH8wVg4dXDCb6YD5DHn+G0AfjkMcOoeAl+pwZfSbDUBjqTEPRB3MOe3wOow/GIY8dQsHLSenUkxIFL4Y61VD0wZzDHp7DZvpgHPLYIfTBXDF4eMVgpg/mM+TxZwh9MA557BDDIUSfE6PPTMGLoU41FH0w57DH5zD6YBzy2CEUvJyUTj0pUfBiqDMNtdAHcw57eA5b6INxyGOH0AdzxeDhFYOFPpjPkMefIYZDcMhDh1DwEn1OjT4UvBjqVEPRB3MOe3wOow/GIY8dQsHLSenMk9JKwYuhTjUUfTDnsIfnsJU+GIc8dgh9MFcMHl4xWA2H4JCHDqEPzucQ65bu54OtL+vjB6+lu76Mtey+jG4c+s0Zo63eUPTBGOpUQ9EHY6hTDUV9jKFONRRtM4Y6z1DWdbTNGOpUQ9E2Y6hTDUU5nc9QY5m2VzyUxYtO39yg6Ibo7YlOK9yg6DS3DYpOu9qg6DSgDYpOS9me6D1NYoOi0/Y1KDqNXIOi08glFH2Yr73+aMO485fnoczXPz0Py26zP5Ru88Ywdt5ShqWw1LmWok3EUidbiq4SS71iqclbiiYUSz1nqb1dEj09K5Y62VK0uFjqXEsVOmIsdbKlaKCx1MmWot9u3lI2bmLPY9n55nP/7bV+iNL13lK051jqOUvNq22iLCWwlGEpLHWupWjPsdTJlqI9x1InW4r2HEudbCnacyx1sqVoz7HUuZYaaM+x1MmWoj1v3lKX+nyz1DwV7xHqcDyy5xH67eY9sqwfHll78x4xPJLPI2bL5pF59y9frs9uf7p0/tLrQAONR/Y8QqWMR/Y8QkeMR/Y8QumLR/Y8QouLR3Y8YtSyeGTPI/SseGTPI/SseGTPI/SseGTPI4ZHWvfI0H386WEYHj/cynj9/oyV+ePB/Rq+kG5DZzd3m708+If7aHBx3/vcRzeM+97nPlpn3Pc+99Fn4773uY+mHPe9zX0jHTzue5/7aPdx3/vcx3UD3Pc+93FFAve9z32G+3Df29zHtQ7c9z73ca0D973PfVzrwH3vcx/XOnDf+9zHtQ7c9zb3TVzrwH3vcx/XOnDf+9zHtQ7c9z73ca0D973PfYb7cN/b3Me1Dtz3PvdxrQP3vc99XOvAfe9zH9c6cN/73Me1Dtz3NvfNXOvAfe9zH9c6cN/73Me1Dtz3PvdxrQP3vc99hvtw39vcx7UO3Pc+93GtA/e9z31c68B973Mf1zpw3/vcx7UO3Pc29y1c68B973Mf1zpw3/vcx7UO3Pc+93GtA/e9z32G+3Df29zHtQ7c9z73ca0D973PfVzrwH3vcx/XOnDf+9zHtQ7c9zb3rVzrwH3vcx/XOnDf+9zHtY5d983LFcZS+sfuO1cbrgTUq42hTbXa0CLXqw0da73a0EDWqw39XL3a0F7Vqs2FPNpUqw3NR73a0AvUqw29QL3aGNpUqw29QL3a0AvUqw29QL3a0AvUqw29QLXa9PQC9WpDL1CvNvQC9WpDL1CvNoY21WpDL1CvNvQC9WpDL1CvNvQC9WpDL1CtNoVeoF5t6AXq1YZeoF5t6AXq1cbQplpt6AXq1YZe4FRtpu76tUmbSudxE/WluEnvUtwEciXugYx9Lu7tW+w2zQFuYrMUN0lYiptwK8Vt4FbiJoJKJxNSpRQ3qVKKm1QpxU2qVJ4qjVQpxU2qlOImVUpxkyqluA3cStykSiluUqUUN6lSiptUKcVNqlSG+JFUKcVNqpTiJlVKcZMqlafK0cCtxE2qlOImVUpxkyqluEmVUtykSiXuiVQpxU2qlOImVUpxkyqVIX4ycCtxkyqluEmVUtykSumpklQpxU2qVOKeSZVS3KRKKW5SpRQ3qVKK28CtxE2qlOImVUpxkyqVIX4mVUpxkyqVuBdSpRQ3qVJ5qlxIlVLcpEopbgO3EjepUoqbVCnFTaqU4iZVSnGTKpW4V1KlFDepUhniV1KlFDepUorbwK3ETaqUnipJlVLcpEopblKlFDepUoi7dKRKKW5SpRQ3qVKKm1QpxW3gVuImVQpDfOlIlVLcpEopblKlFDepUnmq7EmVUtykSiluUqUUN6lSitvArcRNqpTiJlVKcZMqpbhJlVLcpEpliC+kSiluUqUUN6lSiptUqTxVFgO3EjepUoqbVCnFTaqU4iZVSnGTKpW4B1KlFDepUoqbVCnFTapUhvjBwK3ETaqU4iZVSnGTKqWnSlKlFDepUonbSJVS3KRKKW5SpRQ3qVKK28CtxE2qlOImVUpxkyqVId5IlVLcpEol7pFUKcVNqlSeKkdSpRQ3qVKK28CtxE2qlOImVUpxkyqluEmVUtykSiXuiVQpxU2qVIb4iVQpxU2qlOI2cCtxkyqlp0pSpRQ3qVKKm1QpxU2qVOKeSZVS3KRKKW5SpRQ3qVKK28CtxE2qVIb4mVQpxU2qlOImVUpxkyqVp8qFVCnFTaqU4iZVSnGTKqW4DdxK3KRKKW5SpRQ3qVKKm1QpxU2qVIb4lVQpxU2qlOImVUpxkyqVp8rVwK3ETaqU4iZVSnGTKqW4SZVS3KRKIe6hI1VKcZMqpbhJlVLcpEphiB86A7cSN6lSiptUKcVNqpSeKkmVUtykSiXunlQpxU2qlOImVUpxkyqluA3cStykSiluUqUUN6lSGeJ7UqUUN6lSibuQKqW4SZXKU2UhVUpxkyqluA3cStykSiluUqUUN6lSiptUKcVNqlTiHkiVUtykSmWIH0iVUtykSiluA7cSN6lSeqokVUpxkyqluEmVUtykSiVuI1VKcZMqpbhJlVLcpEopbgO3EjepUhnijVQpxU2qlOImVUpxkyqVp8qRVCnFTaqU4iZVSnGTKqW4DdxK3KRKKW5SpRQ3qVKKm1QpxU2qVIb4iVQpxU2qlOImVUpxkyqVp8rJwK3ETaqU4iZVSnGTKqW4SZVS3KRKJe6ZVCnFTaqU4iZVSnGTKpUhfjZwK3GTKqW4SZVS3KRK6amSVCnFTapU4l5IlVLcpEopblKlFDepUorbwK3ETaqU4iZVSnGTKpUhfiFVSnGTKpW4V1KlFDepUnmqXEmVUtykSiluA7cSN6lSiptUKcVNqpTiJlVKcZMqhbitI1VKcZMqhSHeOlKlFDepUorbwK3ETaqUnipJlVLcpEopblKlFDepUom7J1VKcZMqpbhJlVLcpEopbgO3EjepUhnie1KlFDepUoqbVCnFTapUnioLqVKKm1QpxU2qlOImVUpxG7iVuEmVUtykSiluUqUUN6lSiptUqQzxA6lSiptUKcVNqpTiJlUqT5WDgVuJm1QpxU2qlOImVUpxkyqluEmVStxGqpTiJlVKcZMqpbhJlcoQbwZuJW5SpRQ3qVKKm1QpPVWSKqW4SZVK3COpUoqbVCnFTaqU4iZVSnEbuJW4SZVS3KRKKW5SpTLEj6RKKW5SpRL3RKqU4iZVKk+VE6lSiptUKcVt4FbiJlVKcZMqpbhJlVLcpEopblKlEvdMqpTiJlUqQ/xMqpTiJlVKcRu4lbhJldJTJalSiptUKcVNqpTiJlUqcS+kSiluUqUUN6lSiptUKcVt4FbiJlUqQ/xCqpTiJlVKcZMqpbhJlcpT5UqqlOImVUpxkyqluEmVUtwGbiVuUqUUN6lSiptUKcVNqpTiJlUKQ/zYkSqluEmVUtykSiluUqXwVDl2Bm4lblKlFDepUoqbVCnFTaqU4iZVKnH3pEopblKlFDepUoqbVKkM8b2BW4mbVCnFTaqU4iZVSk+VpEopblKlEnchVUpxkyqluEmVUtykSiluA7cSN6lSiptUKcVNqlSG+EKqlOImVSpxD6RK5Wf3QKqUuptUKcVNqpTiNnArP7tJlVJ3kyqluEmVUtykSiluUqXyVGmkSiluUqUUN6lSiptUKcVt4FbiJlVKcZMqpbhJlafinpf+inu+YbHhJlXu4l6G62OXab7F/YNgo0FxmDaCw7Lz4HK5jHX9y5dWdHtwWSMY09gtPx89XRbeejYgV8r182Qow43Bl+h1rOs19A9dP94++LuWY6MpNKWWjUbcr6jl0A0fWtq6I/zHyyjjbXMXPbhftnNlv3aDd0mjyRyX/AJ63YbSfr0BHT74MrZeJ6rVD1Rjo90DhvosQxmGwlBnGqrR/ghD/fLgrtveYVfsJUM12pBhqM8yVKMdIIb6VZX+Q5Vh9dGt0eoSlzzlEupZXLLrkoniF5f8Qyl2/cuXi0I7L6MflusM01vn++eJ/hlLnWwpymos9aSlxu3idX8J6q+ksolmG/e9z32G+3Df29xHZ477nnXfvF2xGdeXrthMFOy4733uo43P6r4PQ+2eH0+8AD1R3GOoUw1Fx4+hzrwAPXM5AEOdaiguBiQ11FTKhmMcd055O/3+TL+PS/ZdQg+PS84sN2fDUBjqTEPRlmOoUw1FAY6hzuy0ZzptDHWqoei0v46hLjyuD+7LuNcYvedbejOdNoY601ALnTaGOrPTXui0MdSphqL+zmqoZ/YF7Pxiz0L9jUtOHYwMQ2GoMw1F/Y2hTjUU9TeGOnXSpv7GUKcaivobQ+3+ysZCp41Ldl2yUlTjkn2X0D7jknN/XmWlf8ZSJ1uKshpLve1XK1bDfbjvbe6jBsd973MfnTnue9tvpqwU7Ljvfe6jjU/qvjO/R7zSxuOSPZdMHW08LjlxMJ86insMdaqhqO0x1KmGorTHUCfmsakzDIWhzjQU1fpzhlrsF0P9gEhDvA/xYrXtLw9dAJGi8wSIrfZ1fb9BXMvjBy9lvH4uL0PXP37wsO0dG+zmg3aMuW0ftcPS33zWzj/FabUm+wri9K22U1WIs6zXVzGskTitNj1fQpxWW5MvIU6rDcSXEMcQp15xWk3GX0KcVhP3lxCn1ST/JcShIahYHBqCc8Up67KJs+6Is8zXF7EsN1f9ys+mvFAQvE+bdbq+4nUZf9EmuOBRxu2KR5l/ueQRvD3rrvqNdvvLBVfVaR5aVJ1Ko0XV6UpaVN1QvUHVaXdaVJ3aqEXV6aNaVJ2iq0XVadAaVH2gm2tRdbq5FlWnm2tRdbq5FlU3VG9Qdbq5FlWnm2tRdbq5FlWnm2tRdbq5BlU3urkWVaeba1F1urkWVaeba1F1Q/UGVaeba1F1urkWVaeba1F1urkWVaeba1D1kW6uRdXp5lpUnW6uRdXp5lpU3VC9QdXp5r6I6lN3vZvbt9+V8UJStyURkgYtiZCUYkmEpOf6KkKO4ybk7IWcqK6SCEkblURICqYkQtIZJRHSEDLF1DrR7CQRkmYniZA0O0mEpNlJMuzQ7OQQcqbZSSIkzU4SIWl2kghJs5NESEPIHELS7CQRkmYniZA0O0mEpNnJUdHNNDs5hFxodpIISbOTREianRzDzkKzk0RIQ8gcQtLsJBGSZieJkDQ7SYSk2UkiJM1ODiFXmp0kQtLsJBGSZidHRbfS7CQR0hAyh5A0O0mEpNlJMuzQ7CQRkmYniZA0OymEnDuanSRC0uwkEZJmJ4mQNDtJhDSEzCEkzU4SIWl2UlR0c0ezk0RImp0kQtLs5BCyp9nJMez0NDtJhKTZSSIkzU4SIQ0hcwhJs5NESJqdJELS7CQRkmYniZA0OzmELDQ7OSq6QrOTREianSRC0uwkEdIQMsewQ7OTREianSRC0uwkEZJmJ4mQNDs5hBxodpIISbOTREianSRC0uwkEdIQMkVFN9DsJBGSZieJkDQ7SYSk2Uky7NDs5BDSaHaSCEmzk0RImp0kQtLsJBHSEDKHkDQ7SYSk2UkiJM1OEiFpdnJUdEazk0PIkWYniZA0O0mEpNnJMeyMNDtJhDSEzCEkzU4SIWl2kghJs5NESJqdJELS7OQQcqLZSSIkzU4SIWl2clR0E81OEiENIXMISbOTREianSTDDs1OEiFpdpIISbOTQ8iZZieJkDQ7SYSk2UkiJM1OEiENIXMISbOTREianRwV3Uyzk0RImp0kQtLs5BByodnJMewsNDtJhKTZSSIkzU4SIQ0hcwhJs5NESJqdJELS7CQRkmYniZA0OzmEXGl2clR0K81OEiFpdpIISbOTREhDyBzDDs1OEiFpdpIISbOTREianSRC0uykEHLpaHaSCEmzk0RImp0kQtLsJBHSEDJDRbd0NDtJhKTZSSIkzU4SIWl2kgw7NDs5hOxpdpIISbOTREianSRC0uwkEdIQMoeQNDtJhKTZSSIkzU4SIWl2clR0Pc1ODiELzU4SIWl2kghJs5Nj2Ck0O0mENITMISTNThIhaXaSCEmzk0RImp0kQtLs5BByoNlJIiTNThIhaXZyVHQDzU4SIQ0hcwhJs5NESJqdJMMOzU4SIWl2kghJs5NDSKPZSSIkzU4SIWl2kghJs5NESEPIHELS7CQRkmYnR0VnNDtJhKTZSSIkzU4OIUeanRzDzkizk0RImp0kQtLsJBHSEDKHkDQ7SYSk2UkiJM1OEiFpdpIISbOTQ8iJZidHRTfR7CQRkmYniZA0O0mENITMMezQ7CQRkmYniZA0O0mEpNlJIiTNTg4hZ5qdJELS7CQRkmYniZA0O0mENIRMUdHNNDtJhKTZSSIkzU4SIWl2kgw7NDs5hFxodpIISbOTREianSRC0uwkEdIQMoeQNDtJhKTZSSIkzU4SIWl2clR0C81ODiFXmp0kQtLsJBGSZifHsLPS7CQR0hAyh5A0O0mEpNlJIiTNThIhaXaSCEmzk0LItaPZSSIkzU4SIWl2UlR0a0ezk0RIQ8gcQtLsJBGSZifJsEOzk0RImp0kQtLs5BCyp9lJIiTNThIhaXaSCEmzk0RIQ8gcQtLsJBGSZidHRdfT7CQRkmYniZA0OzmELDQ7OYadQrOTREianSRC0uwkEdIQMoeQNDtJhKTZSSIkzU4SIWl2kghJs5NDyIFmJ0dFN9DsJBGSZieJkDQ7SYQ0hMwx7NDsJBGSZieJkDQ7SYSk2UkiJM1ODiGNZieJkDQ7SYSk2UkiJM1OEiENIVNUdEazk0RImp0kQtLsJBGSZifJsEOzk0PIkWYniZA0O0mEpNlJIiTNThIhDSFzCEmzk0RImp0kQtLsJBGSZidHRTfS7OQQcqLZSSIkzU4SIWl2cgw7E81OEiENIXMISbOTREianSRC0uwkEZJmJ4mQNDs5hJxpdpIISbOTREianRwV3Uyzk0RIQ8gcQtLsJBGSZifJsEOzk0RImp0kQtLs5BByodlJIiTNThIhaXaSCEmzk0RIQ8gcQtLsJBGSZidHRbfQ7CQRkmYniZA0OzmEXGl2cgw7K81OEiFpdpIISbOTREhDyBxC0uwkEZJmJ4mQNDtJhKTZSSIkzU4GIceuo9nJUNFdhKTZSSIkzU4SIWl2kghpCJlj2KHZSSIkzU4SIWl2kghJs5NESJqdHEL2NDtJhKTZSSIkzU4SIWl2kghpCJmioutpdpIISbOTREianSRC0uwkGXZodnIIWWh2kghJs5NESJqdJELS7CQR0hAyh5A0O0mEpNlJIiTNThIhaXZyVHSFZieHkAPNThIhaXaSCEmzk2PYGWh2kghpCJlDSJqdJELS7CQRkmYniZA0O0mEpNnJIaTR7CQRkmYniZA0OzkqOqPZSSKkIWQOIWl2kghJs5Nk2KHZSSIkzU4SIWl2cgg50uwkEZJmJ4mQNDtJhKTZSSKkIWQOIWl2kghJs5OjohtpdpIISbOTREianRznyIlmJ8cROdHsJBGSZieJkDQ7Sc6RhpA5jkianSRC0uwkEZJmJ4mQNDtJhh2anRxCzjQ7SYSk2UkiJM1OEiFpdpIIaQiZQ0ianSRC0ux8ESHn5fqKL/8cvJA0O+8Tsrdhw2xTvyPlNHbXPz1dXv+tlIEkpVwP4KEMN7ov0Wte5iuNyz/n2wf/MAmtESbZNQmNFCbZM8lC24VJdk1Ck4ZJyrper2Rd3t/oTUJLh0l2TUIDiEmGbvgwye2rDh318TLKeHsBPXpwv24tSb/eKBg++NKjXIP46nP4YjgVp34Jp9Lh4tTPc2rpui0cdMVeciolNU79Gk6lhcepTzrVbHPqOO2c/Zdle4drN/iYRL+P/T7RficOn1xkwKlfwqkrVzpw6tdwKpdbcOrnOfXEmLRyzQenfg2ncuEJp36iU/v+Q+5hdYF+NeyH/d5nPy4RYb832o/rPtjvE+1XPh5clp2X0Q/LvOHo/A6llSs/ePWreJXLRHi1Fq+Owyb37l/eyepcU8LW6Wx9MS22xtb5bM3VKmxdja3n7SLsuC4v2ZpLW9g6oa25Doatn7P1VMrGeRxfaiz6zrAf9nuf/bgOhv0+0X4npioumeHUr+FULpjh1K/hVC6X4dTPdOp5KZ0rYDj1Szi156IWTr3AuL7BoS/jXk36zM+kPP6idN9z8Qn7faL9TvtSX99zPQmnfg2ncokIp34NpxpOxamf5tTzvn7a91x4wqlfw6lceMKpn+jUx18VvKiK/bDf++zHJSLs90b7cd0H+32i/U788mlfuPKDV7+KV7lMhFdr8ep5G5oK15SwdUJbcwEKWye0tWFrbF2LrU/bAVi4tIWtE9qa62DY+klbv+V2AX3hkhlO/RpO5eoaTv08p564C6ZwIQ6nfgmnDlyGw6nPOfXMX1QZuLKG/d5oP66AYb9PtN957f/ARS2c+jWcajgVp34Jp3LpCad+plNPu5o0cDUJp34Np3I16Y1OXTaH9EuZfnHqD3W4glKzOlw1qFgdoymvWR2K5ErU6ddAHXrWmtWhW6xZHUOdis87dEg1q0NvUrM6dAU1q0NXULM6dAUVqzPSFdSsDl1BzerQFdSsDl1BzeoY6lSsDl1BxT3bSFdQszp0BTWrQ1dwrjpjP29/ePhFnR+8Sf9S3hN5XsubhK7lTebW8iZFa3kbvKW8Sbpa3mRXLW/SqJY3+VLLm3wp5T2TL7W8yZda3uRLLW/ypZa3wVvKm3yp5U2+1PImX2p5ky+1vMmXUt4L+VLLm3yp5U2+1PImX2p5G7ylvMmXWt7kSy1v8qWWN/lSy5t8eS7vqVzvTjFN0y+8g/c3fdzxZ5o+3l+ZowcvG+WLavPjBw/z9tuKwzwOtw/+LvtKzG1SdtJ2k7IT+puUne6hSdkN2VuUnSamSdkphJqUnV6qSdmpx5qUnZYupexrf30Zwzr3jx+8zMuV3LL0ziOlo9LDI3seof/DI1O5qr1MNu28DPu4SdPl3zd30N4sRbeIpU62FL0llto7kxkewSM7HqERxSMnn5poW7HUyZaiycVSe2cyal88sucROmI8YtMVxmJr5zzS0xHjkZ3PkZ6OGI/seYTSF4+cG4N6Sl8sdbKlDEtxJts5k9ER45E9j1D64pGTT02UvljqZEvREWOpvTMZHTEe2fFIoSPGIzvXEQodMR7Z+xyhI8Yjex6h9MUj58agYlgKS51rKTpiLLV3JqMjxiN7HqH0xSMnn5oofbHUyZaiI8ZSO2eygY4Yj+x5hI4Yj+xcRxjoiPHI3ucIHTEe2fOI4RFi0KkxaKD0xVInW4qOGEvtncnoiPHInkcoffHIyacmSl8sda6ljI4YS+2cyYyOGI/seYSOGI/sXEcwOmI8svc5YngEj+x4hNIXj5wcgyh9sdTJlqIjxlJ7ZzI6Yjyy5xFKXzxy7qlppPTFUidbio4YS+2cyUY6Yjyy5xE6Yjyycx1hNDzC58jO5wgdMR7Z8wilLx45OQZR+mKpky1FR4yl9s5kdMR4ZMcjE6UvHjn31DRR+mKpky1FR4yl9s5kdMR4ZM8jhke4jvD4OsJER4xH9j5H6IjxyJ5HKH3xyMkxiNIXS51sKTpiLLVzJpvpiPHInkcoffHIuaemmdIXS51sKTpiLLV3JjM8gkd2PEJHjEd2riPMdMR4ZO9zhI4Yj+x5hNIXj5wcgyh9sdS5llroiLHUzplsoSPGI3seofTFIyefmih9sdTJljIsxZls50xGR4xH9jxCR4xHdq4jLHTEeGTPI3TEGT1i3XJ9ydaX9fGD19JdX8Zadl9Gd2G3eWO01VuKjhhLnWuplY4YS51sKSplLHWypWigsdTJlqKBxlInW8qwFJY611IU1hkt9e3XKrb3VxYvOx10k7JTKzcpO01xk7LT5jYo+9DRuDYpO61ok7LTXDYpO+1ik7IbsrcoOy1dk7LT0qWUfZivL3m0Ydz5y/NQ5uufnodlt/EfSre5Yxg7byo6QEx1uqloGDHV6aaiv8RUr5lqcqbqaUcx1bOm2tlFcWGLqTDV2aai2cVUp5uK3hhTnW4qw1SY6mxT0XljqtnGTe55LDvfmO6/vdYPWbrem4pGHVM9a6p5tU2WpQSmolHHVKebikYdU51uKhp1THW2qQqNOqY63VQ06pjqdFPRqGOq001Fo46pTjeVYSpMdanUN1PNU/EuoSLHJfsuofPGJfOyfrhk7c27hBI7pUvMls0l8+5fvly53f506fxF2UIrjUsu7+rjTw/D8PjhVsbrvgAr88eD+zV8Id32jSi7uQfH5cE//EeBjf/e6L+Brhv/vdN/1OL4753+o0HHf+/0H2U7/nun/wz/4b83+o/GH/+9039cS8B/7/QfVynw3zv9x/UP/PdO/3H9A/+90X/G9Q/8907/cf0D/73Tf1z/wH/v9B/XP/DfO/1n+A//vdF/XP/Af+/0H9c/8N87/cf1D/z3Tv9x/QP/vdN/XP/Af2/038j1D/z3Tv9x/QP/vdN/XP/Af+/0H9c/8N87/Wf4D/+90X9c/8B/7/Qf1z/w3zv9x/UP/PdO/3H9A/+9039c/8B/b/TfxPUP/PdO/3H9A/+9039c/8B/7/Qf1z/w3zv9Z/gP/73Rf1z/wH/v9B/XP/DfO/3H9Q/8907/cf0D/73Tf1z/wH9v9N/M9Q/8907/cf0D/73Tf1z/wH/v9B/XP/DfO/1n+A//vdF/XP/Af+/0H9c/9v1n0+Y/W5fbB/9g2GiHb+v16BnHft5hOF95L8vNYVmuNmy0hn4G4Tpd//C6jL8g/OzPiEY72i8hztJogfk1xGm03fsa4jRafX0NcRrthb6GOIY49YrTaKPwNcRpNG5/DXHI8RWLQ0NQsTg0BPWKs9IQVCwODUHF4tAQVCwODUHF4hji1CsODUHF4tAQVCwODUHF4tAQVCwODUG14lhHQ1CxODQEFYtDQ1CxODQEFYtjiFOvODQEFYtDQ1CxODQEFYtDQ1CxODQE9YrT0xBULA4NQcXi0BBULA4NwbniTN3129c2lc7zNnhLeZPjtbyJ5lrepO2TeW8/iGHTHPAmQGt5k4mlvAsxV8ub5KrlTRiVzieFfKnlbfCW8iZfanmTL7XnS/Klljf5UsubfCnlPZAvtbzJl1re5Estb/KllrfBW8qbfKnlTb6U5vmBfKnlTb7U8iZfSnkb+VJ6vjTypZY3+VLLm3yp5W3wlvImX2p5ky+1vMmXWt7kSy1v8qWU90i+lOb5kXyp5U2+1PImX2p5G7yl50vypZY3+VLLm3yp5U2+1PImX0p5T+RLLW/ypZY3+VLLm3yp5W3wVub5iXyp5U2+1PImX2p5ky+150vypZT3TL7U8iZfanmTL7W8yZda3gZvKW/ypZY3+VLLm3yp5U2+lOb5mXwp5b2QL7W8yZda3uRL6flyIV9qeRu8pbzJl1re5Estb/Klljf5UsubfCnlvZIvtbzJl1re5Etpnl/Jl1reBm8pb/Klljf5Unu+JF9qeZMvtbzJl0reY0e+1PImX2p5ky+1vMmXWt4Gbylv8qWWN/lSmefHjnyp5U2+1PImX0p59+RL6fmyJ19qeZMvtbzJl1reBm8pb/Klljf5UsubfKnlTb7U8iZfSnkX8qU0zxfypZY3+VLLm3yp5W3wlp4vyZda3uRLLW/ypZY3+VLLm3wp5T2QL7W8yZda3uRLLW/ypZa3wVuZ5wfypZY3+VLLm3yp5U2+1J4vyZdS3ka+1PImX2p5ky+1vMmXWt4Gbylv8qWWN/lSy5t8qeVNvpTmeSNfSnmP5Estb/Klljf5Unq+HMmXWt4Gbylv8qWWN/lSy5t8qeVNvtTyJl9KeU/kSy1v8qWWN/lSmucn8qWWt8Fbypt8qeVNvtSeL8mXWt7kSy1v8qWU90y+1PImX2p5ky+1vMmXWt4Gbylv8qWWN/lSmudn8qWWN/lSy5t8KeW9kC+l58uFfKnlTb7U8iZfankbvKW8yZda3uRLLW/ypZY3+VLLm3wp5b2SL6V5fiVfanmTL7W8yZda3gZv6fmSfKnlTb7U8iZfanmTL7W8yZdK3lNHvtTyJl9qeZMvtbzJl1reBm9hnp868qWWN/lSy5t8qeVNvtSeL8mXUt49+VLLm3yp5U2+1PImX2p5G7ylvMmXWt7kSy1v8qWWN/lSmud78qWUdyFfanmTL7W8yZfS82UhX2p5G7ylvMmXWt7kSy1v8qWWN/lSy5t8KeU9kC+1vMmXWt7kS2meH8iXWt4Gbylv8qWWN/lSe74kX2p5ky+1vMmXUt5GvtTyJl9qeZMvtbzJl1reBm8pb/Klljf5UprnjXyp5U2+1PImX0p5j+RL6flyJF9qeZMvtbzJl1reBm8pb/Klljf5UsubfKnlTb7U8iZfSnlP5Etpnp/Il1re5Estb/KllrfBW3q+JF9qeZMvtbzJl1re5Estb/KllPdMvtTyJl9qeZMvtbzJl1reBm9lnp/Jl1re5Estb/Klljf5Unu+JF9KeS/kSy1v8qWWN/lSy5t8qeVt8JbyJl9qeZMvtbzJl1re5Etpnl/Il1LeK/lSy5t8qeVNvpSeL1fypZa3wVvKm3yp5U2+1PImX2p5ky+1vMmXSt5zR77U8iZfanmTL5V5fu7Il1reBm8pb/Klljf5Unu+JF9qeZMvtbzJl1LePflSy5t8qeVNvtTyJl9qeRu8pbzJl1re5Etpnu/Jl1re5Estb/KllHchX0rPl4V8qeVNvtTyJl9qeRu8pbzJl1re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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "ndLNCoQgFAXgd7nrFl2131eJIawsBLEwGxiidx+LZmiGNrq5eMTvujkrdKJZhlrqfpyhrFZQY8utHLVL6xZBY6RScqiv1xDvA/F4P09c73G23FgoEWkEQnfuRND5XioBJcvY9ogAiT+h/oT5k8SbkNtfClqkpykYoV+EGB8oCUFpCMpCUB6A6G0PCpYnH5TE7BdtLj65kbxR4uxZv+j2Ujv7msRfAycztqJbjNi7eKmhmxVmESFurVv9Bg==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "register_dkim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim"
      ]
    },
    {
      "name": "get_participants",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "name",
                            "type": {
                              "kind": "array",
                              "length": 2,
                              "type": {
                                "kind": "field"
                              }
                            }
                          },
                          {
                            "name": "npk_m_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "randomness",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "header",
                            "type": {
                              "fields": [
                                {
                                  "name": "contract_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "nonce",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "storage_slot",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "note_hash_counter",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::note::note_header::NoteHeader"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::participant_note::ParticipantNote"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_participants"
      ]
    },
    {
      "name": "check_and_register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12235207718074526931": {
            "error_kind": "string",
            "string": "Escrow contract is not registered"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7P3bkizZslyJ/ct+xoNfzG/9KxQKBWSjKRBpASgE+ATpf2fsqsrILKROt1rIuSLcTcfbQXecOm5DY6Xr1HBz/R//+t//0//z//f//n/85//yf/zX//av/+3/9j/+9X/+1//Xf/zv//m//pfH/+t//Gub//j/9t/+P//xv/z7//nf/vt//P/+93/9b+N6DP/hX//pv/zvj/9xG4b/6z/86//4z//nf/rX/xZb/F//4dunp33e//r0tK+fnx7jEJ+el/H469PzckzJp/fj+d/ej2V8fnoeZvHpcX7+t8d53p+fnlb14WFaPz48bMvXD//f/8O/tgCMBrMARoNZAaPBbIDRYHbAaDAHYCSYfQCMBjMCRoOZAKPB4HwbYAIwGgzOtwEG59sAg/NtgMH5NsDgfDWYA+fbAIPzbYDB+TbA4HwbYAIwGgzOtwEG59sAg/NtgMH5NsDgfDWYccD6tsjgfVtkML8tMrjfFpmATIMM/rdFBgPcIoMDbpHBArfI4IEbZEY8cIsMHrhFBg/cIoMHbpEJyDTI4IFbZPDALTJ44BYZPHCLDB64QWbCA7fI4IFbZPDALTJ44BaZgEyDDB64RQYP3CKDB26RwQO3yOCBG2RmPHCLDB64RQYP3CKDB26RCcg0yOCBW2TwwC0yeOAWGTxwiwweuEEm8MAtMnjgFhk8cIsMHrhFJiDTIIMHbpHBA7fI4IFbZPDALTJ44AaZBQ/cIoMHbpG5vAfelieZ/cjIbPv8cd37MP2MzOU98NvIBGQaZC7vgd9GpoMHjmH5uPoYjs+/kvtf/ye23/9/ooMre/xcG59/vY8viu3i08fjdvDXp49j3b9ekPjqTPP+8d+ephjnb9d/3Pv6V+lwtmP9+L+xHXuk/772D4mnY/ryL2aV/2KW7fmtHr7+85rlh8ePfzD7sgzJP699iuenpyO76c/Lxz+vmIbzf4rT9vynOG2RfLjnP/J1RJ4ryzMhz5XlmZHnyvLEq+UZHyf6jwsavzD8tz5/XNFyuStaL3dF2+WuaL/cFR1Xu6JtuNwVjZe7oulyVzRf7ore8Dd7eGZzU6zfr2i53BW9/m/2ti7P8+b/pNr3T3/ewh/X9MVHbOo6Hr/PflzH47D+t0//MetmNOtuNOtRadZ1fs66fZ91H4xmHY1mnSrN+vzwNH05dz1nnY1mDaNZl1L3nC+zzt9nreSbpmF7zjpt32et5JuyWSv5pmzWUr7py7/X6fv99bi4b9qfFnccxiMZ9vfFq9PxcVqc5jFLTDs+iHJc3Oq5y3Nxd3oRed7148RxcUPtLk+YyPPHsG84BMT0lGqaM1MRH55o+/JAyrRMf179euur32599futr/648dVPw3Drqx9vffXTra9+vvXVx62v/s732mm48712Gu58r52GO99rp+HW99rx1vfa8db32vHW99rx1vfa8db32vHW99rx1vfa8db32vHW99rx1vfa6db32unW99rp1vfa6db32unW99rp1vfa6db32unW99rp1vfa6db32vnW99r51vfa+db32vnW99r51vfa+db32vnW99r54vfa/fkUwb4P36/+4vfa5Oovfq891i/b2ePfLv/7h2NZn4/BLMfnAygm29lTXNx6IOaviHlxJ4aYvyLmxY0pYv6KmBf36Yj5K2IGYtYR8+KnOMT8FTEvfqhFzF8R8+JnfMT8FTEvHnkg5q+ISQJUR8yFBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEB1xFxJgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzI0EqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXE3EmAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEfMgwSokJgkQIXEJAEqJCYJUCExAzHriEkCVEhMEqBCYpIAFRKTBKiQmCRAZcScBxKgQmKSABUSkwSokJgkQIXEDMSsIyYJUCExSYAKiUkCVEhMEqBCYpIA1RFzJAEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTEnEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJgAqJSQJUSEwSoEJikgDVEXMmASokJglQITFJgAqJSQJUSMxAzDpikgAVEpMEqJCYJECFxCQBKiQmCVAdMYMEqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXEXEiAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEfMlQSokJgkQIXEJAEqJCYJUCExAzHriEkCVEhM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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_notes_internal",
        "get_collapse_hints",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "pack_arguments_oracle_wrapper",
        "pack_returns_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_managed_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_managed_escrows"
      ]
    },
    {
      "name": "get_escrow_class_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAGEHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAAGtHgIAAgkmAgMAAQo4AgMEIwIABAAAAIUkAAABvyYCAgAALAgBBCYCBQQEABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYsCAECAAABAgEsDgQCJgIEBAEmAgUEACYCBgQDLAwFASIAAADhDDgBBgUjAgAFAAABDyIAAADzLA0CASYCAgQCACgBAgQAOAQCBSwNBQMsDAMBJSwNAgUcDAEHAAA4AwcILgwACAAHJgIJBAMMOAEJCiMCAAoAAAE6JAAAAdEtBAAFgAMnAIAEBAAEJAAAAeMtCIAFAAgAKAgCCQA4CQEKLA4HCgA4AQQFDjgBBQcjAgAHAAABdyQAAAJxLA4IAiwMBQEiAAAA4ScAgAQEeAANAAAAgASAAyMAgAMAAAGsKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVSVfKdc0WarDsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAB/iIAAAIJLQCAA4AFIgAAAnAtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAACXC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAACKycBgAUEAAEDAIAGAAKABiIAAAJwJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "1ZrbjuIwDIbfpde9iHOyzausRqMCZVSpKqjASivEu2+KaKdb2FTDMDPxDWrQn/qTkzqxk1O2LpfHt9eq2Wz32eLXKau3q+JQbZvQOp3zbNlWdV29vY7/zlT34/mi3++KpmvuD0V7yBbgWeVZ2azDIyoV3rCp6jJbWLTn/FatlOvVSrtBDZbuqK0huqqtYRzU5O6ICUz/agIHY/FLnqF9BjzpXh3ovxH+KZ63MHjez3kenOnhwbGNw7PW/atZezuBJ3wuPKh/4YMJ1l9uIkzcb7DhPm/D42DDo5ubdsT9jCYGNxm5wPhRnksv90gv/ZAtTY/0MuZur/AN4jA8huY8rYF6efgARuHA8x01avBXNWozMy6eqA8H4dFPx8WQbH6rhfOjbH4n3P9OuP+9cP97L5sflXB+J5yfZfOTFc4vfP/AwuMny16/tE4+/jD0eU14NFN+m/z+n4kHfnY3/D8yfxQM/E7H+ZFNn1aO6iTW8QX/Z7afz8OX7X0v2/sIsmNP8ns3VEMpEpW9iT2U+t4ZlVYx/vT9r/Cd38fFoSSNZijrsrpZqjn9zyW61HHyqWaU3yjZ/jcq+VQtzg9WNr9OvlQxw598qhPnN8mnmjP8yaf6cX7hqZqxwv2f/lHBDL/w+JP+UUGcP/1S+wx/+qWu//OfQ+t30VbFsi6v13s2x2Y1uu1z+LMrJxd/du12Va6PbdldAXq//dONYzhVB4CX7qZCaKHLSXWNbosLIekFsMFkMPsX",
      "brillig_names": [
        "get_escrow_class_id"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "usdc",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "register_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10966310306735189739": {
            "error_kind": "string",
            "string": "Escrow contract USDC does not match registry USDC"
          },
          "12806906349574299095": {
            "error_kind": "string",
            "string": "Escrow contract has already been registered"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14827131733433028185": {
            "error_kind": "string",
            "string": "Escrow contract registry does not match this contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17408225848945384450": {
            "error_kind": "string",
            "string": "Proving nullifier inclusion failed"
          },
          "17540660350934727925": {
            "error_kind": "string",
            "string": "Nullifier does not match value in witness"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089479698890196495": {
            "error_kind": "string",
            "string": "Escrow contract admin does not match sender of message"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6337220856976823863": {
            "error_kind": "string",
            "string": "Escrow contract class ID does not match expected class ID"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_contract_instance_internal",
        "get_nullifier_membership_witness",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "unpack_returns",
        "get_public_keys_and_partial_address",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "pack_arguments_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "set_contract_registered",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_contract_registered"
      ]
    },
    {
      "name": "check_dkim_key_hash_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "check_dkim_key_hash_public"
      ]
    },
    {
      "name": "check_dkim_key_hash_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5886526716701834683": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_private can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_returns_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAAABAEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAlRoCLLm+nq\n5U8x+eVn4detbaeEaE6iW4eFI6JWSNX+CUa+O3N20ywwfRbkJOML+vDlhZfKASqORKQX/3lJXNgX\neJ1eheWytWREzFS8GC/RLNtKvv7LB0kTREy1vn8GuQeN7by4RK8u2R35rjyB1zYlrRZmjRo0Yyql\nREnLqPBEL6U8nZl6G8RmTl61A+6Y3+D2jBwO/N2OyQo5Oo0tR/YXfXuFnDqVVKUOyAmuPMO0w2Md\n0h/Hjm7Kk6yGLqzlEhK0V6ldhZyKttEJlJ2B2Bvk/wjz4c+rP3Y+pJty9F0wJEG/SsEuG5/f1bW7\n17lNUKWlR+z3lH27n2wgZMV5wp4UvN2C/ypZH1Ub6z/EM3vXVVfwjzdZWKad3Ng8aUcJbhs4I0Fu\najvwQakBoOLCPB2zJCXqT3Ec9bOX/iUQhWF0ATmmFGHRKnbuOVtPHDkmqUE4r089n967WcODojU6\nwqktjC/oVfZaeXnlbJEqlIDlWHwr9y91Cn1NaRljFkqlECqHEK2Ho8Be1crPjUEI0RcDAhlQKym3\nfWCHWE9j4fULFkcUI7/Z7Gm2oKkCJbDBGMqfNvl0/qkF4/N+keqIqvUfUbarWUimcHY1O+Ze1iAG\n/qHeftR7/JbbuMDeOu7JTg76Xs2D69/vYXFMrwG29MZrPu6yYBF72TKudLSpQ9jeCjwuBMGhopIT\noK3Q9cI6XNIFSeLNaTypf99GJ1a5yMMjsFr2Kyzkbk2KlZfK9kZ7DJBxroqcifkwLz7P05c4+iXW\ntK3k5KYmr2nG96+KvtqVnesWzPD52R8OFQ3lfxngJqVhFdIr9PqFdktPx0H6QDoVaeqm6cNi44NQ\nemPo70wdWofvthy4uxUKRzAmRGoSdEeIpmW+UOcDuoGZDa0H8BE/AU2l8u2I1ov813hiHhk1yiRD\nRNOexGC0eHHn/hIcEkAej1UXHd9Xap8TnNkbdvu00KVYI9bMTZ9dmKwnX+YBinSzXot56jQb1xKK\n2PW4axgVbY7yRplMTjJOzKE4DC85Ed04PPKWVAHVV0B7p+nl6iGd4LxscGOv4iVoq2i5IbA+/GiB\nFCYprAdludB+XcUybgnyIuYKMUpR7ytKCg0ngi/3u5SDsp35d4XuX53STwoM84ypMWvkAMdDu7s7\n7AHWqxqveUTCvgSupAYNcUaNR9MftIDiwZLdtmc+XL6oAgKjyP0GF80GW1zYWuxsvHlPbYcdLu4x\nGL+xMZ1ld9YSv4HV+04iOcv7ljd+zwoYNejMmuy5fwULG1vD+nyScixjW+JyhpmnNJ/RqYPfEVhR\nDulMxyjr/osSPmMswSxZFjBl7JjYcJ/soQjUcXqHih9OnmMGy5KQsvnTdb4ft6kT/Ib7pmwm0vSH\nCbcB5JkHoBNGHv6MkZhoNSAngfn76Q+iXGovX+HcMJ0LDanx+OEzxDhyrxYvkNl8dlVtWc6PLSi2\nxlnU7vMo0Y86hvPIXQZprbcNstCrr8+aOPscxyIuxwkRchjEnYHBHOYp9EwqqSikH+bA8HZ76Cod\nXbBrXyl6d1l2U2WxnPbVKf9NUMqfE8HfhxlD7hXMEeymcuWvK+E5voWyldL6WDzdqZRUG2kOPJqT\n312zbI8m251/MY0BZ3CidoJ8ES5fL1dYWg8tkEXggkxt7KuM3nmYueFEtwGHwdWvBSdxQd1dWvVK\nFe91qGE4Flc93peH1EKCc/e8DsEUqnz4WX/lrmSJafp7KreqC2ab3mAc7cQD/K/98v8cAMJX80om\nFQEzW5uxLnaM7TAcP86WJ8SwsMiffjEpECHWaXFDu0gwFkaSDJpxzMklI/SESrW4/qFd1YGi3WFH\nHx/AXmI77kSvgOCwxB0qpq5u3Tv5GUXRszQHqjhVtusiz2mZauRxBWvK57PDjLw6zG3vQWTYeLVu\nWy/iv6UhmQdcwsPJ4web7IZ2SqXP0COWI4OcUb5v/oPHfIC4+UrVDF3W4p6skHbML1mV/PJ8jIi0\nhSmJGb9xZEQJQtb2xa0J/Fb1ohItHtk1OGC6aKtbesQ2+IiZmkj3nvIS5kg/FAiDSZwiZljYO00M\nx7CMFdrOTiO/QbVeMJi9joLnSxweHyaMCUW96klPv8UuhYHBXANz2LKGv3JzAVcaVOFjbncBuS+S\nBCriVW4xz3LMOZDGt+dwweYuJQTOmG8hMk/5OTA4/+YoThdERaDrEaY+C3AHIgwsAvTsLBxfrakF\na4w3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAijZgVPiaqE5xfmVoS1rgoNE5801i7AI+iWU9C4gWKTaCru9sEL+XedxRom0sZjL\n672Za6gt1ILAzZ+T26XJSPEPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvJ8qczwFCmSOmHYcsfCJMQmRoHJE2ov3nE3M173Fv7N4Z\nKxptOxTf5amtY5UdLXZt9e5ME1hEP1oUCGtRluE+Rg=="
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000b3dd3286"
            },
            {
              "kind": "string",
              "value": "ParticipantNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "name",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseEscrow"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "entitlements",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "escrow_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "dkim_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "managed_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participants",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participant_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "dkim_key_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "verifier_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::DKIMKeyHashRegistered"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_bulk_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_bulk_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_registry_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_registry_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_class_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_class_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "usdc",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow_contract_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_and_register_participant_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_and_register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::set_contract_registered_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::set_contract_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "105": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "107": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "108": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "109": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "110": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "112": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "113": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "114": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "119": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "120": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "122": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\n\npub struct NullifierMembershipWitness {\n    pub index: Field,\n    pub leaf_preimage: NullifierLeafPreimage,\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let serialized_leaf_preimage = array::subarray(fields, 1);\n\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"
    },
    "125": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "126": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "129": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "131": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 bytes.\n//\n// Each 31 byte chunk is converted into a Field as if the chunk was the Field's big endian representation. If the last chunk\n// is less than 31 bytes long, then only the relevant bytes are conisdered.\n// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\npub fn bytes_to_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut dst = [0; (N + 30) / 31];\n\n    for dst_index in 0..((N + 30) / 31) {\n        let mut field_value = 0;\n\n        for i in 0..31 {\n            let byte_index = dst_index * 31 + i;\n            if byte_index < N {\n                // Shift the existing value left by 8 bits and add the new byte\n                field_value = field_value * 256 + input[byte_index] as Field;\n            }\n        }\n\n        dst[dst_index] = field_value;\n    }\n\n    dst\n}\n\n// Converts an input array of fields into bytes. Each field of input has to contain only 31 bytes.\n// TODO(#8618): Optimize for public use.\npub fn fields_to_bytes<let N: u32, let M: u32>(input: [Field; M]) -> [u8; N] {\n    let mut dst = [0; N];\n\n    for src_index in 0..M {\n        let field = input[src_index];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let src: [u8; 31] = field.to_be_bytes();\n\n        // Since some of the bytes might not be occupied (if the source value requiring less than 31 bytes),\n        // we have to compute the start index from which to copy.\n        let remaining_bytes = N - src_index * 31;\n        let src_start_index = if remaining_bytes < 31 {\n            // If the remaining bytes are less than 31, we only copy the remaining bytes\n            31 - remaining_bytes\n        } else {\n            0\n        };\n\n        // Note: I tried combining this check with `assert_max_bit_size` above but `assert_max_bit_size` expects\n        // the argument to be a constant. Using comptime block to derive the number of bits also does not work\n        // because comptime is evaluated before generics.\n        for i in 0..src_start_index {\n            assert(src[i] == 0, \"Field does not fit into remaining bytes\");\n        }\n\n        for i in 0..31 {\n            let byte_index = src_index * 31 + i;\n            if byte_index < N {\n                dst[byte_index] = src[src_start_index + i];\n            }\n        }\n    }\n\n    dst\n}\n\nmod test {\n    use crate::utils::bytes::{bytes_to_fields, fields_to_bytes};\n\n    #[test]\n    fn test_bytes_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_bytes() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_bytes(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_less_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_bytes(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_bytes_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_bytes() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_input_to_fields_and_back(input: [u8; 128]) {\n        let output = bytes_to_fields(input);\n        let input_back: [u8; 128] = fields_to_bytes(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_bytes(input);\n        let input_back = bytes_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"Field does not fit into remaining bytes\")]\n    fn test_too_few_destination_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_bytes(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_bytes_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_bytes(input);\n    }\n\n    #[test]\n    fn test_fields_to_bytes_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_bytes(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "145": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::DEPLOYER_CONTRACT_ADDRESS,\n    hash::compute_siloed_nullifier,\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for BlockHeader {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for BlockHeader {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for BlockHeader {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for BlockHeader {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n"
    },
    "146": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr",
      "source": "use dep::protocol_types::block_header::BlockHeader;\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{\n    context::PrivateContext,\n    note::{note_interface::{NoteInterface, NullifiableNote}, utils::compute_siloed_nullifier},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: BlockHeader, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for BlockHeader {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving nullifier inclusion failed\",\n            );\n\n            // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n            // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n            // care about is showing that the tree contains an entry with the expected nullifier.\n            assert(\n                witness.leaf_preimage.nullifier == nullifier,\n                \"Nullifier does not match value in witness\",\n            );\n        }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(\n        header: BlockHeader,\n        note: Note,\n        context: &mut PrivateContext,\n    )\n    where\n        Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for BlockHeader {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(self, note: Note, context: &mut PrivateContext)\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"
    },
    "148": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "149": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "150": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "153": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "154": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "161": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "197": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr",
      "source": "pub global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable},\n    hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct NullifierLeafPreimage {\n    pub nullifier: Field,\n    pub next_nullifier: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<Field> for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_key: Field, next_index: u32) -> Self {\n        Self { nullifier: self.nullifier, next_nullifier: next_key, next_index }\n    }\n\n    fn update_value(self, _nullifier: Field) -> Self {\n        assert(false, \"Tried to update a nullifier\");\n        Self::empty()\n    }\n\n    fn build_insertion_leaf(nullifier: Field, low_leaf: Self) -> Self {\n        Self { nullifier, next_nullifier: low_leaf.next_nullifier, next_index: low_leaf.next_index }\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value =\n            compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(\n            self.nullifier,\n            siloed_value,\n            \"Value of the nullifier leaf does not match read request\",\n        );\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"
    },
    "205": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "212": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "241": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n"
    },
    "252": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "267": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "268": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "284": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "287": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "289": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "290": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "293": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "294": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "296": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "297": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "301": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "302": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "303": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "304": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "307": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "313": {
      "path": "/Users/ianbrighton/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "321": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_escrow/src/types/entitlement_note.nr",
      "source": "use aztec::{\n    encrypted_logs::encrypted_event_emission::encode_and_encrypt_event,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::{note, note_custom_interface},\n    note::utils::compute_note_hash_for_nullify,\n    oracle::{random::random, notes::check_nullifier_exists, debug_log::debug_log_format},\n    prelude::{NoteHeader, NullifiableNote, NoteInterface, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        traits::{Serialize, Deserialize},\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::{poseidon2_hash_with_separator, poseidon2_hash_bytes},\n        utils::field::field_from_bytes,\n    },\n};\nuse compressed_string::CompressedString;\nuse generators::GENERATORS;\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\nuse crate::{ZERO_DESTINATION, ZImburseEscrow::{SpotReimbursementClaimed, RecurringReimbursementClaimed, EntitlementNullified}};\n\nglobal ENTITLEMENT_NOTE_LENGTH: u32 = 8;\n\n#[note_custom_interface]\npub struct EntitlementNote {\n    // the user that is allowed to use this entitlement\n    recipient: AztecAddress,\n    // the type of receipt verifier that this entitlement can be used for\n    verifier_id: u8,\n    // the maximum value that can be withdrawn from the escrow using this entitlement\n    max_value: U128,\n    // date range that verified emails can be used for\n    date_start: u32,\n    date_end: u32,\n    // destination if used for travel\n    destination: Field,\n    // whether or not the entitlement is a spot entitlement\n    spot: bool,\n    // blinding factor & nullifier secret for the note\n    randomness: Field,\n}\n\nimpl NoteInterface<ENTITLEMENT_NOTE_LENGTH> for EntitlementNote {\n\n    fn serialize_content(self) -> [Field; ENTITLEMENT_NOTE_LENGTH] {\n\n        [\n            self.recipient.to_field(),\n            self.verifier_id as Field,\n            self.max_value.to_integer(),\n            self.date_start as Field,\n            self.date_end as Field,\n            self.destination,\n            self.spot as Field,\n            self.randomness\n        ]\n    }\n\n    fn deserialize_content(serialized_note: [Field; ENTITLEMENT_NOTE_LENGTH]) -> EntitlementNote {\n        EntitlementNote {\n            recipient: AztecAddress::from_field(serialized_note[0]),\n            verifier_id: serialized_note[1] as u8,\n            max_value: U128::from_integer(serialized_note[2]),\n            date_start: serialized_note[3] as u32,\n            date_end: serialized_note[4] as u32,\n            destination: serialized_note[5],\n            spot: serialized_note[6] as bool,\n            randomness: serialized_note[7],\n            header: NoteHeader::empty()\n        }\n    }\n\n    fn to_be_bytes(self, storage_slot: Field) -> [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] {\n        let serialized_note = self.serialize_content();\n        let mut buffer: [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] = [0; ENTITLEMENT_NOTE_LENGTH * 32 + 64];\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = EntitlementNote::get_note_type_id().to_be_bytes();\n        for i in 0..32 {\n            buffer[i] = storage_slot_bytes[i];\n            buffer[32 + i] = note_type_id_bytes[i];\n        }\n        for i in 0..serialized_note.len() {\n            let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n            for j in 0..32 {\n                buffer[64 + i * 32 + j] = bytes[j];\n            }\n        }\n        buffer\n    }\n\n    fn get_note_type_id() -> Field {\n        comptime\n        {\n            let bytes = \"EntitlementNote\".as_bytes();\n            let hash = poseidon2_hash_bytes(bytes);\n            let hash_bytes = hash.to_be_bytes::<4>();\n            field_from_bytes(hash_bytes, true)\n        }\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn compute_note_hash(self) -> Field {\n        let serialized = self.serialize_content();\n        let generators = [\n            GENERATORS[0],\n            GENERATORS[1],\n            GENERATORS[2],\n            GENERATORS[3],\n            GENERATORS[4],\n            GENERATORS[5],\n            GENERATORS[6],\n            GENERATORS[7],\n            GENERATORS[8]\n        ];\n        let data = [\n            from_field_unsafe(serialized[0]),\n            from_field_unsafe(serialized[1]),\n            from_field_unsafe(serialized[2]),\n            from_field_unsafe(serialized[3]),\n            from_field_unsafe(serialized[4]),\n            from_field_unsafe(serialized[5]),\n            from_field_unsafe(serialized[6]),\n            from_field_unsafe(serialized[7]),\n            from_field_unsafe(self.get_header().storage_slot)\n        ];\n        std::embedded_curve_ops::multi_scalar_mul(generators, data).x\n    }\n}\n\nimpl NullifiableNote for EntitlementNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = self.randomness; // use as nullifier_secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = self.randomness; // use as nullifier secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for EntitlementNote {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient)\n            & (self.date_start == other.date_start)\n            & (self.date_end == other.date_end)\n            & (self.destination == other.destination)\n            & (self.max_value == other.max_value)\n            & (self.randomness == other.randomness)\n            & (self.spot == other.spot)\n            & (self.verifier_id == other.verifier_id)\n    }\n}\n\nimpl EntitlementNote {\n    \n    /**\n     * EntitlementNote constructor\n     *\n     * @param recipient - the address of the recipient of the entitlement (NOT THE OWNER OF THE NOTE)\n     * @param verifier_id - the type of verifier that the entitlement can be used for\n     * @param max_value - the maximum value that can be withdrawn from the escrow using the entitlement\n     * @param date_start - the start of the date range that the entitlement can be used for (0 for recurring)\n     * @param date_end - the end of the date range that the entitlement can be used for (0 for recurring)\n     * @param destination - the destination of the entitlement (ZERO_DESTINATION for recurring)\n     * @param randomness - blinding factor for the note (inputted since must be same between the two notes)\n     */\n    fn new(\n        recipient: AztecAddress,\n        verifier_id: u8,\n        max_value: U128,\n        date_start: u32,\n        date_end: u32,\n        destination: str<31>,\n        spot: bool,\n        randomness: Field\n    ) -> Self {\n        let destination_compressed: CompressedString<1, 31> = CompressedString::from_string(destination);\n\n        // assert destination \n        if spot == false {\n            assert(date_end == 0, \"Date end must be zero if entitlement is recurring.\");\n            assert(date_start == 0, \"Date start must be zero if entitlement is recurring.\");\n            assert(destination == ZERO_DESTINATION, \"Destination must be empty if entitlement is recurring.\");\n        }\n\n        Self {\n            recipient,\n            verifier_id,\n            max_value,\n            date_start,\n            date_end,\n            destination: destination_compressed.value[0],\n            spot,\n            randomness,\n            header: NoteHeader::empty()\n        }\n    }\n\n    /**\n     * Return the destination of the entitlement\n     *\n     * @return the utf8 bytes of the destination\n     */\n    fn destination(self) -> [u8; 31] {\n        CompressedString::<1, 31> { value: [self.destination] }.to_bytes()\n    } \n\n    /**\n     * Constrain a given timestamp to be within the date range of the entitlement\n     *\n     * @param timestamp - the timestamp to check\n     */\n    fn check_date_range(self, timestamp: u32) {\n        debug_log_format(\"\\n\\n\\n\\nChecking date range:\\nStart: {0}\\nTimestamp:{1}\\nEnd:{2}\", [\n            self.date_start as Field,\n            timestamp as Field,\n            self.date_end as Field\n        ]);\n        assert(\n            (timestamp >= self.date_start) & (timestamp <= self.date_end),\n            \"Receipt is out of entitlement date range\"\n        );\n    }\n\n    /**\n     * Determine the amount to reimburse for a given claimed amount (lesser of the two)\n     *\n     * @param claimed - the amount claimed by the user\n     * @return the amount to reimburse\n     */\n    fn amount_to_reimburse(self, claimed: U128) -> Field {\n        if self.max_value >= claimed {\n            claimed.to_field()\n        } else {\n            self.max_value.to_field()\n        }\n    }\n\n    fn derive_shared_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            self.serialize_content(),\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Derives the nullifier for recurring notes\n     * @dev recurring notes are nullified for a scope (month) without destroying the ntoe\n     *      prove nullifier non-inclusion to use\n     *\n     * @param timestamp - the timestamp (month/ year) from the email receipt verifier\n     * @return - the month nullifier for the note\n     */\n    fn derive_recurring_nullifier(self, timestamp: Field) -> Field {\n        let serialized = self.serialize_content();\n        let mut inputs: [Field; ENTITLEMENT_NOTE_LENGTH + 1] = [0; ENTITLEMENT_NOTE_LENGTH + 1];\n        for i in 0..ENTITLEMENT_NOTE_LENGTH {\n            inputs[i] = serialized[i];\n        }\n        inputs[ENTITLEMENT_NOTE_LENGTH] = timestamp;\n        poseidon2_hash_with_separator(\n            inputs,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Assert that a recurring nullifier has not been used before and emits it\n     * @dev uses oracle check_nullifier_exists which is technically unsafe but will be caught by kernel\n     *\n     * @param context - the private context to use for the oracle call\n     * @param timestamp - the timestamp to check\n     */\n    fn check_and_emit_recurring_nullifier(self, context: &mut PrivateContext, timestamp: Field) {\n        // derive recurring nullifier for the month\n        let recurring_nullifier = self.derive_recurring_nullifier(timestamp);\n        // check the nullifier has not been emitted via oracle call (rely on kernel to actually constrain)\n        let recurring_nullifier_exists = unsafe { check_nullifier_exists(recurring_nullifier) };\n        assert(!recurring_nullifier_exists, \"Entitlement has already been claimed for this month\");\n        // emit the nullifier\n        context.push_nullifier(recurring_nullifier);\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a recurring claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     * @param timestamp - the timestamp of the claim\n     */\n    fn emit_recurring_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field, timestamp: Field) {\n        RecurringReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n            timestamp\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                self.recipient\n            )\n        );\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a spot claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     */\n    fn emit_spot_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field) {\n        SpotReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                self.recipient\n            )\n        );\n    }\n\n    /**\n     * Admin or recipient notifies counterparty that note has been nullified\n     * @dev admin emits event when revoking entitlement, recipient emits when claiming spot\n     * @dev clients must scan for these events to prune notes that are no longer valid\n     *\n     * @param context - the private execution context\n     * @param to - the address of the counterparty to notify\n     * @param from - the address of the notifier who nullified the entitlement note\n     */\n    fn emit_nullified(self, context: &mut PrivateContext, to: AztecAddress, from: AztecAddress) {\n        EntitlementNullified { randomness: self.randomness }.emit(\n            encode_and_encrypt_event(\n                context,\n                to,\n                from\n            )\n        );\n    }\n}\n"
    },
    "364": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "459": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/registry_definition.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\n\nglobal REGISTRY_DEFINITION_LENGTH: u32 = 3;\n\npub struct RegistryDefinition {\n    admin: AztecAddress,\n    usdc: AztecAddress,\n    escrow_contract_id: Field\n}\n\nimpl Serialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn serialize(self: Self) -> [Field; REGISTRY_DEFINITION_LENGTH] {\n        [self.admin.to_field(), self.usdc.to_field(), self.escrow_contract_id]\n    }\n}\n\nimpl Deserialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn deserialize(fields: [Field; REGISTRY_DEFINITION_LENGTH]) -> Self {\n        RegistryDefinition {\n            admin: AztecAddress::from_field(fields[0]),\n            usdc: AztecAddress::from_field(fields[1]),\n            escrow_contract_id: fields[2]\n        }\n    }\n}\n\nimpl RegistryDefinition {\n    /**\n     * Create a new definition for a Z-Imburse escrow registry contract\n     *\n     * @param admin - The address that can add dkim keys to the registry\n     * @param usdc The address of the USDC token\n     * @param escrow_contract_id The ID of the escrow contract\n     * @return The new escrow registry definition\n     */\n    pub fn new(admin: AztecAddress, usdc: AztecAddress, escrow_contract_id: Field) -> Self {\n        RegistryDefinition { admin, usdc, escrow_contract_id }\n    }\n}\n"
    },
    "460": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/participant_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}\n},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n"
    },
    "473": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/library_methods/dkim.nr",
      "source": "use aztec::{context::public_context::PublicContext, unencrypted_logs::unencrypted_event_emission::emit};\nuse crate::{\n    BULK_KEY_LENGTH,\n    ZImburseRegistry::{DKIMKeyHashRegistered, Storage}\n};\n\n/**\n * Register a single DKIM key\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hash - the hash of the DKIM key to add to the registry\n * @param verifier_id - the verifier ID to register the DKIM key to\n*/\n\npub fn register_dkim_key(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hash: Field, verifier_id: Field) {\n    let stored_id = storage.dkim_registry.at(dkim_key_hash).read();\n    assert(stored_id == 0, \"DKIM key has already been registered\");\n    storage.dkim_registry.at(dkim_key_hash).initialize(verifier_id);\n    emit(\n        context,\n        DKIMKeyHashRegistered { dkim_key_hash, verifier_id }\n    );\n}\n\n/**\n * Register multiple DKIM keys\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n * @param verifier_ids - the verifier IDs to register the DKIM keys to\n */\npub fn register_dkim_keys_bulk(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hashes: [Field; BULK_KEY_LENGTH], verifier_ids: [Field; BULK_KEY_LENGTH]) {\n    for i in 0..BULK_KEY_LENGTH {\n        if (verifier_ids[i] != 0) {\n            register_dkim_key(context, storage, dkim_key_hashes[i], verifier_ids[i]);\n        }\n    }\n}"
    },
    "474": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\nmod library_methods;\nmod test;\nmod types;\n\npub global BULK_KEY_LENGTH: u32 = 4;\n\n#[aztec]\ncontract ZImburseRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, PrivateSet, PublicImmutable, Map},\n        macros::{storage::storage, events::event, functions::{private, public, view, initializer, internal}},\n        note::{\n            note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions,\n            note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE\n        },\n        protocol_types::{\n            contract_instance::ContractInstance, address::partial_address::PartialAddress,\n            contract_class_id::ContractClassId, abis::function_selector::FunctionSelector, traits::Serialize\n        },\n        oracle::get_contract_instance::get_contract_instance,\n        keys::getters::get_public_keys, utils::comparison::Comparator,\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt_note_unconstrained, encode_and_encrypt_note},\n        unencrypted_logs::unencrypted_event_emission::emit\n    };\n    use std::{meta::derive, collections::bounded_vec::BoundedVec};\n    use dep::address_note::address_note::AddressNote;\n    use dep::zimburse_verifiers::constants::verifier_ids;\n    use dep::z_imburse_escrow::ZImburseEscrow;\n    use crate::{\n        library_methods::dkim::{register_dkim_key, register_dkim_keys_bulk},\n        types::{registry_definition::RegistryDefinition, participant_note::{ParticipantNote, NAME_LENGTH}},\n        BULK_KEY_LENGTH\n    };\n\n    #[derive(Serialize)]\n    #[event]\n    struct DKIMKeyHashRegistered {\n        dkim_key_hash: Field,\n        verifier_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        definition: PublicImmutable<RegistryDefinition, Context>,\n        escrow_registry: Map<AztecAddress, PublicImmutable<bool, Context>, Context>,\n        dkim_registry: Map<Field, PublicImmutable<Field, Context>, Context>,\n        managed_escrows: Map<AztecAddress, PrivateSet<AddressNote, Context>, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: Map<AztecAddress, PrivateSet<AddressNote, Context>, Context>,\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract\n     *\n     * @param usdc - The address of the USDC token\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n     */\n    #[public]\n    #[initializer]\n    fn constructor(\n        usdc: AztecAddress,\n        escrow_contract_id: Field,\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // initialize the registry definition\n        let definition = RegistryDefinition::new(context.msg_sender(), usdc, escrow_contract_id);\n        storage.definition.initialize(definition);\n        // add any DKIM key hashes that were passed in at initialization\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Bulk registration of DKIM keys\n     *\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys\n     */\n    #[public]\n    fn register_dkim_bulk(\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        // bulk insert up to 50 dkim key hashes\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Register a DKIM key hash for email verifiers to anchor trust to\n     *\n     * @param verifier_id - the ID of the verifier\n     * @param dkim_key_hash - the hash of the DKIM key\n     */\n    #[public]\n    fn register_dkim(verifier_id: Field, dkim_key_hash: Field) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not registry admin\");\n        // ensure that the dkim key has not already been registered\n        register_dkim_key(&mut context, storage, dkim_key_hash, verifier_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     * @param escrow_contract - the address of the escrow contract to register\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check the contract class ID by recomputing the contract address\n        let definition = storage.definition.read();\n        let contract_instance: ContractInstance = unsafe {\n            get_contract_instance(escrow_contract)\n        };\n        let computed_escrow_address = AztecAddress::compute(\n            contract_instance.public_keys,\n            PartialAddress::compute(\n                ContractClassId::from_field(definition.escrow_contract_id), // constrained here\n                contract_instance.salt,\n                contract_instance.initialization_hash,\n                contract_instance.deployer\n            )\n        );\n        assert(\n            computed_escrow_address == escrow_contract, \"Escrow contract class ID does not match expected class ID\"\n        );\n        // check that the contract has been deployed\n        // annoying that we can't use this in the deploy tx\n        context.historical_header.prove_contract_initialization(escrow_contract);\n\n        // check that the contract has not already been registered\n        let registration_status = storage.escrow_registry.at(escrow_contract).read();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        let escrow_params = ZImburseEscrow::at(escrow_contract).get_registration_params().view(&mut context);\n        assert(\n            escrow_params[0] == context.this_address(), \"Escrow contract registry does not match this contract\"\n        );\n        assert(escrow_params[1] == definition.usdc, \"Escrow contract USDC does not match registry USDC\");\n        assert(\n            escrow_params[2] == context.msg_sender(), \"Escrow contract admin does not match sender of message\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let admin_keys = get_public_keys(context.msg_sender());\n        let mut escrow_note = AddressNote::new(escrow_contract, admin_keys.npk_m.hash());\n\n        // use unconstrained - why would you lie here\n        storage.managed_escrows.at(context.msg_sender()).insert(&mut escrow_note).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender()\n            )\n        );\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.escrow_registry.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n    fn check_and_register_participant(participant: AztecAddress, participant_name: str<60>, escrow: AztecAddress) -> bool {\n        // todo: switch to check that the sender is an escrow\n        // check that sender is admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        let is_registered = storage.escrow_registry.at(escrow).read();\n        assert(is_registered, \"Escrow contract is not registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new().select(AddressNote::properties().address, Comparator.EQ, participant).set_limit(1);\n        let not_registered = storage.participants.at(escrow).get_notes(options).len() == 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        if not_registered {\n            ZImburseRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, escrow).call(&mut context);\n        }\n        // add escrow to participants private set\n        ZImburseRegistry::at(context.this_address()).register_participant_escrow(participant, escrow).call(&mut context);\n        not_registered\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant(participant: AztecAddress, participant_name: str<60>, admin: AztecAddress, escrow: AztecAddress) {\n        let admin_keys = get_public_keys(admin);\n        // add the participant to the admin set of participants\n        let mut participant_note = ParticipantNote::new(participant, participant_name, admin_keys.npk_m.hash());\n        storage.participants.at(escrow).insert(&mut participant_note).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, admin, admin)\n        );\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant_escrow(participant: AztecAddress, escrow: AztecAddress) {\n        let participant_keys = get_public_keys(participant);\n        // add escrow to the participant's set of escrows\n        let mut escrow_note = AddressNote::new(escrow, participant_keys.npk_m.hash());\n        storage.participant_escrows.at(participant).insert(&mut escrow_note).emit(\n            encode_and_encrypt_note(\n                &mut context,\n                participant,\n                participant\n            )\n        );\n    }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the public context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[public]\n    #[view]\n    fn check_dkim_key_hash_public(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the private context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[private]\n    #[view]\n    fn check_dkim_key_hash_private(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /** Get the class ID that all escrow contracts must match */\n    #[public]\n    #[view]\n    fn get_escrow_class_id() -> Field {\n        storage.definition.read().escrow_contract_id\n    }\n\n    /** Get the registration status of an escrow contract */\n    #[public]\n    #[view]\n    fn get_escrow_registry_status(escrow_contract: AztecAddress) -> bool {\n        storage.escrow_registry.at(escrow_contract).read()\n    }\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param offset - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_managed_escrows(admin: AztecAddress, offset: u32) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.managed_escrows.at(admin).view_notes(options);\n        let mut managed_escrows = BoundedVec::new();\n        for i in 0..notes.len() {\n            managed_escrows.push(notes.get_unchecked(i).address);\n        }\n        (managed_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param participant - the address of the participant\n     * @param offset - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_participant_escrows(\n        participant: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participant_escrows.at(participant).view_notes(options);\n        let mut participant_escrows: BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE> = BoundedVec::new();\n        for i in 0..notes.len() {\n            participant_escrows.push(notes.get_unchecked(i).address);\n        }\n        (participant_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param offset - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<ParticipantNote, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participants.at(escrow).view_notes(options);\n        (notes, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n}\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "60": {
      "path": "std/uint128.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"
    },
    "63": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/address_note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "69": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "72": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "75": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "76": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "79": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "83": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "90": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "91": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "93": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
