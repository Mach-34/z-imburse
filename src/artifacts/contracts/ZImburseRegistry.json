{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "ZImburseRegistry",
  "functions": [
    {
      "name": "set_contract_registered",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_contract_registered"
      ]
    },
    {
      "name": "register_dkim_bulk",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim_bulk"
      ]
    },
    {
      "name": "get_escrow_registry_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_escrow_registry_status"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 21,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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10puOHIt+4Yj1xpxOHItKNsjf/xlctbqczDyaLT6HI5cq8/myB9/mRyNVp/DkWv1ORr5rFuRDkP+QVELyhYUtUZsQVEDcQOKs26GOZiixtYWFHV1aUFRV5cWFPWmYguKukY3oDjrtn2DKeoa/R0Uo3XLnf9LncJbinq36LsoGrpSTFuKegOoBUVSig0oaur+HopuFXKpU+KWoqbu75qLOVwpFlYXTd0tKOq38y0oau3SgCL47oHG3KP4oR67Zqipx87qNfUvzMg323fcUW+v6q29GaspXX/Xi5W8vTk2Fq/Vdacv77459oMKKZUClaBUClSiUilQYaVSoJKUSoFKVipbKq/cVQ2YilUqBSpOqRSoaLYtUaF5qJh1UyJPFSrJrVuBJpdvGYYSw7B8P0POXCv50gc7Z5ZvxJyz+fbgD94TpeZD8J4ojx+C90RJ/xC8J6ohDsF7ourkCLzjRHXPIXhPVFEdgvdEtdoheE9UBR6CNynvoby1vhzLW+vLsby1vhzLW+vLsby1vhzKm7W+HMtb68uxvLW+HMtb68uxvEl5D+Wt9eVY3lpfjuWt9eVY3lpfjuWt9eVQ3knry7G8tb4cy1vry7G8NX835k1X3jdvMFl5az5py5vXd504JrPlrflkKO+s+WQsb80nY3lrPhnLW+9/j+VNynsob83fY3nr/e+xvPX+91jeg+tLWm8vWPLmG94fejKUHh69H1BVjwXT48D0eDA9BKYngOmJYHoYTA+WP7MB82cL5s8WzJ8tmD9bMH8evUcUXd+zGNhU8maiuKbCYPibVPihPhxafTy0ej60+nRo9fnI6kfvv9RYvT20endo9f7Q6g+91jrotTbYq/pgCuqh19qqeui1tqoeeq2tqodea2vqPfRaW1UPvdZW1Tfwe3areva36j96CN17iN174O49pO495N49tNhToNKD7d6D696D795D92uaul/T1P2anuldrxDfYvoVnfM37D6/xWR9i+xg3vorlLG89VcoY3nrr1DG8tanHMby1qcchvLWt8i2fmoq55W3dVve+pTDWN76lMNY3lpfjuVNynsob60vx/LW+nIsb60vx/LW+nIsb60vh/LWt5oO5q31zljeWu+M5U3KeyjvF66XMdR4X7f7tBSvH21DibdLISxDTXxzKzSXPtsbt5web29kl8/lo18cAd3tfeU79/RsNj+b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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7921989071249124615": {
            "error_kind": "string",
            "string": "Function register_participant can only be called internally"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "notify_created_note_oracle_wrapper",
        "compute_payload_unconstrained",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "usdc",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7V3djty2Dn6Xvc6FJJL66asUB0GSpsUCQVIk6QEOir778eyONc5aHsUqd4ayeFPMNvpM8iMlUZQs//3w28f3f/3x9vHz71++Pfzy698Pn758ePf98cvn6a+//3nz8P7r46dPj3+8Xf7vB3P6jwv2CfDtz3efT39/+/7u6/eHX6xP5s3Dx8+/TT+DMdMjfn/89PHhFwz+n/+8mVDUgoqmCdUmK7WgEjShYgMKDDShQgvK2iaUb0G5Jllut5ffrFtTSHNrSim3thgLrRFiPLdGSCG3jlRoHC3QuXG0ZJeNT9qDYdDeOze39p4q2jswc2sHhJfWzpSeHbyfnx2t/6H1Sf8IzPoHV9E/eDg3DuGiz8TsSZ1kZanjJamDhiPYgskBEbypBVuMc2uXMFWCzVk7d0Nno3kZbIiRW//wb+gkL0odb2WpwzEuRwd59IHquBxxDh+MPl4fl60xKT/bWMAXIzMG07n+vfOf+tY/Yuf6d85/6pz/1Df/tH+98Yr6nxSyVppCXphC7vZTXjJZoeRWMeRImEIgjSG4wygXzUUhuj5K+DSvXYK56O4sPiufOlYeWZjHi/IeK8qToTkUyMSK8jsVqY3mmEaylmAoa+NI1vqhfOuH8m0YyrfRdmvtk/rUtfrJ9K0+HqirAGRFAO2yKJ1KWzKY65ZxWqbm1mBKmkAy+dnJXurvLphnIo+UGd2RSG+ONHjflcgjzfn3JNJqRDIRqRHJQ6TTiGQiUiOSh0jQiGQiMiiRLESiUyJ5iPRKJAuRhEokD5E6a/MQeagi+F2J1IjkITLorM1EpOaRPER2XOC/NZGJMpHJvyQyaD3yJ4lEY8K5NRpnVkRaHSNLRD5Ro2uVLWpcv9vEr05Nv1vQ/5oashdqyFRGpujys6NLtjYh0PwSCS5HsZLSzhl7buucTcvGJweNXILowkE08ODSh4N0iBPuoIHPj3ThII/qINkO0h4k20GHOpZ7SAcNXDPswkEdH/UexEGaZgt3kCYJsh2UNEkQ7qCBt3F6cFA0A28P9eEgrWbLdpDVNFu4gzTNFu4gTbNlO8ihOki2gzTNlu0g0DRbuIO0mi3bQahptnAHaZot20E08Nn0PhyE6iDZDtI0W7aDRn5FsQsH6ZmE+zsILw4i99JBI99MJsRBweXPnwQ0LxyUDKqDZDtIkwTZDhr5jcg+HKRb3rId5LSSINxBqA6S7SBNs2U7CLQHCXeQptmyHcRypWLIt8RMDqp9WtIFP1+F4mKCSmvWa1YShpGsZXmDvx9r/UjW+qF864fybRjKtyxfs+3H2jSStSxfyu3H2jiStSxv9fVjbceZ46S/NabjSeXZgI5zgCcDrBFuQA9nE6wB6YHcCY3Su1MfNKJ2ahYaUWnkoFH66qIPGkmjkYVG6euhPmj00kv0ndCoCQ8HjUETHhYadYphoVGnGA4ao/RaXic0Si8S9kFj0goPC42a8DDQOBWelUYOGlFp5KBRKzwcNFpNeFho1ISHg0anFR4WGjXh4aARNOFhoVH6ubZOaNSEh4NG1ISHhUatN3LQqHsxP0njtVtArBV/vLaHV6AmGnWK4aBR/IHgTmjUNTUDjU78eedOaNRVDAuNOsVw0GhRaeSgUaORg0anCQ8LjSyXusfcOln/AzFPQniu9q8IYXkZoCqEY0ZOIWYhqXqlhk9zZFAw8eLAdPYgx53VU8I2C3EGbEUlJJpbI/lL61iObONyZNuwbPysPnGof6l4GKj1TGtg7sfWBLdm1BsWJ4eLSriOJE83EMLyheiqkGJZbhoicYYl6ypCWEOqfKDOJcpBkmLVaoo5SPxC/Ym7Quvg7DzKBgfhuvrh8rZrMOivNz6da8sX8Jhk/Mra5IayNjJY6ynHv/f0g7UnIWDgBkLKH8XjFuIZhESX56tIWAsO7+dnBx+hEhyX13YDWawFR4pzv7fWOHgZHOBgKGsTh7U5u5gSnlS1Ns3chGAr1qKb9UC4PBinwf1Je4CutY89a49dc49dc09dc0+hZ+297Vp737P25VfXutGeetY+3WHM2ZMXQV5hTj/jy0QHy0MmmDAX78BSbYF5cuGsPqSlsWchHPe+UTaaYq2ugxDjxWeVRVScRt55xWvJrhgKDEc6KPvXW6op72wOOAeVRV2a8vJz4wREK+XLH7zZ6V402b3Lmmh2b/Q3EJJuYUn58zO8QsjgLYTcwhJ7C0ts5BZCayHAEsJ5qJ0iqSAE7S2E3MISwlsISTcQ4m9hib+FJYFjJsd8Lm/qePCDkHVrb+cLyT1CQaEoTKHopCnkhSmUjDSFUJpCwoLaG2FB7Y2woPbWSlNIGkNOWLf3Tli3905atwdp3R7uGdS+1tbZvAnrnORNWI+3d2w+MuOTWzu2/GmROypUPtVyR4X8zYfPAClXAAt90ZM0hZIwhW6/WKopFIQpFK00haQFdZQW1ElaUN9+sXRdoWCEMRSMsG4frLBuH6ywbh+ssG4f3D2DOqZK29N+R34ywQ+Z97P6Ubb6nZzeDICieaycpgyQulYfQ9fqkxOtfi/nRgPJHsxe8ZwJL4/+5oNZNHOIxcWJkXJbyAM3LN4asgbOyseOlb/9yphT+Z6Zjz0zH3tmPrmelff9Kh+N7Vl56lh5a3pWHiUrT25e8RKlgvKih8qK8k70JFVTvmfmoWfmoWfmUXR6UFNedHpQUZ5Epwc15UWnBxXlvej0oKY8ilY+v5zil9egTMoXnhtsfm6lQgwhv6gEYfGmkkvuzIrsMfhOrMiud9yNlaCsrFmJsqeje7EiO8O4EyspjchKdHNdf/oJK1aSHXJcSXlXGBIUWHEHHFeSoSUrz3YecKQo2QmD+BMG8ScO4k+UvWJls5NkL2757BzEn8KLFXx24iB2HjB3Ltl5xNpD0c4DVp5Kdso+wcFo5yD+TEOMt86YIebPyc4h1ivO2OOsV/K55WTi9SpLQpfbIvk1KcdxPh8p7jg9n5GU4yyb+EgBjZQ1KUcsDP1EkT/fbTn9XH41w51ZGXJDqMaK8LMs92JlzG2yCitjHmCpsqKxUmAlaKyUWBnysNPUIrOyUCKzEmWfZL3L9vvEih5KKLAi+6WoO7Fij1gqY2DlgBuN/56VA5XhOFkZcmausSL8vap7sTJkxl9j5fY3vXTBisZKgRXUcaXEis5BBVZIY6XAitcsrsTKkDX+GivhleegJyERbyHkFpak8PpCnL3Dhwl3XZyV5ldmAhm3bPysvheu/uX7ciX1nXD2L7dTBvrxS4DP6gtnv6I+9M0+pK7VR+xb/b7Zp77Zpyh83Ge873EaZoU7a9vaZ/WFd5WK+qFv9su7mr2oD+VPde77wOy08phzZhv9ZXlU/sSsCz5/DWeyu9J62mqf9Y9EF03AFJdpDnNrl2ylNdC8oFp++9OVTJySmfnBDpxdNn6isXwnnNK4l0aNRg4aXVAaGWgsf+ZMadxLo0YjB42o0chCo1caf4ZGl1KmcfHpkZnG8oFypXEvjaQ0ctCoeSMHjR6URg4aNeHhoDHoFMNCo04xHDRGozRy0KjRyEFj0nojC42aNzLQiEajkYNGqxUeDhqBo1PHrPzpRv8KMWRo1ojMaRvu3Lq8H71LEYCsCKA1C0VStzU4RFQPCfeQ9iHhHqKgHpLtIe/UQ8I9pH1IuIeC9iHpHvLqIdnroWjVQ8I9ROoh4R7S9ZBwDyVQDwn3kGbbsj1ERjMF6R7STEG4h6xRDwn3kPYh4R5yqB4S7iFdDwn3EGgfEu4h1Nq2cA/RwLXty3vjkUyocZ7yqaPp5+UiKxfMM5N+4Kx4F5No7Hwzx/QzFZgcOHvlZTJoTHIxGZVJHibjwFXsnUw6yEyCKzCpMcnE5Mg7K6xM+pHr68xMambOxKTVmORiUmOSiUmnmfnPMmlCZnJZ7chM6mqRiUnQmORiUjNzJiZRM3MuJgfez+JlUmvmXEx6zcy5mBz45CEvkyO/j8PMpMYkE5Mjv9/CymTA4hqHYJZBcGHmvEcekBowaT+m/EWFCqZBjm+Q4xvkBGjAhP2Y8v30FYzfj0m2AVOOnXwnCfm4xqTdmGiwAVNcpU4l/DPGL7fvzpjyBS4VTNiPcQ1yXIMcaJADfj+mPO5UMNSASfsx5XGngmmInfLdm1cxyRR96oKbT0CdhvQVaqviH/I05WNco3wLyjXJ2jpdeh21deKxgipXo0K85ANmdTIsbVReaqjQgtq4armGoiZUakH5JjZ8E/OhSVZoYj42MR+bmI9NzKcmNlIDG2CMbUL5FtTGWzTJznm3TVBAUQvKNclyLbLsxthrIF/atlxPWG+LaxWfRSzGs5jOIujVRWwwxiri9a2A17cCbmBFenURG5Mdq4j46iLIMYjIZ8vdctCKxbX5651az0mhc6usEGyAUQyNgxgaRwndcuHhgIYmO4qhg3jUGTOKoTiKoYNML84OMr1sfM7+gIa6UQYjlmViF4amQQyFQVYvDkaZXnCU6QVHmV5okNWLo1GmFxplevGjrF78KNNLGGV62djDPJ6hcZTpJY4yvaRB1qNTBfswhuLFUFptZAMcJte9eloKAA8zGNUMPcxgVDP0MLluxVA6TCmlZuhhMqOKoX6UwciPMr2EUTwaRpleQnl6sT4fQ3Y2/GDoEyxiG2y3tAKtISe1NtgLVeU3lBK6c+NEafHk52NWW1+mvptCWH7BokYslt+xqMLKrzLUYdQEozZp5fcTqrCNY95VWLh1RExDSW5tFmcBJ+izSsGJUykaaSrRxtHtu3Vl2jg9fUeFhI2+5KW5LEhzWRDmMg+HSYyufikSPB6mCFgzdBSPHqfAUDP0MGXdiqF+FI8eZ3u0YuiBtkevfawB/IG2R68beqDt0Yqhx9kerRh6nNM31w1NxzncWTF0kMEomEEGo2COc7jzuqF2FI8e6CWJiqGDzKMBRvHogd4duGpo2iqO5S04awKtUakFtXHNgcVcGbQU16jYgqImWRvb/zWUb0FtfB3LBpdRac3hxi5vBZXKHGK+rnD6+VJDNMY1oXwLauM+mhoKiyiCzDxRWKNSC8o1ySrf8FZFhRbURv+qoDa2OGsoakFt9K8ayregQpOs0GRXbOIwNslKTV7eGAGm3ZqMSi9P26LdGAFqKN+C2hgBaqhyX4bLLVEAq3HDbvTlGiq2oDZGgBrKt6A2doBqqCY2sIl5apJFTcz7JuZ9E/MbszkQZpQPaxS1oDbqkzVUbEFtjDY1VGpAbV18UUM1ybLQkG+4jaNOFdTGHZ01FLWgyq/fBZwT80BmhSnffpRwDvjk3Rrj92PKL6lUMNiAiftXJwgGmlChBbV1IUgF1STLNclyTbKgSRY0ycImf2GTLGqya+NLLRXUxpe8ayhsQjX1lPL9d1fHGChvHiY7H/NJsMaUby+vYNJuDJZ7fgWz3x4sF36vjmVo94+z6BrklK8/uY4BbMA0yMEGOeWq0VSqmTFhtZbAcs2ogmmQU84wr2PKq9kKpkFObJBTXscu/FPANOQCmGg3hoxpwMT9mHI+WcHs7wvk9o8HBLYBE/Zj0DVgGuRQgz3UEDvU4B/fEAehgbfQwFtDnk97++k/01//fff18d37Tx+/TYjTP/71+cP3xy+fz39+/9+f87+8//r46dPjH2///Prlw8ff/vr68e2nLx9O//Zgzv/5NRC9CcFPupyIBf8GT7+fakWnT58QxNOf9qmlexMIJw0mLf4P",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgIEASYCAwQAHxgAAwACgEMtCIBDAAEkAAAAQCcCAAEEgEQmAgIEADoNAAEAAiQAABeXKAIAAgDewPQwCjgBAgMmAgQEACYCBgQDADgEBgUsCAECABABBQEmAwIEAQAoAgIFLA4EBQAoBQIFLA4EBSYCBQQDADgCBQQmAgQBASYCBQA0JgIGAAcmAgcAACYCCAAEJgIJBAEmAgoAASYCCwA5JgIMAAUmAg0BACYCDgA2JwIADwDerSYCEAAIJgIRAAYmAhIEACYCEwQEIwIAAwAAAOsiAAAG0SYCFQQKLAgBFiYCFwQLABABFwEmAxYEAQAoFgIXHzwACQAVABcsDRYXACgXAhcsDhcWLA0WFwAoFwIXLA4XFiwNFhcAKBcCFywOFxYsCAEXAAABAgEsDhYXLAgBFgAAAQIBLA4SFiYCGQQaLAgAGiwMFxssDBYcABAAGQAkAAAXwCwEAAAsDBsYJgIaBBssCAAbLAwIHCwMGB0AEAAaACQAABg7LAQAACwMHBkmAhoEGywIABssDBccLAwWHQAQABoAJAAAF8AsBAAALAwcGCYCGwQcLAgAHCwMER0sDBgeABAAGwAkAAAYOywEAAAsDB0aJgIbBBwsCAAcLAwXHSwMFh4sDBAfABAAGwAkAAAYnCwEAAAsDB0YLA0YGwAoGwIbLA4bGCYCHAQdLAgAHSwMFx4sDBYfLAwQIAAQABwAJAAAGJwsBAAALAweGywNGxYAKBYCFiwOFhssCAEWAAABAgEsDg0WLAgBFwAAAQIBLA4HFywIARwAAAECASYCHQCDLA4dHB4CAB0ANTgAHQAeAB8AIwIAHwAAApkiAAACjCwMDQMsDAcUIgAAAqYsDAQDLAweFCIAAAKmIwIAAwAAArcmAiAEADsJASA1OAAdAAMAIAIjAgAgAAAC2iIAAALNLAwNHiwMBx8iAAAC5ywMBB4sDAMfIgAAAucjAgAeAAAC+CYCHQQAOwkBHSwIAR0mAh4EAgAQAR4BJgMdBAEAKB0CHh88ABIACQAeLA0dHgAoHgIeLA4eHQAoHQIgADggEiEsDSEeHAweIAQcDCAdACwIAR4mAiAECwAQASABJgMeBAEAKB4CIB88AAkAFQAgLA0eIAAoIAIgLA4gHiYCIAAsLAgBISYCIgQMABABIgEmAyEEAQAoIQIiJgIjBAsAOCMiIywMIiQMOCQjJRYMJSUjAgAlAAADtCwOICQAKCQCJCIAAAOVLAgBIAAAAQIBLA4hICwMEgMiAAADygw4AxUhIwIAIQAAFw0iAAAD3CwNIBUsDRUeACgeAh4sDh4VKgIAHgAAAAAAAAAACwAAAAAAAAAAJgIkBCUsCAAlLAweJgAQACQAJAAAGh0sBAAALAwmICwMJyEsDCgiLAwpIywNIB4AKB4CHiwOHiAsCAEeAAABAgEsDiAeLA0hIAAoIAIgLA4gISwIASAAAAECASwOISAsCAEhAAABAgEsDiIhLAgBIgAAAQIBLA4jIiYCIwQLLAwSAyIAAASJDDgDIyQjAgAkAAAWiyIAAASbJgIjBCQsCAAkLAweJSwMICYsDCEnLAwiKAAQACMAJAAAGsQsBAAALAwlFSYCHgANLAgBICYCIQQEABABIQEmAyAEAQAoIAIhLAwhIiwOHiIAKCICIiwOHSIAKCICIiwOFSIsDSAVACgVAhUsDhUgKgIAFQAAAAAAAAAAAwAAAAAAAAAAJgIjBCQsCAAkLAwVJQAQACMAJAAAGh0sBAAALAwlHSwMJh4sDCchLAwoIiwNHRUAKBUCFSwOFR0sCAEVAAABAgEsDh0VLA0eHQAoHQIdLA4dHiwIAR0AAAECASwOHh0sCAEeAAABAgEsDiEeLAgBIQAAAQIBLA4iISYCIgQDLAwSAyIAAAWmDDgDIiMjAgAjAAAWCSIAAAW4JgIjBCQsCAAkLAwVJSwMHSYsDB4nLAwhKAAQACMAJAAAGsQsBAAALAwlIAo4HyAVIwIAFQAABfUkAAAbSAo4FAcVHgIAHQEKOBQdHhI4FR4UIwIAFAAABhYkAAAbWh4CABQBKAIAFQA7msoBLgwAFQAdCjgdBx4jAgAeAAAGPCQAABtsLwwADwAVLAgBFSYCHQQEABABHQEmAxUEAQAoFQIdLAwdHiwOFB4AKB4CHiwOGR4AKB4CHiwOGh4sDBIDIgAABn0MOAMiFCMCABQAABW0IgAABo8sDBIDIgAABpgMOAMTFCMCABQAABScIgAABqoeAgADADMCAAMAKAICFSwNFRQmAhYEAgA4FRYDOg0AAwAUIgAABtEoAgADALLR7zgKOAEDFCwNAgMAKAMCAywOAwIjAgAUAAAG+SIAAAiZJgIUBAgsCAEVJgIWBAkAEAEWASYDFQQBACgVAhYfPAAJABQAFiwNFRQAKBQCFCwOFBUsDRUUACgUAhQsDhQVLA0VFAAoFAIULA4UFSwIARQAAAECASwOFRQsCAEVAAABAgEsDhIVJgIXBBgsCAAYLAwUGSwMFRosDBAbABAAFwAkAAAbfiwEAAAsDBkWLA0WFwAoFwIXLA4XFiYCGAQZLAgAGSwMFBosDBUbLAwQHAAQABgAJAAAG34sBAAALAwaFywNFxQAKBQCFCwOFBcsCAEUAAABAgEsDg0ULAgBFQAAAQIBLA4HFSwIARgAAAECASYCGQB6LA4ZGCYCGQQaLAgAGiwMFBssDBUcLAwYHQAQABkAJAAAHP8sBAAAJgIcBB0sCAAdLAwUHiwMFR8sDBggLAwKIQAQABwAJAAAHSksBAAALAweGSwMHxosDCAbHgIAHAEKOBkcHSMCAB0AAAhgJAAAHlEsDBIDIgAACGkMOAMTGSMCABkAABOEIgAACHsAKAICFCwNFBMmAhUEAgA4FBUDOg0AAwATIgAACJkoAgADAAF4enwKOAEDEywNAgMAKAMCAywOAwIjAgATAAAIwSIAAArQJgIDBAIsCAETJgIUBAMAEAEUASYDEwQBACgTAhQfPAAJAAMAFCwNEwMAKAMCAywOAxMsDRMDACgDAgMsDgMTLA0TAwAoAwIDLA4DEywIAQMAAAECASwOEwMsCAETAAABAgEsDhITJgIVBBYsCAAWLAwDFywMExgsDBEZABAAFQAkAAAeYywEAAAsDBcUJgIWBBcsCAAXLAwDGCwMExksDBEaABAAFgAkAAAeYywEAAAsDBgVLAgBAwAAAQIBLA4NAywIARMAAAECASwOBxMsCAEWAAABAgEmAhcAaCwOFxYmAhcEGCwIABgsDAMZLAwTGiwMFhsAEAAXACQAABz/LAQAACYCGgQbLAgAGywMAxwsDBMdLAwWHiwMCh8AEAAaACQAAB0pLAQAACwMHBcsDB0YLAweGR4CABoBCjgXGhsjAgAbAAAKDiQAAB79JgIXBBosCAAaLAwDGywMExwsDBYdLAwDHiwMEx8sDBYgLAwKISwMAyIsDBMjLAwWJCwMCCUsDAUmLAwDJywMEygsDBYpLAwMKiwMDissDAMsLAwTLSwMFi4sDBEvLAwDMCwMEzEsDBYyLAwGMywMCzQsDAM1LAwTNiwMFjcsDBA4LAwVOSwMFDoAEAAXACQAAB8PLAQAACwNAgMAKAMCAywOAwIAKAICCywNCwYmAhAEAgA4CxADOg0AAwAGIgAACtAoAgADAMEQqIoKOAEDBiMCAAYAAArrIgAADNAsCAEDJgIGBAIAEAEGASYDAwQBACgDAgYfPAAJAAkABiwNAwYAKAYCBiwOBgMsDQMGACgGAgYsDgYDLA0DBgAoBgIGLA4GAywIAQYAAAECASwOAwYsCAEDAAABAgEsDhIDJgIQBBMsCAATLAwGFCwMAxUAEAAQACQAACIsLAQAACwMFAsmAgYEEywIABMsDAgULAwLFQAQAAYAJAAAGDssBAAALAwUAywIAQYAAAECASwODQYsCAELAAABAgEsDgcLLAgBEAAAAQIBJgITAF8sDhMQJgITBBQsCAAULAwGFSwMCxYsDBAXABAAEwAkAAAc/ywEAAAeAgATAR4CABQACjgTFBUjAgAVAAAL/SQAACKnLAgBEyYCFAQDABABFAEmAxMEAQAoEwIULAwUFSwOCBUAKBUCFSwOAxUmAhQEFSwIABUsDBMWABAAFAAkAAAiuSwEAAAsDBYDJgIXBBgsCAAYLAwFGSwMBhosDAsbLAwQHCwMAx0AEAAXACQAACQkLAQAACwMGRMsDBoULAwbFSwMHBYoAgADADuaygAAOAMWBi4MAAYAAwo4AwcLIwIACwAADKYkAAAbbC8MAA8ABi8MAAoAFgAoAgILLA0LBiYCDwQCADgLDwM6DQADAAYiAAAM0CgCAAIAppiSlQo4AQIDIwIAAwAADOsiAAAPBSwIAQImAgMEAgAQAQMBJgMCBAEAKAICAx88AAkACQADLA0CAwAoAwIDLA4DAiwNAgMAKAMCAywOAwIsDQIDACgDAgMsDgMCLAgBAwAAAQIBLA4CAywIAQIAAAECASwOEgImAgsEEywIABMsDAMULAwCFQAQAAsAJAAAIiwsBAAALAwUBiYCAwQTLAgAEywMERQsDAYVABAAAwAkAAAYOywEAAAsDBQCLAgBAwAAAQIBLA4NAywIAQYAAAECASwOBwYsCAELAAABAgEmAg8AWCwODwsmAg8EEywIABMsDAMULAwGFSwMCxYAEAAPACQAABz/LAQAAB4CAA8JCjgPChAjAgAQAAAN+CQAACUcLAgBDyYCEAQDABABEAEmAw8EAQAoDwIQLAwQESwODBEAKBECESwOAhEmAgwEEywIABMsDA8UABAADAAkAAAiuSwEAAAsDBQCJgITBBQsCAAULAwOFSwMAxYsDAYXLAwLGCwMAhkAEAATACQAACQkLAQAACwMFQwsDBYPLAwXECwMGBEmAgMEEywIABMsDAwULAwPFSwMEBYsDBEXABAAAwAkAAAlLiwEAAAsDBQCJgIGBAEmAgwEAwA4BgwLLAgBAwAQAQsBJgMDBAEAKAMCCywOBgsAKAsCCywOBgsmAgsEAwA4AwsGLAwGCywOAgsAKAMCCywNCwYmAgwEAgA4CwwCOg0AAgAGIgAADwUoAgACANFSbU0KOAECAyMCAAMAAA8gIgAAEBgsCAECAAABAgEsDg0CLAgBAwAAAQIBLA4HAywIAQYAAAECASYCCwBLLA4LBiYCCwQTLAgAEywMAhQsDAMVLAwGFgAQAAsAJAAAHP8sBAAAHgIACwkKOAsKDCMCAAwAAA+GJAAAJT4mAg8EEywIABMsDAIULAwDFSwMBhYsDAoXABAADwAkAAAdKSwEAAAsDBQLLAwVDCwMFg4mAgMEASYCDwQDADgDDwYsCAECABABBgEmAwIEAQAoAgIGLA4DBgAoBgIGLA4DBiYCBgQDADgCBgMsDAMGLA4OBgAoAgIOLA0OBiYCDwQCADgODwM6DQADAAYiAAAQGCgCAAIArb4D6Ao4AQIDIwIAAwAAEDMiAAASMiwIAQEmAgIEAgAQAQIBJgMBBAEAKAECAh88AAkACQACLA0BAgAoAgICLA4CASwNAQIAKAICAiwOAgEsDQECACgCAgIsDgIBLAgBAgAAAQIBLA4BAiwIAQEAAAECASwOEgEmAgYEEywIABMsDAIULAwBFQAQAAYAJAAAIiwsBAAALAwUAyYCAgQTLAgAEywMCBQsDAMVABAAAgAkAAAYOywEAAAsDBQBLAgBAgAAAQIBLA4NAiwIAQMAAAECASwOBwMsCAEGAAABAgEmAgcAHywOBwYmAgcEEywIABMsDAIULAwDFSwMBhYAEAAHACQAABz/LAQAAB4CAAcJCjgHCgsjAgALAAARQCQAACVQLAgBByYCCgQDABABCgEmAwcEAQAoBwIKLAwKCywOCAsAKAsCCywOAQsmAggEEywIABMsDAcUABAACAAkAAAiuSwEAAAsDBQBJgIMBBMsCAATLAwFFCwMAhUsDAMWLAwGFywMARgAEAAMACQAACQkLAQAACwMFAcsDBUILAwWCiwMFwsuDAALAAEcDAEDARwMAwIAJgIDBAEmAgYEAwA4AwYFLAgBAQAQAQUBJgMBBAEAKAECBSwOAwUAKAUCBSwOAwUmAgUEAwA4AQUDLAwDBSwOAgUAKAECBSwNBQMmAgYEAgA4BQYCOg0AAgADIgAAEjImAgECciYCAgJsJgIDAiAmAgUCayYCBgJjJgIHAnMmAggCbyYCCQJVJgIKAnQmAgsCZSYCDAJ3JgIOAm4sCAEPJgIQBBEAEAEQASYDDwQBACgPAhAsDBARLA4JEQAoEQIRLA4OEQAoEQIRLA4FEQAoEQIRLA4OEQAoEQIRLA4IEQAoEQIRLA4MEQAoEQIRLA4OEQAoEQIRLA4DEQAoEQIRLA4HEQAoEQIRLA4LEQAoEQIRLA4CEQAoEQIRLA4LEQAoEQIRLA4GEQAoEQIRLA4KEQAoEQIRLA4IEQAoEQIRLA4BEQo4DQQBIwIAAQAAE4MmAgIEEiwIAQMmAgUEEgAQAQUBLAwDBSkDAAUF5Y+YWQcxYpAAKAUCBQAoDwIGJgIHBBAtBAAGgAMtBAAFgAQtBAAHgAUkAAAlYiYCBgQQADgFBgUsDhIFACgFAgU7DQMCJSYCGgQEDDgDGhsjAgAbAAATmyQAACWoACgWAhoAOBoDGywNGxkKOBkHGiMCABoAABR8IgAAE7smAhsEBAw4AxscIwIAHAAAE9IkAAAlqAAoFwIbADgbAxwsDRwaJgIbBBwsCAAcLAwUHSwMFR4sDBgfLAwUICwMFSEsDBgiLAwKIywMFCQsDBUlLAwYJiwMCCcsDAUoLAwUKSwMFSosDBgrLAwMLCwMDi0sDBQuLAwVLywMGDAsDBExLAwUMiwMFTMsDBg0LAwGNSwMCzYsDBQ3LAwVOCwMGDksDBA6LAwaOywMGTwAEAAbACQAAB8PLAQAACIAABR8ADgDCRkOOAMZGiMCABoAABSTJAAAJbosDBkDIgAACGkmAhUEBAw4AxUZIwIAGQAAFLMkAAAlqAAoGAIVADgVAxksDRkUCjgUBxUjAgAVAAAVlCIAABTTJgIZBAQMOAMZGiMCABoAABTqJAAAJagAKBsCGQA4GQMaLA0aFSYCGQQdLAgAHSwMFh4sDBcfLAwcICwMFiEsDBciLAwcIywMCiQsDBYlLAwXJiwMHCcsDAgoLAwFKSwMFiosDBcrLAwcLCwMDC0sDA4uLAwWLywMFzAsDBwxLAwRMiwMFjMsDBc0LAwcNSwMBjYsDAs3LAwWOCwMFzksDBw6LAwQOywMFTwsDBQ9ABAAGQAkAAAfDywEAAAiAAAVlAA4AwkUDjgDFBUjAgAVAAAVqyQAACW6LAwUAyIAAAaYHAwDFAAAOAoUGSYCGgQDDDgDGh0jAgAdAAAV1SQAACWoACgVAhoAOBoDHSwNHRQvDAAUABkAOAMJFA44AxQZIwIAGQAAFgAkAAAluiwMFAMiAAAGfSMCACMAABYWIgAAFmsmAiQEAww4AyQlIwIAJQAAFi0kAAAlqAAoIAIkADgkAyUsDSUjJgIkBCUsCAAlLAwVJiwMHScsDB4oLAwhKSwMIyoAEAAkACQAACXMLAQAACIAABZrADgDCSMOOAMjJCMCACQAABaCJAAAJbosDCMDIgAABaYjAgAkAAAWmCIAABbtJgIlBAsMOAMlJiMCACYAABavJAAAJagAKBUCJQA4JQMmLA0mJCYCJQQmLAgAJiwMHicsDCAoLAwhKSwMIiosDCQrABAAJQAkAAAlzCwEAAAiAAAW7QA4AwkkDjgDJCUjAgAlAAAXBCQAACW6LAwkAyIAAASJLA0gIQA4AwkiDjgDIiMjAgAjAAAXKCQAACW6JgIkBAoMOAMkJSMCACUAABc/JAAAJagAKB4CJAA4JAMlLA0lIyYCJQQLDDgiJSYjAgAmAAAXZCQAACWoLQQAIYADJwCABAQADCQAACb9LQiABQAkACgkAiUAOCUiJiwOIyYsDiQgLAwiAyIAAAPKJwCABAR4AA0AAACABIADIwCAAwAAF78pAQABBfeh86+lrdTKOwEBAiUkAAAXlywNAQMsDQIEJgIGBAoMOAQGByMCAAcAABfkJAAAJagAKAMCBgA4BgQHLA0HBSwIAQYmAgcEAgAQAQcBJgMGBAEAKAYCBywMBwgsDgUIJgIFBAEAOAQFBw44BAcIIwIACAAAGC4kAAAluiwOAwEsDgcCLAwGASUkAAAXlyYCBAAECjgBBAUmAgQEAAAoAgIHADgHBAgsDQgGIwIABQAAGI4iAAAYaiYCAgAGCjgBAgQjAgAEAAAYhSYCBQQAOwkBBSwMBgMiAAAYlywMBgMiAAAYlywMAwElJAAAF5cmAgUAACwIAQYmAgcEBQAQAQcBJgMGBAEAKAYCBywMBwgsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUILAgBBQAAAQIBLA4GBSYCBgQEJgIHBAEmAggEACwMCAQiAAAZBgw4BAYDIwIAAwAAGXQiAAAZGCwNAQMsDQIEADgEBgcOOAQHCCMCAAgAABk3JAAAJbosDgMBLA4HAiwNBQEmAgMEBCwIAAQsDAEFABAAAwAkAAAniywEAAAsDAUCLA0CAQAoAQIBLA4BAiwMAgElLA0FAywNAQgsDQIJADgJBAoOOAkKCyMCAAsAABmXJAAAJbomAgsECgw4CgsMIwIADAAAGa4kAAAlqAAoCAILADgLCgwsDQwJJgIKBAQMOAQKCyMCAAsAABnTJAAAJagtBAADgAMnAIAEBAAFJAAAJv0tCIAFAAgAKAgCCgA4CgQLLA4JCwA4BAcDDjgEAwkjAgAJAAAaECQAACW6LA4IBSwMAwQiAAAZBiQAABeXJgICAAAsCAEDJgIEBAQAEAEEASYDAwQBACgDAgQsDAQFLA4CBQAoBQIFLA4CBQAoBQIFLA4CBSwNAwQAKAQCBCwOBAMsCAEEJgIFBAUAEAEFASYDBAQBACgEAgUsDAUGLA4CBgAoBgIGLA4CBgAoBgIGLA4CBgAoBgIGLA4BBiYCAQQAJgICAQAsDAIFLAwBBiwMBAIsDAUELAwDASwMBgMlJAAAF5csDQQFJgIGAQAKOAUGByMCAAcAABroJgIIBAA7CQEIJgIFBAYsCAAGLAwBBywMAggsDAMJLAwECgAQAAUAJAAAKUYsBAAALA0BBSwNAgYsDQMHLA4FASwOBgIsDgcDJgIBAQEsDgEEJgIBBAAAKAYCAwA4AwEELA0EAiwMAgElKQEAAQX0gAGmWdMnQjsBAQIlKQEAAQUfAFASQCQi7jsBAQIlKQEAAQUfCi0n3IKHojsBAQIlJAAAF5cmAgUAACwIAQYmAgcEBQAQAQcBJgMGBAEAKAYCBywMBwgsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUILAgBBQAAAQIBLA4GBSYCBgQEJgIHBAEmAggEACwMCAQiAAAb6Aw4BAYDIwIAAwAAHFYiAAAb+iwNAQMsDQIEADgEBgcOOAQHCCMCAAgAABwZJAAAJbosDgMBLA4HAiwNBQEmAgMEBCwIAAQsDAEFABAAAwAkAAAniywEAAAsDAUCLA0CAQAoAQIBLA4BAiwMAgElLA0FAywNAQgsDQIJADgJBAoOOAkKCyMCAAsAABx5JAAAJbomAgsECAw4CgsMIwIADAAAHJAkAAAlqAAoCAILADgLCgwsDQwJJgIKBAQMOAQKCyMCAAsAABy1JAAAJagtBAADgAMnAIAEBAAFJAAAJv0tCIAFAAgAKAgCCgA4CgQLLA4JCwA4BAcDDjgEAwkjAgAJAAAc8iQAACW6LA4IBSwMAwQiAAAb6CQAABeXHgIABAAeAgAFADI4AAQABQAGJgIEAQEjAgAGAAAdKCQAACq3JSQAABeXJgIGAAAsCAEHJgIIBAQAEAEIASYDBwQBACgHAggsDAgJLA4GCQAoCQIJLA4GCQAoCQIJLA4GCSwIAQYAAAECASwOBwYmAgcEAyYCCAQBJgIJBAAsDAkFIgAAHYoMOAUHASMCAAEAAB3cIgAAHZwsDQYBACgBAgMAOAMJBCwNBAIAKAECBAA4BAgFLA0FAyYCBAQCACgBAgYAOAYEBywNBwUsDAIBLAwDAiwMBQMlLA0GARwMBQIAADgEAgMuDAADAAImAgoEAww4BQoLIwIACwAAHgckAAAlqC0EAAGAAycAgAQEAAQkAAAm/S0IgAUAAwAoAwIKADgKBQssDgILADgFCAEOOAUBAiMCAAIAAB5EJAAAJbosDgMGLAwBBSIAAB2KKQEAAQXwTQ/4Hf2d9zsBAQIlJAAAF5csDQEELA0CBSYCBwQCDDgFBwgjAgAIAAAehyQAACWoACgEAgcAOAcFCCwNCAYsCAEHJgIIBAIAEAEIASYDBwQBACgHAggsDAgJLA4GCSYCBgQBADgFBggOOAUICSMCAAkAAB7RJAAAJbosDgQBLA4IAiYCAgQILAgACCwMAwksDAcKABAAAgAkAAAYOywEAAAsDAkBJSkBAAEFtAuQydjdSyQ7AQECJSQAABeXLAgBIiYCIwQDABABIwEmAyIEAQAoIgIjLAwjJCwOECQAKCQCJCwOHyQmAiMEJCwIACQsDCIlABAAIwAkAAAiuSwEAAAsDCUQJgInBCgsCAAoLAwRKSwMDSosDA4rLAwPLCwMEC0AEAAnACQAACQkLAQAACwMKSMsDCokLAwrJSwMLCYmAicEKCwIACgsDCMpLAwkKiwMJSssDCYsABAAJwAkAAAlLiwEAAAsDCkQJgIjAAAKOBAjJCMCACQAAB/ZJAAAKsksDSIQACgQAhAsDhAiJgIkBCUsCAAlLAwiJgAQACQAJAAAIrksBAAALAwmECYCJwQoLAgAKCwMESksDA0qLAwOKywMDywsDBAtABAAJwAkAAAkJCwEAAAsDCkiLAwqJCwMKyUsDCwmKAIADQA7msoAADgNJg4uDAAOAA0KOA0jDyMCAA8AACBmJAAAG2wnAgANAN6tLwwADQAOLwwAIAAmLAgBDSYCDgQEABABDgEmAw0EAQAoDQIOLAwODywOIw8AKA8CDywOIw8AKA8CDywOIw8oAgAOAFSqZmgsCAEPJgIQBAQAEAEQASYDDwQBACgPAhAsDBARLA4fEQAoEQIRLA4gEQAoEQIRLA4OESwNDQ4AKA4CDiwODg0sCAEOAAABAgEsDg0OJgINBAAmAhAEAyYCEQQBLAwNISIAACEYDDghEAEjAgABAAAhoiIAACEqLA0OASYCBAQDBigEAgImAgYEAwA4BAYFLAgBAwAQAQUBJgMDBAEAKAMCBSwOBAUAKAUCBSwOBAUmAgYEAwA4AwYFACgBAgYtBAAGgAMtBAAFgAQtBAAEgAUkAAAlYgAoAwIFLA0FBCYCBgQCADgFBgE2DQABAAQlJgICBAMMOCECAyMCAAMAACG5JAAAJagAKA8CAgA4AiEDLA0DASwNDgImAgQEAww4IQQFIwIABQAAIeIkAAAlqC0EAAKAAycAgAQEAAQkAAAm/S0IgAUAAwAoAwIEADgEIQUsDgEFADghEQEOOCEBAiMCAAIAACIfJAAAJbosDgMOLAwBISIAACEYJAAAF5csDQEDLA0CBCYCBgQBDDgEBgcjAgAHAAAiUCQAACWoACgDAgYAOAYEBywNBwUsCAEGJgIHBAIAEAEHASYDBgQBACgGAgcsDAcILA4FCCYCBQQBADgEBQcOOAQHCCMCAAgAACKaJAAAJbosDgMBLA4HAiwMBgElKQEAAQXFpbjoTUJFBTsBAQIlJAAAF5cqAgADAAAAAAAAAAACAAAAAAAAAAAmAggECSwIAAksDAMKABAACAAkAAAaHSwEAAAsDAoELAwLBSwMDAYsDA0HLA0EAwAoAwIDLA4DBCwIAQMAAAECASwOBAMsDQUEACgEAgQsDgQFLAgBBAAAAQIBLA4FBCwIAQUAAAECASwOBgUsCAEGAAABAgEsDgcGJgIHBAImAggEACYCCQQBLAwIAiIAACNkDDgCBwgjAgAIAAAjoiIAACN2JgICBAcsCAAHLAwDCCwMBAksDAUKLAwGCwAQAAIAJAAAGsQsBAAALAwIASUjAgAIAAAjryIAACQEJgIKBAIMOAIKCyMCAAsAACPGJAAAJagAKAECCgA4CgILLA0LCCYCCgQLLAgACywMAwwsDAQNLAwFDiwMBg8sDAgQABAACgAkAAAlzCwEAAAiAAAkBAA4AgkIDjgCCAojAgAKAAAkGyQAACW6LAwIAiIAACNkJAAAF5cmAgoANAo4AQoLJgIKAAAKOAUKDCYCCgEAIwIACwAAJOQiAAAkTyYCEAA2CjgBEBEjAgARAAAkqCIAACRmJgIQADkKOAEQESMCABEAACSBJgISBAA7CQESCjgMCgEjAgABAAAkkyQAACrbLAwCCywMAw0sDAQOLAwFDyIAACTPCjgMCgEjAgABAAAkuiQAACrbLAwCCywMAw0sDAQOLAwFDyIAACTPLAwLBiwMDQcsDA4ILAwPCSIAACULCjgMCgEjAgABAAAk9iQAACrbLAwCBiwMAwcsDAQILAwFCSIAACULLAwHAiwMCAMsDAYBLAwJBCUpAQABBe2I4AG6NwqJOwEBAiUkAAAXly4MAAQABSwMBQElKQEAAQVSVfKdc0WarDsBAQIlKQEAAQVK9/6E4augRTsBAQIlAQCAA4AFgActAIADgAgtAIAEgAkLAIAIgAeACiMAgAoAACWnLQGACIAGLQKABoAJAQCACAACgAgBAIAJAAKACSIAACV2JSkBAAEF6J0J/qERLQ47AQECJSkBAAEFRafKcRlB5BU7AQECJSQAABeXLA0DBiwNBAcmAggBAAo4BwgJIwIACQAAJfQmAgoEADsJAQomAgcEAwo4BgcIJgIGBAEjAgAIAAAmiSIAACYQLA0BBywNAggsDQMJLA0ECiYCDAQDDDgJDA0jAgANAAAmNyQAACWoLQQAB4ADJwCABAQABCQAACb9LQiABQALACgLAgwAOAwJDSwOBQ0AOAkGBQ44CQUHIwIABwAAJnQkAAAluiwOCwEsDggCLA4FAywOCgQiAAAm/CYCBwQILAgACCwMAQksDAIKLAwDCywMBAwAEAAHACQAAClGLAQAACwNAQcsDQIILA0ECSYCCgQALQQAB4ADJwCABAQABCQAACb9LQiABQALACgLAgwAOAwKDSwOBQ0sDgsBLA4IAiwOBgMsDgkEIgAAJvwlLQGAA4AGCwCABgACgAcjAIAHAAAnGCIAACcjLQCAA4AFIgAAJ4otAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAAndi0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAnRScBgAUEAAEDAIAGAAKABiIAACeKJSQAABeXLA0BAwAoAwIDLA4DASwNAQMAKAMCAywOAwEsCAEDAAABAgEsDgEDLAgBAQAAAQIBJgIEBAAsDgQBJgIFAAAsCAEGJgIHBAUAEAEHASYDBgQBACgGAgcsDAcILA4FCAAoCAIILA4FCAAoCAIILA4FCAAoCAIILA4FCCwNBgUAKAUCBSwOBQYsCAEFAAABAgEsDgYFJgIGAAYmAgcEASYCCAQELAwEAiIAACg7DDgCCAQjAgAEAAAoUiIAAChNLA0FASUsDQUELA0DCSwNAQomAgwEBAw4CgwNIwIADQAAKHUkAAAlqAAoCQIMADgMCg0sDQ0LLAgBDCYCDQQCABABDQEmAwwEAQAoDAINLAwNDiwOCw4AOAoHCw44CgsNIwIADQAAKLokAAAluiwOCQMsDgsBJgIKBA0sCAANLAwGDiwMDA8AEAAKACQAABg7LAQAACwMDgkmAgsEBAw4AgsMIwIADAAAKPwkAAAlqC0EAASAAycAgAQEAAUkAAAm/S0IgAUACgAoCgILADgLAgwsDgkMADgCBwQOOAIECSMCAAkAACk5JAAAJbosDgoFLAwEAiIAACg7JAAAF5cmAgYEACYCBwQBJgIIBAMsDAYFIgAAKWMMOAUIBiMCAAYAACnQIgAAKXUsDQEFLA0CBiwNAwcsDQQIJgIJBAQsCAEKJgILBAUAEAELASYDCgQBACgGAgsmAgwEBAAoCgINPg8ACwANLA0KBgAoBgIGLA4GCiwOBQEsDgoCLA4HAywOCAQlLA0DBgw4BQYJIwIACQAAKeYiAAAqlywNAQYsDQIJLA0DCiwNBAsmAg0EBAw4BQ0OIwIADgAAKg0kAAAlqAAoCQINADgNBQ4sDQ4MJgIOBAMMOAUODyMCAA8AACoyJAAAJagAKAYCDgA4DgUPLA0PDQA4DA0OJgINBAQMOAUNDyMCAA8AACpcJAAAJagtBAAJgAMnAIAEBAAFJAAAJv0tCIAFAAwAKAwCDQA4DQUPLA4ODywOBgEsDgwCLA4KAywOCwQiAAAqlwA4BQcGDjgFBgkjAgAJAAAqriQAACW6LAwGBSIAACljKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVeLG9yVJmsyzsBAQIlKQEAAQUC3G4ngHYSnTsBAQIlLQAYyhjK",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_participants",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "name",
                            "type": {
                              "kind": "array",
                              "length": 2,
                              "type": {
                                "kind": "field"
                              }
                            }
                          },
                          {
                            "name": "npk_m_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "randomness",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "header",
                            "type": {
                              "fields": [
                                {
                                  "name": "contract_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "nonce",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "storage_slot",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "note_hash_counter",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::note::note_header::NoteHeader"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::participant_note::ParticipantNote"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3dbhxHsoTfRde+qL+sn32VxcKwvd6FAME2/HOAA8PvfkZsTg91pmuS6imjI6rzxpCsbjIj2Mwva8iM+fPDv3/8/o//fvvxp//8/NuHf/zzzw+ffv7hu98//vzT5W9//vXNh+9//fjp08f/fvv2f39wn/8jqb7c8Nsv3/30+e+//f7dr79/+IfPzX3z4cef/n35Y3Hu8iH+8/HTjx/+kUr+65u7q6urrxfXkNdra9q4VIK8Xipy+7DeyV//+uZSTBtQjLRrMdU/LibF66Up17tixD1fTHP59eIW3ONisrs6k9+YuBbjBxST0rUYKUox9fpx337YtZiwWUwsaa0mlpyUcor3188Rbu5vXhpyvn7kcCntdvFSTsQqJ2GVI1jlZKxyClY5FaucBlVOdljleKxysLpyxurKGasrZ6yunLG6csbqyhmrK2esrlywunLB6soFqysXrK5csLpywerKBasrF6yuXLC6csHqyhWrK1esrlyxunLF6soVqytXrK5csbpyxerKFasrV6yu3LC6csPqyg2rKzesrtywunLD6soNqys3rK7csLpyg+rK2UF15eygunJ2UF05O6iunB1UV778EBmrHKiunB1UV84Oqitnh9WVPVZX9lhd2WN1ZY/VlT1WV/ZYXdljdWWP1ZU9Vlf2WF05/L1d+eVT+L//U4S//1OM6Yjp+iuKJeenvm4JqxzBKidjlVOwyqlY5TSocqLDKsdjlROwysHqyhGrK0esrhyxunLE6soRqytHrK6csLpywurKCasrJ6yunLC6csLqygmrKyesrpywunLC6sqC1ZUFqysLVlcWrK4sWF1ZsLqyYHVlwerKgtWVBasrZ6yunLG6csbqyhmrK2esrpyxunLG6soZqytnrK6csbpywerKBasrF6yuXLC6csHqygWrKxesrlywunL5e7vyy6dof/unqO7v/xTv6YhFvvgUL/eFnffFnfelnffJzvvyzvvKzvvqzvvavvvetcSzdd/O56XtfF7azuel7Xxe2s7npe18XtrO56XtfF7avuelOLfzPr/zvrDzvrjzvrTzPtl5X955X9l5X915387nxe98Xnq/oVzXZLnLn9/8oto28ryL6+Wu3j6Lz37r6noNuPPt9pFDbUtFAa6iCFdRgqtI4CrKcBUVuIoqXEUNraLeLy8fWNERPVuuFQUXvqjo/toaUny9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",
      "brillig_names": [
        "get_participants"
      ]
    },
    {
      "name": "register_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10966310306735189739": {
            "error_kind": "string",
            "string": "Escrow contract USDC does not match registry USDC"
          },
          "12806906349574299095": {
            "error_kind": "string",
            "string": "Escrow contract has already been registered"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14827131733433028185": {
            "error_kind": "string",
            "string": "Escrow contract registry does not match this contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17408225848945384450": {
            "error_kind": "string",
            "string": "Proving nullifier inclusion failed"
          },
          "17540660350934727925": {
            "error_kind": "string",
            "string": "Nullifier does not match value in witness"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089479698890196495": {
            "error_kind": "string",
            "string": "Escrow contract admin does not match sender of message"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6337220856976823863": {
            "error_kind": "string",
            "string": "Escrow contract class ID does not match expected class ID"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_contract_instance_internal",
        "get_nullifier_membership_witness",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "unpack_returns",
        "get_public_keys_and_partial_address",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "pack_arguments_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_escrow_class_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAGEHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAAGtHgIAAgkmAgMAAQo4AgMEIwIABAAAAIUkAAABvyYCAgAALAgBBCYCBQQEABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYsCAECAAABAgEsDgQCJgIEBAEmAgUEACYCBgQDLAwFASIAAADhDDgBBgUjAgAFAAABDyIAAADzLA0CASYCAgQCACgBAgQAOAQCBSwNBQMsDAMBJSwNAgUcDAEHAAA4AwcILgwACAAHJgIJBAMMOAEJCiMCAAoAAAE6JAAAAdEtBAAFgAMnAIAEBAAEJAAAAeMtCIAFAAgAKAgCCQA4CQEKLA4HCgA4AQQFDjgBBQcjAgAHAAABdyQAAAJxLA4IAiwMBQEiAAAA4ScAgAQEeAANAAAAgASAAyMAgAMAAAGsKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVSVfKdc0WarDsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAB/iIAAAIJLQCAA4AFIgAAAnAtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAACXC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAACKycBgAUEAAEDAIAGAAKABiIAAAJwJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "1ZrdbuowDMffpde9iPNlm1c5mqYCZapUFVTgSEeIdz8poqUrXasxtsU3qEH/1D85qRM7OSXrfHl8ey2qzXafLP6cknK7yg7Ftgqt0zlNlnVRlsXba//vRDU/ni/6/S6rmub+kNWHZAGeVZrk1To8olLhDZuizJOFRX9O79VKuVattOvUYGlEbQ3RVW0NY6cmNyImMO2rCRz0xS9pgvYZ8KRbdaD/QfineN5C53k/53lwpoUHx3YanrVuX83a2wE84XPhQb2HDyZYf7uJMHF/wIb7ug2PnQ2Pbm7aEbczmhjcYOQC42d5Lr3cI730Q7Y0PdLLmNFe4ZtWt+GxZsbTGgiv8vAB9MKB5xE1avBXNWozMy6eqA0H4dEPx8WQbH6rhfOjbH4n3P9OuP+9cP97L5sflXB+J5yfZfOTFc4vfP/AwuMny16/tI4+/jC0eU14NEN+G/3+n4k7fnZ3/L8yfxR0/E5P8yObNq3s1Umshwv+72w/n4cv2/tetvcRZMee6PduqLpSJCp7F3so9r0z3khG+eP3v8Ibv58Wh5I0mq6sy+puqeb4P5fJpY6jTzUn+Y2S7X+jok/VpvnByubX0ZcqZvijT3Wm+U30qeYMf/Sp/jS/8FTNWOH+j/+oYIZfePyJ/6hgmj/+UvsMf/ylro/5z6H1N6uLbFnm1+s9m2O16t32Ofzb5YOLP7t6u8rXxzpvrgDdbv804xhO1QHgpbmpEFroUlJNo9niEqRkgsFg9D8=",
      "brillig_names": [
        "get_escrow_class_id"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "ndLNCoQgFAXgd7nrFl2z31eJIawsBNEwGxiidx+LZmiGNrq5eMTvujkr9LxdxkaoQc9Q1StI3TErtHJp3SJojZBSjM31GuJ9IB7v54mpPc6WGQsVYhIBV707EXR+EJJDRfNse0SAxJ8k/oT6k9SbkNtfSorlaUpKsy9CjA+UhqAsBOUhqAhAyW0PyjQuPigl+S/aXHwyI1gr+dmzYVHdpXb2NfG/Bk5Gd7xfDN+7eKmhmzXmESFurVv9Bg==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "get_participant_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "5ZzRbtxGEkX/Rc9+6Kqu6q7OrywWge04gQDBDmxngUXgf1/OSJyRRZkNzzLkvWQeAskm2XUU856So6q/73778O6vP369//j7py93v/zr77uHT+/ffr3/9HH47O9vb+7efb5/eLj/49fnv3yXTv/SfL7+y59vP54+/fL17eevd79IaenN3YePvw0f1pSGJ/x+//Dh7her5dubydWR4uni0HK5NuyVS1396VL362Ml+bd/v7lTW6AWb2MtIfO1WB4vtRKTWvz/r6Wl8nRx0zRfS0nj16U8+xKOtZQFajEba/HaqSXG5z5/7FhLfbUWjTyyDh9X61RjVsc/MubyDLjKa7XXuHwhI+fL1VVfuVhSa3ksZfjYnl9+Agh2gEYOkBM7gLADKDtAZgcwdgBnByjsAOwmzuwmzvAmlpQvAMPHLwEM3sQ9AHgT9wDgTSypPgOoEwB4E/cA4E3cA4A38VB1uwAMn7wEgDdxDwDexD0AeBP3APBNPA/g+CbuAOCbuAOAb+IOAL6JOwD4Ju4AsJvY2U3sBCb2dAVweQlAYOJ5AAITzwIUfBPXsAtADX8JgG/iDgC+iTsA+CYO1QtAaH4JgG/iDgC+iTsA+CaOco3RKJMYxTdxBwDfxB0AfBPH9a/Xh49f/sVWxTdxBwDfxB0ALBOfKsJS66kiLFeeKsKS36kiLJudKsLS06kiLN+cKsISyFBRYBnhVBFWxJ8qgsvsgMvsgMvsgMvsgMvsgMvsgMvsgMvsBpfZDS6zG1xmN7jMbnCZ3eAyu8FldoPL7AaX2Q0usyXBhbYkuNSWBBfbkuByWxJccEuCS25JcNEtCS67JcGFtyS89Ba89Ba89Ba89Ba89Ba89Ba89Ba89Ba89Ba89Ba89Fa89Fa89Fa89Fa89Fa89Fa89NYt0jtKXEoKnZRU8UoKvJIaXEmbLDfolCR4JSleSRmvJMMryfFKwkvvjJfeGS+9M156G156G156G156G156G156G156G156G156G156G156O156O156O156O156O156O156O156O156O156O156F7z0LnjpXfDSu+Cld8FL74KX3gUvvQteehe89C546V3x0rvipXfFS++Kl94VL70rXnpXvPSueOld8dK74qV34KV34KV34KV34KV34KV34KV34KV34KV34KV34KV3w0vvhpfeDS+9G156N7z0bnjp3fDSu+Gld8NL7waX3prg0lsTXHprgktvTXDprQkuvTXBpbcmuPTWBJfemuDSWxNeegteegteegteegteegteegteegteegteegteegteeiteeiteeiteeiteeiteeiteeuPNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWirerKXizVoq3qyl4s1aKt6speLNWuoms5Yt+1hSy2VSkuGV5HglFbySKl5JgVdSQyspbzJr2SlJ8EpSvJLg0jsnuPTOCS69c4JL77zFrKWklC5PHz6uk6ICsagGWNQWE5dDIdenJ0/peVHTy4e/6B3/AA4fPvsD+Agg7ADKDpDZAYwdwNkBCjyA1ZrHh8ezi0XSI0LlRwh+hEaPoPhG7iLgO9lC2tPVLs2/Q5he7abjxRbXa7U84uIbfFFcfN8vims7w80u49ubW9Lp24vfTSwMTNB9LAtM0KssC0zQ2SwLTNAHLQqcCbqmZYH31mN1gffWZXWB99ZndYHtaMBH67Ty0TqtfLROKx+t08pH67TsaJ2WHa3TsqN1Wna0TmuLDR8LAp8RuHunMwJ3N3RGwO9vXKWOCKplioDfsXQR8HuQHoLjdxXfIeQ8RcDvE7oI+ObvIuC73IcCLgjtlXcB385dBHw7dxHw7dxDKAR/kLKMPxfkwzceUwT8BqMkS09Xl1RsioDWYJyLQmsZTkVVtCbgXNQmWh/cdi3Kej9cV8r4J1BLPLv4EUDZATI7gLEDODtAYQeo7ADBDtDIASKxA7CbONhNHOwm3mLFx7IA7CYOdhMHu4mD3cTBbuLGbuLGbuLGbuLGbuIt1rUsC8Bu4sZu4sZu4sZu4kZuYkvkJrZEbmJL5Ca2RG5iS+QmtkRuYkvkJrZEbmJL5Ca2xG5iYTexsJtY2E0s7CbeZhHRkgDsJhZ2Ewu7iYXdxMJuYmU3sbKbWNlNrOwm3mbpz5IA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",
      "brillig_names": [
        "get_participant_escrows"
      ]
    },
    {
      "name": "check_and_register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12235207718074526931": {
            "error_kind": "string",
            "string": "Escrow contract is not registered"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7P3bkiRZs5yJvct/jQs/mJ/wKhQKBeSPoUBkBKAQ4BUE786o7s7IbJSpr67JVRHupt/dxkzs2m6fRqfr0nBz/Z//+vd//n/+//7f/4//8l//j//23//1H/9v//Nf/+d/+3/9p//xX/7bf338v/7nv7b5j/9v//3/85/+64//53//H//p//s//vUfx/UY/sO//vN//ffjf9yG4X/9h3/9H//l//zP//qPsa3/6z/89Olpn/e/Pj3t6+enxziST8/LePz16Xk5psanxzXG+eNS1pjW5+fnYck+Pz//9XGe9+enp+zCx2FaPz48bMvXD//f/8O/tgCNQrOARqFZQaPQbKBRaHbQKDQHaASafQCNQjOCRqGZQKPQ4IYlmgCNQoMblmhwwxINbliiwQ1LNLhhhebADUs0uGGJBjcs0eCGJZoAjUKDG5ZocMMSDW5YosENSzS4YYVmHLDDmg1+WLPBEGs2OGLNJmAj2eCJNRtMsWaDK9ZssMWaDb5YshnxxZoNvlizwRdrNvhizSZgI9ngizUbfLFmgy/WbPDFmg2+WLKZ8MWaDb5Ys8EXazb4Ys0mYCPZ4Is1G3yxZoMv1mzwxZoNvliymfHFmg2+WLPBF2s2+GLNJmAj2eCLNRt8sWaDL9Zs8MWaDb5Ysgl8sWaDL9Zs8MWaDb5YswnYSDb4Ys0GX6zZ4Is1G3yxZoMvlmwWfLFmgy/WbK7vi5fhk80aLTbb/kS5D9P32FzfF7+PTcBGsrm+L34fmw6+OIZl+evTMRzj89P7X/8ntt//f6KDS3v8xBuff8WPL5rtyaePYxn/+vRxrPvXC0q+PNO8f/zb0/S4ufx0/ce9r39N3c627x/Xvx3D3PwvbP+QeDqmL//NrNl/M/uyPb/Vw9f/wOb0w8/7+b4sQ+M/r32K56enL9+1/NPz8vGfV0zD+X+K0/b8T3HaovHhnv+RryPyXFmeCXmuLM+MPFeWJ14tzzh+2rXxC8Mf+vxxRcvlrmi93BVtl7ui/XJXdFztirbhclc0Xu6Kpstd0Xy5K3rD3+zhmdFNsf58Rcvlruj1f7O3dXmeN/831f5DciXz80K+JqTZvzw9frf9uI7HYf1vn/5j1s1o1t1o1qPSrOv8nHX7edZ9MJp1NJp1qjTr88PT9OXc9Zx1Npo1jGZdSt1zvsw6/zxrJd80Ddtz1mn7edZKvqk1ayXf1Jq1lG/68t/r9PP99bi4b9qfFnccxqMx7O+LV6fj47Q4zWMrMe34QMpxcavnLs/F3elF5HnXjxPHxQ21uzxhIs8fw77hEBDTU6ppbpmK+PBE25cHUqYl/rz69dZXv9366vdbX/1x46ufhuHWVz/e+uqnW1/9fOurj1tf/Z3vtdNw53vtNNz5XjsNd77XTsOt77Xjre+1463vteOt77Xjre+1463vteOt77Xjre+1463vteOt77Xjre+1063vtdOt77XTre+1063vtdOt77XTre+1063vtdOt77XTre+1063vtfOt77Xzre+1863vtfOt77Xzre+1863vtfOt77Xzxe+1+/Mpgscl/Xz1F7/XNq7+4vfaY/2ynT3+7fJ//nAs6/MxmOX4fADFZDt7iotbD8T8FTEv7sQQ81fEvLgxRcxfEfPiPh0xf0XMQMw6Yl78FIeYvyLmxQ+1iPkrYl78jI+YvyLmxSMPxPwVMUmA6oi5kAAVEpMEqJCYJECFxCQBKiRmIGYdMUmAColJAlRITBKgQmKSABUSkwSojpgrCVAhMUmAColJAlRITBKgQmIGYtYRkwSokJgkQIXEJAEqJCYJUCExSYDqiLmRABUSkwSokJgkQIXEJAEqJGYgZh0xSYAKiUkCVEhMEqBCYpIAFRKTBKiOmDsJUCExSYAKiUkCVEhMEqBCYgZi1hGTBKiQmCRAhcQkASokJglQITFJgOqIeZAAFRKTBKiQmCRAhcQkASokZiBmHTFJgAqJSQJUSEwSoEJikgAVEpMEqIyY80ACVEhMEqBCYpIAFRKTBKiQmIGYdcQkASokJglQITFJgAqJSQJUSEwSoDpijiRAhcQkASokJglQITFJgAqJGYhZR0wSoEJikgAVEpMEqJCYJECFxCQBqiPmRAJUSEwSoEJikgAVEpMEqJCYgZh1xCQBKiQmCVAhMUmAColJAlRITBKgOmLOJECFxCQBKiQmCVAhMUmACokZiFlHTBKgQmKSABUSkwSokJgkQIXEJAGqI2aQABUSkwSokJgkQIXEJAEqJGYgZh0xSYAKiUkCVEhMEqBCYpIAFRKTBKiOmAsJUCExSYAKiUkCVEhMEqBCYgZi1hGTBKiQmCRAhcQkASokJglQITFJgOqIuZIAFRKTBKiQmCRAhcQkASokZiBmHTFJgAqJSQJUSEwSoEJikgAVEpMEqI6YGwlQITFJgAqJSQJUSEwSoEJiBmLWEZMEqJCYJECFxCQBKiQmCVAhMUmA6oi5kwAVEpMEqJCYJECFxCQBKiRmIGYdMUmAColJAlRITBKgQmKSABUSkwSojpgHCVAhMUmAColJAlRITBKgQmIGYtYRkwSokJgkQIXEJAEqJCYJUCExSYDKiBkDCVAhMUmAColJAlRITBKgQmIGYtYRkwSokJgkQIXEJAEqJCYJUCExSYDqiDmSABUSkwSokJgkQIXEJAEqJGYgZh0xSYAKiUkCVEhMEqBCYpIAFRKTBKiOmBMJUCExSYAKiUkCVEhMEqBCYgZi1hGTBKiQmCRAhcQkASokJglQITFJgOqIOZMAFRKTBKiQmCRAhcQkASokZiBmHTFJgAqJSQJUSEwSoEJikgAVEvP1CdC6SzF/XFG8PMaYHv/Ix6eXeWl8vcZpio/rn+avUmX/9roM+1+fXpf58xszZh+ep+njsudp/oJmT2fcxo+r3rft64f/wDiCsQfGCYw9MM5g7IExwPiPMB7Hx3XMw7j8hHEBYw+MKxj/CcZ5mD8xxtFg/nkZ0/LFNqYfHvf9ae6+sv4QaEOgNwt0LMtToG0//3A8Dy5xzF/H+0PLHS3LaHmgZRUtF46rb9ZyeqQ8Hx8epviOlpyZ62jJwf3dWo7jR0w5jfPxv5vThUjg4gIFAl1bIGKMdws0xce/PE174zLGeX/+MBXDT2nKQppSSU2il1upuczPn1SXZf2O7ySnMRWeUMdT+JUE6F7Cb8/obzm+E/2txEWmwpMt/Q7hP7Vs/kFu/PC5ki29W6BuP7CsgZZltCSxerOW/X5gWcmr6mhJWvVuLc+j/pVU6eICkf5cW6CNlObdAnX8eWUjeqmkJnnKrdTsFp1v5DSmwgfCewpPAnQv4Xv9ZrIRF5kKT7b0G4Rfp4+XKEzrsnzPfZMtXVwgsqV3C9TN/+zEUHW0JISqoyUR1Nu17OU4d1KlOloGWv4jLcfxg8g8Tkvr2NjvHSM7gc67Ber2eNZORlNHS2KXOlqS0LxZy36P2u2EOWW0PAhz3q3l+UNfBwnNxQUidrm4QGQp7xao44N2R6BmITWJXm6lZrcfKw5yGlPhCXVMhScBupfwvX7/OoiLLIVfBrKl3yF8t3eMLAPZ0rsF6vUDyzIQQ9XRksTqzVp2+4FlGQIty2hJWvVuLU+j/mUgVbq4QKQ/FxeIlObdAvX7eWUZiF4KqTmSp9xKzV7R+TKS05gKT6hjKjwJ0L2E7/WbyRgI7yk82dJvEL7fKyyWkWzp4gKRLb1boH7+hxiqjpaEUGW0nIig3q5lL8c5kSrV0fL1QdFyfBl0vYmW0749nwXYt+1/t5DTDMYeGAOMPTAuYOyBcQXjP8J4HJ/v0hp/Ol5PGxh7YNzB+I9c129rXG08FD8dCPRmgbo9SD0PaFlGyxEty2jJcfXNWvZ7KH7mzFxHy0DLN2t5/nj2TCRwcYEIGy4uEDHGuwXq+Ej8TJpSSU2il1up2e2xgiCnMRWeUMdUeBKgewnf60mVIC4yFT4Q/jcI3+9tYEG29G6Buv3AEsRQdbQksXqzlv1+YAnyqjpakla9W8vzqH8hVbq4QKQ/FxeIlObdAnX8eWUheqmkZqDmndTsFp0v5DSmwhPqmApPAnQv4Xv9ZrIQF5kKT7b0G4Tv+LKplWzp4gKRLb1boG7+ZyWGqqMlIVQdLQMt361lL8e5kirV0ZKg6J9p+dsaVxuP2q0EOu8WqNvjWSsZTR0tiV3KaLmR0LxZy36P2m2EOXW0JMx5t5bnD31tJDQXFygQ6NoCkaW8W6COD9ptpCmV1CR6uZWa3X6s2MhpTIUn1PEUficBupfwvX7/2omLTIUnW/odwvd7x8hOtvRugbr9wLIHWpbRksTqzVr2+4FlJ6+qoyVp1bu1PI/6d1KliwtE+nNtgQ5SmncL1PHnlYPopZKa5Cm3UrNbdH6Q05gKHwjvKTwJ0L2E7/WbyUFcZCo82dJvEL7jKywOsqWLC0S29G6BevmfdSCGqqMlIVQdLYmg3q5lJ8e5DqRKdbSMl2u5fWq5T+PftPzjipbLXdHrj9bbNn5e0fTzFW2Xu6LXH3KO5UO1eRiOn6/ouNoVjS/3pvvyPPcMw9T4s7kvzx9492X5/LM5/zgx/fzpKZ6fno6x8el5+XicNKavf5DTb9r08dlpi8aHx21/GpT9y4T5h4fnvzwO2/L1w3/IMyLPleV5uYN83L6Pp4+I9ef/nufLXdHL7+bjtj6dyHaMje/w59dhO9Yv38n0r+n4GaeOy/63T/8x62I062o061Zp1vXzmaktmXU3mvXwmXUaKs36/PA0fbmHP2cdjWadjGadS91zvsw6/zxrFJp1GrbnrNP286yVfFNr1kq+qTVrKd/05b/XKbm/Xtw37U+LOw7j0Rj29x3Vp+PjtDg9AujG6Xsen0fLed6/dVSfLm71LiLPu5KU+eLu1F2eixvqbvL8MewbHHVMT6mmuXXXio+b7rZ++aO4xJ9XP9/66uPWV7/c+urXW1/9duur32999cedrz6GW1/9eOurv/W9Nm59r41b32vj1vfauPW9Nm59r41b32vj1vfa5db32uXW99rl1vfa5db32uXW99rl1vfa5db32uXW99rl1vfa5db32vXW99r11vfa9db32vXW99rXd0d3vfpb32vXW99r11vfa9db32vXW99rt1vfa7db32u3W99rt1vfa19fGPhrV78/nyJ4XNLPV3/xe23j6i9+rz3WL6tk498u/+cPx7I+H4NZjs8HUFxWybaLWw/E/BUxL+7EEPNXxLy4MUXMXxBzv7hPR8xfEfPixxbE/BUxL36KQ8xfEfPih1rE/BUxAzHriHnxyAMxf0VMEqBCYpIAFRKTBKiQmCRAdcQ8SIAKiUkCVEhMEqBCYpIAFRIzELOOmCRAhcQkASokJglQITFJgAqJSQJURsxtIAEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTFHEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJgAqJSQJUSEwSoEJikgDVEXMiASokJglQITFJgAqJSQJUSMxAzDpikgAVEpMEqJCYJECFxCQBKiQmCVAdMWcSoEJikgAVEpMEqJCYJECFxAzErCMmCVAhMUmAColJAlRITBKgQmKSANURM0iAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEfMhQSokJgkQIXEJAEqJCYJUCExAzHriEkCVEhMEqBCYpIAFRKTBKiQmCRAdcRcSYAKiUkCVEhMEqBCYpIAFRIzELOOmCRAhcQkASokJglQITFJgAqJSQJUR8yNBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEB1xNxJgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzIMEqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQGXE3AcSoEJikgAVEpMEqJCYJECFxAzErCMmCVAhMUmAColJAlRITBKgQmKSANURcyQBKiQmCVAhMUmAColJAlRIzEDMOmKSABUSkwSokJgkQIXEJAEqJCYJUB0xJxKgQmKSABUSkwSokJgkQIXEDMSsIyYJUCExSYAKiUkCVEhMEqBCYpIA1RFzJgEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTGDBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEB1xFxIgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzJUEqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXE3EiAColJAlRITBKgQmKSABUSM14u5rpLMf+4opfHGNPjH/n49DIvja/XOE3xcf3T/FWq7N9el2H/69PrMn9+Y8bsw/M0fVz2PM1f0OzpjNv4cdX7tn398B8YVzD2wLiBsQfGHYw9MB5g/EcYj+PjOuZhXP53jPsAxh4YRzD+E4zzMH9ijKPB/PMypuWLbUw/PO7709x9Zf0h0IRAbxboWJanQNt+/uF4HlzimL+O94eWM1qW0TLQsoyWHFffrOX0SHk+PjxM8R0tOTPX0ZKD+7u1HMePmHIa5+Mnc0okcHGBCBuuLdBBjPFugab4+JenaW9cxjjvzx+mYvgpTTlIUyqpSfRyKzWX+fmT6rKs3/CdBzmNqfCB8J7CkwDdS/jtGf0tx3eiv4O4yFR4sqXfIfynls0/yI0fPg+ypXcL1O0HloMYqoqWx0Bi9WYtu/3AcgzkVXW0JK16t5anUf+DPgJdW6BAoGsLRErzboH6/bxyDEQvldQkT7mVmr2i82MgpzEVnlDHU/iRBOhewnf6zeQYiYtMhSdb+g3Cr9PHSxSmdVm+5b5HsqWLCxQI9GaB+vkfYqg6WhJC1dGSCOrtWnZznKRKdbQkKPpnWo7jB5F5nJbWsbHbO0aOiUDn3QJ1ezxrIqOpoyWxSx0tSWjerGW/R+2mQMsyWhLmvFvL84e+JhKaiwtE7HJxgchS3i1QxwftJtKUQmrORC+3UrPbjxUzOY2p8IQ6psKTAN1L+F6/f82B8J7Cky39DuG7vWPkmMmW3i1Qtx9YZmKoOlqSWL1Zy34/sMzkVWW0DNKqd2t5HvUHqdLFBSL9ubhApDTvFqjjzysRqFlITfKUW6nZLToPchpT4Ql1TIUnAbqX8L1+MwniIk/hF7Kl3yB8x1dYLGRLFxeIbOndAnXzPwsxVB0tAy3LaEkE9XYtuzlOUqU6Wr4+KFqOL4OuN9Fy2rfnswD7tv1kIXcw9sB4gLEDxnUAYw+MIxj/Ecbj+HyX1vjT8XqdwNgD4wzGf+S6flvjauOh+DUQ6M0CdXuQel3QsoyWK1qW0ZLj6pu17PdQ/MqZuY6WHNzfreX549kbkcDFBSJsuLhAxBjvFqjjI/EbaUolNQM176Rmt8cKNnIaU+EJdUyFJwG6l/C9nlTZiItMhSdb+h3C93sb2E629G6Buv3AshND1dGSxOrNWvb7gWUnr6qjZaDlm7U8j/p3UqWLC0T6c3GBSGneLVDHn1d2opdKapKn3ErNbtH5QU5jKjyhjqnwJED3Er7XbyYHcZGp8IHw/YXv+LKpg2zp4gKRLb1boH7+hxiqjpaEUHW0JIJ6u5adHOc4DMRKhcQkKvpnYv62ztXzh+0eCpHpvFuhXk9oPcQkpykkZiBmHTHJad4sZrcH7h5ikukUEpNQ591inj789VCIqObqChHAXFyhkVTl3Qr1e+buISe5Sik5CWFuJWevXy4eypPYuCofKG+qPFnQvZTv9nPYSHDkqjwp0+9QvttbRx4KkTK9W6F+P7eMBFJ1xJzIrt4sZsefWyaSq0Jiklu9W8xG7j+RL11doUChiytEXvNuhXr+2DIRwpSSk2TlVnL2y9EnEhtX5Yl3TJWfyYLupXy3X1BmgiNX5UmZfoPy/d5x8VCIlOnqCgUKvVmhjiaIQKqQmMRRhcQkjHq7mP18J/lSITFfHxltn2Lu0/g3Mf+4pBiud0mvP2Rv2/h5SVNySdP1Lun1x51j+RBuHoYjuaS43iW93KXuy/MMNAxT46/nvjx/9d2X5fOv5/zj9PTzp6d4fno6xsan5+XjUdOYvv5dTr9s08dnpy0aHx63/elU9i8T5h8env/yOGzL1w//qc+KPpfW5+Ve8nEfP56GItbkP+n9epf08vv6uK1PU7IdY+Nr/PmN2I71y9cy/ZM6fgas47L/7dN/DLsMTsOOTsNOlYZdP5+n2rJhZ6dhw2nYpdKwzw9P05eb+eewq9Owm9Owe6lbz5dh52TYSg5qGrbnsNP287BrJQfVHLaSg2oOW8pBfflvdkrus+vFHdT+tLs/djEb0/6+s/t0fBwep0cyff7hcR6fJ8153v/Xt87ua6DPlbOV9eI+1V6fi1vrbvr8Oe0bvHVMT7GmuTHtFh+33m398odxib8uf7/35R+3vvxtuPflj/e+/Onelz/f+/Lj3pe/3Pvy13tf/r3vutu977rbve+6+73vuvu977r7ve+6+73vuvu977r7ve+6+73vuvu977r7ve+6+73vuse977rHve+6x73vuse977rHve+6x73vuse977rHve+6x73vuset77rjcOu77jjc+q47Dre+647Dre+643Dru+443PquOw63vuuOw63vuuNw67vuOFz8rrs/Hzh4XNLPlz9e/K7buvyL33WP9csu2vi36//5w7Gsz4dmluPzcRWXXbRxvLgJQc1fUvPingw1f0nNQM1Cal7csaPmL6l58QMMav6Smhc/z6HmL6l58eMtav6Smhc/7aPmr6g5XTz8QM1fUpMsqJKaZEGV1CQLqqRmoGYhNcmCKqlJFlRJTbKgSmqSBVVSkyyokJozWVAlNcmCKqlJFlRJTbKgSmoGahZSkyyokppkQZXUJAuqpCZZUCU1yYIKqRlkQZXUJAuqpCZZUCU1yYIqqRmoWUhNsqBKapIFVVKTLKiSmmRBldQkCyqk5kIWVElNsqBKapIFVVKTLKiSmoGahdQkC6qkJllQJTXJgiqpSRZUSU2yoEJqrmRBldQkC6qkJllQJTXJgiqpGahZSE2yoEpqkgVVUpMsqJKaZEGV1CQLKqTmRhZUSU2yoEpqkgVVUpMsqJKagZqF1CQLqqQmWVAlNcmCKqlJFlRJTbKgQmruZEGV1CQLqqQmWVAlNcmCKqkZqFlITbKgSmqSBVVSkyyokppkQZXUJAsqpOZBFlRJTbKgSmqSBVVSkyyokpqBmoXUJAuqpCZZUCU1yYIqqUkWVElNsqA6ak4DWVAlNcmCKqlJFlRJTbKgSmoGahZSkyyokppkQZXUJAuqpCZZUCU1yYIKqTmSBVVSkyyokppkQZXUJAuqpGagZiE1yYIqqUkWVElNsqBKapIFVVKTLKiQmhNZUCU1yYIqqUkWVElNsqBKagZqFlKTLKiSmmRBldQkC6qkJllQJTXJggqpOZMFVVKTLKiSmmRBldQkC6qkZqBmITXJgiqpSRZUSU2yoEpqkgVVUpMsqJCaQRZUSU2yoEpqkgVVUpMsqJKagZqF1CQLqqQmWVAlNcmCKqlJFlRJTbKgQmouZEGV1CQLqqQmWVAlNcmCKqkZqFlITbKgSmqSBVVSkyyokppkQZXUJAsqpOZKFlRJTbKgSmqSBVVSkyyokpqBmoXUJAuqpCZZUCU1yYIqqUkWVElNsqBCam5kQZXUJAuqpCZZUCU1yYIqqRmoWUhNsqBKapIFVVKTLKiSmmRBldQkCyqk5k4WVElNsqBKapIFVVKTLKiSmoGahdQkC6qkJllQJTXJgiqpSRZUSU2yoEJqHmRBldQkC6qkJllQJTXJgiqpGahZSE2yoEpqkgVVUpMsqJKaZEGV1CQLqqPmPJAFVVKTLKiSmmRBldQkC6qkZqBmITXJgiqpSRZUSU2yoEpqkgVVUvP1WdC6SzX/uKTx5YHG9PhHPj69zEvjCzZOU3wMMM1fxcr+7XUZ9r8+vS7z53dmzD48T9PHZc/T/IXNns64jR9XvW/b1w//yXGEYxeOExy7cJzh2IVjwPEfcTyOj+t4xKrLzxwXOHbhuMLxn3B85IefHONoQP+8jGn5Yh/TD4/7/jR5X1k/FdpQ6M0KHcvyVGjbzz8czxNMHPPX8f4Uc0fMOmIeiFlGzImD65vFnB6Jz8eHhym+JSan50JicoR/t5jj+BFaTuN8/GRRJ8KBqysUKHRxhQg03q3QFB//8jTtjcsY5/35S1UMP+cqE7lKKTkJYW4l5zI/f2VdlvVb7pPExlV54h1T5WeyoHspvz1TwOX4Vgo4Exy5Kk/K9DuU/xSz+Te59UPoTMr0boX6/dwyB2LWEZPs6s1idvy5ZSa5KiQmudW7xWzk/jP50tUVIge6uEJBXvNuhXr+2BKEMKXkJFm5lZz9cvQgsXFVPlDeVHmyoHsp3+0XlCA4clWelOk3KL9OH69amNZl+aYHJ2W6ukKkTO9WqJ8JWgikColJHFVITMKot4vZzXcu5EuFxAzE/EdijuMHkXmcltbxseObSBainXcr1O+ZrYW0ppCYBDCFxCSrebOYHR/AW4h16oi5Euu8W8zGk2ArWc3VFSKAubpCpCrvVqjn43drIGclOQlhbiVnv58uVhIbV+WJd1yVJwu6l/Ldfg5bCY5Mld9ImX6H8h3fRLKRMr1boX4/t2wEUoXEJLt6s5gdf27ZAjHriElu9W4xG7n/Rr50dYXIga6uEHnNuxXq+WPLRghTSc6dZOVWcvbL0XcSG1fliXdclScLupfy3X5B2QPlTZUnZfoNyvd8z8VOynR1hUiZ3q1QRxNEIFVITOKoOmIehFFvF7Ob7zzIlwqJ+frIaDm+TLreRMxp355PB+zb9pORPGY4duEYcOzCcYFjF44rHP8Rx+P4fO3W+PNB+9jg2IXjDsd/ZL5+W2lr64H540ChNyvU7RnrGAbErCPmiJh1xOTg+mYx+z0wHwOn50JiBmK+WczzJ7cfP4Si0MUVIna4ukIEGu9WqOPj8jGQq5SSkxDmVnJ2e9QgRhIbV+WJd1yVJwu6l/K9Hl+JkeDIVflA+d+gfL83h8VIyvRuhfr93DISSBUSk+zqzWJ2/LllJLkqJCa51bvFbOT+E/nS1RUiB7q6QuQ171ao548tEyFMKTkDOe8kZ78cfSKxcVWeeMdVebKgeynf7ReUieDIVXlSpt+gfMf3UsVMynR1hUiZ3q1QPxM0E0gVEpM4qpCYgZjvFrOb75zJlwqJSWT0z8T8baWtrQfwZqKddyvU75mtmbSmkJgEMHXEDLKaN4vZ8QG8INYpJCaxzrvFbDwJFmQ1V1coUOjiCpGqvFuhno/fBblKKTkJYW4lZ7+fLoLExlV54h1T5ReyoHsp3+3nsIXgyFV5UqbfoXzHN5EspEzvVqjfzy1LIGYdMcmu3ixmx59bFpKrQmKSW71bzEbuv5AvXV0hcqCLK7SS17xboZ4/tqyEMKXkJFm5lZz9cvSVxMZV+UB5U+XJgu6lfLdfUFaCI1flSZl+g/I933OxkjJdXSFSpncr1M8EbQRShcQkjiokJmHU28Xs5js38qVCYsbLxdw+xdyn8W9i/nlJy/Uu6fWH7G0bPy9pSi5pu94lvf64cywfws3DcCSXdFzukvbcpR7T/rykZfvbJf35v5b6oX14/q3bh2VoTDIO8/PvxrB/+SOzjulfmY8HQ6fhc+ppz6bep/jwCvt0fP4XNP84c/38l/H5L8f09e9z+qWbnlexRePD47Y/Hcv+9ZpzGM9/eRy25euH/wQ+Afy1wOcOwMd1eN77x60FfHs+8jVu49j4t4/4+A/7WI6//RX48/Lj3pe/3Pvy13tf/ta8/LXvfWpfnsHYMEwNS70vz0eB9uULx/yvTcW/Tfur9XkcHo7nlzHWxEccl7ukY3j5JW3r8wa7HWPja/z5jdiO9cvXMvVx4+evOuOy/+3Tfw47Og07OQ07Vxp2/XyIc8uGDadhF6dh10rDPj88fT0cfQ67OQ27Ow17lLr1fBl2/mnYZajkoKZhew47bcmwlRxUc9hKDqo5bCkH9eW/2WlPho1rD7s/7e44jEdj2t93dp+Oj8Pj9Pg5rHEcn8fnSXOe92+d3Zfh4qbvIvq8K1tZhov7VHt9Lm6tu+nz57Rv8NbPbHjcp7l164qPW++2fvnDuMRfl3/c+vLH4d6XP9778qd7X/5878uPe1/+cu/LX+99+du9L//ed93x3nfd6d533ened93p3nfd6d533ened93p3nfd6d533ened93p3nfd6d533fned9353nfd+d533fned9353nfd+d533fned9353nfd+d533fned92491037n3XjXvfdePed92491037n3XjXvfdePed92491037n3XXS5+192fDxzs+5Bc/sXvuq3Lv/hd91i/7KKNf7v+nz8cy/p8aGY5Ph9XcdlFW5aLmxDU/CU1AzULqXlxi4qav6TmxR07av6Smhc/wKDmL6l58fMcav6Smhc/3qLmr6i5Xvy0j5q/pObFww/U/CU1yYIqqUkWVEnNQM1CapIFVVKTLKiSmmRBldQkC6qkJllQITU3sqBKapIFVVKTLKiSmmRBldQM1CykJllQJTXJgiqpSRZUSU2yoEpqkgUVUnMnC6qkJllQJTXJgiqpSRZUSc1AzUJqkgVVUpMsqJKaZEGV1CQLqqQmWVAhNQ+yoEpqkgVVUpMsqJKaZEGV1AzULKQmWVAlNcmCKqlJFlRJTbKgSmqSBdVRcx3IgiqpSRZUSU2yoEpqkgVVUjNQs5CaZEGV1CQLqqQmWVAlNcmCKqlJFlRIzZEsqJKaZEGV1CQLqqQmWVAlNQM1C6lJFlRJTbKgSmqSBVVSkyyokppkQYXUnMiCKqlJFlRJTbKgSmqSBVVSM1CzkJpkQZXUJAuqpCZZUCU1yYIqqUkWVEjNmSyokppkQZXUJAuqpCZZUCU1AzULqUkWVElNsqBKapIFVVKTLKiSmmRBhdQMsqBKapIFVVKTLKiSmmRBldQM1CykJllQJTXJgiqpSRZUSU2yoEpqkgUVUnMhC6qkJllQJTXJgiqpSRZUSc1AzUJqkgVVUpMsqJKaZEGV1CQLqqQmWVAhNVeyoEpqkgVVUpMsqJKaZEGV1AzULKQmWVAlNcmCKqlJFlRJTbKgSmqSBRVScyMLqqQmWVAlNcmCKqlJFlRJzUDNQmqSBVVSkyyokppkQZXUJAuqpCZZUCE1d7KgSmqSBVVSkyyokppkQZXUDNQspCZZUCU1yYIqqUkWVElNsqBKapIFFVLzIAuqpCZZUCU1yYIqqUkWVEnNQM1CapIFVVKTLKiSmmRBldQkC6qkJllQHTW3gSyokppkQZXUJAuqpCZZUCU1AzULqUkWVElNsqBKapIFVVKTLKiSmmRBhdQcyYIqqUkWVElNsqBKapIFVVIzULOQmmRBldQkC6qkJllQJTXJgiqpSRZUSM2JLKiSmmRBldQkC6qkJllQJTUDNQupSRZUSU2yoEpqkgVVUpMsqJKaZEGF1JzJgiqpSRZUSU2yoEpqkgVVUjNQs5CaZEGV1CQLqqQmWVAlNcmCKqlJFlRIzSALqqQmWVAlNcmCKqlJFlRJzUDNQmqSBVVSkyyokppkQZXUJAuqpCZZUCE1l9dnQesu1fzzkl4eaEyPf+Tj08u8NL5g4/S8knGav4qV/dvrMux/fXpd5s/vzJh9eJ6mj8uep/kLmz2dcRs/rnrftq8f/pPjBMcuHGc4duEYcOzCcYHjP+J4HB/XMQ/j8jPHFY5dOG5w/Ccc52H+5BhHA/rnZUzLF/uYfnjc96fJO4b5Z4V2FHqzQseyPBXa9vMPx/MEE8f8dbw/xTwQs4yY64CYdcTk4PpmMadH4vPx4Qf2b4nJ6bmQmBzh3y3mOH6EltM4Hz9Z1DVQ6OIKETtcXSECjXcrNMXHvzxNe+Myxnl//lIVw8+5ykquUkpOQphbybnMz19Zl2X9lvsksTFVfiPecVWeLOheym/PFHA5vpUCbgRHrsqTMv0O5T/FbP5Nbv0QugUKvVmhfj+3bARShcQku3qzmB1/btlIrgqJSW71bjEbuf9GvnRxhXZyoKsrRF7zboV6/tiyE8KUkpNk5VZy9svR90B5U+WJd1yVJwu6l/LdfkHZCY5clSdl+g3Kr9PHqxamdVm+6cFJmS6u0EHK9G6F+pmgg0CqkJjEUYXEJIx6u5jdfOcRiFlHTCKjfybmOA4fHx6npXV87PgmkoNo590K9Xtm6yCtKSQmAUwhMclq3ixmvwfw9oFYp5CYxDrvFvP8SbCHFCh0cYUIYK6uUKDQmxXq+PjdPpCrlJKTEOZWcnb76WIfSGxclSfecVWeLOheyvf6OWwfCY5clSdl+h3K93sTyT6SMr1boW4/t+wjgVQhMQMx3ytmx59bRpKrQmKSW71bzEbuP5IvXV0hcqCrK0Re826Fev7YMhHClJKTZOVWcvbL0ScSG1fliXdclQ+Uv5Xy3X5BmQiOXJUnZfoNynd8z8U+kTJdXSFSpncr1NEEEUjVEXMmjiokJmHU28Xs5jtn8qVCYr4+MlqOL5OuNxFz2rfn0wH7tv1kJOeAYxeOCxy7cFzh2IXjBsd/xPE4Pl+7Nf580J53OHbheMDxH5mv31ba2npgPgYUerNC/Z6xjhEx64g5IWYdMTm4vlnMjg/MRyBmHTE5wr9bzMaT20E4cHWFiB2urhCBxrsV6vm4fJCrVJJzIYS5lZz9HjVYSGxclSfecVWeLOheynd7fGUJlDdVnpTpdyjf8c1hCynTuxXq93PLQiBVSEyyqzeL2fHnloXkqo6YK7nVu8Vs5P4r+dLVFSIHurpC5DXvVqjnjy1rIGclOUlWbiVnvxx9JbFxVZ54x1V5sqB7Kd/tF5SV4MhU+Y2U6Tco3/O9VBsp09UVImV6t0L9TNBGIFVIzEDMOmISRr1dzH6+k3ypkJhERv9MzN9W2tp6AG8j2nm3Qv2e2dpIa+qIuRPAFBKTrObNYnZ8AG8n1ikkJrHOu8VsPAm2BwpdXCECmKsrRKryboV6Pn63k6uUkpMQ5lZy9vvpYiexMVX+IN5xVZ4s6F7Kd/s57CA4clWelOl3KN/xTSRHoNCbFer3c8tBIFVITLKrN4vZ8eeWg+SqkJjkVu8Ws5H7H+RL11boGMiBrq4Qec27Fer4Y8sxEMKUkpNk5VZydsvRjyFQ3lR54h1X5cmC7qV8r19QjoHgyFV5UqbfoHzH91wcAynTxRUaSZnerVA/EzQSSBUSkziqkJiEUW8Xs5vvHAMx64j5+sho+xRzn8a/ifnnJa3Xu6TXH7K3bfy8pCm5pP16l/T6486xfAg3D8Px8yVNw/UuqYNLnYdlfv4f2ZbGJW3DxxOe2/T5Lz9m+euCpqtd0Hy1C4qrXdBytQtar3ZB29UuaL/aBR0Xu6BZ/K3ep+cFHcvfLujP/7X87+m8flzZPu9rY45xmJ+Gati/zjGm9utjjmn4vB1MezbzPsXzOqbj01rMP8Kon3k+/+WYvhrX9G48Pa9ii8aHx21/HuX2r9ecw3j+y+NXUacP4BPAXwt87gB8XIfnoWjcWsC357Ow4zaOTTH356eHr8eRbfxrgLj7AMvdB1jvPsDWGiCGaPwfiXH8OOrHH3eoL/9H0k+Pz08vn/8Jbx+3q/1yV3Rc7YpiuNwVjZe7oulyVzRf7oricle0XO6K1std0eX+Zsfl/mbH5f5mL5f7m71c7m/2crm/2cvl/mYvl/ubvVzub/Zyub/Zy+X+Zi+X+5u9XO5v9nq5v9nr5f5mr5f7m71e7m/2erm/2evl/mavl/ubvV7ub/Z6ub/Z6+X+Zm+X+5u9vf5v9vx8nibmY/16RT9/eNmfP00t+5d/Ov3wvj1/NTq+RJXT8teok8+os8+o4TPq4jPq6jPq5jPq7jPqYTPqPviM6uOWdh+3tPu4pd3HLe0+bmn3cUu7j1vafdzS7uOWDh+3dPi4pcPHLR0+bunwcUuHj1s6fNzS4eOWDh+3dLi4pWkYXNzSjzeR+4zq4pYeo7q4pceo4TOqi1t6jFrILR3Dxz/8txqWKdsSHOP5fohx+bLN9wmmkLfqC6aQE+sLppBv6wpmLOTy+oIp5An7ginkIPuCKeQ3+4IJwORgCnnZvmBwvgIMzleAwfkKMDjfHMyE8xVgcL4CDM5XgMH5CjABmBwMzleAwfkKMDhfAQbnK8DgfHMwM85XgMH5CjA4XwEG5yvABGByMDhfAQbnK8DgfAUYnK8Ag/PNwQTOV4DB+QowOF8BBucrwARgcjA4XwEG5yvA4HwFGJyvAIPzzcEsOF8BBucrwOB8BRicrwATgMnB4HwFGJyvAIPzFWBwvgIMzjcHs+J8BRicrwCD8xVgcL4CTAAmB4PzFWBwvgIMzleAwfkKMDjfHMyG8xVgcL4CDM5XgMH5CjABmBwMzleAwfkKMDhfAQbnK8DgfHMwlXqR+oLB+QowOF8BBucrwARgcjA4XwEG5yvA4HwFGJyvAIPzzcFU6rjqCwbnK8DgfAUYnK8AE4DJweB8BRicrwCD8xVgcL4CDM43BTNW6ivrCwbnK8DgfAUYnK8AE4DJweB8BRicrwCD8xVgcL4CDM43B0OHmwKD8xVgcL4CDM5XgAnA5GBwvgIMzleAwfkKMDhfAQbnm4Ohw02BwfkKMDhfAQbnK8AEYHIwOF8BBucrwOB8BRicrwCD883B0OGmwOB8BRicrwCD8xVgAjA5GJyvAIPzFWBwvgIMzleAwfnmYOhwU2BwvgIMzleAwfkKMAGYHAzOV4DB+QowOF8BBucrwOB8czB0uCkwOF8BBucrwOB8BZgATA4G5yvA4HwFGJyvAIPzFWBwvjkYOtwUGJyvAIPzFWBwvgJMACYHg/MVYHC+AgzOV4DB+QowON8cDB1uCgzOV4DB+QowOF8BJgCTg8H5CjA4XwEG5yvAuDrfZY4nmGVNwJg63x9vGf3rwz9O0j+Dce1wm2IYPsDEeCRgTJ1vG4yp822DMXW+bTBhCmaZPm7X0zJvCRhT59sGY+p822BMnW8bjKnzbYNxdb7r8gSzbsPPYFw73NpgXJ1vE4yr822CcXW+TTABmByMq/NtgnF1vk0wrs63CcbV+TbB4HxTMJNrh1sbDM5XgMH5CjA4XwEmAJODwfkKMDhfAQbnK8DgfAUYnG8OxrXDrQ0G5yvA4HwFGJyvABOAycHgfAUYnK8Ag/MVYHC+AgzONwfj2uHWBoPzFWBwvgIMzleACcDkYHC+AgzOV4DB+QowOF8BBuebg3HtcGuDwfkKMDhfAQbnK8AEYHIwOF8BBucrwOB8BRicrwCD883BuHa4tcHgfAUYnK8Ag/MVYAIwORicrwCD8xVgcL4CDM5XgMH55mBcO9zaYHC+AgzOV4DB+QowAZgcDM5XgMH5CjA4XwEG5yvA4HxzMK4dbm0wOF8BBucrwOB8BZgATA4G5yvA4HwFGJyvAIPzFWBwvjkY1w63NhicrwCD8xVgcL4CTAAmB4PzFWBwvgIMzleAwfkKMDjfHIxth1sTDM5XgMH5CjA4XwEmAJODwfkKMDhfAQbnK8DgfAUYnG8Ohg43BQbnK8DgfAUYnK8AE4DJweB8BRicrwCD8xVgcL4CDM43BTPT4abA4HwFGJyvAIPzFWACMDkYnK8Ag/MVYHC+AgzOV4DB+eZg6HBTYHC+AgzOV4DB+QowAZgcDM5XgMH5CjA4XwEG5yvA4HxzMHS4KTA4XwEG5yvA4HwFmABMDgbnK8DgfAUYnK8Ag/MVYHC+ORg63BQYnK8Ag/MVYHC+AkwAJgeD8xVgcL4CDM5XgMH5CjA43xwMHW4KDM5XgMH5CjA4XwEmAJODwfkKMDhfAQbn+wCzNT69PXFs2+cVL+NfDG1N8rB/MjySL5etSW6A8a17a4GxNcktMK4mOT7/TsfR+nSMy/qccFs+L+MviK6GuivEAOL3Iboa9a4QTU39I67++IcfGcGa3CxMTX0bjKtTj2F4/mc3ZvbC1am3wNjW0zXBuDr1JhhXp75Mz1v7Mm8JGFf33QQTgMnBuLrkJhjXOLsJhjg7z/mpp1NgeJAjB0M9nQLDgxwCDA9yCDA8yCHABGByMDzIIcDwIIcAg/MVYHC+AgzONwdDPZ0Cg/MVYHC+AgzOV4AJwORgcL7ffiDVt8mu8RSdb5NdC4ypSZ6Hcfzrw/OwRALG1CQ3wbg22bXBmJrkNhhTk9wGY2qS22ACMDkYU5M8j8+rmMclOT24Ntm1wbg+EtwE4+p8m2BsHwnut6IQtq13XSHaPmrcEyILhB0gskDYAWIA8fsQWSDsANE1J+8KkWXDdNkwXJsC22BYNkxXx8K2KbAJhmVDAcbW1bfAsGyYbkiFbVNgEwzLhgIMy4YCjOvTJE0wPHKdPtwWNAUKMDQFKjA8ci3A8Mi1AMMj1wJMACYHwyPXAgzLhgIMy4YCDM5XgMH55mBoClRgcL4CDM5XgMH5CjABmBwMzleAwfl+dwszfEsFz5cNw7dUsAWGZcN03yVcSwXbYFg2FGBYNhRgWDYUYAIwORjXZcMmGJYN09WxcC0VbINh2VCAcXW+LTC2TYE9VxRsWwW7QmSBsANEFgg7QAwgfh8iC4QdILJA2AGia07eFSLLhvmyoWuzYRMMzYZidYxmQwWGZUMBxtbVt8AEG1LphhTNhgoMy4YCDMuGAozr0yRNMDxynT/cRrOhAsMj1wIMj1wLMDxyLcAEYHIwPHItwPDItQDDsqEAw7KhAIPzzcHQbKjA4HwFGJyvAIPzFWACMDkYnK8Ag/MVYHC+397CdG02bC4bujYbNsHQbCj2XWg2VGBYNhRgWDYUYAIwORiWDQUY12XDJhiWDfPVMZoNFRiWDVMwi2tbYRsMC4TfXlFYaCDsAZEFwg4QA4jfh8gCYQeILBB2gMgCYQeIrjl5V4gsG6bLhotrs2EbDMuG6erYQrOhAsOyoQATgMnBsGyYbkgtNBsqMCwbCjAsGwowrk+TtMDQbJg/3LbQbKjA8Mi1AMMj1wJMACYHwyPXAgyPXAswPHItwLBsKMCwbJiDodlQgcH5CjA4XwEG5yvABGByMDhfAQbnK8DgfAUYnO93tzAX12bD1rLh4tps2AbDsmG677LQbKjAsGwowARgcjAsGwowLBsKMK7Lhk0wLBvmq2M0Gwowrs2GbTCuzrcJhgXC768o0EDYA2IA8fsQWSDsAJEFwg4QWSDsAJEFwg4QXXPynhBdmw2by4auzYZtMCwb5qtjNBsqMAGYHIytq2+BYdkw35Ci2VCBYdlQgGHZMAdj22zYBMMj1/nDbTQbKjA8ci3ABGByMDxyLcDwyLUAwyPXAgyPXAswLBvmYGg2VGBwvgIMzleAwfkKMAGYHAzOV4DB+QowOF8BBucrwOB8v72F6dps2Fw2dG02bINh2TDfd6HZUIEJwORgWDYUYFg2FGBYNhRgXJcNm2BYNkxXx1aaDRUYlg0FGFfn2wTDAuG3VxTWIYD4fYgsEHaAyAJhB4gsEHaAyAJhB4gsEH4fomtbYV+ILBumy4ara7NhGwzLhunq2EqzoQLDsqEAY+vqW2BYNkw3pFaaDRUYlg1zMLbNhk0wrk+TNMHwyHX6cNtKs6ECE4DJwfDItQDDI9cCDI9cCzA8ci3A8Mh1DoZmQwWGZUMBBucrwOB8BZgATA4G5yvA4HwFGJyvAIPzFWBwvjkY37rCbluYq2uzYWvZcHVtNmyDYdkw3XdZaTZUYFg2FGBYNhRgWDYUYFg2FGBclw1bYGg2FKtjNBsqMCwbCjCuzrcJJlhR+PaKAg2EPSCyQNgBIguEHSCyQNgBIguE34fo2kDYF6JrTt4VIsuG+bKha7NhG0ywOpaujtFsqMCwbCjA2Lr6FhiWDfMNKZoNBRiaDRUYlg0FGNenSZpgeOQ6f7iNZkMFhkeuBRgeuRZgeORagOGRawGGR65zMDQbKjAsGwowLBsKMDhfASYAk4PB+QowOF8BBucrwOB8BRicbw7Gt66wBQbn++0tTNdmw+ayoWuzYRtMsO+S7rvQbKjAsGwowLBsKMCwbCjAsGyYgtlsmw2bYFg2TFfHNpoNFRiWDQWYAEwOhgXCb68obDQQ9oDIAmEHiCwQdoDIAuH3IdJA2AMiC4QdILrm5F0hsmyYLhturs2GbTAsG6arYxvNhgoMy4YCjK2rb4Fh2TDdkNpoNlRgWDYUYFg2FGBcnyZpggme4coebttoNlRgeORagOGRawGGR64FGB65zsHQbKjA8Mi1AMOyoQDDsqEAE4DJweB8BRicrwCD8xVgcL4CDM43B0OzoQKD8xVgcL7f3cLcXJsNW8uGm2uzYRsMy4b5vgvNhgoMy4YCDMuGAgzLhjkY22bDJhjXZcMmGJYN89Uxmg0VmABMDsbV+TbBsED4/RUFGgh7QGSBsANEFgi/D5EGwh4QWSDsAJEFwg4QXXPyrhCDZcN02dC12bANhmXDfHWMZkMFhmVDAcbW1TfA0GwoNqRoNlRgWDYUYFg2FGACMDkYHrnOH26j2VCB4ZFrAYZHrgUYHrnOwdBsqMDwyLUAwyPXAgzLhgJMACYHg/MVYHC+AgzOV4DB+QowON8cDM2GCgzOV4DB+QowON9vb2G6Nhs2lw1dmw3bYFg2zPddaDZUYFg2FGBYNkzB7DQbKjAsGwowrsuGTTAsG6arY/sQgMnBsGwowLg63yYYFgi/vaKw00DYAyILhN+HSANhD4gsEHaAyAJhB4gsEHaAGED8PkSWDdNlw9212bANhmXDdHVsp9lQgWHZMAdj22zYBMOyYbohtdNsqMCwbCjABGByMK5PkzTB8Mh1+nDbTrOhAsMj1wIMj1znYGg2VGB45FqA4ZFrAYZHrgWYAEwOhmVDAQbnK8DgfAUYnK8Ag/PNwdBsqMDgfAUYnK8Ag/MVYAIw39zC3F2bDVvLhrtrs2EbDMuG+b4LzYYKDMuGORiaDRUYlg0FGJYNBRjXZcMmmGB1LF0do9lQgWHZUIBxdb5NMCwQfn9FgQbCDhBpIOwBkQXCDhBZIOwAkQXCDhADiN+H6JqTd4XIsmG+bOjabNgGw7JhvjpGs6EAY9ts2ARj6+pbYFg2zDekaDZUYAIwORiWDQUY16dJmmB45Dp/uI1mQwWGR65zMDQbKjA8ci3A8Mi1AMMj1wJMACYHw7KhAMOyoQCD8xVgcL4CDM43B0OzoQKD8xVgcL4CDM5XgAnA5GBwvt/ewnRtNmwuG7o2G7bBsGyY77vQbJiDOWg2VGBYNhRgWDYUYFg2FGACMDkYlg3T1bGDZkMFhmVDAcbV+TbBsED47RWFgwbCHhBZIOwAkQXCDhBZIOwAMYD4fYgsEHaA6JqTd4XIsmG6bHi4Nhu2wbBsmK6OHTQbKjAsGwowtq6+BYZlw3RD6qDZUIFh2VCAYdlQgHF9mqQJhkeu04fbDpoNBRiaDRUYHrkWYHjkWoDhkWsBJgCTg+GRawGGZUMBhmVDAQbnK8DgfHMwNBsqMDhfAQbnK8DgfAWYAEwOBucrwOB8v7uFebg2G7aWDQ/XZsM2GJYN830Xmg0VGJYNBRiWDQUYlg0FmABMDsZ12bAJhmXDfHWMZkMFhmVDAcbV+bbA0EDYYUWBBsIeEFkg7ACRBcIOEAOI34fIAmEHiCwQdoDompN3hciyYb5s6Nps2ARDs6FYHaPZUIFh2VCAsXX1LTDBhlS6IUWzoQLDsqEAw7KhAOP6NEkTDI9c5w+30WyowPDItQDDI9cCDI9cCzABmBwMj1wLMDxyLcCwbCjAsGwowOB8czA0GyowOF8BBucrwOB8BZgATA4G5yvA4HwFGJzvt7cwXZsNm8uGrs2GDTDzQLNhuu/yAMOyoQDDsqEAw7KhABOAycGwbCjAuC4bNsGwbJitjj3AsGwowLBsmINxbStsg2GB8LsrCg+ILBB2gMgCYQeIAcTvQ2SBsANEFgg7QGSBsANE15y8K0SWDbNlw3lwbTZsg2HZMFsde4Bh2VCAYdlQgAnA5GBYNsw2pB5gWDYUYFg2FGBYNhRgXJ8maYGh2TB9uO0BhkeuBRgeuRZgeORagAnA5GB45FqA4ZFrAYZHrgUYlg0FGJYNczA0GyowOF8BBucrwOB8BZgATA4G5yvA4HwFGJyvAIPz/eYW5oMhy4b5sqFrs2EbDMuG+b4LzYYKDMuGAkwAJgfDsqEAw7KhAOO6bNgEw7JhvjpGs6EA49ps2Abj6nybYFgg/P6KAg2EPSAGEL8PkQXCDhBZIOwAkQXCDhBZIOwA0TUn7wnRtdmwuWzo2mzYBsOyYb46RrOhAhOAycHYuvoWGJYN8w0pmg0VGJYNBRiWDXMwts2GTTA8cp0/3EazoQLDI9cCTAAmB8Mj1wIMj1wLMDxyLcDwyLUAw7JhDoZmQwUG5yvA4HwFGJyvABOAycHgfAUYnK8Ag/MVYHC+AgzO97tbmKNrs2Fr2XB0bTZsg2HZMN13GWk2VGACMDkYlg0FGJYNBRiWDQUY12XDJhj6R9IHPEfbZsMmmGs733UePi5knefx64f/vPxr+9N12T4eClzXcTv/8Lg+r3rchu3nWa9tOfvOGoVm3b7M+mW34TnrtY1h31mv7fUe38rxOes2n394evxS8nF4Hn984hTMsH2srDz+5jb+wse0bB/XPH25jB//ez/fO2L4+JeXmOLrh/9Efm0XWRL5tf1pSeTXdr4VkV+8068k8ou79YrIL37CqIj84gedisgD5K9GfvFjX0XknD5fjpzT58uRc/p8OXJOn69GfvFezZLIOX2+HDmnz5cj5/T5cuQB8lcj5/T5cuScPl+OnNPny5Fz+nw5ck6fr0Z+8W7bksg5fb4cOafPlyPn9Ply5AHyVyPn9Ply5Jw+X46c0+fLkXP6fDlyTp+vRn7x0uiSyDl9vhw5p8+XI+f0+XLkAfJXI+f0+XLknD5fjpzT58uRc/p8OXJOn69GfvHi9qsgX4ePN6/EOg0/U+RA2YMiZ8QeFDn29aAYUPwnFJfnNf/tRb8fFDmc9aDIeasHRY5QPShyKupBkYNOB4oXr4a/C0XOLh384sVL5+9CkbNLD4oBxQ4UObv0oMjZpQdFzi49nA5nlx4UObt0oLhzdulBkbNLD4qcXXpQ5OzSg2JAsQNFzi49KHJ26UGRs0uHE+DO2aUHRc4uHSgenF16UOTs0oMiZ5ceFDm7dHA6R0CxA0XOLj0ocnbpQZGzSw+KnF16UOTs8n2K08DZpQdFzi49KHJ26UGRs8v3T4DTEFDsQJGzSw+KnF16UOTs0oMiZ5ceFDm7dHA6I2eXHhQ5u/SgyNmlB0XOLj0oBhQ7UOTs0oMiZ5ceFDm79KDI2aUHRc4uHU6AE2eXHhQ5u/SgyNmlB0XOLj0oBhQ7UOTs0sHpTJxdelDk7NKDImeXHhQ5u3SgOHN26UGRs0sPipxdelDk7NKDYkCxA0XOLh1OgDNnlx4UObv0oMjZpQdFzi4dKAZnlx4UObt0cDrB2aUHRc4uPSgGFDtQ5OzSgyJnlx4UObv0oMjZpQdFzi4dKC6cXXpQ5OzS4QS4cHbpQZGzSw+KAcUOFDm79KDI2aUHRc4uPZwOZ5ceFDm7dKC4cnbpQZGzSw+KnF16UOTs0oNiQLEDRc4uPShydulBkbNLhxPgytmlB0XOLh0obpxdelDk7NKDImeXHhQ5u3RwOltAsQNFzi49KHJ26UGRs0sPipxdelDk7NKB4s7ZpQdFzi49KHJ26UGRs0uHE+AeUOxAkbNLD4qcXXpQ5OzSgyJnlx4UObt0cDoHZ5ceFDm79KDI2aUHRc4uPSgGFDtQ5OzSgyJnlx4UObv0oMjZpQdFzi7fPwHOA2eXHhQ5u/SgyNmlB0XOLj0oBhQ7UOTs8n2nMw+cXXpQ5OzSgyJnlx4UObt0oDhydulBkbNLD4qcXXpQ5OzSg2JAsQNFzi4dToAjZ5ceFDm79KDI2aUHRc4uHShOnF16UOTs0sHpTJxdelDk7NKDYkCxA0XOLj0ocnbpQZGzSw+KnF16UOTs0oHizNmlB0XOLh1OgDNnlx4UObv0oBhQ7ECRs0sPipxdelDk7NLD6XB26UGRs0sHisHZpQdFzi49KHJ26UGRs0sPigHFDhQ5u/SgyNmlB0XOLh1OgMHZpQdFzi4dKC6cXXpQ5OzSgyJnlx4UObt0cDpLQLEDRc4uPShydulBkbNLD4qcXXpQ5OzSgeLK2aUHRc4uPShydulBkbNLhxPgGlDsQJGzSw+KnF16UOTs0oMiZ5ceFDm7dHA6G2eXHhQ5u/SgyNmlB0XOLj0oBhQ7UOTs0oMiZ5ceFDm79KDI2aUHRc4uHU6AO2eXHhQ5u/SgyNmlB0XOLj0oBhQ7UOTs0sHp7JxdelDk7NKDImeXHhQ5u3SgeHB26UGRs0sPipxdelDk7NKDYkCxA0XOLh1OgAdnlx4UObv0oMjZpQdFzi7fpxgDZ5ceFDm7fN/pxMDZpQdFzi49KAYUO1Dk7NKDImeXHhQ5u/SgyNmlB0XOLh0ojpxdelDk7NLhBDhydulBkbNLD4oBxQ4UObv0oMjZpQdFzi49nA5nlx4UObt0oDhxdulBkbNLD4qcXXpQ5OzSg2JAsQNFzi49KHJ26UGRs0uHE+DE2aUHRc4uHSjOnF16UOTs0oMiZ5ceFDm7dHA6c0CxA0XOLj0ocnbpQZGzSw+KnF16UOTs0oFicHbpQZGzSw+KnF16UOTs0uEEGAHFDhQ5u/SgyNmlB0XOLj0ocnbpQZGzSwens3B26UGRs0sPipxdelDk7NKDYkCxA0XOLj0ocnbpQZGzSw+KnF16UOTs0uEEuHJ26UGRs0sPipxdelDk7NKDYkCxA0XOLh2czsrZpQdFzi49KHJ26UGRs0sHihtnlx4UObv0oMjZpQdFzi49KAYUO1Dk7NLhBLhxdulBkbNLD4qcXXpQ5OzSgeLO2aUHRc4uHZzOztmlB0XOLj0oBhQ7UOTs0oMiZ5ceFDm79KDI2aUHRc4uHSgenF16UOTs0uEEeHB26UGRs0sPigHFDhQ5u/SgyNmlB0XOLj2cDmeXHhQ5u3yf4jJwdulBkbNLD4qcXXpQ5OzSg2JAsQNFzi49KHJ26UGRs8v3T4DLwNmlB0XOLh0ojpxdelDk7NKDImeXHhQ5u3RwOmNAsQNFzi49KHJ26UGRs0sPipxdelDk7NKB4sTZpQdFzi49KHJ26UGRs0uHE+AUUOxAkbNLD4qcXXpQ5OzSgyJnlx4UObt0cDozZ5ceFDm79KDI2aUHRc4uPSgGFDtQ5OzSgyJnlx4UObv0oMjZpQdFzi4dToDB2aUHRc4uPShydulBkbNLD4oBxQ4UObt0cDrB2aUHRc4uPShydulBkbNLB4oLZ5ceFDm79KDI2aUHRc4uPSgGFDtQ5OzS4QS4cHbpQZGzSw+KnF16UOTs0oHiytmlB0XOLh2czsrZpQdFzi49KAYUO1Dk7NKDImeXHhQ5u/SgyNmlB0XOLh0obpxdelDk7NLhBLhxdulBkbNLD4oBxQ4UObv0oMjZpQdFzi49nA5nlx4UObt0oLhzdulBkbNLD4qcXXpQ5OzSg2JAsQNFzi49KHJ26UGRs0uHE+DO2aUHRc4uHSgenF16UOTs0oMiZ5ceFDm7dHA6R0CxA0XOLj0ocnbpQZGzSw+KnF16UOTs8n2K68DZpQdFzi49KHJ26UGRs8v3T4CP/79Q7ECRs0sPipxdelDk7NKDImeXHhQ5u3RwOiNnlx4UObv0oMjZpQdFzi49KAYUO1Dk7NKDImeXHhQ5u/SgyNmlB0XOLh1OgBNnlx4UObv0oMjZpQdFzi49KAYUv3+Pnji79PgucnbpQZGzSw+KnF16UOTs0oHizNmlwz165uzS47vI2aUHRc4uPSgGFDtQ5OzSgyJnlx4UObv0cDqcXXpQ5OzSgWJwdulBkbNLD4qcXXpQ5OzSg2JAsQNFzi7/hOK2f1zG43+cf6ZY6ewyDU+K07o1wEzr8yo+gY/Tnl3FMnwMuC7z+BXizx+ep+d88zR/IZ79y9O+fcz3+B+3rx/+U55Kh6KC8lQ6bRWUp9Ixrp48S6Xz4Q3lOY6PQG4exuVneSodPAvKU+lEW1CeSkfl+8kzD/OnPHE0tPy8jGn5+tNE9uFx35/Hr2OYfxY+EL6m8MczkBiPbT//8COy+IBx/HzqXiplF3xHfs93hGSG70jrO0I8VPM7Mg3D8+g8TPGt7wgZFd+R1neEoKzod2QcP39Ymo+fDisrEZyp8IR7psITGxYVfop4wtgblzHO+4cfGGP4Ob1cSS/5lrS/JcG3hG/JuMwf5MZlWb9zDlnJRflCdf1CEaLyher6hSJx5Qv1+BZtzwh/Ob4V4a/Es3yhun6hyHJv9IX6/I40b0ytB082styiwvf7wXgj9uU70vqOkBDX/I50/MF4Ix/mO9L6jgTfkZrfkcZPjBsprqnwpK2mwpOKFhW+58/FG1En35L2t4T8km9Jz5/sdnJRvlBdv1CEqHyhun6hSFz5QvX8DXgnnuUL1fULFXyhbvOFWqfpY751Wb53GtvJck2FJ8stKnxH30rsy3ek9R0h9OU70vqOEPlW/Y50O4EcpLh8R1rfEYLZt35HxnH4+PA4La3Yo+M7Fw8C1KLC93us+SAT5TvS+o4E3xG+I43vCIloze9Ix0ffD8JTviOt7wjhadHvSONh6YNE1FR4Yk5L4beB7LKo8B0ffN8G0ku+Je1vCVEn35KOP75uA7koX6iuX6jgC8UXqucXisSVL1TH5wS2gXiWL1TXLxRZ7o2+UP3eubgNZLlFhe/2g/E2EPvyHWl8R0YS4prfkX4/GG8j+TDfkdZ3hHS46Hek8RPjSIprKnwgvKfwpKJFhe/5c/FI1Mm3pP0tIb/kW9LzJ7uRXJQvVNcvFCEqX6ieX6iJxJUvVM/fgCfiWb5QXb9QZLn3+UJ1fPXeNpHlmgofCF9T+I6+ldiX70jrO0Loy3ek9R0h8q36Hel3AiHF5TvS+o54BLN/zDpfPDPc14+gYj2+XEj64XEYn0+2D/PnV2Abkg8vz2tevnwPY53Sr/i8Pr/i2+eA0/gXxIvnZNeAOD8zp/nrJT8hXjwbusc38eI5yz2+iQHE738TL36ov8c38eKn3nt8Ey9+LLzHN/Hi56Z7fBMvfrC4xTcxOLF8/5sYnFg6fBM5sfwDiNsza5n38UvYsv0FsdKJZZo/0q1xiukrxD9nDaNZK/n/1qyVbHrE8w/BMqznfwim8XmbeaTAn2DmH08C/Axkea7/7MsytD49xfPT0zE2Pj0vz3j7yxtVpoz0tD2j8OnhJs4/PG778+epfZgaHx6mzz+i2/L1w39+TyqdROb9eH5Pxu38ezIe2xP5EDvfk8b3hMPWPzAW+1P3eV+2n40Fh63vQ1yufdjaxuGDyzbGeP7h4/ETw18fPrYvfW97+h//9EDzvLXFF+O6//Uf6XLtI9Rb0Vz7YPRWNNc+7rwVTYBGobn2YeqtaK599normmsfN96K5toO+61oru2b34lmxQ1LNLhhiQY3LNHghiWaAI1CgxuWaHDDEg1uWKLBDUs0uGGFZsMNSzS4YYkGNyzR4IYlmgCNQoMblmhwwxINbliiwQ1LNLhhhWbHDUs0uGGJBjcs0eCGJZoAjUKDG5ZocMMSDW5YosENSzS4YYXmwA1LNLhhiQY3LNHghiWaAI1CgxuWaHDDEg1uWKLBDUs0uGGBZh9wwxINbliiwQ1LNLhhiSZAo9DghiUa3LBEgxuWaHDDEg1uWKEZccMSDW5YosENSzS4YYkmQKPQ4IYlGtywRIMblmhwwxINblihuXhp91vR4IYlGtywRIMblmgCNAoNbliiwQ1LNLhhiQY3LNHghhWai9dRvhUNbliiwQ1LNLhhiSZAo9DghiUa3LBEgxuWaHDDEg1uWKG5eNXhW9HghiUa3LBEgxuWaAI0Cg1uWKLBDUs0uGGJBjcs0eCGFRq66DQa3LBEgxuWaHDDEk2ARqHBDUs0uGGJBjcs0eCGJRo6nL/d4bznrXUPFMPH5WzD0IA4zsPHpOM8f4H4o8z952/BsYwf34Jj3b/7Lci75e40wHT3AdpOcfr7f4d//q/F/7X/teX/2v9afvd9/Bn6+F/bx9Yfi3H8+L8xTmPjs/MyfvzL83JMXxQ5sn95jc9/e43p80/LPCzZ55ft418fl+NT7+lj2s1q2r3UtOP2cZccx2P5edrDaVrRI1V12tFq2qnUtPPzX3/cg/ev0ya34PF5B56Hn8HMgMnBBGByMAtgcjC1fF9HMLUsYkcwtdxkRzC1jGc/MHstj9oRTC072xEMzleAwfkKMAGYHAzOV4DB+QowOF8BBucrwOB8czAHzleAwfkKMDhfAcbY+T5nPLaff907jJ3vORicr/hPCecrwOB8BRicrwCD803BHAPOV4DB+QowOF8BhsxXgAnA5GBwvgIMzleAwfkKMDhfAQbnm4MZcb4CDM5XgMH5CjA4XwEmAJODwfkKMDhfAQbnK8DgfAUYnG8OZvJ1vuMwfe6nb8vPaHy9bxONr/ttovH1v000UQpNDNvHx2PYf562lq1tTVvLq7amrWVAW9PWcpWtaWtZxWV+vnNl+fKunI9p51r+rzVtLUvXmraWS2tNW8t4taYNq2lreanWtMXe69SYtth7nRrT1vJSrWmtvFRYeako5qVO38d2RDEv1Zi2mJdqTBtW0xbzUo1pnd6ReYTTOzKPKOalGtMW81Ln0y7FvFRjWisvtdTyUudvBD2WWl6qNW1YTVvLS7Wm5Xm0/CGahefRBBieRxNgeB4tB7OyiSHAsIkhwBhvYpy9S+VYefuOABOAycEYb2KcgzF2vudgjJ3vORhj53sOxtj5noIp1grUz+AVKxDqCIYdZAGGHWQBJgCTg2EHWYAh8xVgyHwFGDJfAYbMNwdD15ACg/MVYMh880Okc9fQOZgATA6GzFeAIfMVYMh8BRgyXwGGzDcHQ9eQMHh0DSkwZL4CDJmvABOAycGQ+QowZL4CDJmvAEPmK8CQ+WZgYqBrSIHB+QowZL7ZIfIBhsxXgAnA5GDIfAUYnK/444vzFWBwvgIMzjcHQ9eQAoPzFWDIfAUYMl8BJngJ/b+yl9A/0Ph63yYaX/fbROPrf5tofB1wE82LPfA4Hs9X20/D5ys751/6d/+49Ff3AvW89Fo+8rSu4DFtLXPYmraW42tNG1bTGhXmPKY1esn7Y1qjl7w/pjV6yftjWqOXvMfgVJjzmNaoMOcxrVFhzmNao8Kcx7RhNa1RYc5jWisv5VSY85jWyks5FebEUK0w5+y1549pjV7y/pjWqDDnMa1RYc5j2rCa1qgw5zGtUWHOY1qjwpzHtEaFOY9pjQpzYnAqzHlMW8tLnRZvPKY1Ksx5TGtUmPOYNqymZec2f2KPbh0Fhs0DAYbNAwGGzYMcDN06Cozx5sHpPhzdOgoMO7cCTAAmB8POrQDDexYFGN6zKMDwnkUBBuebGzy6dRQYdm4FGHZuBRh2bgWYAEwOhsxXgCHzFWDIfAUYMl8BBuebg6FbR4Eh880PkXTrKDBkvgJMACYHQ+YrwJD5CjBkvgIMma8Ag/PNDR7dOgoMma8AQ+YrwJD5CjABmBwMma8AQ+YrwJD5CjBkvgIMzjcFM9Kto8CQ+aaHyJFuHQWGzFeACcDkYMh8BRgyXwGGzFeAIfMVYHC+ucGjW0eBIfMVYMh8BRgyXwEmAJODIfMVYMh8BRhadX58OKmOGWnV0Wh83W8LzeTrf5tofB1wE82LPXC/rqfx1X1APS89jOpuRqtyn7FYuU9r2lo2rjVtLWfWmtbphfSjVbnPaFXuM1qV+4xW5T6jVbnPaFXuM1qV+4xW5T6jVbnPaFXuM1Yr92lMa+WlqpX7NKZ1KvcZrcp9Rqtyn9Gq3Ge0KvcZrcp9Rqtyn9Gq3GcsVu7TmtapKHEsVu7TmjaMyn3GYuU+rWlreanWtLW8VGtadm7zJ/bo1hFg6NZRYNg8EGDYPBBg2DwQYIJ9uHQfjm4dBYadWwGGnVsBhp1bAcbY+Z6Cce7WOQfD22YEGJxvbvDo1lFgAjA5GHZuBRh2bgUY3rMowJD5CjBkvjkYunUUGDJfAQbnK8DgfAWY4BCZHiLp1lFgyHwFGDJfAYbMV4Ah883BOHfrnIMh8xVgcL65waNbR4EJwORgyHwFGDJfAYbMV4Ah8xVgyHxTMBPdOgoMma8Ag/MVYHC+AkxwiMwOkRPdOgoMma8AQ+YrwJD5CjBkvjkY526dczBkvgIMzjc3eHTrKDABmBwMma8AQ+YrwJD5CjBkvgIMmW8OhladPz6cVMdMtOpoNL7ut4nG1/820QRoFJoXe+B+XU/Tq/uAel66U7nPZFXuMxUr92lMW6zcpzVtLWfWmtbphfSTVbnPZFXuM1mV+0xW5T6TVbnPZFXuM1mV+0xW5T6TVbnPZFXuM1Ur92lMG1bTWnkpq3KfyarcZ7Iq95msyn0mq3KfyarcZ7Iq95msyn2mYuU+rWmdihKnYuU+rWmdyn2mYuU+rWlreanGtMVqeFrTsnObP7FHt44Cw+aBABOAycGweSDAsHkgwLBzm+/D0a2jwLBzm4OhW0eBYedWgDF2vudgjJ3vOZgATA4G55sbPLp1FBh2bgUYdm4FGHZuczB06ygwZL4CDJmvAEPmK8AEYHIwOF8BBucrwJD55odIunUUGDLfHAzdOgoMma8AQ+YrwJD5CjABmBwMzjc3eHTrKDBkvgIMma8AQ+abgpnp1lFgyHwFGDJfAYbMV4AJwORgcL4CDM5XgCHzTQ+RM906CgyZbw6Gbh0FhsxXgCHzFWDIfAWYAEwOBuebGzy6dRQYMl8BhsxXgCHzzcEYd+s0wJD5CjBkvgIMrTo/PpxUx8y06mg0vu63icbX/zbR+DrgJpoXe+B+XU/zq/uAOl66VbnPbFXuMxcr92lNW8vGtaYNq2mdXkg/W5X7zFblPrNVuc9sVe4zW5X7zFblPrNVuc9sVe4zW5X7zFblPnO1cp/GtFZeqlq5T2Nap3Kf2arcZ7Yq95mtyn1mq3Kf2arcZ7Yq95mtyn3mYuU+rWmdihLnYuU+jWmtyn3mYuU+rWlreanWtLW8VGva4Im99Ik9unUUGDYPBBg2DwQYNg8EGDYPcjB06/w734ejW0eBYedWgGHnVoAJwORgjJ3vORhj53sOhrfNCDA4X2HwcL45GLp1FBh2bgUYdm4FGN6zKMAEYHIwZL4CDJmvAEPmK8DgfAUYnG8Ohm4dcYikW0eBIfMVYMh8BZgATA6GzFeAIfMVYMh8BRicrzB4ON8UTNCto8CQ+QowZL4CDJmvABOAycGQ+QowZL4CDJmvAIPzFWBwvjkYunXyQ2TQraPAkPkKMGS+AkwAJgdD5ivAkPkKMGS+AgzOVxg8nG8Ohm4dBYbMV4Ah8xVgyHwFmABMDobMV4ChVefHh5PqmKBVR6Pxdb9NNL7+t4WmWCtQVzQv9sD9up7i1X1APS/dqdwnrMp9oli5T2vaWjauNW0tZ9aa1umF9GFV7hNW5T5hVe4TVuU+YVXuE1blPmFV7hNW5T5hVe4TVuU+Ua3c53zaauU+jWmtvJRVuU9YlfuEVblPWJX7hFW5T1iV+4RVuU9YlftEsXKf1rRORYlRrNynNa1TuU8UK/dpTVvLS7WmreWlWtOyc5s/sUe3jgLD5kEOxrlb5xwMmwcCDJsHAgw7t/k+HN06Cgw7twIMO7cCDDu3Aoyx8z0HY+x8T8E4d+ucg8H55gaPbh0Fhp1bASYAk4Nh51aA4T2LAgyZrwBD5ivAkPnmYJy7dc7B4HwFGJyvAEPmmx8i6dZRYMh8BRgyXwGGzFeAIfMVYMh8UzCLc7fOORicb2rwFrp1FBgyXwEmAJODIfMVYMh8BRgyXwGGzFeAIfPNwTh365yDwfkKMDhfAYbMNz9E0q2jwJD5CjBkvgIMma8AQ+YrwJD55mCcu3XOweB8c4NHt44CQ+YrwARgcjBkvgIMma8AQ+YrwJD5CjC06vz4cFIds9Cqo9H4ut8mGl//20Tj64CbaOKuXU/Lq/uAel66U7nPYlXusxQr92lNW8vGNaYtVu7TmtbphfSLVbnPYlXus1iV+yxW5T6LVbnPYlXus1iV+yxW5T6LVbnPYlXus1Qr92lMa+WlqpX7NKZ1KvdZrMp9Fqtyn8Wq3GexKvdZrMp9Fqtyn8Wq3GcpVu7TmjasprXyUlblPkuxcp/WtLW8VGvaWl6qMS3dOv/On9ijW0eBYfNAgGHzQIAJwORg2DwQYNi5zffh6NZRYNi5FWDYuc3B0K2jwBg733Mwxs73HAxvmxFgAoOXGjy6dRQYdm4FGHZuBRh2bgUY3rOYg6FbR4Eh8xVgyHwFGDJfASYAk4PB+QowZL75IZJuHQWGzFeAIfNNwax06ygwZL4CDJmvAEPmK8AEBi8zeCvdOgoMma8AQ+YrwJD5CjBkvjkYunUUGDJfAYbMV4Ah8xVgAjA5GJyvAEPmmx8i6dZRYMh8BRgy3xwM3ToKDJmvAEPmK8CQ+QowgcFLDR7dOgoMma8AQ+YrwJD5CjBkvjkY42adBhgyXwGGVp0fH06qY1ZadTSaAI1C4+t/m2h8HXATzYs9cL+up/XVfUA9L92p3Ge1KvdZi5X7tKatZeNa09ZyZq1pw+iF9KtVuc9qVe6zWpX7rFblPqtVuc9qVe6zWpX7rFblPqtVuc9qVe6zViv3aUxr5aWqlfs0pnUq91mtyn1Wq3Kf1arcZ7Uq91mtyn1Wq3Kf1arcZy1W7tOa1qkocS1W7tOa1qncZy1W7tOatpaXak1by0u1pmXnNn9ij24dBYbNAwGGzQMBhs0DAYbNAwGGndt8H45uHQWGnVsBhp1bAYadWwEmAJODMXa+52B424wAg/PNDR7dOgoMO7c5GLp1FBh2bgUY3rMowJD5CjABmBwMma8AQ+YrwOB8BRicrwBD5pseIje6dRQYMl8BhsxXgCHzFWACMDkYMl8BhsxXgMH5pgZvo1tHgSHzzcHQraPAkPkKMGS+AgyZrwATgMnBkPkKMGS+AgzOV4DB+QowZL75IZJuHQWGzFeAIfMVYMh8BZgATA6GzFeAIfMVYHC+ucGjW0eBIfPNwdCto8CQ+QowZL4CDJmvABOAycHQqvPjw0l1zEarjkbj636baHz9bxONrwNuoXl1hVC/rqft1X1APS/dqdxnsyr32YqV+7SmrWXjWtPWcmataZ1eSL9ZlftsVuU+m1W5z2ZV7rNZlftsVuU+m1W5z2ZV7rNZlftsVuU+W7Vyn8a0Vl6qWrlPY1qncp/Nqtxnsyr32azKfTarcp/Nqtxnsyr32azKfbZi5T6NaYuV+7SmtfJSVuU+W7Fyn9a0YTVtLS/Vmpad2/yJPbp1FBg2DwQYNg9yMM7dOudg2DwQYNi5zffh6NZRYAIwORh2bgUYdm4FGGPnew7G2Pmeg+FtMzkYunWEwaNbR4Fh51aAYedWgAnA5GB4z6IAQ+YrwJD5CjBkvgIMmW8KZnfu1jkHg/MVYMh800PkTreOAhOAycGQ+QowZL4CDJmvAEPmK8CQ+eZg6NYRBo9uHQWGzFeAIfMVYAIwORgyXwGGzFeAIfMVYMh8BRgy3xyMc7fOORicrwBD5psfIunWUWACMDkYMl8BhsxXgCHzFWDIfAUYMt8cDN06wuDRraPAkPkKMGS+AkwAJgdD5ivAkPkKMGS+AgytOj8+nFTH7LTqSDTh636baHz9bxONrwNuonmxB+7X9bS/ug+o56U7lfvsVuU+e7Fyn9a0tWxca9pazqwxrVW5z25V7rNblfvsVuU+u1W5z25V7rNblfvsVuU+u1W5z25V7rNblfvs1cp9GtNaealq5T6NacOoWmG3KvfZrcp9dqtyn92q3Ge3KvfZrcp9dqtyn71YuU9rWqeixL1YuU9rWqdyn71YuU9r2lpeqjVtLS/Vmpad2/yJPbp1FBg2DwQYNg8EGDYPBJgATA6Gndt8H45uHQWGnVsBhp1bAYad2xyMc7fOORhj53sOhrfNCDA439zg0a2jwLBzK8CwcyvAsHMrwPCeRQGGzDcFc9Cto8CQ+QowZL4CDM5XgAnA5GDIfNND5EG3jgJD5ivAkPkKMGS+ORjnbp1zMGS+AgyZrwCD880NHt06CgyZrwBD5ivAkPkKMGS+AgyZbw6Gbh0FhsxXgCHzFWBwvgJMACYHQ+abHyLp1lFgyHwFGDJfAYbMNwfj3K1zDobMV4Ah8xVgcL65waNbR4Eh8xVgyHwFGDJfAYbMV4Ah883BGPfqNMDQqvPjw0l1zEGrjkbj636baAI0Co2vA26iebEH7tf1dLy6D6jnpTuV+xxW5T5HsXKf1rS1bFxr2lrOrDWt0wvpD6tyn8Oq3OewKvc5rMp9Dqtyn8Oq3OewKvc5rMp9Dqtyn8Oq3OeoVu7TmNbKS1Ur92lM61Tuc1iV+xxW5T6HVbnPYVXuc1iV+xxW5T6HVbnPUazcpzWtU1HiUazcpzWtU7nPUazcpzFtscae1rS1vFRrWnZu8yf26NZRYAIwORg2DwQYNg8EGDYPBBh2bvN9OLp1BBi6dRQYdm4FGHZuBRhj53sOJgCTg+FtMwIMzjc3eHTrKDDs3Aow7NxmYJaBbh0FhvcsCjBkvgIMma8AE4DJwZD5CjA4XwEG5yvAkPlmh8gHGDLfHAzdOgoMma8AQ+YrwJD5CjABmBwMma8Ag/PNDR7dOgoMma8AQ+abg6FbR4Eh8xVgyHwFGDJfASYAk4Mh8xVgcL4CDM5XgCHzzQ+RdOsIMHTrKDBkvgIMma8AQ+YrwARgcjBkvgIMzjc3eHTrKDBkvgIMmW8Ohm4dBYbMV4Ah8xVgyHwFmKA65l9ZdcwDDa06Eo2v+22i8fW/TTS+DriJ5sUeuFvX0zK8ug+o56Ublfs8pjUq93lMW8vxtaYNq2lrObPWtEYvpH9Ma1Tu85jWqNznMa1Ruc8yOJX7PKY1Kvd5TGtU7vOY1qjc5zFtWE1rVO7zmNbKS1Ur92lMa+WlqpX7nE/rVO7zmNao3OcxrVG5z2Nao3Kfx7RhNa1Ruc9jWqNyn8e0RuU+j2mNihIf0xoVJS5DsXKf1rRG5T6PaWt5qda0tbxUa9qwmpad2/yJPbp1FBg2DwQYNg8EGDYPcjDO3TrnYNi5zffh6NZRYNi5FWACMDkYdm4FGGPnew7G2Pmeg+FtMwIMzjc1eCPdOgoMO7cCDDu3Agw7twJMACYHQ+YrwJD5CjBkvgIMma8Ag/PNwTh365yDIfNND5Ej3ToKDJmvABOAycGQ+QowZL4CDJmvAEPmK8DgfHODR7eOAkPmK8CQ+QowZL4CTAAmB0PmK8CQ+QowZL4CDJmvAIPzzcE4d+ucgyHzzQ+RdOsoMGS+AkwAJgdD5ivAkPkKMGS+AgyZrwCD880NHt06CgyZrwBD5ivAkPkKMAGYHAyZrwBD5ivA0Krz48NJdcxIq45G4+t+W2gWX//bROPrgJtoXuyB+3U9ja/uA+p56WFUdzNalfuMxcp9WtPWsnGtaWs5s9a0Ti+kH63KfUarcp/RqtxntCr3Ga3KfUarcp/RqtxntCr3Ga3KfUarcp+xWrlPY1orL1Wt3KcxrVO5z2hV7jNalfuMVuU+o1W5z2hV7jNalfuMVuU+Y7Fyn9a0TkWJY7Fyn9a0YVTuMxYr92lNW8tLtaat5aVa07Jzmz+xR7eOAEO3jgLD5oEAw+aBAMPmgQAT7MOl+3B06ygw7NwKMOzcCjDs3Aowxs73DMzk3K1zDoa3zQgwON/U4E106ygwAZgcDDu3Agw7twIM71kUYMh8BRgy3xwM3ToKDJmvAIPzFWBwvgJMcIhMD5F06ygwZL4CDJmvAEPmK8CQ+eZgnLt1zsGQ+QowON/c4NGto8AEYHIwZL4CDJmvAEPmK8CQ+QowZL45GLp1FBgyXwEG5yvA4HwFmOAQmR4i6dZRYMh8BRgyXwGGzFeAIfPNwTh365yDIfMVYHC+ucGjW0eBCcDkYMh8BRgyXwGGzFeAIfMVYMh8czC06vzx4aQ6ZqJVR6Pxdb9NNL7+t4kmQKPQvNgD9+t6ml7dB9Tz0p3KfSarcp+pWLlPY9pi5T6taWs5s9a0Ti+kn6zKfSarcp/Jqtxnsir3mazKfSarcp/Jqtxnsir3mazKfSarcp+pWrlPY9qwmtbKS1mV+0xW5T6TVbnPZFXuM1mV+0xW5T6TVbnPZFXuMxUr92lN61SUOBUr92lN61TuMxUr92lNW8tLNaYtVsPTmpad2/yJPbp1FBg2DwSYAEwOhs0DAYbNAwGGndt8H45uHQWGndsUzEy3jgLDzq0AY+x8z8EYO99zMAGYHAzONzV4M906Cgw7twIMO7cCDDu3ORi6dRQYMl8BhsxXgCHzFWACMDkYnK8Ag/MVYMh880Mk3ToKDJlvDoZuHQWGzFeAIfMVYMh8BZgATA4G55sbPLp1FBgyXwGGzFeAIfPNwdCto8CQ+QowZL4CDJmvABOAycHgfAUYnK8AQ+abHyLp1lFgyHxzMHTrKDBkvgIMma8AQ+YrwARgcjA439zg0a2jwJD5CjBkvgIMmW8OxrhbpwGGzFeAIfMVYGjV+fHhpDpmplVHo/F1v000vv63icbXATfRvNgD9+t6ml/dB9Tx0q3KfWarcp+5WLlPa9paNq41bVhN6/RC+tmq3Ge2KveZrcp9Zqtyn9mq3Ge2KveZrcp9Zqtyn9mq3Ge2KveZq5X7NKa18lLVyn0a0zqV+8xW5T6zVbnPbFXuM1uV+8xW5T6zVbnPbFXuMxcr92lN61SUOBcr92lMa1XuMxcr92lNW8tLtaat5aVa0wZP7KVP7NGto8CweSDAsHkgwLB5IMCweZCCCbp1/p3uwwXdOgoMO7cCDDu3AkwAJgdj7HzPwRg733MwvG1GgMH5CoOH883B0K2jwLBzK8CwcyvA8J5FASYAk4Mh8xVgyHwFGDJfAQbnK8DgfHMwdOuIQyTdOgoMma8AQ+YrwARgcjBkvgIMma8AQ+YrwOB8hcHD+eZg6NZRYMh8BRgyXwGGzFeACcDkYMh8BRgyXwGGzFeAwfkKMDjfHAzdOuIQSbeOAkPmK8CQ+QowAZgcDJmvAEPmK8CQ+QowOF9h8HC+ORi6dRQYMl8BhsxXgCHzFWACMDkYMl8BhladHx9OqmOCVh2Nxtf9NtH4+t8WmmKtQF3RvNgD9+t6ilf3AfW8dKdyn7Aq94li5T6taWvZuNa0tZxZa1qnF9KHVblPWJX7hFW5T1iV+4RVuU9YlfuEVblPWJX7hFW5T1iV+0S1cp/zaauV+zSmtfJSVuU+YVXuE1blPmFV7hNW5T5hVe4TVuU+YVXuE8XKfVrTOhUlRrFyn9a0TuU+UazcpzVtLS/VmraWl2pNy85t/sQe3ToKDJsHKZjFuVvnHAybBwIMmwcCDDu36T7cMgRgcjDs3Aow7NwKMOzcCjDGzvccjLHzPQXj3K1zDgbnmxs8unUUGHZuBZgATA6GnVsBhvcsCjBkvgIMma8AQ+abg3Hu1jkHg/MVYHC+AgyZb36IpFtHgSHzFWDIfAUYMl8BhsxXgCHzzcE4d+ucg8H55gaPbh0FhsxXgAnA5GDIfAUYMl8BhsxXgCHzFWDIfHMwzt0652BwvgIMzleAIfPND5F06ygwZL4CDJmvAEPmK8CQ+QowZL45GOdunXMwON/c4NGto8CQ+QowAZgcDJmvAEPmK8CQ+QowZL4CDK06Pz6cVMcstOpoNL7ut4nG1/820fg64CaauGvX0/LqPqCel+5U7rNYlfssxcp9WtPWsnGNaYuV+7SmdXoh/WJV7rNYlfssVuU+i1W5z2JV7rNYlfssVuU+i1W5z2JV7rNYlfss1cp9GtNaealq5T6NaZ3KfRarcp/FqtxnsSr3WazKfRarcp/FqtxnsSr3WYqV+7SmDatprbyUVbnPUqzcpzVtLS/VmraWlzqfdqVb59/pE3sr3ToKDJsHAgybBwJMACYHw+aBAMPObboPt9Kto8CwcyvAsHObg6FbR4Exdr7nYIyd7zkY3jYjwAQGLzV4dOsoMOzcCjDs3Aow7NwKMLxnMQdDt44CQ+YrwJD5CjBkvgJMACYHg/MVYMh880Mk3ToKDJmvAEPmm4OhW0eBIfMVYMh8BRgyXwEmMHipwaNbR4Eh8xVgyHwFGDJfAYbMNwdDt44CQ+YrwJD5CjBkvgJMACYHg/MVYMh880Mk3ToKDJmvAEPmm4OhW0eBIfMVYMh8BRgyXwEmMHipwaNbR4Eh8xVgyHwFGDJfAYbMNwdj3KzTAEPmK8DQqvPjw0l1zEqrjkYToFFofP1vE42vA26iebEH7tf1tL66D6jnpTuV+6xW5T5rsXKf1rS1bFxr2lrOrDVtGL2QfrUq91mtyn1Wq3Kf1arcZ7Uq91mtyn1Wq3Kf1arcZ7Uq91mtyn3WauU+jWmtvFS1cp/GtE7lPqtVuc9qVe6zWpX7rFblPqtVuc9qVe6zWpX7rMXKfVrTOhUlrsXKfVrTOpX7bMXKfVrT1vJSrWlreanWtOzcpk/sbUMAJgfD5oEAw+aBAMPmgQDD5oEAw85tug+30a2jwLBzK8CwcyvAsHMrwARgcjDGzvccDG+bEWBwvrnBo1tHgWHnNgdDt44Cw86tAMN7FgUYMl8BJgCTgyHzFWDIfAUYnK8Ag/MVYMh880Mk3ToKDJmvAEPmK8CQ+QowAZgcDJmvAEPmK8DgfHODR7eOAkPmm4OhW0eBIfMVYMh8BRgyXwEmAJODIfMVYMh8BRicrwCD8xVgyHzzQyTdOgoMma8AQ+YrwJD5CjABmBwMma8AQ+YrwOB8c4NHt44CQ+abg6FbR4Eh8xVgyHwFGDJfASYAk4OhVefHh5PqmI1WHY3G1/020fj63yYaXwfcQvPqCqF+XU/bq/uAel66U7nPZlXusxUr92lNW8vGtaat5cxa0zq9kH6zKvfZrMp9Nqtyn82q3GezKvfZrMp9Nqtyn82q3GezKvfZrMp9tmrlPo1prbxUtXKfxrRO5T6bVbnPZlXus1mV+2xW5T6bVbnPZlXus1mV+2zFyn3Op92Llfu0pnXyUrtVuc9erNynNW1YTVvLS7WmZec2fWJvp1tHgWHzQIBh8yAH49ytcw6GzQMBhp3bdB9up1tHgQnA5GDYuRVg2LkVYIyd7zkYY+d7Doa3zeRg6NYRBo9uHQWGnVsBhp1bASYAk4PhPYsCDJmvAEPmK8CQ+QowZL45GOdunXMwOF8Bhsw3P0TSraPABGByMGS+AgyZrwBD5ivAkPkKMGS+ORi6dYTBo1tHgSHzFWDIfAWYAEwOhsxXgCHzFWDIfAUYMl8Bhsw3B+PcrXMOBucrwJD55odIunUUmABMDobMV4Ah8xVgyHwFGDJfAYbMNwdDt44weHTrKDBkvgIMma8AE4DJwZD5CjBkvgIMma8AQ6vOjw8n1TE7rToSzebrfptofP1vE42vA26iebEH7tf1tL+6D6jnpTuV++xW5T57sXKf1rS1bFxr2lrOrDGtVbnPblXus1uV++xW5T67VbnPblXus1uV++xW5T67VbnPblXus1uV++zVyn0a01p5qWrlPo1pw6lawarcZ7cq99mtyn12q3Kf3arc57Aq9zmsyn2OYuU+rWmdihKPIaymdSr3OYqV+7SmreWlWtPW8lKtadm5TZ/YO+jWUWDYPBBg2DwQYNg8EGACMDkYdm7TfbiDbh0Fhp1bAYadWwGGndscjHO3zjkYY+d7Doa3zQgwON/c4NGto8CwcyvAsHMrwLBzK8DwnkUBhsw3B0O3jgJD5ivAkPkKMDhfASYAk4Mh880PkXTrKDBkvgIMma8AQ+abg3Hu1jkHQ+YrwJD5CjA439zg0a2jwJD5CjBkvgIMma8AQ+YrwJD55mDo1lFgyHwFGDJfAQbnK8AEYHIwZL75IZJuHQWGzFeAIfMVYMh8czDO3TrnYMh8BRgyXwEG55sbPLp1FBgyXwGGzFeAIfMVYMh8BRgy3xyMca9OAwytOj8+nFTHHLTqaDS+7reJJkCj0Pg64CaaF3vgfl1Px6v7gHpeulO5z2FV7nMUK/dpTVvLxrWmreXMWtM6vZD+sCr3OazKfQ6rcp/DqtznsCr3OazKfQ6rcp/DqtznsCr3OazKfY5q5T6Naa28VLVyn8a0TuU+h1W5z+FU7rMOTuU+j2mNyn0e0xqV+zymNSr3eUwbVtMaFSU+pjUqSnxMa+SlHtMalfs8pq3lpRrTFmvsaU1by0u1pmXnNnti7wGGzQMBJgCTg2HzQIBh80CAYfNAgGHnNtuHe4Bh5zYHQ7eOAsPOrQDDzq0AY+x8z8EEYHIwvG1GgMH55gaPbh0Fhp1bAYad2xwM3ToKDO9ZFGDIfAUYMl8BJgCTgyHzFWBwvgIMzleAIfPND5F06wgwdOsoMGS+AgyZrwBD5ivABGByMGS+AgzONzd4dOsoMGS+AgyZbw6Gbh0FhsxXgCHzFWDIfAWYAEwOhsxXgMH5CjA4XwGGzDc/RNKtI8DQraPAkPkKMGS+AgyZrwATgMnBkPkKMDjf3ODRraPAkPkKMGS+ORi6dRQYMl8BhsxXgCHzFWCC6ph/ZdUxDzS06kg0vu63icbX/zbR+DrgJpoXe+BuXU/r8Oo+oJ6XblTu85jWqNznMW0tx9eaNqymreXMWtMavZD+Ma1Ruc9jWqNyn8e0RuU+6+BU7vOY1qjc5zGtUbnPY1qjcp/HtGE1rVG5z2NaKy9VrdynMa2Vl6pW7nM67WhV7jNalfuMVuU+o1W5zziE1bRO5T6jVbnPaFXuMxYr92lN61SUOBYr92lN61TuMxYr92lNW8tLtaYNq2nZuU2f2Bvp1lFg2DwQYNg8EGDYPMjBOHfrnINh5zbdhxvp1lFg2LkVYAIwORh2bgUYY+d7DsbY+Z6D4W0zAgzONzd4dOsoMOzcCjDs3Aow7NwKMAGYHAyZrwBD5ivAkPkKMGS+AgzONwfj3K1zDobMNz9E0q2jwJD5CjABmBwMma8AQ+YrwJD5CjBkvgIMzjc3eHTrKDBkvgIMma8AQ+YrwARgcjBkvgIMma8AQ+YrwJD5CjA43xyMc7fOORgy3/wQSbeOAkPmK8AEYHIwZL4CDJmvAEPmK8CQ+QowON/c4NGto8CQ+QowZL4CDJmvABOAycGQ+QowZL4CDK06Pz6cVMeMtOpoNL7ut4Vm9/W/TTS+DriJ5sUeuF/X0/jqPqCelx5GdTejVbnPWKzcpzVtLRvXmraWM2tNa/VCeqtyn9Gq3Ge0KvcZrcp9Rqtyn9Gq3Ge0KvcZrcp9Rqtyn9Gq3GeqVu7TmNbJS03Vyn0a0zqV+0xDWE3rVO4zWZX7TFblPpNVuc9kVe4zWZX7TMXKfVrTOhUlTsXKfVrThlG5z1Ss3Kc1bS0v1Zq2lpdqTcvObfrE3kS3jgBDt44Cw+aBAMPmgQDD5oEAE+zDZftwE906Cgw7twIMO7cCDDu3Aoyx8z0F49ytcw6Gt80IMDjf3ODRraPABGByMOzcCjDs3AowvGdRgCHzFWDIfHMwdOsoMGS+AgzOV4DB+QowwSEyPUTSraPAkPkKMGS+AgyZrwBD5puDce7WOQdD5ivA4Hxzg0e3jgITgMnBkPkKMGS+AgyZrwBD5ivAkPnmYOjWUWDIfAUYnK8Ag/MVYIJDZHqIpFtHgSHzFWDIfAUYMl8Bhsw3B+PcrXMOhsxXgMH55gaPbh0FJgCTgyHzFWDIfAUYMl8BhsxXgCHzzcHQqvPHh5PqmIlWHY3G1/020fj63yaaAI1C82IP3K/raXp1H1DPS3cq95msyn2mYuU+jWmLlfu0pq3lzFrTWr2Q3qrcZ7Iq95msyn0mq3KfyarcZ7Iq95msyn1mq3Kf2arcZ7Yq95mrlfs0pg2raZ281GxV7jNblfvMVuU+s1W5z2xV7jNblfvMVuU+s1W5z1ys3Kc1rVNR4lys3Kc1rVO5z1ys3Kc1bS0v1Zi2WA1Pa1p2btMn9ma6dRQYNg8EmABMDobNAwGGzQMBhp3bdB9upltHgWHnNgdDt44Cw86tAGPsfM/BGDvfczABmBwMzjc3eHTrKDDs3Aow7NwKMOzc5mDo1lFgyHwFGDJfAYbMV4AJwORgcL4CDM5XgCHzzQ+RdOsoMGS+ORi6dRQYMl8BhsxXgCHzFWACMDkYnG9u8OjWUWDIfAUYMl8Bhsw3B0O3jgJD5ivAkPkKMGS+AkwAJgeD8xVgcL4CDJlvfoikW0eBIfPNwdCto8CQ+QowZL4CDJmvABOAycHgfHODR7eOAkPmK8CQ+QowZL45GONunQYYMl8BhsxXgKFV58eHk+qYmVYdjcbX/TbR+PrfJhpfB9xE82IP3K/raX51H1DHS7cq95mtyn3mYuU+rWlr2bjWtGE1rdUL6a3KfWarcp/Zqtxntir3Catyn7Aq9wmrcp+wKveJIaymdfJSUa3cpzGtk5eKauU+jWmdyn3CqtwnrMp9wqrcJ6zKfcKq3Cesyn3CqtwnipX7tKZ1KkqMYuU+jWmtyn2iWLlPa9paXqo1bS0v1Zo2eGIve2Iv6NZRYNg8EGDYPBBg2DwQYNg8yMHQrfPvdB8u6NZRYNi5FWDYuRVgAjA5GGPnew7G2Pmeg+FtMwIMzlcYPJxvDoZuHQWGnVsBhp1bAYb3LAowAZgcDJmvAEPmK8CQ+QowOF8BBuebg6FbRxwi6dZRYMh8BRgyXwEmAJODIfMVYMh8BRgyXwEG5ysMHs43B0O3jgJD5ivAkPkKMGS+AkwAJgdD5ivAkPkKMGS+AgzOV4DB+eZg6NYRh0i6dRQYMl8BhsxXgAnA5GDIfAUYMl8BhsxXgMH5CoOH883B0K2jwJD5CjBkvgIMma8AE4DJwZD5CjC06vz4cFIdE7TqaDS+7reJxtf/ttAUawXqiubFHrhf11O8ug+o56U7lfuEVblPFCv3aU1by8a1pq3lzFrTWr2Q3qrcZ7Eq91msyn0Wq3KfxarcZxnCalqncp/FqtxnsSr3WazKfZZq5T7n01Yr92lMa+WlrMp9Fqtyn8Wq3GexKvdZrMp9Fqtyn8Wq3GexKvdZipX7tKZ1KkpcipX7tKZ1KvdZipX7tKat5aVa09byUq1p2blNn9hb6NZRYNg8yME4d+ucg2HzQIBh80CAYec23Ydb6NZRYNi5FWDYuRVg2LkVYIyd7zkYY+d7Csa5W+ccDM43N3h06ygw7NwKMAGYHAw7twIM71kUYMh8BRgyXwGGzDcH49ytcw4G5yvA4HwFGDLf/BBJt44CQ+YrwJD5CjBkvgIMma8AQ+abg3Hu1jkHg/PNDR7dOgoMma8AE4DJwZD5CjBkvgIMma8AQ+YrwJD55mCcu3XOweB8BRicrwBD5psfIunWUWDIfAUYMl8BhsxXgCHzFWDIfHMwzt0652BwvrnBo1tHgSHzFWACMDkYMl8BhsxXgCHzFWDIfAUYWnV+fDipjllo1dFofN1vE42v/22i8XXATTRx166n5dV9QD0v3ancZ7Eq91mKlfu0pq1l486nXYuV+7SmdXoh/WpV7rNalfusQ1hN61Tus1qV+6xW5T6rVbnPalXus1qV+6xW5T5rtXKfxrRWXqpauU9jWqdyn9Wq3Ge1KvdZrcp9Vqtyn9Wq3Ge1KvdZrcp91mLlPq1pw2paKy9lVe6zFiv3aU1by0u1pq3lpRrT0q3z7/SJvZVuHQWGzQMBhs0DASYAk4Nh80CAYec23Ydb6dZRYNi5FWDYuc3B0K2jwBg733Mwxs73HAxvmxFgAoOXGjy6dRQYdm4FGHZuBRh2bgUY3rOYg6FbR4Eh8xVgyHwFGDJfASYAk4PB+QowZL75IZJuHQWGzFeAIfPNwdCto8CQ+QowZL4CDJmvABMYvNTg0a2jwJD5CjBkvgIMma8AQ+abg6FbR4Eh8xVgyHwFGDJfASYAk4PB+QowZL75IZJuHQWGzFeAIfPNwdCto8CQ+QowZL4CDJmvABMYvNTg0a2jwJD5CjBkvgIMma8AQ+abgzFu1mmAIfMVYGjV+fHhpDpmpVVHownQKDS+/reJxtcBN9G82AP363paX90H1PPSncp9Nqtyn61YuU9r2lo2rjVtLWfWmjaMXki/WZX7bFblPptVuc9mVe6zWZX7bFblPptVuc9mVe6zWZX7bFblPlu1cp/GtFZeqlq5T2Nap3KfzarcZ7Mq99msyn02q3KfzarcZ7Mq99msyn22YuU+rWmdihK3YuU+rWmdyn22YuU+rWlreanWtLW8VGtadm7TJ/Y2unUUGDYPBBg2DwQYNg8EGDYPBBh2btN9uI1uHQWGnVsBhp1bAYadWwEmAJODMXa+52B424wAg/PNDR7dOgoMO7c5GLp1FBh2bgUY3rMowJD5CjABmBwMma8AQ+YrwOB8BRicrwBD5psfIunWUWDIfAUYMl8BhsxXgAnA5GDIfAUYMl8BBuebGzy6dRQYMt8cDN06CgyZrwBD5ivAkPkKMAGYHAyZrwBD5ivA4HwFGJyvAEPmmx8i6dZRYMh8BRgyXwGGzFeACcDkYMh8BRgyXwEG55sbPLp1FBgy3xwM3ToKDJmvAEPmK8CQ+QowAZgcDK06Pz6cVMdstOpoNL7ut4nG1/820fg64Aaa/dUVQv26nvZX9wH1vHSncp/dqtxnH8Jq2lo2rjVtLWfWmtbphfS7VbnPblXus1uV++xW5T67VbnPblXus1uV++xW5T67VbnPblXus1cr92lMa+WlqpX7NKZ1KvfZrcp9dqtyn92q3Ge3KvfZrcp9dqtyn92q3GcvVu7TmLZYuU9rWisvZVXusxcr92lNG1bT1vJSrWnZuU2f2Nvp1lFg2DwQYNg8yME4d+ucg2HzQIBh5zbdh9vp1lFgAjA5GHZuBRh2bgUYY+d7DsbY+Z6D4W0zORi6dYTBo1tHgWHnVoBh51aACcDkYHjPogBD5ivAkPkKMGS+AgyZbw7GuVvnHAzOV4Ah880PkXTrKDABmBwMma8AQ+YrwJD5CjBkvgIMmW8Ohm4dYfDo1lFgyHwFGDJfASYAk4Mh8xVgyHwFGDJfAYbMV4Ah883BOHfrnIPB+QowZL75IZJuHQUmAJODIfMVYMh8BRgyXwGGzFeAIfPNwdCtIwwe3ToKDJmvAEPmK8AEYHIwZL4CDJmvAEPmK8DQqvPjw1l1DK06Cs0x+LrfJhpf/9tE4+uAm2he7IH7dT0dQ9z30p3KfQ6rcp+jWLlPa9paNq41bS1n1pjWqtznsCr3OazKfQ6rcp/DqtznsCr3OazKfQ6rcp/DqtznsCr3OazKfY5q5T6Naa28VLVyn8a0YVStcFiV+xxW5T6HVbnPYVXuc1iV+xxW5T6HVbnPUazcpzWtU1HiUazcpzWtU7nPUazcpzVtLS/VmraWl2pNy85t+sTeQbeOAsPmgQDD5oEAw+aBABOAycGwc5vuwx106ygw7NwKMOzcCjDs3OZgnLt1zsEYO99zMLxtRoDB+eYGj24dBYadWwGGnVsBhp1bAYb3LAowZL45GLp1FBgyXwGGzFeAwfkKMAGYHAyZb36IpFtHgSHzFWDIfAUYMt8cjHO3zjkYMl8BhsxXgMH55gaPbh0FhsxXgCHzFWDIfAUYMl8Bhsw3B0O3jgJD5ivAkPkKMDhfASYAk4Mh880PkXTrKDBkvgIMma8AQ+abg3Hu1jkHQ+YrwJD5CjA439zg0a2jwJD5CjBkvgIMma8AQ+YrwJD5ZmC2wbhXpwGGVp0fH/65OuaBhlYdicbX/TbRBGgUGl8H3ETzYg/crevpcenbfS/dqNznMa1Ruc82FCv3aU1by8a1pq3lzFrTGr2Q/jFtWE1rVO7zmNao3OcxrVG5z2Nao3Kfx7RG5T7b4FTu85jWqNznMa1Ruc9jWisvVa3cpzGtlZeqVu7TmNao3OcxrVG5z2Nao3KfbXAq93lMa1Tu85jWqNznMa1Ruc9j2rCa1qgo8TGtUVHiY1orL+VU7vOYtpaXakxbrLGnNW0tL9Walp3b/Ik9unUUmABMDobNAwGGzQMBhs0DAYad22wf7gGGndscDN06Cgw7twIMO7cCjLHzPQcTgMnB8LYZAQbnmxs8unUUGHZuBRh2bnMwdOsoMLxnUYAh8xVgyHwFmABMDobMV4DB+QowOF8Bhsw3P0TSrSPA0K2jwJD5CjBkvgIMma8AE4DJwZD5CjA439zg0a2jwJD5CjBkvjkYunUUGDJfAYbMV4Ah8xVgAjA5GDJfAQbnK8DgfAUYMt/8EEm3jgBDt44CQ+YrwJD5CjBkvgJMACYHQ+YrwOB8c4NHt44CQ+YrwJD5pmBGunUUGDJfAYbMV4Ah8xVgguqYf6XVMSOtOhqNr/ttovH1v000vg64iebFHrhf19P46j6gnpfuVO4zWpX7jMXKfVrThtW0tZxZa1qnF9KPVuU+o1W5z2hV7jNalfuMVuU+o1W5z2hV7jNalfuMVuU+o1W5z1it3KcxrZWXqlbucz6tVbnPaFXuM1qV+4xW5T6jVbnPaFXuM1qV+4xW5T5jsXKf1rRORYljsXKf1rRO5T5jsXKf1rS1vFRr2rCalp3b/Ik9unUUGDYPBBg2DwQYNg9yMM7dOudg2LlN9+FGunUUGHZuBZgATA6GnVsBxtj5noMxdr7nYHjbjACD880NHt06Cgw7twIMO7cCDDu3AkwAJgdD5ivAkPkKMGS+AgyZrwCD883BOHfrnIMh880PkXTrKDBkvgJMACYHQ+YrwJD5CjBkvgIMma8Ag/PNDR7dOgoMma8AQ+YrwJD5CjABmBwMma8AQ+YrwJD5CjBkvgIMzjcH49ytcw6GzDc/RNKto8CQ+QowAZgcDJmvAEPmK8CQ+QowZL4CDM43NXgT3ToKDJmvAEPmK8CQ+QowAZgcDJmvAEPmK8DQqvPjw0l1zESrjkbj635baEZf/9tE4+uAm2he7IH7dT1Nr+4D6nnpYVR3M1mV+0zFyn1a09ayca1pazmz1rROL6SfrMp9Jqtyn8mq3GeyKveZrMp9Jqtyn8mq3GeyKveZrMp9Jqtyn6lauU9jWisvVa3cpzGtU7nPZFXuM1mV+0xW5T6TVbnPZFXuM1mV+0xW5T5TsXKf1rRORYlTsXKf1rRhVO4zFSv3aU1by0u1pq3lpVrTsnObP7FHt44AQ7eOAsPmgQDD5oEAw+aBABPsw2X7cBPdOgoMO7cCDDu3Agw7twKMsfM9BePcrXMOhrfNCDA439zg0a2jwARgcjDs3Aow7NwKMLxnUYAh8xVgyHxzMHTrKDBkvgIMzleAwfkKMMEhMj1E0q2jwJD5CjBkvgIMma8AQ+abg3Hu1jkHQ+YrwOB8c4NHt44CE4DJwZD5CjBkvgIMma8AQ+YrwJD55mDo1lFgyHwFGJyvAIPzFWCCQ2R6iKRbR4Eh8xVgyHwFGDJfAYbMNwUzO3frnIMh8xVgcL6pwZvp1lFgAjA5GDJfAYbMV4Ah8xVgyHwFGDLfHAytOn98OKmOmWnV0Wh83W8Tja//baIJ0Cg0L/bA/bqe5lf3AfW8dKdyn9mq3GcuVu7TmLZYuU9r2lrOrDWt0wvpZ6tyn9mq3Ge2KveZrcp9Zqtyn9mq3Ge2KveZrcp9Zqtyn9mq3GeuVu7TmDasprXyUlblPrNVuc9sVe4zW5X7zFblPrNVuc9sVe4zW5X7zMXKfVrTOhUlzsXKfVrTOpX7zMXKfVrT1vJSjWmL1fC0pmXnNn9ij24dBYbNAwEmAJODYfNAgGHzQIBh5zbfh6NbR4Fh5zYHQ7eOAsPOrQBj7HzPwRg733MwAZgcDM43N3h06ygw7NwKMOzcCjDs3OZg6NZRYMh8BRgyXwGGzFeACcDkYHC+AgzOV4Ah880PkXTrKDBkvjkYunUUGDJfAYbMV4Ah8xVgAjA5GJxvbvDo1lFgyHwFGDJfAYbMNwdDt44CQ+YrwJD5CjBkvgJMACYHg/MVYHC+AgyZb36IpFtHgSHzTcEE3ToKDJmvAEPmK8CQ+QowAZgcDM43NXhBt44CQ+YrwJD5CjBkvjkY426dBhgyXwGGzFeAoVXnx4eT6pigVUej8XW/TTS+/reJxtcBN9G82AP363qKV/cBdbx0q3KfsCr3iWLlPq1pa9m41rRhNa3TC+nDqtwnrMp9wqrcJ6zKfcKq3Cesyn3CqtwnrMp9wqrcJ6zKfaJauU9jWisvVa3cpzGtU7lPWJX7hFW5T1iV+4RVuU9YlfuEVblPWJX7RLFyn9a0TkWJUazcpzGtVblPFCv3aU1by0u1pq3lpVrTBk/spU/s0a2jwLB5IMCweSDAsHkgwLB5kIOhW+ff+T4c3ToKDDu3Agw7twJMACYHY+x8z8EYO99zMLxtRoDB+QqDh/PNwdCto8CwcyvAsHMrwPCeRQEmAJODIfMVYMh8BRgyXwEG5yvA4HxzMHTriEMk3ToKDJmvAEPmK8AEYHIwZL4CDJmvAEPmK8DgfIXBw/nmYOjWUWDIfAUYMl8BhsxXgAnA5GDIfAUYMl8BhsxXgMH5CjA43xTMQrdOfohc6NZRYMh8BRgyXwEmAJODIfMVYMh8BRgyXwEG5ysMHs43B0O3jgJD5ivAkPkKMGS+AkwAJgdD5ivA0Krz48NJdcxCq45G4+t+m2h8/W8LTbFWoK5oXuyB+3U9La/uA+p56U7lPotVuc9SrNynNW0tG9eatpYza03r9EL6xarcZ7Eq91msyn0Wq3KfxarcZ7Eq91msyn0Wq3KfxarcZ7Eq91mqlfucT1ut3KcxrZWXsir3WazKfRarcp/FqtxnsSr3WazKfRarcp/FqtxnKVbu05rWqShxKVbu05rWqdxnKVbu05q2lpdqTVvLS7WmZec2f2KPbh0Fhs2DHIxzt845GDYPBBg2DwQYdm7zfTi6dRQYdm4FGHZuBRh2bgUYY+d7DsbY+Z6Cce7WOQeD880NHt06Cgw7twJMACYHw86tAMN7FgUYMl8BhsxXgCHzzcE4d+ucg8H5CjA4XwGGzDc/RNKto8CQ+QowZL4CDJmvAEPmK8CQ+eZgnLt1zsHgfHODR7eOAkPmK8AEYHIwZL4CDJmvAEPmK8CQ+QowZL4pmNW5W+ccDM5XgMH5CjBkvukhch0CMDkYMl8BhsxXgCHzFWDIfAUYMt8cjHO3zjkYnG9u8OjWUWDIfAWYAEwOhsxXgCHzFWDIfAUYMl8BhladHx9OqmNWWnU0Gl/320Tj63+baHwdcBNN3LXraX11H1DPS3cq91mtyn3WYuU+rWlr2bjGtMXKfVrTOr2QfrUq91mtyn1Wq3Kf1arcZ7Uq91mtyn1Wq3Kf1arcZ7Uq91mtyn3WauU+jWmtvFS1cp/GtE7lPqtVuc9qVe6zWpX7rFblPqtVuc9qVe6zWpX7rMXKfVrThtW0Vl7KqtxnLVbu05q2lpdqTVvLSzWmpVvn3/kTe3TrKDBsHggwbB4IMAGYHAybBwIMO7f5PhzdOgoMO7cCDDu3ORi6dRQYY+d7DsbY+Z6D4W0zAkxg8FKDR7eOAsPOrQDDzq0Aw86tAMN7FnMwdOsoMGS+AgyZrwBD5ivABGByMDhfAYbMNz9E0q2jwJD5CjBkvjkYunUUGDJfAYbMV4Ah8xVgAoOXGjy6dRQYMl8BhsxXgCHzFWDIfFMwG906CgyZrwBD5ivAkPkKMAGYHAzOV4Ah800PkRvdOgoMma8AQ+abg6FbR4Eh8xVgyHwFGDJfASYweKnBo1tHgSHzFWDIfAUYMl8Bhsw3B2PcrNMAQ+YrwNCq8+PDSXXMRquORhOgUWh8/W8Tja8DbqJ5sQfu1/W0vboPqOelO5X7bFblPluxcp/WtLVsXGvaWs6sNW0YvZB+syr32azKfTarcp/Nqtxnsyr32azKfTarcp/Nqtxnsyr32azKfbZq5T6Naa28VLVyn8a0TuU+m1W5z2ZV7rNZlftsVuU+m1W5z2ZV7rNZlftsxcp9WtM6FSVuxcp9WtM6lftsxcp9WtPW8lKtaWt5qda07NzmT+zRraPAsHkgwLB5IMCweSDAsHkgwLBzm+/D0a2jwLBzK8CwcyvAsHMrwARgcjDGzvccDG+bEWBwvrnBo1tHgWHnNgdDt44Cw86tAMN7FgUYMl8BJgCTgyHzFWDIfAUYnK8Ag/MVYMh880Mk3ToKDJmvAEPmK8CQ+QowAZgcDJmvAEPmK8DgfHODR7eOAkPmm4LZ6dZRYMh8BRgyXwGGzFeACcDkYMh8BRgyXwEG5yvA4HwFGDLf9BC5062jwJD5CjBkvgIMma8AE4DJwZD5CjBkvgIMzjc3eHTrKDBkvjkYunUUGDJfAYbMV4Ah8xVgAjA5GFp1fnw4qY7ZadXRaHzdbxONr/9tovF1wC00r64Q6tf1tL+6D6jnpTuV++xW5T57sXKf1rS1bFxr2lrOrDWt0wvpd6tyn92q3Ge3KvfZrcp9dqtyn92q3Ge3KvfZrcp9dqtyn92q3GevVu7TmNbKS1Ur92lM61Tus1uV++xW5T67VbnPblXus1uV++xW5T67VbnPXqzcpzFtsXKf1rRWXsqq3GcvVu7Tmjaspq3lpVrTsnObP7FHt44Cw+aBAMPmQQ7GuVvnHAybBwIMO7f5PhzdOgpMACYHw86tAMPOrQBj7HzPwRg733MwvG0mB0O3jjB4dOsoMOzcCjDs3AowAZgcDO9ZFGDIfAUYMl8BhsxXgCHzzcE4d+ucg8H5CjBkvvkhkm4dBSYAk4Mh8xVgyHwFGDJfAYbMV4Ah803BHHTr5AbvoFtHgSHzFWDIfAWYAEwOhsxXgCHzFWDIfAUYMl8Bhsw3B+PcrXMOBucrwJD55odIunUUmABMDobMV4Ah8xVgyHwFGDJfAYbMNwdDt44weHTrKDBkvgIMma8AE4DJwZD5CjBkvgIMma8AQ6vOjw8n1TEHrToSzezrfptofP1vE42vA26iebEH7tf1dLy6D6jnpTuV+xxW5T5HsXKf1rS1bFxr2lrOrDGtVbnPYVXuc1iV+xxW5T6HVbnPYVXuc1iV+xxW5T6HVbnPYVXuc1iV+xzVyn0a01p5qWrlPo1pw6ha4bAq9zmsyn0Oq3Kfw6rc57Aq9zmsyn0Oq3Kfo1i5T2tap6LEo1i5T2tap3Kfo1i5T2vaWl6qNW0tL9Walp3b/Ik9unUUGDYPBBg2DwQYNg8EmABMDoad23wfjm4dBYadWwGGnVsBhp3bHIxzt845GGPnew6Gt80IMDjf3ODRraPAsHMrwLBzK8CwcyvA8J5FAYbMNwdDt44CQ+YrwJD5CjA4XwEmAJODIfPND5F06ygwZL4CDJmvAEPmm4HZB+dunXMwZL4CDJmvAIPzzQzeA0wAJgdD5ivAkPkKMGS+AgyZrwBD5puDoVtHgSHzFWDIfAUYnK8AE4DJwZD55odIunUUGDJfAYbMV4Ah883BOHfrnIMh8xVgyHwFGJxvbvDo1lFgyHwFGDJfAYbMV4Ah8xVgyHxzMMa9Og0wtOr8+PDP1TEPNLTqSDS+7reJJkCj0Pg64CaaF3vgbl1Pj0vf7nvpRuU+j2mNyn32oVi5T2vaWjauNW0tZ9aa1uiF9I9pw2pao3Kfx7RG5T6PaY3KfR7TGpX7PKY1KvfZB6dyn8e0RuU+j2mNyn0e01p5qWrlPo1prbxUtXKfxrRG5T6PaY3KfR7TGpX77INTuc9jWqNyn8e0RuU+j2mNyn0e04bVtEZFiY9pjYoSH9NaeSmncp/HtLW8VGPaYo09rWlreanWtOzc5k/s0a2jwARgcjBsHggwbB4IMGweCDDs3Ob7cHTrCDB06ygw7NwKMOzcCjDGzvccTAAmB8PbZgQYnG9u8OjWUWDYuRVg2LnNwdCto8DwnkUBhsxXgCHzFWACMDkYMl8BBucrwOB8BRgy3/wQSbdODmakW0eBIfMVYMh8BRgyXwEmAJODIfMVYHC+qcEb6dZRYMh8BRgy3xwM3ToKDJmvAEPmK8CQ+QowAZgcDJmvAIPzFWBwvgIMmW9+iKRbR4ChW0eBIfMVYMh8BRgyXwEmAJODIfMVYHC+ucGjW0eBIfMVYMh8czB06ygwZL4CDJmvAEPmK8AE1TH/SqtjRlp1NBpf99tE4+t/m2h8HXATzYs9cL+up/HVfUA9L92p3Ge0KvcZi5X7tKYNq2lrObPWtE4vpB+tyn1Gq3Kf0arcZ7Qq9xmtyn1Gq3Kf0arcZ7Qq9xmtyn1Gq3KfsVq5T2NaKy9VrdznfFqrcp/RqtxntCr3Ga3KfUarcp/RqtxntCr3Ga3KfcZi5T6taZ2KEsdi5T6taZ3KfcZi5T6taWt5qda0YTUtO7f5E3t06ygwbB4IMGweCDBsHuRgnLt1zsGwc5vvw9Gto8CwcyvABGByMOzcCjDGzvccjLHzPQfD22YEGJxvbvDo1lFg2LkVYNi5FWDYuRVgAjA5GDJfAYbMV4Ah8xVgyHwFGJxvCmZy7tY5B0Pmmx4iJ7p1FBgyXwEmAJODIfMVYMh8BRgyXwGGzFeAwfnmBo9uHQWGzFeAIfMVYMh8BZgATA6GzFeAIfMVYMh8BRgyXwEG55uDce7WOQdD5psfIunWUWDIfAWYAEwOhsxXgCHzFWDIfAUYMl8BBuebGzy6dRQYMl8BhsxXgCHzFWACMDkYMl8BhsxXgKFV58eHk+qYiVYdjcbX/bbQhK//baLxdcBNNC/2wP26nqZX9wH1vPQwqruZrMp9pmLlPq1pa9m41rS1nFlrWqcX0k9W5T6TVbnPZFXuM1mV+0xW5T6TVbnPZFXuM1mV+0xW5T6TVbnPVK3cpzGtlZeqVu7TmNap3GeyKveZrMp9Jqtyn8mq3GeyKveZrMp9Jqtyn6lYuU9rWqeixKlYuU9r2jAq95mKlfu0pq3lpVrT1vJSrWnZuc2f2KNbR4ChW0eBYfNAgGHzQIBh80CACfbh0n04unUUGHZuBRh2bgUYdm4FGGPnewrGuVvnHAxvmxFgcL65waNbR4EJwORg2LkVYNi5FWB4z6IAQ+YrwJD5pmBmunUUGDJfAQbnK8DgfAWY4BCZHSJnunUUGDJfAYbMV4Ah8xVgyHxzMM7dOudgyHwFGJxvbvDo1lFgAjA5GDJfAYbMV4Ah8xVgyHwFGDLfHAzdOgoMma8Ag/MVYHC+AkxwiEwPkXTrKDBkvgIMma8AQ+YrwJD55mCcu3XOwZD5CjA439zg0a2jwARgcjBkvgIMma8AQ+YrwJD5CjBkvjkYWnX++HBSHTPTqqPR+LrfJhpf/9tEE6BRaF7sgft1Pc2v7gPqeelO5T6zVbnPXKzcpzFtsXKf1rS1nFlrWqcX0s9W5T6zVbnPbFXuM1uV+8xW5T6zVbnPbFXuM1uV+8xW5T6zVbnPXK3cpzFtWE1r5aWsyn1mq3Kf2arcZ7Yq95mtyn1mq3Kf2arcZ7Yq95mLlfu0pnUqSpyLlfu0pnUq95mLlfu0pq3lpRrTFqvhaU3Lzm3+xB7dOgoMmwcCTAAmB8PmgQDD5oEAw85tvg9Ht44Cw85tDoZuHQWGnVsBxtj5noMxdr7nYAIwORicb27w6NZRYNi5FWDYuRVg2LlNwQTdOgoMma8AQ+YrwJD5CjABmBwMzleAwfkKMGS+6SEy6NZRYMh8czB06ygwZL4CDJmvAEPmK8AEYHIwON/c4NGto8CQ+QowZL4CDJlvDoZuHQWGzFeAIfMVYMh8BZgATA4G5yvA4HwFGDLf/BBJt44CQ+abg6FbR4Eh8xVgyHwFGDJfASYAk4PB+eYGj24dBYbMV4Ah8xVgyHxzMMbdOg0wZL4CDJmvAEOrzo8PJ9UxQauORuPrfptofP1vE42vA26iebEH7tf1FK/uA+p46VblPmFV7hPFyn1a09ayca1pw2papxfSh1W5T1iV+4RVuU9YlfuEVblPWJX7hFW5T1iV+4RVuU9YlftEtXKfxrRWXqpauU9jWqdyn7Aq9wmrcp+wKvcJq3KfsCr3Catyn7Aq94li5T6taZ2KEqNYuU9jWqtynyhW7tOatpaXak1by0u1pg2e2Euf2KNbR4Fh80CAYfNAgGHzQIBh8yAHQ7fOv/N9OLp1FBh2bgUYdm4FmABMDsbY+Z6DMXa+52B424wAg/MVBg/nm4JZ6NZRYNi5FWDYuRVgeM+iABOAycGQ+QowZL4CDJmvAIPzFWBwvjkYunXyQ+RCt44CQ+YrwJD5CjABmBwMma8AQ+YrwJD5CjA4X2HwcL45GLp1FBgyXwGGzFeAIfMVYAIwORgyXwGGzFeAIfMVYHC+AgzONwdDt444RNKto8CQ+QowZL4CTAAmB0PmK8CQ+QowZL4CDM5XGDycbw6Gbh0FhsxXgCHzFWDIfAWYAEwOhsxXgKFV58eHk+qYhVYdjcbX/TbR+PrfFppirUBd0bzYA/frelpe3QfU89Kdyn0Wq3KfpVi5T2vaWjauNW0tZ9aa1umF9ItVuc9iVe6zWJX7LFblPotVuc9iVe6zWJX7LFblPotVuc9iVe6zVCv3OZ+2WrlPY1orL2VV7rNYlfssVuU+i1W5z2JV7rNYlfssVuU+i1W5z1Ks3Kc1rVNR4lKs3Kc1rVO5z1Ks3Kc1bS0v1Zq2lpdqTcvObf7EHt06CgybBzkY526dczBsHggwbB4IMOzc5vtwdOsoMOzcCjDs3Aow7NwKMMbO9xyMsfM9A7M6d+ucg8H5pgZvpVtHgWHnVoAJwORg2LkVYHjPogBD5ivAkPkKMGS+ORjnbp1zMDhfAQbnK8CQ+eaHSLp1FBgyXwGGzFeAIfMVYMh8BRgy3xyMc7fOORicb27w6NZRYMh8BZgATA6GzFeAIfMVYMh8BRgyXwGGzDcH49ytcw4G5yvA4HwFGDLf/BBJt44CQ+YrwJD5CjBkvgIMma8AQ+abg3Hu1jkHg/PNDR7dOgoMma8AE4DJwZD5CjBkvgIMma8AQ+YrwNCq8+PDSXXMSquORuPrfptofP1vE42vA26iibt2Pa2v7gPqeelO5T6rVbnPWqzcpzVtLRvXmLZYuU9rWqcX0q9W5T6rVbnPalXus1qV+6xW5T6rVbnPalXus1qV+6xW5T6rVbnPWq3cpzGtlZeqVu7TmNap3Ge1KvdZrcp9Vqtyn9Wq3Ge1KvdZrcp9Vqtyn7VYuU9r2rCa1spLWZX7rMXKfVrT1vJSrWlreanGtHTr/Dt/Yo9uHQWGzQMBhs0DASYAk4Nh80CAYec234ejW0eBYedWgGHnNgWz0a2jwBg733Mwxs73HAxvmxFgAoOXGbyNbh0Fhp1bAYadWwGGnVsBhvcs5mDo1lFgyHwFGDJfAYbMV4AJwORgcL4CDJlvfoikW0eBIfMVYMh8czB06ygwZL4CDJmvAEPmK8AEBi81eHTrKDBkvgIMma8AQ+YrwJD55mDo1lFgyHwFGDJfAYbMV4AJwORgcL4CDJlvfoikW0eBIfMVYMh8czB06ygwZL4CDJmvAEPmK8AEBi81eHTrKDBkvgIMma8AQ+YrwJD55mCMm3UaYMh8BRhadX58OKmO2WjV0WgCNAqNr/9tovF1wE00L/bA/bqetlf3AfW8dKdyn82q3GcrVu7TmraWjWtNW8uZtaYNoxfSb1blPptVuc9mVe6zWZX7bFblPptVuc9mVe6zWZX7bFblPptVuc9WrdynMa2Vl6pW7tOY1qncZ7Mq99msyn02q3KfzarcZ7Mq99msyn02q3KfrVi5T2tap6LErVi5T2tap3KfrVi5T2vaWl6qNW0tL9Walp3b/Ik9unUUGDYPBBg2DwQYNg8EGDYPBBh2btN9uJ1uHQWGnVsBhp1bAYadWwEmAJODMXa+52B424wAg/NNDd5Ot44Cw85tDoZuHQWGnVsBhvcsCjBkvgJMACYHQ+YrwJD5CjA4XwEG5yvAkPnmh0i6dRQYMl8BhsxXgCHzFWACMDkYMl8BhsxXgMH55gaPbh0Fhsw3B0O3jgJD5ivAkPkKMGS+AkwAJgdD5ivAkPkKMDhfAQbnK8CQ+eaHSLp1FBgyXwGGzFeAIfMVYAIwORgyXwGGzFeAwfnmBo9uHQWGzDcHQ7eOAkPmK8CQ+QowZL4CTAAmB0Orzo8PJ9UxO606Go2v+22i8fW/TTS+DriF5tUVQv26nvZX9wH1vHSncp/dqtxnL1bu05q2lo1rTVvLmbWmdXoh/W5V7rNblfvsVuU+u1W5z25V7rNblfvsVuU+u1W5z25V7rNblfvs1cp9GtNaealq5T6NaZ3KfXarcp/dqtxntyr32a3KfXarcp/dqtxntyr32YuV+zSmLVbu05rWyktZlfvsxcp9WtOG1bS1vFRrWnZu8yf26NZRYNg8EGDYPEjBHM7dOudg2DwQYNi5TffhDrp1FJgATA6GnVsBhp1bAcbY+Z6DMXa+52B420wOhm4dYfDo1lFg2LkVYNi5FWACMDkY3rMowJD5CjBkvgIMma8AQ+abg3Hu1jkHg/MVYMh880Mk3ToKTAAmB0PmK8CQ+QowZL4CDJmvAEPmm4OhW0cYPLp1FBgyXwGGzFeACcDkYMh8BRgyXwGGzFeAIfMVYMh8czDO3TrnYHC+AgyZb36IpFtHgQnA5GDIfAUYMl8BhsxXgCHzFWDIfHMwdOsIg0e3jgJD5ivAkPkKMAGYHAyZrwBD5ivAkPkKMLTq/PhwUh1z0Koj0ay+7reJxtf/NtH4OuAmmhd74H5dT8er+4B6XrpTuc9hVe5zFCv3aU1by8a1pq3lzBrTWpX7HFblPodVuc9hVe5zWJX7HFblPodVuc9hVe5zWJX7HFblPodVuc9RrdynMa2Vl6pW7tOYNoyqFQ6rcp/DqtznsCr3OazKfQ6rcp/DqtznsCr3OYqV+7SmdSpKPIqV+7SmdSr3OYqV+7SmreWlWtPW8lKtadm5zZ7YOwa6dRQYNg8EGDYPBBg2DwSYAEwOhp3bbB/uAYadWwGGnVsBhp1bAYad2xyMc7fOORhj53sOhrfNCDA439zg0a2jwLBzK8CwcyvAsHMrwPCeRQGGzDcHQ7eOAkPmK8CQ+QowOF8BJgCTgyHzzQ+RdOsoMGS+AgyZrwBD5puDce7WOQdD5ivAkPkKMDjf3ODRraPAkPkKMGS+AgyZrwBD5ivAkPnmYOjWUWDIfAUYMl8BBucrwARgcjBkvvkhkm4dBYbMV4Ah8xVgyHxzMM7dOudgyHwFGDJfAQbnmxs8unUUGDJfAYbMV4Ah8xVgyHwFGDLfHIxxr04DDK06Pz78c3XMAw2tOhKNr/ttognQKDS+DriJ5sUeuFvX0+PSt/teulG5z2Nao3KfYyhW7tOatpaNa01by5m1pjV6If1j2rCa1qjc5zGtUbnPY1qjcp/HtEblPo9pjcp9jsGp3OcxrVG5z2Nao3Kfx7RWXqpauU9jWisvVa3cpzGtUbnPY1qjcp/HtEblPsfgVO7zmNao3OcxrVG5z2Nao3Kfx7RhNa1RUeJjWqOixMe0Vl7KqdznMW0tL3U+7Vissac1bS0v1ZqWndv0ib2Rbh0FJgCTg2HzQIBh80CAYfNAgGHnNt2HG+nWEWDo1lFg2LkVYNi5FWCMne85mABMDoa3zQgwON/c4NGto8CwcyvAsHObg6FbR4HhPYsCDJmvAEPmK8AEYHIwZL4CDM5XgMH5CjBkvvkhkm4dAYZuHQWGzFeAIfMVYMh8BZgATA6GzFeAwfnmBo9uHQWGzFeAIfPNwdCto8CQ+QowZL4CDJmvABOAycGQ+QowOF8BBucrwJD55odIunUEGLp1FBgyXwGGzFeAIfMVYAIwORgyXwEG55sbPLp1FBgyXwGGzDcHQ7eOAkPmK8CQ+QowZL4CTFAd86+0OmakVUej8XW/TTS+/reJxtcBN9G82AP363oaX90H1PPSncp9Rqtyn7FYuU9r2rCatpYza03r9EL60arcZ7Qq9xmtyn1Gq3Kf0arcZ7Qq9xmtyn1Gq3Kf0arcZ7Qq9xmrlfs0prXyUtXKfc6ntSr3Ga3KfUarcp/RqtxntCr3Ga3KfUarcp/RqtxnLFbu05rWqShxKlbu05rWqdxnKlbu05q2lpdqTRtW07Jzmz6xN9Gto8CweSDAsHkgwLB5kINx7tY5B8PObboPN9Gto8CwcyvABGByMOzcCjDGzvccjLHzPQfD22YEGJxvbvDo1lFg2LkVYNi5FWDYuRVgAjA5GDJfAYbMV4Ah8xVgyHwFGJxvDsa5W+ccDJlvfoikW0eBIfMVYAIwORgyXwGGzFeAIfMVYMh8BRicb27w6NZRYMh8BRgyXwGGzFeACcDkYMh8BRgyXwGGzFeAIfMVYHC+ORjnbp1zMGS++SGSbh0FhsxXgAnA5GDIfAUYMl8BhsxXgCHzFWBwvrnBo1tHgSHzFWDIfAUYMl8BJgCTgyHzFWDIfAUYWnV+fDipjplo1dFofN1vC83m63+baHwdcBPNiz1wv66n6dV9QD0vPYzqbiarcp+pWLlPa9paNq41bS1n1prW6YX0k1W5z2RV7jNZlftMVuU+k1W5z2RV7jNZlftMVuU+k1W5z2RV7jNVK/dpTGvlpaqV+zSmdSr3mazKfSarcp/Jqtxnsir3mazKfSarcp/ZqtxnLlbu05rWqShxLlbu05o2jMp95mLlPq1pa3mp1rS1vFRrWnZu0yf2Zrp1BBi6dRQYNg8EGDYPBBg2DwSYYB8u24eb6dZRYNi5FWDYuRVg2LkVYIyd7ykY526dczC8bUaAwfnmBo9uHQUmAJODYedWgGHnVoDhPYsCDJmvAEPmm4OhW0eBIfMVYHC+AgzOV4AJDpHpIZJuHQWGzFeAIfMVYMh8BRgy3xyMc7fOORgyXwEG55sbPLp1FJgATA6GzFeAIfMVYMh8BRgyXwGGzDcHQ7eOAkPmK8DgfAUYnK8AExwi00Mk3ToKDJmvAEPmK8CQ+QowZL45GOdunXMwZL4CDM43N3h06ygwAZgcDJmvAEPmK8CQ+QowZL4CDJlvDoZWnT8+nFTHzLTqaDS+7reJxtf/NtEEaBSaF3vgfl1P86v7gHpeulO5z2xV7jMXK/dpTFus3Kc1bS1n1prW6YX0s1W5z2xV7jNblfvMVuU+s1W5z2xV7jNblfvMVuU+s1W5z2xV7jNXK/dpTBtW01p5Katyn9mq3Ge2KveZrcp9wqrcJ6zKfcKq3Cesyn1iCKtpnYoSo1i5T2tap3KfKFbu05q2lpdqTFushqc1LTu36RN7QbeOAsPmgQATgMnBsHkgwLB5IMCwc5vuwwXdOgoMO7c5GLp1FBh2bgUYY+d7DsbY+Z6DCcDkYHC+ucGjW0eBYedWgGHnVoBh5zYHQ7eOAkPmK8CQ+QowZL4CTAAmB4PzFWBwvgIMmW9+iKRbR4Eh883B0K2jwJD5CjBkvgIMma8AE4DJweB8c4NHt44CQ+YrwJD5CjBkvjkYunUUGDJfAYbMV4Ah8xVgAjA5GJyvAIPzFWDIfPNDJN06CgyZbw6Gbh0FhsxXgCHzFWDIfAWYAEwOBuebGzy6dRQYMl8BhsxXgCHzzcEYd+s0wJD5CjBkvgIMrTo/PpxUxwStOhqNr/ttovH1v000vg64iebFHrhf11O8ug+o46VblfuEVblPFCv3aU1by8a1pg2raZ1eSB9W5T5hVe4TVuU+YVXuE1blPmFV7hNW5T5hVe4TVuU+YVXuE9XKfRrTWnmpauU+jWmdyn0Wq3KfxarcZ7Eq91msyn2WIaymdSr3WazKfZZi5T6taZ2KEpdi5T6Naa3KfZZi5T6taWt5qda0tbxUa9rgib3sib2Fbh0Fhs0DAYbNAwGGzQMBhs2DHAzdOv9O9+EWunUUGHZuBRh2bgWYAEwOxtj5noMxdr7nYHjbjACD8xUGD+ebg6FbR4Fh51aAYedWgOE9iwJMACYHQ+YrwJD5CjBkvgIMzleAwfnmYOjWEYdIunUUGDJfAYbMV4AJwORgyHwFGDJfAYbMV4DB+QqDh/PNwdCto8CQ+QowZL4CDJmvABOAycGQ+QowZL4CDJmvAIPzFWBwvjkYunXEIZJuHQWGzFeAIfMVYAIwORgyXwGGzFeAIfMVYHC+wuDhfHMwdOsoMGS+AgyZrwBD5ivABGByMGS+AgytOj8+nFTHLLTqaDS+7reJxtf/ttAUawXqiubFHrhf19Py6j6gnpfuVO6zWJX7LMXKfVrT1rJxrWlrObPWtE4vpF+syn0Wq3KfxarcZ7Eq91msyn0Wq3KfxarcZ7Eq91msyn0Wq3KfpVq5z+m0a7Vyn8a0Tl5qtSr3Wa3KfdYhrKZ1KvdZrcp9Vqtyn9Wq3Ge1KvdZi5X7tKZ1Kkpci5X7tKZ1KvdZi5X7tKat5aVa09byUq1p2blNn9hb6dZRYNg8yME4d+ucg2HzQIBh80CAYec23Ydb6dZRYNi5FWDYuRVg2LkVYIyd7zkYY+d7Csa5W+ccDM43N3h06ygw7NwKMAGYHAw7twIM71kUYMh8BRgyXwGGzDcH49ytcw4G5yvA4HwFGDLf/BBJt44CQ+YrwJD5CjBkvgIMma8AQ+abg3Hu1jkHg/PNDR7dOgoMma8AE4DJwZD5CjBkvgIMma8AQ+YrwJD55mCcu3XOweB8BRicrwBD5psfIunWUWDIfAUYMl8BhsxXgCHzFWDIfHMwzt0652BwvrnBo1tHgSHzFWACMDkYMl8BhsxXgCHzFWDIfAUYWnV+fDipjllp1dFofN1vE42v/22i8XXATTRx166n9dV9QD0v3ancZ7Uq91mLlfu0pq1l4xrTFiv3aU1r9UJ6q3Kf1arcZ7Uq91mtyn1Wq3Kf1arcZ7Uq91mtyn02q3KfzarcZ6tW7tOY1slLbUNYTetU7rNZlftsVuU+m1W5z2ZV7rNZlftsVuU+m1W5z1as3Kc1bVhNa+WlrMp9tmLlPq1pa3mp1rS1vFRjWrp1/p0+sbfRraPAsHkgwLB5IMAEYHIwbB4IMOzcpvtwG906Cgw7twIMO7c5GLp1FBhj53sOxtj5noPhbTMCTGDwUoNHt44Cw86tAMPOrQDDzq0Aw3sWczB06ygwZL4CDJmvAEPmK8AEYHIwOF8Bhsw3P0TSraPAkPkKMGS+ORi6dRQYMl8BhsxXgCHzFWACg5caPLp1FBgyXwGGzFeAIfMVYMh8czB06ygwZL4CDJmvAEPmK8AEYHIwOF8Bhsw3P0TSraPAkPkKMGS+ORi6dRQYMl8BhsxXgCHzFWACg5caPLp1FBgyXwGGzFeAIfMVYMh8czDGzToNMGS+AgytOj8+nFTHbLTqaDQBGoXG1/820fg64CaaF3vgfl1P26v7gHpeulO5z2ZV7rMVK/dpTVvLxrWmreXMWtOG0wvprcp9Nqtyn82q3GezKvfZrMp9dqtyn92q3Ge3KvfZrcp99iGspnXyUnu1cp/GtE5earcq99mtyn12q3Kf3arcZ7cq99mtyn12q3Kf3arcZy9W7tOa1qkocS9W7tOa1qncZy9W7tOatpaXak1by0u1pmXnNn1ib6dbR4Fh80CAYfNAgGHzQIBh80CAYec23Yfb6dZRYNi5FWDYuRVg2LkVYAIwORhj53sOhrfNCDA439zg0a2jwLBzm4OhW0eBYedWgOE9iwIMma8AE4DJwZD5CjBkvgIMzleAwfkKMGS++SGSbh0FhsxXgCHzFWDIfAWYAEwOhsxXgCHzFWBwvrnBo1tHgSHzzcHQraPAkPkKMGS+AgyZrwATgMnBkPkKMGS+AgzOV4DB+QowZL75IZJuHQWGzFeAIfMVYMh8BZgATA6GzFeAIfMVYHC+ucGjW0eBIfPNwdCto8CQ+QowZL4CDJmvABOAycHQqvPjw0l1zE6rjkbj636baHz9bxONrwNuoXl1hVC/rqf91X1APS/dqdxntyr32YuV+7SmrWXjWtPWcmataa1eSG9V7rNblfscVuU+h1W5z2FV7nNYlfscQ1hN61Tuc1iV+xxW5T5HtXKfxrRWXqpauU9jWqdyn8Oq3OewKvc5rMp9/v/tXdGu5MaN/Zc8z4PIKpJV37JYBIk3CAwYceAkC+yD/327595W90yrWhZHh7d0VS+Gry3qUGweVvVpllhPNdynnmq4Tz3VcJ96quE+9ZMN91l52k823GftaU+1lzrVcJ/6yYb7rD1tPtXTfq691NrTjjO3ix17dczWaQVmnDxoBGacPFgOzJln67wOzDh50AjMOHO7eB6ujtk6rcDkEZjlwIwzt43AjDO3jcCceOf7OjAn3vm+Dsx428xyYMZsncYGb8zWaQVmnLltBGacuW0EJo/ALAdmvGexEZih+TYCMzTfRmCG5tsIzNB8lwNz5tk6rwMzdr6NwAzNd/lL5Jit0wpMHoFZDszQfBuBGZpvIzBD820EZmi+jcAMzXc5MGO2TmODN2brtAIzNN9GYIbm2whMHoFZDszQfBuBGZpvIzBD820EZmi+jcAMzXc5MGeerfM6MGPn2wjM0HyXv0SO2TqtwOQRmOXADM23EZih+TYCMzTfRmCG5tsIzNB8lwMzZus0Nnhjtk4rMEPzbQRmaL6NwOQRmOXADM23EZih+TYCMzTfRmDGVJ3rxQujY+qYqtMMTT3v7nc1NOfd/66G5rw74NXQBO+B95v1VKPnAe3p+pmG+9RTDfepn2y4z9rTfq5t3NrTfq6d2cunpWk603Sf6+OeaLzP9XFPNN/n+rgnGvBzfdx8rsc90Yif6+OeaMbP9XFPNOTn+rgnmvJzfdwTjfm5PO6Z5vxcH/dcu6rPNuln7XHPtas606yf6+OeaNjP9XFPNO3n+rgnGvdzfdwTzfu5Pu6JBv5cHvdME3+uj3uikT/Xxz3R/MTr455ogOL1cfO5HvdEY3+uj/u5dlWrj/u5dlWrj/u5dlWrjztO5C71810iM0bvNCMzTia0IjOOJrQiM84mtCKTR2QakRnncpfOzF0jMw7mtiIzTua2IjOO5rYiM87mNiJz5iE8K5E58R54JTLjxTStyIw9cGOnNwbxNCMzTui2IjOO6LYiM87otiIzXszYiszQgRuRGeN4mpEZOnArMkMHbkVm7IFbkckjMo3IDB248Y1yDOVpRmbowK3IDB24FZmhAzcic+bBPCuRGTpwKzJDB25FZuyBGzu9MZynGZmhA7ciM3TgVmSGDtyKzNCBW5EZOnAjMmNETzMyQwduRWbowK3IjD1wKzJ5RKYRmaEDN75RjkE9zcgMHbgVmaEDtyIzdOBGZM48rGclMkMHbkVm6MCtyIw9cGOnNwb2NCMzdOBWZIYO3IrM0IFbkRk6cCsyQwduRObEI3vWIjMm9lwvfh5Lc43NGNnTjs1598HrsckjNs3YnHcvvB6bxd2wlXJ7H7DVKa08L5ci71dz5Yfn1cXnpWn2n7M+RCfdfLIOfTrRvJ/r455q4A99soE/q4/7uTZgq4/7ufZUq497qlfT05TP9binGvhD5xr4Q+ca+EPnGvhD5xr4Q+ca+EPnGvhD5xr4Q+ca+EOfbeDP2uOea1f12Qb+rD3uqQb+0LkG/tC5Bv7QuQb+0LkG/tC5Bv7QuQb+0LkG/tAnG/iz+rinGqNIn2zgz+rjnmrgD32ygT9rj/vJpvisPu7n2lWtPu44X7vci0dj3k4zMnlEphGZcbagFZlxtqAVmXG2oBWZcb52+dwbjXk7rciMeTvNyIzzta3IjPO1rciceA+8Epk8ItOIzHjHTCsyYw/c2OmNeTvNyIzzta3IjPO1jciMeTvNyIz3LLYiM3TgVmSGDtyKTB6RaURm6MCtyIw9cCsyYw/ciszQgRvfKMe8nVZkxrydZmSGDtyKzNCBW5EZOnArMnlEphGZoQO3IjP2wI2d3pi304zM0IFbkRk6cCMyY95OMzJDB25FZujArcgMHbgVmTwi04jM0IFbkRl74FZkxh64FZmhAze+UY55O63IjHk7zcgMHbgVmaEDtyIzdOBWZPKITCMyQwduRWbsgRs7vTFvpxmZoQO3IjN04EZkxrydZmSGDtyKzNCBW5EZOnArMnlMk/nT8jQZGpN2XsTmvPvg9dicdye8Hpvz7oXXY3OqV7/yJxtTtPq4pxpTxOcaU8SfbEzR6uPmcz3u59oJrj7uqV6oz+caU8TnGlPE5xpTxOcaU8TnGlPE5xpTxOcaU8TnGlPE5xpTxOcaU8SfbUzR2uOea1f12cYUrTzuucYU8bnGFPG5xhTxucYU8bnGFPG5xhTxucYU8bnGFPEnG1O0+rjn+gXwk40pWn3c3ndVMt0fV/Pa41qZXSkTPz7u88Wvu5C4+4lGHxeZ3vdqHxeZPCLTiEzvO0BgZF6e3uDuJxp9XGR631d+XGR634J+XGR6361+WGS6n2j0cZEZe+DGqt39RKOPi8zYA7cik0dkGpE58R54JTIn3gOvRObEe+CVyJx4D7wSmRPvgV9HpvuJRh8XmbEHbkVm7IFbkTnxHvj1N8ruJxp9XGSGDtyKzNCBW5EZOnArMkMHbkVm7IEbq3b3E40+LjJjD9yKzNgDtyIzdOBWZPKITCMyQwduRWbowK3IDB24FZmhA7ciM/bAjch0P9Ho4yJz4j3w62+U3U80+rjIDB24FZk8ItOIzNCBW5EZOnArMufdA6+9p5G7n2n0kbE57z54NTbdzzX6yNicdy+8Hpv13bDKyvMy1RsI80N0Slq4WMrtYZXuN6bLB/DuUNrBIU40O1Sn1w6R1HtAlR4OV5Y5SLlDnyTaJ0tabj5ZqrLgk3bokwX79HhxFnm8+N2j0p1HtTeP/sCIkmiPqDuPuDuPUnce5e48ku480u486q5m1+5qdu2tZqept5qdpt5qdpp6q9lp6q1mp6m3mp2m3mp2mnqr2WnqrWanqbeanabuajZ1V7Opu5pN3dVs6q5mU3c1m7qr2dRdzabuajZ1V7Opu5rN3dVs7q5mc3c1m7ur2dxdzebuajZ3V7O5u5rN3dVs7q5mp+5qduquZqfuanbqrman7mp26q5mp+5qduquZqfuanbqrmbn7mp27q5m5+5qdu6uZufuanburmbn7mp27q5m5+5qdu6uZkt3NVu6q9nSXc2W7mq2dFezpbuaLd3VbOmuZkt3NVu6q9naXc3W7mq2dleztbuard3VbO2uZmt3NVu7q9naXc3W7mq2dVezrbuabd3VbOuuZlt3Ndu6q9nWXc227mq2dVezrbuaXbqr2aW7ml26q9mlu5pduqvZpbuaXbqr2d2dg0zdnYNM3Z2DTN2dg0zdnYNM3Z2DTN2dg0zdnYNM3Z2DTN2dg0zdnYNM3Z2DTN2dg8zdnYPM3Z2DzN2dg8zdnYPMU281O3d3DjJ3dw4yd3cOMnd3DjJ3dw4yh5+DXH9zTQ4/CflHfOIOfUod+pQ79Km/N0Zl6u+NUTn8VOQf8al06FPtz6fG2cikt7eplcu2asWnS+G9oVzy8/7qNTJaujqx3K6+fIWcrzZeuNhour0pzyjT64urJX6/uFr+5hVwi4EseY7kpSYuxIZGbJqx4RGbZmz6eyNjDj+7+kd8kg592nl9/W7z/HxxyrfXeya9v5vU6s2fxbX1wpb5Dag2TSv+GHGaySDldX5fQvR+raY7gYno5lDZw6FiN4d40hXClXTziIveb738ctiDvEr28sdff/v5l19+/vuff/n1p7/8++df//Gvq+l0/cdyDupcdkwenou+Zspymrw2KdtN6maT5XO8r01ouwlvN0nbTfJ2k8USZ3VeJadnE91uYttNynaT1vZ1rozpe5PmicAXJrTdhLebLH76dbqZVHo2ydtNZLuJbjdZ/PRrutXBmsuTSdluUjebLJ8tem1CKyYPy+nNhLebpO0my5/+/G7uWuqTiWw30e0mtt1keQmf6L5c6bcBWNiNl9uiLA8LOL29Jn35yMSOAMsnIPYEIDQAowESGiCjAQQNoGgAQwOgmaxoJhuayYZmsqGZbGgmG5rJhmZy2SGLhG97LEn0BLDDZyD5pjLJ48bnHWDzZ3A1Eo+ROoyqgANcd6jFIjeBUB6vfQcwNEBBA1QwAE170EhoRtBnBIIjMBwhwREyHEHgCApHMHBNpqnAESoagSY4AsERGI6Q4AgZjiBwBIUjwDlNcE4TnNMM5zTDOc1YTl/+ouuVjb6iaf7Zp0z2oKjWr5bctrw4SLOD6cHBsvQ71yzbXn6Ce7z0GgDB3l5//PZp/tXw4Ufx99vbDre/fXim6fvbF+zt64/fvtzEYqv23e2b9Nzp9vTDty/zL5Mlf585TWJuuf3tW0YR/f726cdvb7ePtjwHJ+94+/odrS5/pBel4fLd4wZy2Tr+McZQltlG9Y/R4LVN3W7TSNjXNuSwYYdNctjk7TaNXzdfLxT5azZMjddoSZlpoOmht4MXmwWq2Jyi9aFL43L52ze2EgFSA0Aa76/aGYT2AJl/D7/+e34G4QiQFAGSI0AkAkQjQCwCpESA1AAQmyJAIhhvEYy3CMZbBOMtgvEWwXiLYLxFMN52YPz1/fP3vW56BilTBAhFgHAESIoAyREgEgGiESAWAVIiQCIYXyMYXyMYXyMYXyMYXyMYXyMYXyMYX3dhvD2A2AJIiQCpeJBGu8DeIBQBwhEgKQIkR4BIBIhGgFgESIkAiWA8RTCeIhhPEYynCMZTBONpD8ZfcnQGufzxDKIRIBYBUiJAagAITxEgFAHCESApAiRHgEQwniMYzxGM5wjGcwTjUwTjUwTjUwTjUwTj0y6Mvx91v/w7PYNIBIhGgFgESIkAqQEgeYoAoQgQjgBJESARjM8RjM8RjM8RjM8RjM8RjJcIxksE43UXMs6virh+dbNnkD1S2ModxIo8g1gESIkAqQEge7SUrINQBAhHgKQIkBwBIhEgEYy3CMZbBOMtgvElgvElgvElgvElgvG7tJQUvvfNF07PIBIBohEgFgFSIkBqAMguLSWrIBQBwhEgKQIkgvE1gvE1gvE1gvE1gvE1gPE8TREgFAGyC+P1/u23KD2DpAiQHAEiESAaAWIRICUCpAaA7NJSsgpCESARjKcIxlME4ymC8RTBeIpgPEUwniIYv0tLSbkfcrn8e34GoQgQjgBJESA5AkQiQDQCxCJASgRIDQBJEYxPEYxPEYxPEYxPEYxPEYxPEYxPEYzfpRGj3t+gdJGd7Blkh+y6lPL5fSqXirvwJDkCRCJANALEIkBKBEgNANmjfWEdhCJAOAJkK+PfrLLLSlxW6rIyl1VxWVWP1eY33bxZkcuKXVau3FBXbqgrN9SVG+rKDXXlhrpyw1y5Ya7cMFdumCs3zJUb5soNc+WGuXLDXLlhrtwortwortwortwortwortwortwortwortwortwortyortyortyortyortyortyortyortyortyortyontxI0+SyIpcVu6ySyyq7rMRlpS6r5dxQtdmqrIyhvdTv92svn8h8qdA7QEEDVDBA45e+HQEIDcBogIQGyGgAQQMoGgDNZEIzmdBMZjSTGc1kRjOZ0UxmNJMZzWRGM5nRTGY0kxnN5IRmckIzOaGZnNBMTmgmJzSTE5rJCc3khGZyQjM5o5mc0UzOaCZnNJMzmskZzeSMZnJGMzmjmZzRTBY0kwXNZEEzWdBMFjSTBc1kQTNZ0EwWNJMFzWRFM1nRTFY0kxXNZEUzWdFMVjSTFc1kRTNZ0Uw2NJMNzWRDM9nQTDY0kw3NZEMz2dBMNjSTDc3kgmZyQTO5oJlc0EwuaCYXNJMLmskFzeSCZnJBM7mimVzRTK5oJlc0kyuayRXN5IpmckUzuaKZXMFMztOEBiA0AKMBEhogowEEDaBoAEMDFDTAViZ/tdrcuPVmRS4rdlkll1V2WYnLSl1W5rIqLitXbrArN9iVG+zKDXblBrtyg125wa7cYFdusCs32JUbyZUbyZUbyZUbyZUbyZUbyZUbyZUbyZUbyZUbyZUb2ZUb2ZUb2ZUb2ZUb2ZUb2ZUb2ZUb2ZUb2ZUb2ZUb4soNceWGuHJDXLkhrtwQV26IKzfElRviyg1x5Ya6ckNduaGu3FBXbqgrN9SVG+rKDXXlhrpyQ125Ya7cMFdumCs3zJUb5soNc+WGuXLDXLlhrtwwV24UV24UV24UV24UV24UV24UV24UV24UV24UV24UV25UV25UV25UV25UV25UV25UV25UV25UV25UV25UT27INLmsyGXFLqvkssouK3FZqcvKXFbFZeXKDZcuKi5dVFy6qLh0UXHpouLSRcWli4pLFxWXLiouXVRcuqi4dFFx6aLi0kXFpYuKSxcVly4qLl1UXLqouHRRcemi4tJFxaWLiksXFZcuKi5dVFy6qLh0UXHpouLSRcWli4pLFxWXLiouXVRcuqi4dFFx6aLi0kXFpYuKSxcVly4qLl1UXLqouHRRcemi4tJFxaWLiksXFZcuKi5dVFy6qLh0UXHpouLSRcWli4pLFxWXLiouXVRcuqi4dFFx6aLi0kXFpYuKSxcVly4qLl1UXLqouHRRcemi4tJFxaWLiksXFZcuKi5dVFy6qLh0UXHpouLSRcWli4pLFxWXLiouXVRcuqi4dFFx6aLi0kXFpYuKSxcVly4qLl1UXbqounRRdemi6tJF1aWLqksXVZcuqi5dVF26qLp0UXXpourSRdWli6pLF1WXLqouXVRduqi6dFF16aLq0kXVpYuqSxdVly6qLl1UXbqounRRdemi6tJF1aWLqksXVZcuqi5dVF26qLp0UXXpourSRdWli6pLF1WXLqouXVRduqi6dFF16aLq0kXVpYuqSxdVly6qLl1UXbqounRRdemi6tJF1aWLqksXVZcuqi5dVF26qLp0UXXpourSRdWli6pLF1WXLqouXVRduqi6dFF16aLq0kXVpYuqSxdVly6qLl1UXbqounRRdemi6tJF1aWLqksXVZcuqi5dVF26qLp0UXXpourSRdWli6pLF1WXLqouXVRduqi6dFF16aLq0kXVpYuqSxdVly6qLl1UXbqounRRdemi6tJFzaWLmksXNZcuai5d1Fy6qLl0UXPpoubSRc2li5pLFzWXLmouXdRcuqi5dFFz6aLm0kXNpYuaSxc1ly5qLl3UXLqouXRRc+mi5tJFzaWLmksXNZcuai5d1Fy6qLl0UXPpoubSRc2li5pLFzWXLmouXdRcuqi5dFFz6aLm0kXNpYuaSxc1ly5qLl3UXLqouXRRc+mi5tJFzaWLmksXNZcuag1d1IRvVibp2YpdVslllV1W4rJSl5W5rIrLqnqsGrrompUrN9SVG+rKDXXlRkMXLfNg9ZpIHq2eX7yVreT3i3NhfoZQPIThIQoeosIhGsLvrhC0A4SlGWKa5ouJpncMDsBIARg5AEMCMHageKH6frFQlW8wnq+WfKtqksv9WtZ3f6wzf0pn/tRgf5LQLYNSnfg5g8rUnUfUnUfcnUepO49ydx5Jdx5pdx5Zdx6V7jzqrmbX7mp27a5m1+5qdu2uZtfuanbtrmZXbM1+w7AAjBKA8eOVUphuUqHwZdf8PUaZpgAMCsDgfTFSWsBIARg5AEN2wCh3jLr0eWgAhuExaIfP/HLFDSNlXsD48VjplKf3i3XSvICxNVZvVsVlVT1WvEOVSKJzpLU+R4F3YJemGePyO8wChgRgaACGBWCUAIyKx0hTAAYFYOywiuq8A2xgpACMHIAhARh78LzefuYQo4XdQLIAjBKAUfEYeQrAoAAMDsDYgeeXH9RnDFvCyAEYEoChARi2BwbdMRZ2mbkEYFQ8hkwBGBSAwQEYKQAj74vx0DR1x5AADA3A2IHnlwX7hlFkoZZICcCoeAydAjB24HmhfMf4lh8LuuJ0u3Omhz3l+2/mRbkzf1Jn/uTO/JGP84fLgj/amT/WmT+lM39qsD9yX6BUn/2xqTN/qDN/uDN/Umf+5M78kc780XB/5p83VBb8sc78KZ35U/vyp3RWn0tn9bl0Vp9LZ/W5dFafS2f1uWhn/nRWn0tn9bl0Vp/r1Jk/ndXn2ll9rp3V59pZfa6d1efaWX2u1pk/ndXn2ld9rlNf9blO1Jk/fdXnOvVVn+vUV32uU1/1uU591ec69VWf61Q686ez+kyd1WfqrD4Td+ZPZ/WZOqvP1Fl9ps7qM3VWn6mz+kx9/T5YeY/6PL/aQyqnNX9obuDg+42z8rs/1Jk/3Jk/qTN/cmf+SGf+aGf+WGf+lM78qVB/vmKkKQCDAjB2qI01zScCq/ACxo/XO53mF/jpVGQlP9bO9tUdTrvs7ZF055FCPXrDsACMEoBRd8BY+Tx2OEmzjkEBGByAkQIwcgCGBGBoAIYFYJQAjACeSwDPJYDnEsBzCeC5BPBcAnguATyXAJ5LAM8lgOcawHMN4LkG8FwDeK4BPNcAnmsAzzWA5xrAcw3guQXw3AJ4bgE8twCeWwDPLYDnFsBzC+C5BfDcAnheAnheAnheAnheAnheAnheAnheAnheAnheAnheAnheA3heA3heA3heA3heA3heA3heA3heA3heA3he4TznaZoCMCgAgwMwUgBGDsCQAAwNwLAAjBKAEcBzCuA5BfCcAnhOATynAJ5TAM8pgOcUwHMK4DkF8JwDeM4BPOcAnnMAzzmA5xzAcw7gOQfwnAN4zgE8TwE8TwE8TwE8TwE8TwE8TwE8TwE8TwE8TwE8TwE8zwE8zwE8zwE8zwE8zwE8zwE8zwE8zwE8zwE8zwE8lwCeSwDPJYDnEsBzCeC5BPBcAnguATyXAJ5LAM81gOcawHMN4LkG8FwDeK4BPNcAnmsAzzWA5xrAcwvguQXw3AJ4bgE8twCeWwDPLYDnFsBzC+B5CeBgCeBgCeBgCeBgo8dLyu09L0UTv8ag6+mk96vpekri9eWJ58GPie3h3u8OWW8OlXCHLm7cHEr54RNeuDbT7Hwmkyfn64Gdb/S7HcR5OrLzfGTn05Gdz0d2Xo7svB7ZeTuy80deYeuBV1iaDrzC0nTgFZamA6+wNB14haXpwCssTQdeYWk68ApL04FXWJoOvMLSdOQVlo68wtKRV1g68gpLR15h6cgrLB15haUjr7B05BWWjrzC0pFXWD7yCstHXmH5yCssH3mF5SOvsHzkFZaPvMLykVdYPvIKy0deYdORV9h05BU2HXmFTUdeYdORV9h05BU2HXmFTUdeYdORV9h05BU2H3mFzUdeYfORV9h85BU2H3mFzUdeYfORV9i8S523fHe+6OPlX0Fkh3p8fTfZDeT6fpZnEIoA4QiQFAGSI0AkAkQjQCwCpESA1AAQjWC8RjBeIxivuzB+vpquPWXPIDkCRCJANALEIkBKBEgNALEpAoQiQDgCJILxFsF4i2C87cH4C9vuIAvbVLMIkBIBUgNAyhQBQhEgHAGSIkByBIhEgEQwvkQwvkQwfo+TqczzUejLvz8cb76B7HGCdB2EIkA4AiRFgOQIEIkA0QgQiwApESABjOdpigDhCJAUAZIjQCQCZI8fL5lmkAvKyuWv3xvBuxxb2dOhXY6ibHNoN9mfdzmK8mHO85GdT0d2Ph/ZeTmy83pk5+3IzpcjO18P7DwfeYXlI6+wfOQVlo+8wu5yFOXDnD/yCstHXmH5yCssH3mF5SOvsOnIK2w68gqbjrzCpiOvsLscRfkw54+8wqYjr7DpyCtsOvIKm468wuYjr7D5yCtsPvIKm4+8wu5yFOXDnD/yCpuPvMLmI6+w+cgrbD7yCitHXmHlyCusHHmFlSOvsHsc3vo454+8wsqRV1g58gorR15h5cgrrB55hdUjr7B65BVWj7zC7nFY8uOcP/IKq0deYfXIK6weeYXVI6+wduQV1o68wtqRV1g78gq7x+Hkj3P+yCusHXmFtSOvsHbkFdaOvMKWXep8Knfn5ZvL30BSBMgedTNNPIMklmeQXeqb3t9pxrU+g2gEiEWAlAiQGgCyy5DgVRCKAOEIkBQBkiNAIhhfIxhfIxi/y5DVpHKvwvW5Cu8yDHUFJO0ytHQVhCJAOAIkRYDkCBCJANEIEIsAKREgEYynCMbvcsI8632bmis/g3AESIoAyREgEgGiESAWAVIiQGoAyC4naVdBIhjPEYznCMbvctJT5L5NvVg+g0gEiEaAWARIiQCpASC7nOxbBaEIEI4ASREgEYxPEYxPEYzf5cSVpvnN26TP77lKu5yMWgWpASC7nDRaBaEIEI4ASREgOQJEIkA0AiSC8TmC8bucqDCyGcTS00ux0y4nH1ZBKAKEI0BSBIhEgGgEiEWAlACQ5b62KtPth9YqbLMV0fT7f1/+kuu1VJd363myWwHIU53uxtffUp+uZtXp/WrWcr/662/TVJf36vtCEB6C8RAJD5HxEIKHUDyE4SEKHgLP7oxnd8azO+PZnfHsznh2Zzy7M57dGc/ujGd3xrNb8OwWPLsFz27Bs1vw7BY8uwXPbsGzW/DsFjy7Fc9uxbNb8exWPLsVz27Fs1vx7FY8uxXPbsWz2/DsNjy7Dc9uw7Pb8Ow2PLsNz27Ds9vw7DY8uwue3QXP7oJnd8Gzu+DZXfDsLnh2Fzy7C57dBc/uimd3xbO74tld8eyueHZXPLsrnt0Vz+6KZ3dFs5unacJDEB6C8RAJD5HxEIKHUDyE4SEKHgLPbsKzm/DsJjy7Cc9uwrOb8OwmPLsJz27Cs5vw7GY8uxnPbsazm/HsZjy7Gc9uxrOb8exmPLsZz+6EZ3fCszvh2Z3w7E54dic8uxOe3QnP7oRnd8KzO+PZnfHsznh2Zzy7M57dGc/ujGd3xrM749md8ewWPLsFz27Bs1vw7BY8uwXPbsGzW/DsFjy7Bc9uxbNb8exWPLsVz27Fs1vx7FY8uxXPbsWzW/HsNjy7Dc9uw7Pb8Ow2PLsNz27Ds9vw7DY8uw3P7oJnd8Gzu+DZXfDsLnh2Fzy7C57dBc/ugmd3wbO74tld8eyueHZXPLsrnt0Vz+6KZ3fFs7vi2Y3vVSN8rxrhe9UI36tG+F41mjIeQvAQiocwPETBQ+DZje9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuF71Qjfq0b4XjXC96oRvleN8L1qhO9VI3yvGuN71Rjfq8b4XjXG96rxlPEQgodQPIThIQoeAs9ufK8a43vVGN+rxvheNcb3qjG+V43xvWqM71VjfK8a43vVGN+rxvheNcb3qjG+V43xvWqM71VjfK8a43vVGN+rxvheNcb3qjG+V43xvWqM71VjfK8a43vVGN+rxvheNcb3qjG+V43xvWqM71VjfK8a43vVGN+rxvheNcb3qjG+V43xvWqM71VjfK8a43vVeHuv2ptZ8plln5n4zNRnZj6z4jOrLrPtvVRvZssZRVJvZpdf3X8soxr9UbtCJDxExkMIHkLxEIaHKHiICodo9EftCoFnt+HZbXh2G57dtpndb2bqMzOfWfGZVZdZmXxm5DNjn1lymTV+jL781D6b1Wez1Php9vLfb2Yp2YIZ+czYZ5Z8ZssMuPxgdTO7aPQLZuozM59Z8ZlVl1njt7pVM/KZsc8s+cyyz8yXJeTLEvJlCfmyhHxZwr4sYV+WsC9L2Jcl7MsS9mUJ+7KEfVnCvixhX5YkX5YkX5YkX5YkX5YkX5YkX5YkX5YkX5YkX5YkX5ZkX5ZkX5ZkX5ZkX5ZkX5ZkX5ZkX5ZkX5ZkX5ZkX5aIL0vElyXiyxLxZYn4skR8WSK+LBFflogvS8SXJerLEvVlifqyRH1Zor4sUV+WqC9L1Jcl6ssS9WWJ+bLEfFliviwxX5aYL0vMlyXmyxLzZYn5ssR8WVJ8WVJ8WVJ8WVJ8WVJ8WVJ8WVJ8WVJ8WVJ8WVJ8WVJ9WVJ9WVJ9WVJ9WVJ9WVJ9WVJ9WVJ9WVJ9WVJdWZKnyWdGPjP2mSWfWfaZic9MfWbmMys+M1+W+LTX3FJDpcxmqgtm2WcmPrPG55bnbgCWbxX659+ztE78frVWkt+//T0rt5TTPSHKDhCFZojC9QmiwiFa6u2eEISHYDxEwkPkPSA0zRDlKWlbyvSeEIqHMDxEwUNUOESa8BCEh2A8RMJD4Nmd8OxOeHYnPLsTnt0Jz+6MZ3fGszvj2Z3x7M54dmc8uzOe3RnP7oxnd8azW/DsFjy7Bc9uwbNb8OwWPLsFz27Bs1vw7BY8uxXPbsWzW/HsVjy7Fc9uxbNb8exWPLsVz27Fs9vw7DY8uw3PbsOz2/DsNjy7Dc9uw7Pb8Ow2PLsLnt0Fz+6CZ3fBs7vg2V3w7C54dhc8uwue3QXP7opnd8Wzu+LZXfHsrnh2Vzy7K57dFc/uimd3hbNbpgkPQXgIxkMkPETGQwgeQvEQhocoeAg8uwnPbsKzm/DsJjy7Cc9uwrOb8OwmPLsJz27Cs5vx7GY8uxnPbsazG9+rJvheNcH3qgm+V03wvWqC71UTfK+a4HvVBN+rJvheNcH3qgm+V03wvWqC71UTfK+a4HvVBN+rJvheNcH3qgm+V03wvWqC71UTfK+a4HvVZJdetZcHVWSXXrXXELv0qq1AEB6C8RAJD7HM7hfvP/uy6eo3EIkA0R8HeX3kRhr9artCFDxE3QPiZZ3SCQ9BeAjGQyQ8RMZDCB5C8RCGhyh4CDy7Dc9uw7Pb8Ow2PLttD3a/3iKY4CE2U+/NrPjMqsusbH+f7eUvvV67/E2QaKJ3UyJ+OJ9P+Yq4/N1uzSh7jMRjpJuNLn/Z9dpl3VzT7TXEZbpnCE3la/h5u0nabpK3m8h2E91uYttNynaTutlkWYe97DpvJrl8Y/JcGpLeXiOdSpqv5aJfb0/Y2zP29mnb7a8mebuJbDfR7Sa23aRsN6mbTfK03YS2m/B2k+VPv+SbSa1/PLksf59cy5V+v9sL9vaKvb1hb1+wt6/Q2y/rb/vdnna8/XNRXdbd9rt9wt5+kbWV9d2kPm4h3+rIsnr22kS3m9h2k7LdpG42WdaSXpvQZpPlb4OvTdJ2k8VPn/MtYVjt+4RZ/vb12kS3m9h2k7LdpG42Wf7S9dpk8dNns5tJfWLl8umW1yZpu0nebiLbTXS7iW00ufxV2t9rjW/f9U0e5rQRtXdFr03ydhPZbqIbTX6//Pm/f/nt57/89Ze//eticv2///nHT//++dd/vP/57//75+3//PW3n3/55ee///mfv/3609/+5z+//e3Pv/z60/X//Wl6/8d/US5fSOt1F3z9i+ULJbn89bVNlZJ+oUzXP+nrtZf/m+36QdDV/u0a+8J8/U88/ye2L+nrf0rzf0r8JX01zDfg6ztkv1zf4niDnq53n2QGv77n+sv1zc43+Ov7e79cX6t7vY/M99HLd3/Wiw/v96kXj6iyzfeRkr5c/lHm+0i9IEvNs1JytUvTlzzdbC5BkTQrB1//02V9tel2i5q+VJkTsmX+++Xj+n8=",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_notes_internal",
        "get_collapse_hints",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "pack_returns_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAAABAEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAABpAJTHa0fem\nFpVeVHRVHDrOMz4ar4NvM8LEUk24fAjpLwzFd54AFiN29UhWw9QcYsqwMZA9MncSZ9QQ2+JUpXwd\nSJT+SO7Aq7JucrPJsLDyL/q1MS8431ko1/ynkDkaFS8sXrq9EeAU81X9IJ1D7wNKa1i0Yyj8neoJ\n0NdghqCaBwPjdkPVKIiMLIki802N3jGYCsqySng8y2CiL40Y1sQk7Ihn0AtrZfUyJ6W6Jr5tjfm+\nS5ey7F0ruzJKG+jAEwHaX1vGvWQ4kOz12QrTxVRRYWzhk5HL0LqzxUw1bYFTB5jML4j09ccpIoyj\nzYWqbjodV92ML8UcysZlcT4BFH4n6MT/tPSXL7y+LgplV6G0V4KE8HF15kIBfLk88bU5qQ0kmV5T\n/SieEcBnCGGFg12DiA2lXFLJ/4+t4FfeiRqJJfbPei0aSXopjUeIuLnxqXZaaZ02WUw52qlL42PK\n5j4d0Y0XLR07lmk+kzMexLvpOjtRnVIehh8dDLiAmVIZzSqHEK2Ho8Be1crPjUEI0RcDAhlQKym3\nfWCHWE9j4fULFkcUI7/Z7Gm2oKkCJbDBGMqfNvl0/qkF4/N+keqIqvUZJzYSCKGqdVTkhv77BKs7\nDnvkdomCDMzuat/kpMSSDR9s3EKsr/m9QN3sgQqNtknSmjqeoLoXKlcSE9yphQe1Cumr66Mimx9t\nvLGSwUzJs3eSg8QH8PUOwKjjG51Mu7gUNXkK7PH1wuUBaFOnqjTlmYHayxh7sMRMlrextZS/XSFG\n85rLQ0jDoiCXk018zWEdi+PBBBkvlxoh4FfWgDTVFnBKRl8+Y3wmtrlcia8kun2sl27EPMbNRo9u\nzIqbqRoJx+egEKEgjN/w2aVPrezFrYHLvYLuZWeDyh686zv3NRtze3/oW7M7Lj5mzorRF5KJe+YR\nAzJiOhGePkzwU1M3LEv0xpRKKx23fHou4o8ip2pIhobS47HnYlnbt9RF754c8nArXjQow5L3iVIO\n9i+qS9jd7VedNeqp83J31n+XDCIPxiJocLmhx+x2t3Pp8s+OqSws2vflrAgfCNXw/TD+Kvnrz30f\nlksHZBOItjEeIc7CduGs3t6OFuNDwR/t7Q8ngi/3u5SDsp35d4XuX53STwoM84ypMWvkAMdDu7s7\n7AHWqxqveUTCvgSupAYNcUaNR9MftIDiwZLdtmc+XL6oALUGuHiB7Nl2/ajUnFEAJhSSgLtU6/zZ\nwgO59uL9eowfLPRK3e2+r7RvLxQgKSbrSzBA0fRNXQ8JEHMY8HH7IwIou9hTP7HY/hfM+dE45ZDi\nyiP2C+O9gPtVYLymrhWXB/DLSOrLT+cP1xa2EI13JbbJuZ2JSj4WF33zdnEupIkGhXuZ4eRw3I/M\n+u02UwfWgDfRqNFckYuQwGrH73xJWgl8clrPWs6Ryyl5Nuv3UnFNSScuHGcfbWO7iO6hdY5SKdUB\nJQgpbu/KBavBa+KAao/+vf/sM+MxixF6SyoyAdQDNUMbpAleqyIMQL2OozVNoMvw0qUmgcHeCool\n+peMGCCkBg+eDGcux4I2rCQLP7B8rk5zDkCo6zqb6aEC0i3SEa+OYuXFo2UwRd0dr0Y4Txi9E136\nzjY1+VM6HmQZU40kLb6vHif2ldzYOvxlj2qkweZE7w4zi6IoLv/bTtTbpgdRHTEnDUQLj5nfIpa7\n2y5K3cQcCH7+Fw0p0pEomxG3K9D3Rp7n4ejddFJ7mt+UAQM/hUZJj4MPBvpIHS3HdKsatgUx1Zg3\nLuFh/Jx9dgR4hgSN/VPEqrmnuqFo+6aXcRdZJYr7ukSVM0XoxGhs+PQXL3V1X6c6s64ndky4/Uyw\nEY4vfXn5x7bLXVx4roZQ/8mZtg+jeufiDNPgF+mYxOMiz2mZauRxBWvK57PDjLw6zG3vQWTYeLVu\nWy/iv6UhmQdcwsPJ4web7IZ2SqXP0COWI4OcUb5v/oPHfIC4+UrVDF3W4p6skHbML1mV/PJ8jIi0\nhSmJGb9xZEQJQtb2xa0J/Fb1ohItHtk1OGC6aKtbesQ2+IiZmkj3nvIS5kg/FAiDSZwiZljYO00M\nx7CMFdrOTiO/QbVeMJi9joLnSxweHyaMCUW96klPv8UuhYHBXANz2LKGv3JzAVcaVOFjbncBuS+S\nBCriVW4xz3LMOZDGt+dwweYuJQTOmG8hMk/5OTA4/+YoThdERaDrEaY+C3AHIgwsAvTsLBxfrakF\na4w3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAijZgVPiaqE5xfmVoS1rgoNE5801i7AI+iWU9C4gWKTaCru9sEL+XedxRom0sZjL\n672Za6gt1ILAzZ+T26XJSPEPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvJ8qczwFCmSOmHYcsfCJMQmRoHJE2ov3nE3M173Fv7N4Z\nKxptOxTf5amtY5UdLXZt9e5ME1hEP1oUCGtRluE+Rg=="
    },
    {
      "name": "check_dkim_key_hash_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5886526716701834683": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_private can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_returns_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "register_dkim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim"
      ]
    },
    {
      "name": "get_managed_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_managed_escrows"
      ]
    },
    {
      "name": "check_dkim_key_hash_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgIEASYCAwQAHxgAAwACgEMtCIBDAAEkAAAARi0EAAGARCcCAAIEgEQmAgMEAToNAAIAAyQAAAPxLAgBAwAAAQIBJgIEAQAsDgQDLAgBAwAAAQIBJgIFAAAsDgUDLAgBAwAAAQIBJgIGAAIsDgYDHgIAAwAeAgAGADI4AAMABgAHJgIDAQEjAgAHAAAApSQAAAQaHgIABgkmAgcAAQo4BgcIIwIACAAAAMEkAAAELCYCBgAFLAgBByYCCAQDABABCAEmAwcEAQAoBwIILAwICSwOBgkAKAkCCSwOAQksCAEBJgIGBAQAEAEGASYDAQQBACgBAgYsDAYILA4FCAAoCAIILA4FCAAoCAIILA4FCCwNAQYAKAYCBiwOBgEqAgAGAAAAAAAAAAACAAAAAAAAAAAsCAEIJgIJBAUAEAEJASYDCAQBACgIAgksDAkKLA4FCgAoCgIKLA4FCgAoCgIKLA4FCgAoCgIKLA4GCiwNAQYAKAYCBiwOBgEsCAEGAAABAgEsDgEGLA0IAQAoAQIBLA4BCCwIAQEAAAECASwOCAEsCAEIAAABAgEmAgkEACwOCQgsCAEKAAABAgEsDgQKJgILBAMmAgwEAiYCDQQBLAwJAiIAAAHpDDgCDA4jAgAOAAACiCIAAAH7LA0KAgo4AgQHIwIABwAAAhUmAgsEADsJAQsmAgIECywIAAssDAYMLAwBDSwMCA4sDAoPABAAAgAkAAAEPiwEAAAsDQYCLA0BBywNCAssDgIGLA4HASwOCwgsDgMKACgHAgIAOAIJAywNAwEKOAEFAgo4AgQDIwIAAwAAAn0kAAAFry4MAAEAAiwMAgElIwIADgAAApUiAAAD0SYCDwQCDDgCDxAjAgAQAAACrCQAAAXBACgHAg8AOA8CECwNEA4sDQgPLA0KEAo4EAQRIwIAEQAAAtgmAhIEADsJARIKOA8LECMCABAAAANjIgAAAuosDQYPLA0BECwNCBEsDQoSJgIUBAMMOBEUFSMCABUAAAMRJAAABcEtBAAPgAMnAIAEBAAEJAAABdMtCIAFABMAKBMCFAA4FBEVLA4OFQA4EQ0ODjgRDg8jAgAPAAADTiQAAAZhLA4TBiwOEAEsDg4ILA4SCiIAAAPRJgIPBBAsCAAQLAwGESwMARIsDAgTLAwKFAAQAA8AJAAABD4sBAAALA0GDywNARAsDQoRLQQAD4ADJwCABAQABCQAAAXTLQiABQASACgSAhMAOBMJFCwODhQsDhIGLA4QASwODQgsDhEKIgAAA9EAOAINDg44Ag4PIwIADwAAA+gkAAAGYSwMDgIiAAAB6ScAgAQEeAANAAAAgASAAyMAgAMAAAQZKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQXtiOABujcKiTsBAQIlJAAAA/EmAgYEACYCBwQBJgIIBAMsDAYFIgAABFsMOAUIBiMCAAYAAATIIgAABG0sDQEFLA0CBiwNAwcsDQQIJgIJBAQsCAEKJgILBAUAEAELASYDCgQBACgGAgsmAgwEBAAoCgINPg8ACwANLA0KBgAoBgIGLA4GCiwOBQEsDgoCLA4HAywOCAQlLA0DBgw4BQYJIwIACQAABN4iAAAFjywNAQYsDQIJLA0DCiwNBAsmAg0EBAw4BQ0OIwIADgAABQUkAAAFwQAoCQINADgNBQ4sDQ4MJgIOBAMMOAUODyMCAA8AAAUqJAAABcEAKAYCDgA4DgUPLA0PDQA4DA0OJgINBAQMOAUNDyMCAA8AAAVUJAAABcEtBAAJgAMnAIAEBAAFJAAABdMtCIAFAAwAKAwCDQA4DQUPLA4ODywOBgEsDgwCLA4KAywOCwQiAAAFjwA4BQcGDjgFBgkjAgAJAAAFpiQAAAZhLAwGBSIAAARbKQEAAQUC3G4ngHYSnTsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAF7iIAAAX5LQCAA4AFIgAABmAtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAAGTC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAGGycBgAUEAAEDAIAGAAKABiIAAAZgJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "check_dkim_key_hash_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000b3dd3286"
            },
            {
              "kind": "string",
              "value": "ParticipantNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "name",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseEscrow"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "entitlements",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "escrow_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "dkim_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "managed_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participants",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participant_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "dkim_key_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "verifier_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::DKIMKeyHashRegistered"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_class_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_class_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_registry_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_registry_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_and_register_participant_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_and_register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::set_contract_registered_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::set_contract_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "usdc",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow_contract_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_bulk_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_bulk_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "105": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "107": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "108": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "109": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "110": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "112": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "113": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "114": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "119": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "120": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "122": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\n\npub struct NullifierMembershipWitness {\n    pub index: Field,\n    pub leaf_preimage: NullifierLeafPreimage,\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let serialized_leaf_preimage = array::subarray(fields, 1);\n\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"
    },
    "125": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "126": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "129": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "131": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 bytes.\n//\n// Each 31 byte chunk is converted into a Field as if the chunk was the Field's big endian representation. If the last chunk\n// is less than 31 bytes long, then only the relevant bytes are conisdered.\n// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\npub fn bytes_to_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut dst = [0; (N + 30) / 31];\n\n    for dst_index in 0..((N + 30) / 31) {\n        let mut field_value = 0;\n\n        for i in 0..31 {\n            let byte_index = dst_index * 31 + i;\n            if byte_index < N {\n                // Shift the existing value left by 8 bits and add the new byte\n                field_value = field_value * 256 + input[byte_index] as Field;\n            }\n        }\n\n        dst[dst_index] = field_value;\n    }\n\n    dst\n}\n\n// Converts an input array of fields into bytes. Each field of input has to contain only 31 bytes.\n// TODO(#8618): Optimize for public use.\npub fn fields_to_bytes<let N: u32, let M: u32>(input: [Field; M]) -> [u8; N] {\n    let mut dst = [0; N];\n\n    for src_index in 0..M {\n        let field = input[src_index];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let src: [u8; 31] = field.to_be_bytes();\n\n        // Since some of the bytes might not be occupied (if the source value requiring less than 31 bytes),\n        // we have to compute the start index from which to copy.\n        let remaining_bytes = N - src_index * 31;\n        let src_start_index = if remaining_bytes < 31 {\n            // If the remaining bytes are less than 31, we only copy the remaining bytes\n            31 - remaining_bytes\n        } else {\n            0\n        };\n\n        // Note: I tried combining this check with `assert_max_bit_size` above but `assert_max_bit_size` expects\n        // the argument to be a constant. Using comptime block to derive the number of bits also does not work\n        // because comptime is evaluated before generics.\n        for i in 0..src_start_index {\n            assert(src[i] == 0, \"Field does not fit into remaining bytes\");\n        }\n\n        for i in 0..31 {\n            let byte_index = src_index * 31 + i;\n            if byte_index < N {\n                dst[byte_index] = src[src_start_index + i];\n            }\n        }\n    }\n\n    dst\n}\n\nmod test {\n    use crate::utils::bytes::{bytes_to_fields, fields_to_bytes};\n\n    #[test]\n    fn test_bytes_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_bytes() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_bytes(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_less_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_bytes(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_bytes_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_bytes() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_input_to_fields_and_back(input: [u8; 128]) {\n        let output = bytes_to_fields(input);\n        let input_back: [u8; 128] = fields_to_bytes(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_bytes(input);\n        let input_back = bytes_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"Field does not fit into remaining bytes\")]\n    fn test_too_few_destination_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_bytes(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_bytes_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_bytes(input);\n    }\n\n    #[test]\n    fn test_fields_to_bytes_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_bytes(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "145": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::DEPLOYER_CONTRACT_ADDRESS,\n    hash::compute_siloed_nullifier,\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for BlockHeader {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for BlockHeader {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for BlockHeader {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for BlockHeader {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n"
    },
    "146": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr",
      "source": "use dep::protocol_types::block_header::BlockHeader;\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{\n    context::PrivateContext,\n    note::{note_interface::{NoteInterface, NullifiableNote}, utils::compute_siloed_nullifier},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: BlockHeader, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for BlockHeader {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving nullifier inclusion failed\",\n            );\n\n            // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n            // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n            // care about is showing that the tree contains an entry with the expected nullifier.\n            assert(\n                witness.leaf_preimage.nullifier == nullifier,\n                \"Nullifier does not match value in witness\",\n            );\n        }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(\n        header: BlockHeader,\n        note: Note,\n        context: &mut PrivateContext,\n    )\n    where\n        Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for BlockHeader {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(self, note: Note, context: &mut PrivateContext)\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"
    },
    "148": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "149": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "150": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "153": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "154": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "161": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "199": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr",
      "source": "pub global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable},\n    hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct NullifierLeafPreimage {\n    pub nullifier: Field,\n    pub next_nullifier: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<Field> for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_key: Field, next_index: u32) -> Self {\n        Self { nullifier: self.nullifier, next_nullifier: next_key, next_index }\n    }\n\n    fn update_value(self, _nullifier: Field) -> Self {\n        assert(false, \"Tried to update a nullifier\");\n        Self::empty()\n    }\n\n    fn build_insertion_leaf(nullifier: Field, low_leaf: Self) -> Self {\n        Self { nullifier, next_nullifier: low_leaf.next_nullifier, next_index: low_leaf.next_index }\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value =\n            compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(\n            self.nullifier,\n            siloed_value,\n            \"Value of the nullifier leaf does not match read request\",\n        );\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"
    },
    "207": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "214": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "243": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "254": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "269": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "270": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "286": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "289": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "291": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "292": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "295": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "296": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "298": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "299": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "303": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "304": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "305": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> std::hash::poseidon2::Poseidon2 {\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: std::hash::poseidon2::Poseidon2,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> std::hash::poseidon2::Poseidon2 {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: std::hash::poseidon2::Poseidon2,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> std::hash::poseidon2::Poseidon2 {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let two_pow_64 = 18446744073709551616;\n    let empty_sponge = std::hash::poseidon2::Poseidon2::new((in_len as Field) * two_pow_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut contructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(contructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == contructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "306": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "309": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "315": {
      "path": "/Users/ianbrighton/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "323": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_escrow/src/types/entitlement_note.nr",
      "source": "use aztec::{\n    encrypted_logs::encrypted_event_emission::encode_and_encrypt_event,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::{note, note_custom_interface},\n    note::utils::compute_note_hash_for_nullify,\n    oracle::{random::random, notes::check_nullifier_exists, debug_log::debug_log_format},\n    prelude::{NoteHeader, NullifiableNote, NoteInterface, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        traits::{Serialize, Deserialize},\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::{poseidon2_hash_with_separator, poseidon2_hash_bytes},\n        utils::field::field_from_bytes,\n    },\n};\nuse compressed_string::CompressedString;\nuse generators::GENERATORS;\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\nuse crate::{ZERO_DESTINATION, ZImburseEscrow::{SpotReimbursementClaimed, RecurringReimbursementClaimed, EntitlementNullified}};\n\nglobal ENTITLEMENT_NOTE_LENGTH: u32 = 8;\n\n#[note]\npub struct EntitlementNote {\n    // the user that is allowed to use this entitlement\n    recipient: AztecAddress,\n    // the type of receipt verifier that this entitlement can be used for\n    verifier_id: u8,\n    // the maximum value that can be withdrawn from the escrow using this entitlement\n    max_value: U128,\n    // date range that verified emails can be used for\n    date_start: u32,\n    date_end: u32,\n    // destination if used for travel\n    destination: Field,\n    // whether or not the entitlement is a spot entitlement\n    spot: bool,\n    // blinding factor & nullifier secret for the note\n    randomness: Field,\n}\n\n// impl NoteInterface<ENTITLEMENT_NOTE_LENGTH> for EntitlementNote {\n\n//     fn serialize_content(self) -> [Field; ENTITLEMENT_NOTE_LENGTH] {\n\n//         [\n//             self.recipient.to_field(),\n//             self.verifier_id as Field,\n//             self.max_value.to_integer(),\n//             self.date_start as Field,\n//             self.date_end as Field,\n//             self.destination,\n//             self.spot as Field,\n//             self.randomness\n//         ]\n//     }\n\n//     fn deserialize_content(serialized_note: [Field; ENTITLEMENT_NOTE_LENGTH]) -> EntitlementNote {\n//         EntitlementNote {\n//             recipient: AztecAddress::from_field(serialized_note[0]),\n//             verifier_id: serialized_note[1] as u8,\n//             max_value: U128::from_integer(serialized_note[2]),\n//             date_start: serialized_note[3] as u32,\n//             date_end: serialized_note[4] as u32,\n//             destination: serialized_note[5],\n//             spot: serialized_note[6] as bool,\n//             randomness: serialized_note[7],\n//             header: NoteHeader::empty()\n//         }\n//     }\n\n//     fn to_be_bytes(self, storage_slot: Field) -> [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] {\n//         let serialized_note = self.serialize_content();\n//         let mut buffer: [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] = [0; ENTITLEMENT_NOTE_LENGTH * 32 + 64];\n//         let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n//         let note_type_id_bytes: [u8; 32] = EntitlementNote::get_note_type_id().to_be_bytes();\n//         for i in 0..32 {\n//             buffer[i] = storage_slot_bytes[i];\n//             buffer[32 + i] = note_type_id_bytes[i];\n//         }\n//         for i in 0..serialized_note.len() {\n//             let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n//             for j in 0..32 {\n//                 buffer[64 + i * 32 + j] = bytes[j];\n//             }\n//         }\n//         buffer\n//     }\n\n//     fn get_note_type_id() -> Field {\n//         comptime\n//         {\n//             let bytes = \"EntitlementNote\".as_bytes();\n//             let hash = poseidon2_hash_bytes(bytes);\n//             let hash_bytes = hash.to_be_bytes::<4>();\n//             field_from_bytes(hash_bytes, true)\n//         }\n//     }\n\n//     fn get_header(self) -> NoteHeader {\n//         self.header\n//     }\n\n//     fn set_header(&mut self, header: NoteHeader) {\n//         self.header = header;\n//     }\n\n//     fn compute_note_hash(self) -> Field {\n//         let serialized = self.serialize_content();\n//         let generators = [\n//             GENERATORS[0],\n//             GENERATORS[1],\n//             GENERATORS[2],\n//             GENERATORS[3],\n//             GENERATORS[4],\n//             GENERATORS[5],\n//             GENERATORS[6],\n//             GENERATORS[7],\n//             GENERATORS[8]\n//         ];\n//         let data = [\n//             from_field_unsafe(serialized[0]),\n//             from_field_unsafe(serialized[1]),\n//             from_field_unsafe(serialized[2]),\n//             from_field_unsafe(serialized[3]),\n//             from_field_unsafe(serialized[4]),\n//             from_field_unsafe(serialized[5]),\n//             from_field_unsafe(serialized[6]),\n//             from_field_unsafe(serialized[7]),\n//             from_field_unsafe(self.get_header().storage_slot)\n//         ];\n//         std::embedded_curve_ops::multi_scalar_mul(generators, data).x\n//     }\n// }\n\nimpl NullifiableNote for EntitlementNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = self.randomness; // use as nullifier_secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = self.randomness; // use as nullifier secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for EntitlementNote {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient)\n            & (self.date_start == other.date_start)\n            & (self.date_end == other.date_end)\n            & (self.destination == other.destination)\n            & (self.max_value == other.max_value)\n            & (self.randomness == other.randomness)\n            & (self.spot == other.spot)\n            & (self.verifier_id == other.verifier_id)\n    }\n}\n\nimpl EntitlementNote {\n    \n    /**\n     * EntitlementNote constructor\n     *\n     * @param recipient - the address of the recipient of the entitlement (NOT THE OWNER OF THE NOTE)\n     * @param verifier_id - the type of verifier that the entitlement can be used for\n     * @param max_value - the maximum value that can be withdrawn from the escrow using the entitlement\n     * @param date_start - the start of the date range that the entitlement can be used for (0 for recurring)\n     * @param date_end - the end of the date range that the entitlement can be used for (0 for recurring)\n     * @param destination - the destination of the entitlement (ZERO_DESTINATION for recurring)\n     * @param randomness - blinding factor for the note (inputted since must be same between the two notes)\n     */\n    fn new(\n        recipient: AztecAddress,\n        verifier_id: u8,\n        max_value: U128,\n        date_start: u32,\n        date_end: u32,\n        destination: str<31>,\n        spot: bool,\n        randomness: Field\n    ) -> Self {\n        let destination_compressed: CompressedString<1, 31> = CompressedString::from_string(destination);\n\n        // assert destination \n        if spot {\n            assert(date_end == 0, \"Date end must be zero if entitlement is spot.\");\n            assert(date_start == 0, \"Date start must be zero if entitlement is spot.\");\n            assert(destination == ZERO_DESTINATION, \"Destination must be empty if entitlement is spot.\");\n        }\n\n        Self {\n            recipient,\n            verifier_id,\n            max_value,\n            date_start,\n            date_end,\n            destination: destination_compressed.value[0],\n            spot,\n            randomness,\n            header: NoteHeader::empty()\n        }\n    }\n\n    /**\n     * Return the destination of the entitlement\n     *\n     * @return the utf8 bytes of the destination\n     */\n    fn destination(self) -> [u8; 31] {\n        CompressedString::<1, 31> { value: [self.destination] }.to_bytes()\n    } \n\n    /**\n     * Constrain a given timestamp to be within the date range of the entitlement\n     *\n     * @param timestamp - the timestamp to check\n     */\n    fn check_date_range(self, timestamp: u32) {\n        debug_log_format(\"\\n\\n\\n\\nChecking date range:\\nStart: {0}\\nTimestamp:{1}\\nEnd:{2}\", [\n            self.date_start as Field,\n            timestamp as Field,\n            self.date_end as Field\n        ]);\n        assert(\n            (timestamp >= self.date_start) & (timestamp <= self.date_end),\n            \"Receipt is out of entitlement date range\"\n        );\n    }\n\n    /**\n     * Determine the amount to reimburse for a given claimed amount (lesser of the two)\n     *\n     * @param claimed - the amount claimed by the user\n     * @return the amount to reimburse\n     */\n    fn amount_to_reimburse(self, claimed: U128) -> Field {\n        if self.max_value >= claimed {\n            claimed.to_field()\n        } else {\n            self.max_value.to_field()\n        }\n    }\n\n    fn derive_shared_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            self.serialize_content(),\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Derives the nullifier for recurring notes\n     * @dev recurring notes are nullified for a scope (month) without destroying the ntoe\n     *      prove nullifier non-inclusion to use\n     *\n     * @param timestamp - the timestamp (month/ year) from the email receipt verifier\n     * @return - the month nullifier for the note\n     */\n    fn derive_recurring_nullifier(self, timestamp: Field) -> Field {\n        let serialized = self.serialize_content();\n        let mut inputs: [Field; ENTITLEMENT_NOTE_LENGTH + 1] = [0; ENTITLEMENT_NOTE_LENGTH + 1];\n        for i in 0..ENTITLEMENT_NOTE_LENGTH {\n            inputs[i] = serialized[i];\n        }\n        inputs[ENTITLEMENT_NOTE_LENGTH] = timestamp;\n        poseidon2_hash_with_separator(\n            inputs,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Assert that a recurring nullifier has not been used before and emits it\n     * @dev uses oracle check_nullifier_exists which is technically unsafe but will be caught by kernel\n     *\n     * @param context - the private context to use for the oracle call\n     * @param timestamp - the timestamp to check\n     */\n    fn check_and_emit_recurring_nullifier(self, context: &mut PrivateContext, timestamp: Field) {\n        // derive recurring nullifier for the month\n        let recurring_nullifier = self.derive_recurring_nullifier(timestamp);\n        // check the nullifier has not been emitted via oracle call (rely on kernel to actually constrain)\n        let recurring_nullifier_exists = unsafe { check_nullifier_exists(recurring_nullifier) };\n        assert(!recurring_nullifier_exists, \"Entitlement has already been claimed for this month\");\n        // emit the nullifier\n        context.push_nullifier(recurring_nullifier);\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a recurring claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     * @param timestamp - the timestamp of the claim\n     */\n    fn emit_recurring_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field, timestamp: Field) {\n        RecurringReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n            timestamp\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a spot claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     */\n    fn emit_spot_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field) {\n        SpotReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Admin or recipient notifies counterparty that note has been nullified\n     * @dev admin emits event when revoking entitlement, recipient emits when claiming spot\n     * @dev clients must scan for these events to prune notes that are no longer valid\n     *\n     * @param context - the private execution context\n     * @param to - the address of the counterparty to notify\n     * @param from - the address of the notifier who nullified the entitlement note\n     */\n    fn emit_nullified(self, context: &mut PrivateContext, to: AztecAddress, from: AztecAddress) {\n        EntitlementNullified { randomness: self.randomness }.emit(\n            encode_and_encrypt_event(\n                context,\n                to,\n                to\n            )\n        );\n    }\n}\n"
    },
    "366": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "461": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/registry_definition.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\n\nglobal REGISTRY_DEFINITION_LENGTH: u32 = 3;\n\npub struct RegistryDefinition {\n    admin: AztecAddress,\n    usdc: AztecAddress,\n    escrow_contract_id: Field\n}\n\nimpl Serialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn serialize(self: Self) -> [Field; REGISTRY_DEFINITION_LENGTH] {\n        [self.admin.to_field(), self.usdc.to_field(), self.escrow_contract_id]\n    }\n}\n\nimpl Deserialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn deserialize(fields: [Field; REGISTRY_DEFINITION_LENGTH]) -> Self {\n        RegistryDefinition {\n            admin: AztecAddress::from_field(fields[0]),\n            usdc: AztecAddress::from_field(fields[1]),\n            escrow_contract_id: fields[2]\n        }\n    }\n}\n\nimpl RegistryDefinition {\n    /**\n     * Create a new definition for a Z-Imburse escrow registry contract\n     *\n     * @param admin - The address that can add dkim keys to the registry\n     * @param usdc The address of the USDC token\n     * @param escrow_contract_id The ID of the escrow contract\n     * @return The new escrow registry definition\n     */\n    pub fn new(admin: AztecAddress, usdc: AztecAddress, escrow_contract_id: Field) -> Self {\n        RegistryDefinition { admin, usdc, escrow_contract_id }\n    }\n}\n"
    },
    "462": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/participant_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}\n},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n"
    },
    "475": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/library_methods/dkim.nr",
      "source": "use aztec::{context::public_context::PublicContext, unencrypted_logs::unencrypted_event_emission::emit};\nuse crate::{\n    BULK_KEY_LENGTH,\n    ZImburseRegistry::{DKIMKeyHashRegistered, Storage}\n};\n\n/**\n * Register a single DKIM key\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hash - the hash of the DKIM key to add to the registry\n * @param verifier_id - the verifier ID to register the DKIM key to\n*/\n\npub fn register_dkim_key(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hash: Field, verifier_id: Field) {\n    let stored_id = storage.dkim_registry.at(dkim_key_hash).read();\n    assert(stored_id == 0, \"DKIM key has already been registered\");\n    storage.dkim_registry.at(dkim_key_hash).initialize(verifier_id);\n    emit(\n        context,\n        DKIMKeyHashRegistered { dkim_key_hash, verifier_id }\n    );\n}\n\n/**\n * Register multiple DKIM keys\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n * @param verifier_ids - the verifier IDs to register the DKIM keys to\n */\npub fn register_dkim_keys_bulk(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hashes: [Field; BULK_KEY_LENGTH], verifier_ids: [Field; BULK_KEY_LENGTH]) {\n    for i in 0..BULK_KEY_LENGTH {\n        if (verifier_ids[i] != 0) {\n            register_dkim_key(context, storage, dkim_key_hashes[i], verifier_ids[i]);\n        }\n    }\n}"
    },
    "476": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\nmod library_methods;\nmod test;\nmod types;\n\npub global BULK_KEY_LENGTH: u32 = 4;\n\n#[aztec]\ncontract ZImburseRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, PrivateSet, PublicImmutable, Map},\n        macros::{storage::storage, events::event, functions::{private, public, view, initializer, internal}},\n        note::{\n            note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions,\n            note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE\n        },\n        protocol_types::{\n            contract_instance::ContractInstance, address::partial_address::PartialAddress,\n            contract_class_id::ContractClassId, abis::function_selector::FunctionSelector, traits::Serialize\n        },\n        oracle::get_contract_instance::get_contract_instance,\n        keys::getters::get_public_keys, utils::comparison::Comparator,\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt_note_unconstrained, encode_and_encrypt_note},\n        unencrypted_logs::unencrypted_event_emission::emit\n    };\n    use std::{meta::derive, collections::bounded_vec::BoundedVec};\n    use dep::address_note::address_note::AddressNote;\n    use dep::zimburse_verifiers::constants::verifier_ids;\n    use dep::z_imburse_escrow::ZImburseEscrow;\n    use crate::{\n        library_methods::dkim::{register_dkim_key, register_dkim_keys_bulk},\n        types::{registry_definition::RegistryDefinition, participant_note::{ParticipantNote, NAME_LENGTH}},\n        BULK_KEY_LENGTH\n    };\n\n    #[derive(Serialize)]\n    #[event]\n    struct DKIMKeyHashRegistered {\n        dkim_key_hash: Field,\n        verifier_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        definition: PublicImmutable<RegistryDefinition, Context>,\n        escrow_registry: Map<AztecAddress, PublicImmutable<bool, Context>, Context>,\n        dkim_registry: Map<Field, PublicImmutable<Field, Context>, Context>,\n        managed_escrows: PrivateSet<AddressNote, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: PrivateSet<AddressNote, Context>,\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract\n     *\n     * @param usdc - The address of the USDC token\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n     */\n    #[public]\n    #[initializer]\n    fn constructor(\n        usdc: AztecAddress,\n        escrow_contract_id: Field,\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // initialize the registry definition\n        let definition = RegistryDefinition::new(context.msg_sender(), usdc, escrow_contract_id);\n        storage.definition.initialize(definition);\n        // add any DKIM key hashes that were passed in at initialization\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Bulk registration of DKIM keys\n     *\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys\n     */\n    #[public]\n    fn register_dkim_bulk(\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        // bulk insert up to 50 dkim key hashes\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Register a DKIM key hash for email verifiers to anchor trust to\n     *\n     * @param verifier_id - the ID of the verifier\n     * @param dkim_key_hash - the hash of the DKIM key\n     */\n    #[public]\n    fn register_dkim(verifier_id: Field, dkim_key_hash: Field) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not registry admin\");\n        // ensure that the dkim key has not already been registered\n        register_dkim_key(&mut context, storage, dkim_key_hash, verifier_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     * @param escrow_contract - the address of the escrow contract to register\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check the contract class ID by recomputing the contract address\n        let definition = storage.definition.read();\n        let contract_instance: ContractInstance = unsafe {\n            get_contract_instance(escrow_contract)\n        };\n        let computed_escrow_address = AztecAddress::compute(\n            contract_instance.public_keys,\n            PartialAddress::compute(\n                ContractClassId::from_field(definition.escrow_contract_id), // constrained here\n                contract_instance.salt,\n                contract_instance.initialization_hash,\n                contract_instance.deployer\n            )\n        );\n        assert(\n            computed_escrow_address == escrow_contract, \"Escrow contract class ID does not match expected class ID\"\n        );\n        // check that the contract has been deployed\n        // annoying that we can't use this in the deploy tx\n        context.historical_header.prove_contract_initialization(escrow_contract);\n\n        // check that the contract has not already been registered\n        let registration_status = storage.escrow_registry.at(escrow_contract).read();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        let escrow_params = ZImburseEscrow::at(escrow_contract).get_registration_params().view(&mut context);\n        assert(\n            escrow_params[0] == context.this_address(), \"Escrow contract registry does not match this contract\"\n        );\n        assert(escrow_params[1] == definition.usdc, \"Escrow contract USDC does not match registry USDC\");\n        assert(\n            escrow_params[2] == context.msg_sender(), \"Escrow contract admin does not match sender of message\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let admin_keys = get_public_keys(context.msg_sender());\n        let mut escrow_note = AddressNote::new(escrow_contract, admin_keys.npk_m.hash());\n\n        // use unconstrained - why would you lie here\n        storage.managed_escrows.insert(&mut escrow_note).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender()\n            )\n        );\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.escrow_registry.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n    fn check_and_register_participant(participant: AztecAddress, participant_name: str<60>, escrow: AztecAddress) -> bool {\n        // todo: switch to check that the sender is an escrow\n        // check that sender is admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        let is_registered = storage.escrow_registry.at(escrow).read();\n        assert(is_registered, \"Escrow contract is not registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new().select(AddressNote::properties().address, Comparator.EQ, participant).set_limit(1);\n        let participant_exists = storage.participants.at(escrow).get_notes(options).len() == 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        let mut added = false;\n        if participant_exists {\n            added = true;\n            ZImburseRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, escrow).call(&mut context);\n        }\n        added\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant(participant: AztecAddress, participant_name: str<60>, admin: AztecAddress, escrow: AztecAddress) {\n        let admin_keys = get_public_keys(admin);\n        let participant_keys = get_public_keys(participant);\n        // add escrow to the participant's set of escrows\n        let mut escrow_note = AddressNote::new(escrow, participant_keys.npk_m.hash());\n        storage.participant_escrows.insert(&mut escrow_note).emit(\n            encode_and_encrypt_note(\n                &mut context,\n                participant,\n                participant\n            )\n        );\n        // add the participant to the admin set of participants\n        let mut participant_note = ParticipantNote::new(participant, participant_name, admin_keys.npk_m.hash());\n        storage.participants.at(escrow).insert(&mut participant_note).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, admin, admin)\n        );\n    }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the public context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[public]\n    #[view]\n    fn check_dkim_key_hash_public(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the private context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[private]\n    #[view]\n    fn check_dkim_key_hash_private(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /** Get the class ID that all escrow contracts must match */\n    #[public]\n    #[view]\n    fn get_escrow_class_id() -> Field {\n        storage.definition.read().escrow_contract_id\n    }\n\n    /** Get the registration status of an escrow contract */\n    #[public]\n    #[view]\n    fn get_escrow_registry_status(escrow_contract: AztecAddress) -> bool {\n        storage.escrow_registry.at(escrow_contract).read()\n    }\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param page_index - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_managed_escrows(offset: u32) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.managed_escrows.view_notes(options);\n        let mut managed_escrows = BoundedVec::new();\n        for i in 0..notes.len() {\n            managed_escrows.push(notes.get_unchecked(i).address);\n        }\n        (managed_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param admin - the address of the participant\n     * @param page_index - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_participant_escrows(\n        participant: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participant_escrows.view_notes(options);\n        let mut participant_escrows: BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE> = BoundedVec::new();\n        for i in 0..notes.len() {\n            participant_escrows.push(notes.get_unchecked(i).address);\n        }\n        (participant_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param page_index - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<ParticipantNote, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participants.at(escrow).view_notes(options);\n        (notes, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n}\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "63": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/address_note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "69": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "72": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "75": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "76": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "79": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "83": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "90": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "91": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "93": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
