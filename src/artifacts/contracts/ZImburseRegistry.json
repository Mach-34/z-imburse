{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "ZImburseRegistry",
  "functions": [
    {
      "name": "check_dkim_key_hash_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5886526716701834683": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_private can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bbty2Fobfxde+4GHx1FcpiiIHtzBg2EEOG9gI8u7VTCyN7JFHVkyG5K//pujEpLjIb6hFfaTl71cfb95/+/fv2/t/Hr5c/fHn96u7hw/vvt4+3A+fvl9pc/y3L5/e3R8+fvn67vPXqz+0T+r66ub+4/C/Qakf11f/3N7dXP0hQX5cn5U20cbH0ib6U2ktaaG0dTo9lrYumZXSMQX3WDqmmKbSVtmF0jpEO8Yd1enaxi8VVsaPhVVw88J/XV9py4FZHhjhwCwPjOPALA+Mf/vAiHJj8KKSnkrHny2E4i3Et7egrZKxtLVphisulE7J6cfSKfk4j2fhe2NsHK9tjGj7PPzUdfhGbQ3/UEkvVlLRhOm7Gp1e67Wyblb81Guvl0q7cR6Y+ZyJYWk+GhlnWDSzL9zyfLTTlcWoy7PRhGk2miArhTPOc2M44L93wG2WAdd+mkZGh7UBD0pPk06vXTuJGW8CbnbH8OkYvvQdvus7fN93+OEV4Ye1JkyM483GJGOeNLJwA3Gna6v5cssuFtbT3cY5tXK3wbs3RfJpmk8in5b5WPX7+Wjtppu5ng3iAdAhJN1eSKa9kGx7IUl7Ibn2QvLthRTaCym2F1JqLiSpcvdWaVqKiz8LSbcXUo27d/CTXgjPwJ2XPuXzkPxsUbGkF4yWyWFpF5+UPnTW7qmzsqfOOqzOejt1Npx31u+ps2FPnY1YnZ0Km7kaHjubdtRZp/bUWQ2WemadtWedxVpBGRWmzppw1lmsFdRKZ2VPnQVbQc3mrDnLs675FVSclrta6bTS23Lm1aTx4dFYvSZT7XQURlsbf7zBvLrmF30759P8OrURPpV2LlzzS+t98/HNPw1k43PobZXHgenkgo7Gri0tZIwkzM7JGWeO4Zu+w7d9hy99h+/6Dt/3HX7oO/zYd/ip6/CD6jv8vrNu6Dvrhr6zbug764a+s27oO+uGvrNu6Dvrhr6zbuw768a+s27sO+vGvrNu7Dvrxr6zbuw768a+s27sO+vGvrNu6jvrpr6zbuo766a+s27qO+umvrNu6jvrpr6zbuo766a+s65WfafdYWu48/j7TrxaNZ9543ToIEZ1Hn/zqXcl/uZzb/Kz3/fWTzpwXlicn47OuHQ6tLKT3/fWqvm1CHFuwdn82ow4t+Bsfq1KnFtwNr92J84NOHXzjzLEuQVn8092xLkFZ/MPusS5BWfzz/3EuQWnECcSTlohKJy0QlA4aYWgcNIKQeGkFULCaWiFoHDSCkHhpBWCwkkrBIVTiBMJJ60QFE5aISictEJQOGmFoHDSCiHhtLRCUDhphaBw0gpB4aQVgsIpxImEk1YICietEBROWiEonLRCUDhphZBwCq0QFE5aISictEJQOGmFoHAKcSLhpBWCwkkrBIWTVggKJ60QFE5aISScjlYICietEBROWiEonLRCUDiFOJFw0gpB4aQVgsJJKwSFk1YICietEBJOTysEhZNWCAonrRAUTlohKJxCnEg4aYWgcNIKQeGkFYLCSSsEhZNWCAlnoBWCwkkrBIWTVggKJ60QFE4hTiSctEJQOGmFoHDSCkHhpBWCwkkrhIQz0gpB4aQVgsJJKwSFk1YICqcQJxJOWiEonLRCUDhphaBw0gpB4aQVQsKZaIWgcNIKQeGkFYLCSSsEhVOIEwknrRAUTlohKJy0QlA4aYWgcNIKAeE0ilYICietEBROWiEonLRCUDiFOJFw0gpB4aQVgsJJKwSFk1YICietEBJOTSsEhZNWCAonrRAUTlohKJxCnEg4aYWgcNIKQeGkFYLCSSsEhZNWCAmnoRWCwkkrBIWTVggKJ60QFE4hTiSctEJQOGmFoHDSCkHhpBWCwkkrhITT0gpB4aQVgsJJKwSFk1YICqcQJxJOWiEonLRCUDhphaBw0gpB4aQVQsIptEJQOGmFoHDSCkHhpBWCwinEiYSTVggKJ60QFE5aISictEJQOGmFkHA6WiEonLRCUDhphaBw0gpB4RTiRMJJKwSFk1YICietEBROWiEonLRCSDg9rRAUTlohKJy0QlA4aYWgcApxIuGkFYLCSSsEhZNWCAonrRAUTlohJJyBVggKJ60QFE5aISictEJQOIU4kXDSCkHhpBWCwkkrBIWTVggKJ60QEs5IKwSFk1YICietEBROWiEonEKcSDhphaBw0gpB4aQVgsJJKwSFk1YICWeiFYLCSSsEhZNWCAonrRAUTiFOJJy0QlA4aYWgcNIKQeGkFYLCSSsEhNMqWiEonLRCUDhphaBw1rBCPr6I8xiT/P6YjIQJgLNu5SumjZExFGPnuMJCae9UfCztnT3FrZcCscaMYVtjZ4MTF/sY9Bh1DGFe+DiQjgOZZyA9BzLPQAYOZJ6BjBzIVw5kSmMcw1rUnQ1k4kBmGUitOJCvG8hh0XUaSEkro34KY1jBqsuFdYzTYi8pe4ZIE1F1RMm5CVGIlwvL9Cgjyc67d6RpSBOIpiVNIJpCmrVpmsH+jIWVkbfQ5HM0Ek0+zNenqfWoMI226WyhSk3QPCIKiOYRUW3UR2RkvLIxcSUMbeNERtSZYTE0LFg8qWM64+nstPHqnH/DGtTQ3ewWPUXPbtEL0XeGPkxC0KW3CEFDhbRb9PRNZdCfaK7ellc2Rg19U31E2TZfDNUUEk1arOo0822+WDosJJo0WPVpXt4EsDRNzSOiEWoekRBRdUQZt14sdQwWTzqWznhmk+qW7ma36Cl6doueVqg39Ln2U4QKabfo6ZuKoPdmfCGD8c69aSUu9E3NI6Jvqo8o20pIhDSBaFJMIdGklmqAZrbVJ00TEk3Ko9fS1FqNhbVxa4+R+d5XIpQ89RFlO8jl6G2QaFLFINGktalOM9+xPEfBg0RTSLM6zcvHwxytTfOIqGKaR0S/Uh9RxkN5joYFiyd1TGc8s21keLqb3aKn6Nktelqh3tDn2h3zVEi7RS9EXwR9vveVePqm+oiybb54qikkmrRY1Wnm23zxdFhINGmw6tO8vAkQaJqaR0Qj1Dwimpv6iDJuvQTqGCyeQp598cwm1QPdzW7RU/TsFj2tUG/oc+2nBCqk3aKnbyqCPuPLMCJ9U/OI6JvqI8q2EopUU0g0KaaQaApp1qeZa/UZaZqQaNaQRy7Nuuo7oWmGYRijjiGcLScDBzLPQEYOZJ6BTBzILAOZFAfylQOZ0ukNXfrskTtpDmSegTQcyFeuwYr93deVw/TJElF1RNmOXychTSCajjSBaPIRtjrNfIfpE5+jkWjyYb4+zcuHuhM1QeOIRFFANI+IaqM+onxH6UXRsGDxpI7pjGeu4weihOj3ip6iZ7foaYV6Q5/pTIsoKqTdoqdvKoM+21vGRNE31UeUa/NFNNUUEk1arOo0s22+iKbDQqJJg1Wf5uVNAC1E1DoiGqHmEdHc1EeUcetFU8dg8aRj6YxnNqmu6W72it5Q9OwWPa1Qb+hz7acYKqTdoqdvKoI+3yusxAgRtY6Ivqk+onwrIaopJJoUU0g0qaUaoJlt9UnTBETTUh69lmaxv/u6cizPUvLUR5TtIJelt0GiSRWDRFNIszbNfMfyLAUPEk0Knvo0Lx8Ps7Q2zSOiimkeEf1KfUQZD+UJDQsWT+qYznhm28gQupvdoqfo2S16IfrO0OfaHRMqpN2ip28qgz7f+0qEvqk+omybL0I1hUSTFqs6zXybL44OC4kmDVZ9mpc3ARxNU/OIaISaRyREVB1Rxq0XRx2DxZOOpTOe2aS6o7vZLXqKnt2ipxXqDX2u/RRPhbRb9PRNRdBnfBmGp29qHhF9U31E2VZCXkgTiCbFFBJNaqkGaGZbfdI0IdGsIY/CiWY0+gnNY0ypvZhCjcftEPQpJnMek24wphoPPsmN7KxS6Twm22BMshiTT+MdQwelViIKw93tsXTQ7nQXiH6h8HCbGO9ydnbYReuf4bgc4UzPW8EofzmcQZdMR5ajnx1ZlsXbrtNpHM0hFayUjmm6O8YUT2Nv1WK2CHFa50RlZtliqbAy0wlaFdy88HEYPYfxrcM4fHj/+fbu7vbfv+8ePrz7evtw/+VQVR3+s/xaSh/HfB/crFc/U9zyuw8vV4nbq6TNVZZfFXa5it5exWyvYrdXke1VFm85IY3fovmXaKzit1cJ26vE7VUW6ccwdj/O5fD4B1y3V9Hbq5jtVRbpJzVWSfq8imyv4rZX8durLNJPdrwLJolnVeL2KmlzleUDwJer6JUq84eGxypmexW7vcoy/TjmvHnuGKu47VX89iphe5UXHof0KV35pwOw8LwVx5TsZulb/1wivLRjm62Bl/YF8zWgSzdgSjdgSzcgpRtwpRvwpRsIpRsoPZN96ZkcSs/kUHomh9IzOZSeyaH0TA6lZ3LM8C1yk099IkgfG8jAwMkoS9x84fPYwGYGh0ruVyr5X6iUXOEBThnuxW76PUQ3L/vYQCjdQCzdQCrcgFY5ppHTUwv+vAVdvAVTvAVbvAUp3oIr3oIv3kIofE8ehHnxFlLpFrQq3oIu3oIp3oIt3oIUb8EVb8EXb6H4nNbF57QuPqdN8Tltis9pU3ZOD5/0oeTytIvKqUl0h6fnBYYP5uWaQ4B6CtCunGAIk7YddjHnRQ8D4Mpe3r/98tPRqCDPf0v2xXm65fIjvOCfv6XnxUma6fLp7ZePoywOKTy7/IvTM9Pl9ZsvH6edySjPvzkvTswtl5/2VJ+eqTtc3r798mFEG88HRzJePj2bVsMHe+HWMDx7jI0MS8fXzRgt0xkn7f3rpsHlOml7nRe+sJfr6F+oY36hjv2FOrK9zgu7m5cThRyKLm8/humkW3CzIwuPR1Hs9iqyvYrbXsVvrPJj+Pi/d59v372/uzmcYDj89Nv9h/FAw/Dx6/8/jT8Zjzx8+vzw4ebjt883h8MPp3MPh2+hlnitffrrONP+1MONRFt3fFI6fLT+Wos+LrKOZYefSjjl+mOZcG3MKYkf/smEa2tOk/fwT0NysGEieGjKqmtRY0NDEM4OfRv69x8=",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_returns_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "register_dkim_bulk",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim_bulk"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 21,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "check_dkim_key_hash_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "check_dkim_key_hash_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "ndLNCoQgFAXgd7nrFl2131eJIawsBLEwGxiidx+LZmiGNrq5eMTvujkrdKJZhlrqfpyhrFZQY8utHLVL6xZBY6RScqiv1xDvA/F4P09c73G23FgoEWkEQnfuRND5XioBJcvY9ogAiT+h/oT5k8SbkNtfClqkpykYoV+EGB8oCUFpCMpCUB6A6G0PCpYnH5TE7BdtLj65kbxR4uxZv+j2Ujv7msRfAycztqJbjNi7eKmhmxVmESFurVv9Bg==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "usdc",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_managed_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_managed_escrows"
      ]
    },
    {
      "name": "get_escrow_registry_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_escrow_registry_status"
      ]
    },
    {
      "name": "set_contract_registered",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_contract_registered"
      ]
    },
    {
      "name": "get_participant_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_participant_escrows"
      ]
    },
    {
      "name": "register_dkim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim"
      ]
    },
    {
      "name": "register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7921989071249124615": {
            "error_kind": "string",
            "string": "Function register_participant can only be called internally"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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515hHw/ez73CdgY/9wrbGfzcK2xn8J+8wqq/h3fXwX/yCus/eYX1n7zC+k9eYfd4S+cSz5LBLakz+OjK5rJezMeQflmne7wfc8/hrHMNJ8w1nDjXcNJcw8lzDafMNZw61XD2eN/dnsOZ664c5rorh7nuymGuu3KY664c5rorh7nuymGuu3KY664c57orx7nuynGuu3Kc664c57orx7nuynGuu3Kc664c57orx7nuymmu+06a68pKc11Zaa4rK811ZeW5VvQ815WV51rR9/j5/57Dmeu+k+e67+S57jt5svvOXCt6mUtnlbnuymWuu3KZ665c5rorl7nuymWuu3KZ665c5rorl7nuynWuu3Kd665c57or17nuynWuu3Kd665c57or17nuynWqu3Jdprrv1GWq+05dprrv1GWq+05dprrv1GWq+05dprrv1GWy+85U3WB1U3WD1c11V3Zz3ZXdXHdlN9dd2c11V3Zz3ZXdXHdlN9dd2c11V/Zz3ZX9XHdlP9dd2c91V/Zz3ZX9XHdlP9dd2c91V/Zz3ZX9XHflda678ly/salz/camzvUbmzrXb2zqXL+xqXP9xqbO9RubOtdvbOpcv7Gpc/3Gps71G5s6129s6ly/salz/camzvUbmzrXb2zqDr8iKdubG8v1hylah64xx1/Hnv55+YXz1w+c6w6/IdlxMG6mwfiZBrPONJgw02DiTINJMw0mzzSYMtNgZroDp5nuwGmmO3Ca6Q6cZroDp5nuwGmmO3Ca6Q6cZroDp5nuwEn3Dpy2VwKtyaWrwTT+bDx/m6eUfP1nf447K9+sa2iP+2swbqbB+JkGs840mDDTYOJEg2lvcA9+uwSDz5fvY7na0tphOb/AK4arjw2cDv46Rf32U7Q3ou97Cvf9p/Dff4r1+08Rvv8U8clTfEWloaj8fJRf2luCU17OttTpn7evujtF+aGodSgqDEXFoag0FJWHospQVB2Jau947EYN1YYbqg03VBtuqDbcUG24odpwQ7XhhmrD3amNdftiR16jiPLLUJQbivJDUXdq4/IlkpyCjApDUXEoKg1F5aGoMhRVR6LWZSjKDUX5oaih2liHamMdqo11qDbWodpYh2pjHaqNcGdeJW9R4vtAp6j2uWo+64RUr6X0r6joRs7VfiqTyrJ9lqM4J6PaWS7rNsISGiNMQ1F5KKoMRdWRqLbj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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "notify_created_note_oracle_wrapper",
        "compute_payload_unconstrained",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_escrow_class_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAGEHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAAGtHgIAAgkmAgMAAQo4AgMEIwIABAAAAIUkAAABvyYCAgAALAgBBCYCBQQEABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYsCAECAAABAgEsDgQCJgIEBAEmAgUEACYCBgQDLAwFASIAAADhDDgBBgUjAgAFAAABDyIAAADzLA0CASYCAgQCACgBAgQAOAQCBSwNBQMsDAMBJSwNAgUcDAEHAAA4AwcILgwACAAHJgIJBAMMOAEJCiMCAAoAAAE6JAAAAdEtBAAFgAMnAIAEBAAEJAAAAeMtCIAFAAgAKAgCCQA4CQEKLA4HCgA4AQQFDjgBBQcjAgAHAAABdyQAAAJxLA4IAiwMBQEiAAAA4ScAgAQEeAANAAAAgASAAyMAgAMAAAGsKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVSVfKdc0WarDsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAB/iIAAAIJLQCAA4AFIgAAAnAtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAACXC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAACKycBgAUEAAEDAIAGAAKABiIAAAJwJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "1ZrdbuowDMffpde9iPNlm1c5mqYCZapUFVTgSEeIdz8poqUrXasxtsU3qEH/1D85qRM7OSXrfHl8ey2qzXafLP6cknK7yg7Ftgqt0zlNlnVRlsXba//vRDU/ni/6/S6rmub+kNWHZAGeVZrk1To8olLhDZuizJOFRXtO79VKuVattOvUYGlEbQ3RVW0NY6cmNyImMO2rCRz0xS9pgvYZ8KRbdaD/QfineN5C53k/53lwpoUHx3YanrVuX83a2wE84XPhQb2HDyZYf7uJMHF/wIb7ug2PnQ2Pbm7aEbczmhjcYOQC42d5Lr3cI730Q7Y0PdLLmNFe4ZtWt+GxZsbTGgiv8vAB9MKB5xE1avBXNWozMy6eqA0H4dEPx8WQbH6rhfOjbH4n3P9OuP+9cP97L5sflXB+J5yfZfOTFc4vfP/AwuMny16/tI4+/jC0eU14NEN+G/3+n4k7fnZ3/L8yfxR0/E5P8yObNq3s1Ums4wv+72w/n4cv2/tetvcRZMee6PduqLpSJCp7F3so9r0z3khG+eP3v8Ibv58Wh5I0mq6sy+puqeb4P5fJpY6jTzUn+Y2S7X+jok/VpvnByubX0ZcqZvijT3Wm+U30qeYMf/Sp/jS/8FTNWOH+j/+oYIZfePyJ/6hgmj/+UvsMf/ylro/5z6H1N6uLbFnm1+s9m2O16t32Ofzb5YOLP7t6u8rXxzpvrgDdbv804xhO1QHgpbmpEFroUlJNo9niEqRkgsFg9D8=",
      "brillig_names": [
        "get_escrow_class_id"
      ]
    },
    {
      "name": "register_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10966310306735189739": {
            "error_kind": "string",
            "string": "Escrow contract USDC does not match registry USDC"
          },
          "12806906349574299095": {
            "error_kind": "string",
            "string": "Escrow contract has already been registered"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14827131733433028185": {
            "error_kind": "string",
            "string": "Escrow contract registry does not match this contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17408225848945384450": {
            "error_kind": "string",
            "string": "Proving nullifier inclusion failed"
          },
          "17540660350934727925": {
            "error_kind": "string",
            "string": "Nullifier does not match value in witness"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089479698890196495": {
            "error_kind": "string",
            "string": "Escrow contract admin does not match sender of message"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6337220856976823863": {
            "error_kind": "string",
            "string": "Escrow contract class ID does not match expected class ID"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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5rPK+gYK2RntBSqzBArZGe0FCtkZ7QW6W0eldhnyS6DvRvunQgW7GAXvd4zsGSN3xsifMZIzRuGMUTxjtNvBSqpGVnaM8hmjcsJo/zyTlpE9Y+TOGPkzRnLGKJwximeMzjwR/swT4c88EXLmiZAzT4SceSL2f6qa03KaWM6rcc+VT6N0xiifMSonjPZ/2lfi8lPWtcJ8N7JnjNwZI3/GSM4YhTNG8YxROmOUzxiVE0bxzBMRzzwR8cwTsf/TEit+2UVx+5raL2Y7SyihdkMx+NXVexd7V8/Q825dZvPOxS7Xi11erULdLv7wXob2PgztfRza+zS093lo78vI3u//WmIY7+3Q3u+P99nWN6ZkW7ZFbn9PedssnjNL58xy08ztdJypnDLb36vcNrPnzNw5M38qk/ncU5LPPSX53FOSzz0lOZ8zK6fMijln5s6Yuf11llQ39KawOgYoftrsz2jqS3nLWnBbbOSETThhE0/Y7D8WxtXx2aSwtcqnrMoZq33lsWllT1m5U1b+lJWcsgqnrOIpq1PPhjv1bLhTz4Y/9Wz4U8+GP/Vs7CuKj8eYfUGx1GPvi9+xySdsynGbfY2vYWNP2LjjY5mcGJvlxNgsJ8ZmOTE272uPDZt8wuYbnWl5RksqG5vvhMeHNvaEjTth40/YyAmbcMKm9Rzs2Zx4DsKJ5+AbvfGhzTdy42Mbe8LmxHgQT4wH8cR4EE+MB/HEeBBPPAfxxHMQTzwH6cRzkE48B+kE03SCaTrBNJ1guj9RSqau4Nu7zacq4fZnSQ2b3Vwn7xcbKVsbt29Tf5Qc/dbGn7DZ75Hykre02h5RbcIJm/0FwNrAZdnJ2/76X5WNcohbm2+W/5Yc5D3fymObsmXq97ehZx+WByH7eF8HvS3qfprJObNwziyeM9vPu6+Asxi7Y5bPmZVTZvsCQtvMnjNz58z8OTM5ZxbOmcVzZueeEnvuKbHnnhJ37inZn33fxih3H67C1mx/SpwlVLOwesf33cydu9v+w3WX97OsBtW72f7DJdFUs7STkv2JcdssnjNL58zyNwDy3WwvJeWUmZhzZvacmTtn5s+ZyTmz0DTLO9y+2R4kId3N4o7ZN09JMffvW9oxy6277X5NpZz6dodzg0Kw58zcOTN/zkzOme0DMKFyM2nVqn4sGfj9aagVZ+pSw+3vzekY/rttL0277zY93F8MKbdYtnbppF0+aVfO2X27uN2ysyft3Ek7f9JOTtp9t1XHxpVd3NrFk3bppF0+aVfO2WVz3O72j7dm9n/+tF+9rDX1fbJ29Yoba9/3je7XrpaRnDEKZ4ziYaO3fIS3i7/Z01/qXD2sNIG3cfN/b//8//7xP/78j//0l3/9z5vJ2//633/95//689/++vnP//r//335X/7pP/78l7/8+d/+4d//42///K//8t//8a//8Je//fPb//Yn8/n//o+V/IeN5Y3s279u3wnrw+1f7/Mqe+shrdi3f9r3a93tn/Lu/Zv9xzXpD+fe/pOr/+n2Id68/Sdf/9NNfPDp7T+9PwVvt3Lp7b983sjnP8S//c/h7pe5+WUXv253sa5efsvnzU1f/fJy+2d8s4/Lx3vzh5jl+luM4f3jU3Uohj+SWT6g+D9KePvf82Pvyj1qe0uFfY/Imvt/vflR3v+b3f2gW/7kw8Yt/3tOf5RVXG/pf0+d9Usmbmub7pbi8B7umzf+1tfcms78mZtyq1/F1lhvy67mdrkNS3C3yY/94/b//P1b+H2CPp7Kjw/yf7h8e95uz9z/Aw==",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_contract_instance_internal",
        "get_nullifier_membership_witness",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "unpack_returns",
        "get_public_keys_and_partial_address",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "pack_arguments_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_participants",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "name",
                            "type": {
                              "kind": "array",
                              "length": 2,
                              "type": {
                                "kind": "field"
                              }
                            }
                          },
                          {
                            "name": "npk_m_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "randomness",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "header",
                            "type": {
                              "fields": [
                                {
                                  "name": "contract_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "nonce",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "storage_slot",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "note_hash_counter",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::note::note_header::NoteHeader"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::participant_note::ParticipantNote"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3dbhxHsoTfRde+qL+sn32VxcKwvd6FAME2/HOAA8PvfkZsTg91pmuS6imjI6rzxpDkbjIj2Mwva8iM+fPDv3/8/o//fvvxp//8/NuHf/zzzw+ffv7hu98//vzT5W9//vXNh+9//fjp08f/fvv2nz+4z/+RVF9u+O2X7376/Pfffv/u198//MPn5r758ONP/778sTh3+RD/+fjpxw//SCX99c3d1dXV14tryOu1detSCfJ6qcjtw3onf/3rm0sxbUAx0q7FVP+4mBSvl6Zc74oR93wxzeXXi1twj4vJ7upMfmPiWowfUExK12KkKMXU68d9+2HXYsJmMbGktZpYclLKKd5fP0e4uV/yxqUh5+tHDpfSbhcv5USschJWOYJVTsYqp2CVU7HKaVDlZIdVjscqB6srZ6yunLG6csbqyhmrK2esrpyxunLG6soFqysXrK5csLpywerKBasrF6yuXLC6csHqygWrKxesrlyxunLF6soVqytXrK5csbpyxerKFasrV6yuXLG6csXqyg2rKzesrtywunLD6soNqys3rK7csLpyw+rKDasrN6iunB1UV84OqitnB9WVs4PqytlBdeXLD5GxyoHqytlBdeXsoLpydlhd2WN1ZY/VlT1WV/ZYXdljdWWP1ZU9Vlf2WF3ZY3Vlj9WVw9/blV8+hf/7P0X4+z/FmI6Yrr+iWHJ+6uuWsMoRrHIyVjkFq5yKVU6DKic6rHI8VjkBqxysrhyxunLE6soRqytHrK4csbpyxOrKCasrJ6yunLC6csLqygmrKyesrpywunLC6soJqysnrK4sWF1ZsLqyYHVlwerKgtWVBasrC1ZXFqyuLFhdWbC6csbqyhmrK2esrpyxunLG6soZqytnrK6csbpyxurKGasrF6yuXLC6csHqygWrKxesrlywunLB6soFqyuXv7crv3yK9rd/iur+/k/xno5Y5ItP8XJf2Hlf3Hlf2nmf7Lwv77yv7Lyv7ryv7bvvXUs8W/ftfF7azuel7Xxe2s7npe18XtrO56XtfF7azuel7XteinM77/M77ws774s770s775Od9+Wd95Wd99Wd9+18XvzO56X3G8p1TZa7/PnNL6ptI8+7uF7u6u2z+Oy3rq7XgDvfbh851LJUFOAqinAVJbiKBK6iDFdRgauowlXU0Crq/fLygRUd0bPlWlFw4YuK7q+tIcXXi2totzzV6OLG1XH9yOlN3GnYPIMGd/3l6RB8e3yxxGsREtPbS18sDGbhsxZGs/BZC5NZ+KyFYhY+a2E2C5+1sJiFz1pYzcJnLWxm4ZMWRmcWPmuhnU6ettBOJ++xMJerhW/eieNqoZ1OnrYwmYXPWmink3dYmNdr85eXvlhop5OnLbTTydMW2unkaQvtdPKshclOJ09baKeTpy2008nTFtrp5GkLk1n4rIV2OnnaQjudPG2hnU6ettBOJ09baKeTOws/+yJ25Nj2xc4R277Y4WDbF5v4t31J5sumLzabb/tiA/e2LzZFb/tio/G2LzbvbvqSbd7d9sXm3W1fbN7d9sXm3W1fkvmy6YvNu9u+2Ly76Us5b99NN18k3Ply2u+jEtYqStp/8YuJp/2m+xoTfS5rtkCud7/7WE57Ih1p4mmPryNNPO1Zd6CJ9bQH468ysdRrFb66OzrX056iR5p42tFvpImnPZ+PNDGZic+baCeWASbaiWWAiXZiGWCinVgGmGgnludNbHZiGWCinVgGmGgnlgEm2ollgInJTHzeRDuxDDDRTiwDTLQTy3tMbP76jgy+xXsT7cQywEQ7sTxtYnVjTix+facWH3zRTCzr71n44r36Barr1e5NNPHl1kWBp1cQ6BVEegXp6xW83Cc778s77ys776s772v77vNu533v+W5ORflqp1TqtZuKz198te+vbmXNPm81xvXqEjYfpCbl9iRJfXv5i4JAryDSK0j4Clq8KWjpToHQK8j0Cgq9gkqvoLEreNebeWArIGCyooCAyYoCAiYrCuiZHOiZHOiZHOiZHOiZHOiZHOmZHOmZHOGZfHlpeFVw+fO9AngmqwrgmawqgGeyqgCeyaoCeCarCuCZrCqAZ7KmIMEzWVUAz2RVAT2TEz2T35UyjK2AnsmJnsmJnsmJnsmJnslCwOTyRkG5V0DAZEUBAZMVBQRMVhQQMFlRQMBkRQEBkxUFBExWFBAwWVFAwOTHCjI9kzM9kzM9kzM9k98Va4itgJ7JmZ7JmZ7JGZ/Jl5//rQouf7lTgM9kRUHBZ7KmAJ/JmgJ8JmsK8JmsKcBnsqYAn8maAnwmawrwmawpoGdyoWdypWdypWdypWdypWfyuxIDsRXQM7kSMFncTYH4OwUETFYUEDBZUUDA5McKGgGTFQUETFYUEDBZUUDAZEUBAZMVBQRMVhTQM7nRM7nRM7mxM7k5diY3x87k5tiZ3Bw7k5sj+E4u6aaglv+vAD95xpd6U1DepK1dFeA/RZqCRK8Af7LTFOBPdpoC/MlOU4A/2WkK8HmgKMBPnlEV4E92mgJ6JuMnz6gK6JmMnzyjKqBnMn7yjKqAnsn4yTOaAvzkGV9DWBXUEO8U4DNZU4DPZE0BPpM1BfhM1hTgM1lTgM9kTQE+kzUF+EzWFOAzWVFAkDyjKaBnMkHyjKaAnskEyTOaAnomEyTPaAromUyQPFNv75Ry+fPdzzIJkmcUBQTJM5oCAiYrCgiYrCggYLKigIDJigICJisKCJisKCBgsqKAnskEyTOKAoLkGU0BPZMJkmc0BfRMJkie0RTQM5kgeabe3v/g8ud0p4CAyYoCAiYrCgiY/FgBQfKMpoCAyYoCAiYrCgiYrCggYLKigIDJigJ6JhMkz2gK6JlMkDyjKCBIntEU0DOZIHlGU0DPZILUk+bzqqCFu406/MSNEMRfSwkh330N8BM3VAXwvUhVAN+LVAXwvUhVkOgVwJ8PVAXwPFAVwJ8PVAXw5wNVARaTLyV5B5ahsdSExc2lJiwSLjVhsW2pCYtWS01Y/FlqwiLKUhMWI5aasLr+UhNgH/eAfdwD9nGwpJmlJsA+DpYGs9QE2MfBEluWmgD7OFiqylITYB8HSz5ZagLs42DpJEtNgH0cLEFkqQmwj4OlfCw1AfZxsCSOpSbAPg6WlrHUBNjHwRItlpoA+zhY6sRSE2AfB0uGWGoC7ONg6Q1LTYB9HCxhYakJsI+DpSAsNQH2cbCkgqUmwD4Oliaw1ATYx8E2/peaAPs42Fb+UhNgHwfbnF9qOqKP11zXmmp4W9P9xaFef+4f3W3fS/xr+Ym7fOEuP3OXX7jLr9zlN+ryD1l7H1i+5y4/cJfPTd1DVt0Hls9N3cxN3cxN3cxN3cxN3cJN3cJN3cJN3cJN3UOW2QeWz03dwk3dwk3dwk3dwk3dyk3dyk3dyk3dyk3dyk3dyk3dyk3dyk3dyk3dyk3dxk3dxk3dxk3dxk3dQ4IZBpbPTd3GTd3GTd3GTd1GTV3vqKnrHTV1vaOmrnfU1PWOmrreUVPXO2rqekdNXe+oqesdN3U9N3U9N3U9N3U9N3UPiQMZWD43dT03dT03dT03dT0WdV9qClgoXWrC4uNSExb0lpqwSLbUhIWnpSYs5iw1YYFkqQmLDktNWC1/qQmwj0fAPh4B+3gE7OMRsI9HwD4eAft4BOzjEbCPR8A+HgH7eALs4wmwjyfAPp4A+3gC7OMJsI8nwD6eAPt4AuzjCbCPC2AfF8A+LoB9HCzlZKkJsI+D5ZEsNQH2cbDkkKUmwD4OlvHxUhNYcMdSE2AfB4vYWGoC7ONgYRhLTYB9HCy2YqkJsI+DBUwsNQH2cbAoiKUmwD4OFtqw1ATYx8HiFZaaAPs4WBDCUhNgHweLLFhqAuzjYOECS02AfRwsBmCpCbCPgy3sLzUB9nGw1fqlJsA+DrYEv9QE2MfB1tWXmgD7ONhi+VITYB8HWwFfagLs42DL2ktNgH0cbK16qQmvjwewBeilJrw+HsBWlZea8Pp4cHh9PIBtCi814fXxALbTu9SE18cD2PbtS01gK7VLTYB9HGz5dakJsI+DrakuNQH2cbCF0qUmwD4Otvq51ATYxwH3OQPgPmcA3OcMgPucAXCfMwDucwbAfc4AuM8ZAPc5A+A+ZwDc5wyA+5wBcJ8zAO5zBsB9zgC4zxkA9zkD4D5nANznDID7nAFwnzMA7nMGwH3OALjPGQD3OQPgPmcA3OcMgPucAXCfMwDucwbAfc4AuM8ZAPc5A+A+ZwDc5wyA+5wBcJ8zAO5zBsB9zgC4zxkA9zkD4D5nANznDID7nAFwnzMA7nMGwH3OALjPGQD3OQPgPmcA3OcMgPucAXCfMwDucwbAfc4AuM8ZAPc5A+A+ZwDc5wyA+5wBcJ8zAO5zBsB9zgC4zxkA9zkD4D5nANznDID7nAFwnzMA7nMGwH3OALjPGQD3OQPgPmcA3OcMgPucAXCfMwDucwbAfc4AuM8ZAfc5I+A+ZwTc54yA+5zR4fXxCLjPGQH3OSPgPmcE3OeMgPucEXCfMwLuc0bAfc4IuM8ZAfc5I+A+ZwTc54yA+5wRcJ8zAu5zRsB9zgi4zxkB9zkj4D5nBNznjID7nBFwnzMC7nNGwH3OCLjPGQH3OSPgPmcE3OeMgPuc8ZB9zhavH/zyx3xfkwDWlAFrKoA1VcCaGl5Nh+xzajV5wJoCYE0RsCbAPp4A+3gC7OMJsI8fsc/pnYv5+tGdOPe2qvvLQ1klXP74RsKrgsau4Ihd0cEKPL2CQK8g0itI8ApSKfH6weubi713rxpkAg15Ag1lAg34bNY14NM5Vd9erxbf5AsN91dLCteLU71dG/KiN+OzfKxefPKP1Ys/J3yd3svsdv0Ojs2F++/gjD9XjFacTqeYYGoZrJhgxhmsmGAiGqyYYH4arHi2aUtVXGabt3TFs01cuuLTzVzldDPXEXkKBys+3cxVTjdzldPNXOV0M1fhnrleNFTuKWrRwD0XLRrwJx0Jvlw1hJA3NODPLrqGNIEG/PniCw0xbmjAnxh0DfgzgK4Bn+oS6k1D2/p+wOe0qqHhc1rXQNCXor/WIjFtzHwN//shu+Rer84upw0NaN8Pn6tKDu0JX6pCmy2Xqg6ZFi+EuFWVtN/4yfn6FIZc31z8qiDSK0j0CoReQaZXUOgVVHoFjV2Bd/QKPL0CeiZ7eiYfkT0yWAE9kz09kz09kz09kz09kwM9kwM9kwM9kwM9k4/IkRmsgJ7JgZ7JgZ7JgZ7JgZ7JkZ7JkZ7JkZ7JkZ7JR2QCDVZAz+RIz+RIz+RIz+RIz+REz+REz+REz+REz+Qj8p0GK6BncqJncqJncqJncqJnstAzWeiZLPRMFnomH5NLNVQBPZOFnslCz2ShZ7LQMznTMznTMznTMznTM/mYjKahCuiZnOmZnOmZnOmZnOmZXOiZXOiZXOiZXOiZfEyGz1AF9Ewu9Ewu9Ewu9Ewu9Eyu9Eyu9Eyu9Eyu9Ew+JslmqAJ6Jld6Jld6Jld6Jld6Jjd6Jjd6Jjd6Jjd6Jjd6Jjd6Jjd6Jjd6Jjd6Jjd2JotjZ7I4diYLfY6X0Od4iWNnstDneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4CX2Ol9DneAl9jpfQ53gJfY6X0Od4Zfocr0yf45Xpc7wyXI7XUhUaZ5eq0Ni5VIXGw6UqNMYtVaFxa6kKjUUvVcFlUi1VoTFjqeqYziD1VlWR+6oOedpzuFWVY72vqiFWtSftZbnR770x7L2xh+yS1hub27rxmKe0tpvzLt47nyGrKpBVVciqGmJVB2VFaFV5yKoCZFURsqoEWRVkb4+QvT1C9vYI2dsjZG9PkL09Qfb2BNnbE2RvT5C9PUH29gTZ2xNkb0+QvT1B9naB7O0C2dsFsrcLZG8XyN4ukL1dIHu7QPZ2geztAtnbM2Rvz5C9PUP29gzZ2zNkb8+QvT1D9vYM2dszZG/PkL29QPb2AtnbC2RvL5C9vUD29gLZ2wtkby+Qvb1A9vYC2dsrZG+vkL29Qvb2CtnbK2Rvr5C9vUL29grZ2ytkb6+Qvb1B9vYG2dsbZG9vkL29Qfb2BtnbG2Rvb5C9vUH29obY24tD7O3FIfb24hB7e3GIvb04xN5eHGJvLw6xtxeH2NuLQ+ztxUH2dg/Z2z1kb/eQvd1D9nYP2ds9ZG/3kL3dQ/Z2D9nbPWRvD5C9PUD29gDZ2wNkbw+QvR1yL7VA7qUWyL3UArmXWiD3UgvkXmo5ZtcyxzdVyUZVCbIqgazqkH71IFfhKy9fRJQZRKDlbtxfnqsPr1fnGtrt4lcFaBkdX63gmA3RoQo8vYJAryDSK0gECnJcFVS5UyD0CvDJrCnAx7KmgIHJjxUwMPmhAmFg8mMFDEx+rICByY8VMDD5sQJ6Jgs9k4WeyULPZKFnstAzOdMzOdMzOdMzOdMz+ZgN8qEK6Jmc6Zmc6Zmc6Zmc6Zlc6Jlc6Jlc6Jlc6Jl8zOb/UAX0TC70TC70TC70TC70TK70TK70TK70TK70TD4msWGoAnomV3omV3omV3omV3omN3omN3omN3omN3omH5O0MVQBPZMbPZMbPZMbPZMbO5OrY2dydexMro6dydWxM7k6diZXx87k6tiZXB07k6tjZ3J19Ez29Ez29Ez29Ez29Ew+JtlmqAJ6Jnt6Jnt6Jnt6Jnt6Jgd6Jgd6Jgd6Jgd6Jh+TSDRUAT2TAz2TAz2TAz2TAz2TIz2TIz2TIz2TIz2TD0rdGqmAnskEaV6aAnomU+R4PVZAz2SKHK/HCuiZTJHj9VgBPZPpc7wqfY5Xpc/xqvQ5XpU+x6vS53hV+hyvSp/jVelzvCp9jlelz/Gq9DlelT7Hq9LneFX6HK9Kn+NV6XO8Kn2OV6XP8ar0OV6VPser0ud4Vfocr0qf41UZcryaW5Prm79XQMDkxwoYcrwUBQRMVhQQMFlRQMBkRQEa0Zaq0Ci1VIVGnqUqNJq8VHVMopGLea1KnHv8nSFRrldLzLd3Z/HevWpI+BryerXkXDY0yAQa8gQaygQa6gQaGr+GY7J1Bmsg4IOqIRBo8PGxhjiBBgZOaxoYOK1pYOB0S1cNxccNDQyc1jQwcFrTwMDpxxqaY+C0poGB05oGBk5rGgg4XaSuGsqWBgJOqxoIOK1qIOC0qoGA00X8TUPa0EDAaVUDAac1DZ6A06oGAk6rGgg4rWqg4LSigYLTNw3Vb2ig4LSigYLTigYCTte4zhpVNmYNT8BpVQMBpzUNgYDTqgYCTlefbhq+5MNGKe7aAJJ/85pgyK96CZg+VC8B/4fqTSfTSzBX7NUb6oZeghlkqF6GeWWkXobZZqRehjnoa/TKbQDP+V5vZJiZRuqdbb7S9M42X2l6Z5uvNL3pZHpnm680vbPNVyKy6pUNvbPNV5re2eYrTe9889VDvelk81U62XyVTjZfpZPNV8dkdx2o92TzVZpvvnqs92TzVTrZfJVONl/JfPPVY70nm6/kZPOVnGy+OiaH7UC9J5uv5GTzlcw3Xz3We7L5Sk42X+WTzVd5vvnqsd6TzVf5ZPPVMZl6B+o92XyVTzZf5ZPNV3m++eqx3pPNV+Vk81U52XxV5puvHus92XxV0sn0nmy+Kiebr8rJ5qtysvmqnOz32yvDfFVXvS1ETa9fFwjDjb8pv+4PMuSqDtXLMF+N1MswX43Um06ml2G+GqmXYb4aqZdhvhqpl2G+GqmXYb7q633RwJAfrGrgnoMWDQSzTYtl1SBhQwP+vJJdvmrI7s278Wx//2eX3Hp1ThuK0+kU488soxXjTy2PFC8a8CcRXQP+dKFrwJ8YlO+H4AiSjHUN+BODrgF/YtA1MEwMmgaGGUDTwEB1TQMDpzUNDJzWNDBwWtMwAacJkox1DRNwmiDJWNcwAacJkox1DRNwmiDJWNcwAacJkox1DRNwmiDJWNcwAacJ0ol1DRNwmiBFWNcwAacJ0n51DRNwmiCVV9cwAacJ0nN1DRNwmiDlVtcwAacJ0mh1DRNwmiA1VtcwAacJ0l11DRNwmiCFVdcwAacJ0lJ1DRNwmiDVVNcwAacJ0kd1DRNwmiAlVNcwAacJ0jx1DRNwmiB1U9cwAacJ0jF1DRNwmiDFUtcwAacJ0iZ1DRNwmiAVUtcwAacJ0ht1DRNwmiBlUdcwAacJ0hB1DRNwmiC1UNcwAacJ0gV1DRNwmiAFUNcwAacJ0vp0DRNwmiBVT9cwAacJ0u90DRNwmiClTtcwAacJ0uR0DRNwmiD1TdcwAacJ0tl0DRNwmiBFTdcwAacJktF0DRNwmiAZTdcwAacpss40DRNwmiKPTNMwAacp8sg0Dfyc9hPkkfkJ8sj8BHlkfoI8Mu/4Oe0nyCPzE+SR+QnyyPwEeWR+gjwyP0EemZ8gj8xPkEfmJ8gj8xPkkfkJ8sj8BHlkfoI8Mj9BHpmfII/MT5BH5ifII/MT5JH5CfLI/AR5ZH6CPDI/QR6ZnyCPzE+QR+YnyCPzE+SR+QnyyPwEeWR+gjwyP0EemZ8gj8xPkEfmJ8gj8xPkkfkJsrz8BFlefoIsLz9Blpc/IkOqlXqV0GqMjxVcXgFL7VqKb1IfXx6DXD92DJ+vuF78KrecS26dTO5F5FVuTPJG7kbVfrUm+SJ31jSzpmPNETlaLNZ4s6ZnTTBretZEs6ZnTTJretaIWdOzZrapdaA1s024A62xabhrjU3DPWuyTcNda2wa7lpj03DXGpuGu9Yks6ZnjU3DXWtsGu5aY9Nw1xqbhrvW2DTcs6bYNNy1xqbhrjU2DXetsWm4a00ya3rW2DTctcam4a41Ng13rbFpuGuNTcM9a6pNw11rbBruWmPTcNcam4a71iSzpmeNTcNda2wa7lpj03DXGpuGu9bYNNyzptk03LXGpuGuNTYNd62xabhrTTJretbYNNy1xqbhrjU2DXetsWm4a41Nwx1rgrNpuGuNTcNda2wa7lpj03DXmmTW9KyxabhrjU3DXWsI5pqSbtbU/PbyFwkefv64jEjxWsoFfP5eAvycoEuA57kuAZ67ugR4PuoS4DmmS4DnjS4B/lUSXQL8qxm6BHg6qxICP50DP50DP50DAZ3rWsrnN0S7l0BAZ00CAZ01CQR01iQQ0FmTQEBnTQIBnRUJkYDOmgQCOmsSCOisSeCn8xEp6KMl8NM54tPZ53qTsPGCZMSnsyoBn86qBHw6axISPp1VCfh0ViXg01mVgE9nVQI+nVUJ+HRWJfDTGT8ZX5fAT2f8VPrLS11+lRDevKXEVQJ+erwuAZ/OqgR8OqsS8OmsSsCnsyoBn86qBHw6qxLw6axKwKezKoGfzvhp1roEfrThRyDrEvjRhh8prEvAX00KfpVw0RAeX/74/cwCQTDrSLkEYatfJ3fcL2gThK0eZg3+CtFh1uCvEB1mDTzPj7MGf4XoMGvwV4gOswZ/of4wa2abWgdaM9uEO84agrDVw6yxabhrjU3DXWtsGu5ak8yanjU2DXetsWm4a41Nw11rbBruWmPTcM8agrDVw6yxabhrjU3DXWtsGu5ak8yanjU2DXetsWm4a41Nw11rbBruWmPTcMeaSBC2epg1Ng13rbFpuGuNTcNda5JZ07PGpuGuNTYNd62xabhrjU3DXWtsGu5Zgx/9e5w1Ng13rbFpuGuNTcNda5JZ07PGpuGuNTYNd62xabhrjU3DXWtsGu5Zgx+1fZw1Ng13rbFpuGuNTcNda5JZ07PGpuGuNTYNd62xabhrjU3DXWtsGu5Zgx9tf5w1Ng13rbFpuGuNTcNda5JZ07PGpuGuNTYNd62xabhrjU3DXWtsGu5Zg/8mBj7EerNGvrBmkUAwf2gSEryE6MIq4fJS1r0EAp7n23uph9buJRBwV5NAwEdNAgHHNAkEvFEk4L+JgS6B4NUMTQIBnTUJBHTWJODTWZXAT2f8NzHQJfDTGf9NDHzMcptU2/2kiv8mBqoE/Dcx0CXg01mVgE9nVQI+nVUJ+HRWJeDTWZWAT2dVAj6dVQn8dCZ4hwtNAsG7VqgS8Omc8u0FydTuX1MleBcIVQI+nVUJ+HRWJeDTWZWAT2dVAj6dVQn4dFYl4NNZk0CQoq9K4KczQSq9KoGfzgQp7yK3FySl3k+qBGnsqgR8OqsS8OmsSsCnsyoBn86aBIJUb1UCPp1VCfh0ViXg01mVwE9ngnRoVQI/nQnSlnOMq4R8/z7PkSAVWZWAT2dFQiJIGVYl4NNZlYBPZ1UCPp1VCfh0ViXg01mVgE9nVQI9nRNBSqsqAZ/OxZdVQvny8hcJBKmnqgR8OqsS8OmsSsCnsyoBH22qBHy0qRLw0aZKwEebJuFdcWWhKhK8i+vl7s2LDD5vSbhtnQZ3+7lTqFsrqjWkK5traH69Orq4cXW87bMGd/vIeePSz7nF1ypi8G8vXoxJZsy2MWLGbBuTzZhtY4oZs21MNWO2jWlmzKYx7woom9KY0NpqjA+PL/Yu5FXfm1yL1UVvLg5wMZiL73DRJ7dO4FLvXTztAD7UxWQuDnDxtKP9UBdPew74OhfL7fdP2wZdTjsCfpWLl58QXfVdftJy52KyeXGEizYvjnDR5sURLtq8+B4XJa6MFin3LiZzcYCLNi+OcNHmxREunvZF5qEunvYV6aEu2tllgItiZ5cRLtrZZYSLdnYZ4aKdXUa4mMzFAS7a2WWEi3Z2GeGinV1GuGhnl3e5WNaFUHkT4ru6aGeXAS5mO7uMcNHOLiNctKn7PS5Gv7oY4/3PXd4VJWwuai7a1D3CRZu6R7hoU/cIF23qHuGiTd0DXCw2dY9w0abuES7aTwxGuGhnlxEuJnNxgIt2dnmXi5JWO/L9q7TFzi4jXLSzywgX7ewywkU7uwxwsdrZZYSLdnYZ4aKdXQZsalQ7u4xwMZmLA1y0s8sIF23qvnNxMcYG6Y4xNhtvG9Ns3N00RraTHUu6foIi7v6ezaespesnavn+8wS34x6/456w457tyelxHo10Evu0u2TXXXnXXWXXXXXXXW3PXZ18Ke0uv+uusOuuXc9G3PVsxF3PRtz1bMRdz0bc9Wxsp0I87jHbGQjN++v3cdy4J+24R3bck3fcU3bcU7++l6UdvVl29GbZ0ZtlR2/e3uFR7kk77tl+DvL1GW2l3d+Td9xTdtxTd9zTvv6e7d8iVu7xO+7RnoOte3Y8B3nHc7D9G4PKPXnHPWXHPTv6Qd7RD8qOflB29IOyox+UHc9B2fEclB3PQdnxHJQdz0HZ8TWtO76mdcfXtO74mtaOnno9bDVxt3fJ8N799a+/Ln/9n+9+/fjd959+/O1y0+f/+8dPP/z+8eefXv/6+//+cv0/3//68dOnj//99pdff/7hx3//8euP3376+YfP/++De/3PP0N28ZuQQ7oU9PkJu5wYL38XFy9/f3kvi8uf0+d/aJ//wb/8QyuXf2jtUsulnv8D",
      "brillig_names": [
        "get_participants"
      ]
    },
    {
      "name": "check_and_register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12235207718074526931": {
            "error_kind": "string",
            "string": "Escrow contract is not registered"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7P3bkizZslyJ/ct+xoNfzG/4FQqFArLRFIi0ABQCfIL0vzN2VWVkFlKnW63OuSLcTcfbQXecOm5DY6Xr1HBz/Z//+t/+8//z//f//n/8l//6v/+3//6v//h/+5//+j/+2//rP/2P//Lf/uvj//U//7XNf/x/++//n//0X//9//zv/+M//X//x7/+47gew3/413/+r//b43/chuH//A//+t//y//xn//1H2OL//M/fPv0tM/7X5+e9vXz02Mc4tPzMh5/fXpejin59H48/9v7sYzPT8/DLD49zs//9jjP+/PT06o+PEzrx4eHbfn64f/7f/jXFoDRYBbAaDArYDSYDTAazA4YDeYAjASzD4DRYEbAaDATYDQYnG8DTABGg8H5NsDgfBtgcL4NMDjfBhicrwZz4HwbYHC+DTA43wYYnG8DTABGg8H5NsDgfBtgcL4NMDjfBhicrwYzDljfFhm8b4sM5rdFBvfbIhOQaZDB/7bIYIBbZHDALTJY4BYZPHCDzIgHbpHBA7fI4IFbZPDALTIBmQYZPHCLDB64RQYP3CKDB26RwQM3yEx44BYZPHCLDB64RQYP3CITkGmQwQO3yOCBW2TwwC0yeOAWGTxwg8yMB26RwQO3yOCBW2TwwC0yAZkGGTxwiwweuEUGD9wigwdukcEDN8gEHrhFBg/cIoMHbpHBA7fIBGQaZPDALTJ44BYZPHCLDB64RQYP3CCz4IFbZPDALTKX98Db8iSzHxmZbZ8/rnsfpp+RubwHfhuZgEyDzOU98NvIdPDAMSwfVx/D8flXcv/r/8T2+/9PdHBlj59r4/Ov9/FFsV18+njcDv769HGs+9cLEl+dad4//tvTFOP87fqPe1//Kh3Otu8f178dw5z++9o/JJ6O6cu/mFX+i1m257d6+PrPa5YfHj/+wezLMiT/vPYpnp+ejuymPy8f/7xiGs7/KU7b85/itEXy4Z7/yNcRea4sz4Q8V5ZnRp4ryxOvlmd8nOg/Lmj8wvDf+vxxRcvlrmi93BVtl7ui/XJXdFztirbhclc0Xu6Kpstd0Xy5K3rD3+zhmc1NsX6/ouVyV/T6v9nbujzPm/+Lav9BXMn8vJD1i4/Y1HU8fp/9uI7HYf1vn/5j1s1o1t1o1qPSrOv8nHX7Pus+GM06Gs06VZr1+eFp+nLues46G80aRrMupe45X2adv89ayTdNw/acddq+z1rJN2WzVvJN2aylfNOXf6/T9/vrcXHftD8t7jiMRzLs74tXp+PjtDjNY5aYdnwQ5bi41XOX5+Lu9CLyvOvHiePihtpdnjCR549h33AIiOkp1TRnpiI+PNH25YGUaZn+vPr11le/3frq91tf/XHjq5+G4dZXP9766qdbX/1866uPW1/9ne+103Dne+003PleOw13vtdOw63vteOt77Xjre+1463vteOt77Xjre+1463vteOt77Xjre+1463vteOt77XTre+1063vtdOt77XTre+1063vtdOt77XTre+1063vtdOt77XTre+1863vtfOt77Xzre+1863vtfOt77Xzre+1863vtfPF77X78ymCxyV9v/qL32uTq7/4vfZYv2xnj3+7/O8fjmV9PgazHJ8PoJhsZ09xceuBmL8i5sWdGGL+ipgXN6aI+StiXtynI+aviBmIWUfMi5/iEPNXxLz4oRYxf0XMi5/xEfNXxLx45IGYvyImCVAdMRcSoEJikgAVEpMEqJCYJECFxAzErCMmCVAhMUmAColJAlRITBKgQmKSANURcyUBKiQmCVAhMUmAColJAlRIzEDMOmKSABUSkwSokJgkQIXEJAEqJCYJUB0xNxKgQmKSABUSkwSokJgkQIXEDMSsIyYJUCExSYAKiUkCVEhMEqBCYpIA1RFzJwEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTEPEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJgAqJSQJUSEwSoEJikgCVEXMeSIAKiUkCVEhMEqBCYpIAFRIzELOOmCRAhcQkASokJglQITFJgAqJSQJUR8yRBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEB1xJxIgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzJkEqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXEDBKgQmKSABUSkwSokJgkQIXEDMSsIyYJUCExSYAKiUkCVEhMEqBCYpIA1RFzIQEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTFXEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJ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s1byTdmspXzTl3+vk7i/Xtw37U+LOw7jkQz7+47q0/FxWpweAXRy+p7H59FynvcfHdWni1u9i8jzriRlvrg7dZfn4oa6mzx/DPsGRx3TU6ppzu5a8XHT3dYvfxSX6c+rn2999XHrq19uffXrra9+u/XV77e++uPOVx/Dra9+vPXV3/peG7e+18at77Vx63tt3PpeG7e+18at77Vx63vtcut77XLre+1y63vtcut77XLre+1y63vtcut77XLre+1y63vtcut77Xrre+1663vteut77Xrre+3ru6O7Xv2t77Xrre+1663vteut77Xrre+1263vtdut77Xbre+1263vta8vDPy1q9+fTxE8Lun71V/8Xptc/cXvtcf6ZZVs/Nvlf/9wLOvzMZjl+HwAxWWVbLu49UDMXxHz4k4MMX9FzIsbU8T8BTH3i/t0xPwVMS9+bEHMXxHz4qc4xPwVMS9+qEXMXxEzELOOmBePPBDzV8QkASokJglQITFJgAqJSQJUR8yDBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEBlxNwGEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJgAqJSQJUSEwSoEJikgDVEXMkASokJglQITFJgAqJSQJUSMxAzDpikgAVEpMEqJCYJECFxCQBKiQmCVAdMScSoEJikgAVEpMEqJCYJECFxAzErCMmCVAhMUmAColJAlRITBKgQmKSANURcyYBKiQmCVAhMUmAColJAlRIzEDMOmKSABUSkwSokJgkQIXEJAEqJCYJUB0xgwSokJgkQIXEJAEqJCYJUCExAzHriEkCVEhMEqBCYpIAFRKTBKiQmCRAdcRcSIAKiUkCVEhMEqBCYpIAFRIzELOOmCRAhcQkASokJglQITFJgAqJSQJUR8yVBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEB1xNxIgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzJ0EqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXEPEiAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEbMfSABKiQmCVAhMUmAColJAlRIzEDMOmKSABUSkwSokJgkQIXEJAEqJCYJUB0xRxKgQmKSABUSkwSokJgkQIXEDMSsIyYJUCExSYAKiUkCVEhMEqBCYpIA1RFzIgEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTFnEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJgAqJSQJUSEwSoEJikgDVETNIgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzIUEqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXEXEmAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEfMjQSokJgkQIXEJAEqJCYJUCEx4+VirntTzD+u6OUxxhTbE/4yL8nXa5ym+Lj+af4q1SY+vS7D/ten12X+/MaM6kLmafq47Hmav6DZ5Yzb+HHV+7Z9/fAfGFcw9sC4gbEHxh2MPTAeYPxHGI/j4zrmYVz+V4z7AMYeGEcw/hOMD3f4iTGOhPnnZTwc63D+4XHfn+buK+sPgSYEerNAx7I8Bdr28w/H8+ASx/x1vD+0nNGyjJaBlmW05Lj6Zi2nR8rz8eFhip9oyZm5jpYc3N+t5Th+xJTTOB/fzCmRwMUFImy4tkAHMca7BZri4788TXtyGeO8P3+YiuFbmnKQplRSk+jlVmou8/Mn1WVZf+A7D3IaU+ED4T2FJwG6l/DbM/pbjp9EfwdxkanwZEu/Q/hPLdM/yMkPnwfZ0rsF6vYDy0EMVUXLYyCxerOW3X5gOQbyqjpakla9W8vTqP9BH4GuLVAg0LUFIqV5t0D9fl45BqKXSmqSp9xKzV7R+TGQ05gKT6jjKfxIAnQv4Tv9ZnKMxEWmwpMt/Qbh1+njJQrTuiw/ct8j2dLFBQoEerNA/fwPMVQdLQmh6mhJBPV2Lbs5TlKlOloSFP0zLcfxg8g8Tkt2bOz2jpFjItB5t0DdHs+ayGjqaEnsUkdLEpo3a9nvUbsp0LKMloQ579by/KGviYTm4gIRu1xcILKUdwvU8UG7iTSlkJoz0cut1Oz2Y8VMTmMqPKGOqfAkQPcSvtfvX3MgvKfwZEu/Q/hu7xg5ZrKldwvU7QeWmRiqjpYkVm/Wst8PLDN5VRktg7Tq3VqeR/1BqnRxgUh/Li4QKc27Ber480oEahZSkzzlVmp2i86DnMZUeEIdU+FJgO4lfK/fTIK4yFP4hWzpNwjf8RUWC9nSxQUiW3q3QN38z0IMVUfLQMsyWhJBvV3Lbo6TVKmOlq8Pipbjy6DrTbSc9u35LMC+bd8s5A7GHhgPMHbAuA5g7IFxBOM/wngcn+/SGr8dr9cJjD0wzmD8R67rtzWuJg/Fr4FAbxao24PU64KWZbRc0bKMlhxX36xlv4fiV87MdbTk4P5uLc8fz96IBC4uEGHDxQUixni3QB0fid9IUyqpGah5JzW7PVawkdOYCk+oYyo8CdC9hO/1pMpGXGQqPNnS7xC+39vAdrKldwvU7QeWnRiqjpYkVm/Wst8PLDt5VR0tAy3frOV51L+TKl1cINKfiwtESvNugTr+vLITvVRSkzzlVmp2i84PchpT4Ql1TIUnAbqX8L1+MzmIi0yFD4TvL3zHl00dZEsXF4hs6d0C9fM/xFB1tCSEqqMlEdTbtezkOMdhIFYqJCZR0T8T87d1rp4/bPdQiEzn3Qr1ekLrISY5TSExAzHriElO82Yxuz1w9xCTTKeQmIQ67xbz9OGvh0JENVdXiADm4gqNpCrvVqjfM3cPOclVSslJCHMrOXv9cvFQnsTGVflAeVPlyYLupXy3n8NGgiNX5UmZfofy3d468lCIlOndCvX7uWUkkKoj5kR29WYxO/7cMpFcFRKT3OrdYia5/0S+dHWFAoUurhB5zbsV6vljy0QIU0pOkpVbydkvR59IbFyVJ94xVX4mC7qX8t1+QZkJjlyVJ2X6Dcr3e8fFQyFSpqsrFCj0ZoU6miACqUJiEkcVEpMw6u1i9vOd5EuFxHx9ZLR9irlP49/E/OOSYrjeJb3+kL1t4+clTeKSputd0uuPO8fyIdw8DIe4pLjeJb3cpe7L8ww0DFPy13Nfnr/67svy+ddzHuSnp3h+ejrG5NPz8vGoaUxf/y7LL9v08dlpi+TD47Y/ncr+ZUL94eH5Xx6Hbfn64T/1WdHn0vq83Es+7uPH01DEKv5J79e7pJff18dtfZqS7RiTr/HnN2I71i9fS2XRpvEzYB2X/W+f/mPYZXAadnQadqo07Pr5PNWmhp2dhg2nYZdKwz4/PE1fbuafw65Ow25Ow+6lbj1fhp3FsJUc1DRsz2Gn7fuwayUHlQ5byUGlw5ZyUF/+zU7iPrte3EHtT7v7713MZNrfd3afjo/D4/RIppPj+Dw+T5rzvP/s7L4G+lw5W1kv7lPt9bm4te6mz5/TvsFbx/QUa5qzW1d83Hq39csfxmX66/L3e1/+cevL34Z7X/5478uf7n35870vP+59+cu9L3+99+Xf+6673fuuu937rrvf+6673/uuu9/7rrvf+6673/uuu9/7rrvf+6673/uuu9/7rrvf+6573Puue9z7rnvc+6573Puue9z7rnvc+6573Puue9z7rnvc+6573PquOw63vuuOw63vuuNw67vuONz6rjsOt77rjsOt77rjcOu77jjc+q47Dre+647Dxe+6+/OBg8clfb/88eJ33ezyL37XPdYvu2jj367/+4djWZ8PzSzH5+MqLrto43hxE4Kav6TmxT0Zav6SmoGahdS8uGNHzV9S8+IHGNT8JTUvfp5DzV9S8+LHW9T8JTUvftpHzV9Rc7p4+IGav6QmWVAlNcmCKqlJFlRJzUDNQmqSBVVSkyyokppkQZXUJAuqpCZZUCE1Z7KgSmqSBVVSkyyokppkQZXUDNQspCZZUCU1yYIqqUkWVElNsqBKapIFFVIzyIIqqUkWVElNsqBKapIFVVIzULOQmmRBldQkC6qkJllQJTXJgiqpSRZUSM2FLKiSmmRBldQkC6qkJllQJTUDNQupSRZUSU2yoEpqkgVVUpMsqJKaZEGF1FzJgiqpSRZUSU2yoEpqkgVVUjNQs5CaZEGV1CQLqqQmWVAlNcmCKqlJFlRIzY0sqJKaZEGV1CQLqqQmWVAlNQM1C6lJFlRJTbKgSmqSBVVSkyyokppkQYXU3MmCKqlJFlRJTbKgSmqSBVVSM1CzkJpkQZXUJAuqpCZZUCU1yYIqqUkWVEjNgyyokppkQZXUJAuqpCZZUCU1AzULqUkWVElNsqBKapIFVVKTLKiSmmRBddScBrKgSmqSBVVSkyyokppkQZXUDNQspCZZUCU1yYIqqUkWVElNsqBKapIFFVJzJAuqpCZZUCU1yYIqqUkWVEnNQM1CapIFVVKTLKiSmmRBldQkC6qkJllQITUnsqBKapIFVVKTLKiSmmRBldQM1CykJllQJTXJgiqpSRZUSU2yoEpqkgUVUnMmC6qkJllQJTXJgiqpSRZUSc1AzUJqkgVVUpMsqJKaZEGV1CQLqqQmWVAhNYMsqJKaZEGV1CQLqqQmWVAlNQM1C6lJFlRJTbKgSmqSBVVSkyyokppkQYXUXMiCKqlJFlRJTbKgSmqSBVVSM1CzkJpkQZXUJAuqpCZZUCU1yYIqqUkWVEjNlSyokppkQZXUJAuqpCZZUCU1AzULqUkWVElNsqBKapIFVVKTLKiSmmRBhdTcyIIqqUkWVElNsqBKapIFVVIzULOQmmRBldQkC6qkJllQJTXJgiqpSRZUSM2dLKiSmmRBldQkC6qkJllQJTUDNQupSRZUSU2yoEpqkgVVUpMsqJKaZEGF1DzIgiqpSRZUSU2yoEpqkgVVUjNQs5CaZEGV1CQLqqQmWVAlNcmCKqlJFlRHzXkgC6qkJllQJTXJgiqpSRZUSc1AzUJqkgVVUpMsqJKaZEGV1CQLqqTm67OgdW+q+ccljS8PNKbYnviXeUm+YOM0xccA0/xVrE18el2G/a9Pr8v8+Z0Z1YXM0/Rx2fM0f2Gzyxm38eOq9237+uE/OY5w7MJxgmMXjjMcu3AMOP4jjsfxcR2PWHX5znGBYxeOKxz/CceHS/zkGEcC/fMyHs51OP/wuO9Pk/eV9VOhDYXerNCxLE+Ftv38w/E8wcQxfx3vTzF3xKwj5oGYZcScOLi+Wczpkfh8fHiY4kdicnouJCZH+HeLOY4foeU0zsc3izoRDlxdoUChiytEoPFuhab4+C9P055cxjjvz1+qYvieq0zkKqXkJIS5lZzL/PyVdVnWH7lPEhtX5Yl3TJWfyYLupfz2TAGX40cp4Exw5Ko8KdPvUP5TzPRvcvZD6EzK9G6F+v3cMgdi1hGT7OrNYnb8uWUmuSokJrnVu8VMcv+ZfOnqCpEDXVyhIK95t0I9f2wJQphScpKs3ErOfjl6kNi4Kh8ob6o8WdC9lO/2C0oQHLkqT8r0G5Rfp49XLUzrsvzQg5MyXV0hUqZ3K9TPBC0EUoXEJI4qJCZh1NvF7OY7F/KlQmIGYv4jMcfxg8g8Tkt2fOz4JpKFaOfdCvV7ZmshrSkkJgFMITHJat4sZscH8BZinTpirsQ67xYzeRJsJau5ukIEMFdXiFTl3Qr1fPxuDeSsJCchzK3k7PfTxUpi46o88Y6r8mRB91K+289hK8GRqfIbKdPvUL7jm0g2UqZ3K9Tv55aNQKqQmGRXbxaz488tWyBmHTHJrd4tZpL7b+RLV1eIHOjqCpHXvFuhnj+2bIQwleTcSVZuJWe/HH0nsXFVnnjHVXmyoHsp3+0XlD1Q3lR5UqbfoHzP91zspExXV4iU6d0KdTRBBFKFxCSOqiPmQRj1djG7+c6DfKmQmK+PjJbjy6TrTcSc9u35dMC+bd+M5DHDsQvHgGMXjgscu3Bc4fiPOB7H52u3xu8H7WODYxeOOxz/kfn6baWt2QPzx4FCb1ao2zPWMQyIWUfMETHriMnB9c1i9ntgPgZOz4XEDMR8s5jnT24/fghFoYsrROxwdYUINN6tUMfH5WMgVyklJyHMreTs9qhBjCQ2rsoT77gqTxZ0L+V7Pb4SI8GRq/KB8r9B+X5vDouRlOndCvX7uWUkkCokJtnVm8Xs+HPLSHJVSExyq3eLmeT+E/nS1RUiB7q6QuQ171ao548tEyFMKTkDOe8kZ78cfSKxcVWeeMdVebKgeynf7ReUieDIVXlSpt+gfMf3UsVMynR1hUiZ3q1QPxM0E0gVEpM4qpCYgZjvFrOb75zJlwqJSWT0z8T8baWt2QN4M9HOuxXq98zWTFpTSEwCmDpiBlnNm8Xs+ABeEOsUEpNY591iJk+CBVnN1RUKFLq4QqQq71ao5+N3Qa5SSk5CmFvJ2e+niyCxcVWeeMdU+YUs6F7Kd/s5bCE4clWelOl3KN/xTSQLKdO7Fer3c8sSiFlHTLKrN4vZ8eeWheSqkJjkVu8WM8n9F/KlqytEDnRxhVbymncr1PPHlpUQppScJCu3krNfjr6S2LgqHyhvqjxZ0L2U7/YLykpw5Ko8KdNvUL7ney5WUqarK0TK9G6F+pmgjUCqkJjEUYXEJIx6u5jdfOdGvlRIzHi5mNunmPs0/k3MPy9pud4lvf6QvW3j5yVN4pK2613S6487x/Ih3DwMh7ik43KXtGuXekz785KW7W+X9Of/mvRD+/D8W7cPy5BMMg7z8+/GsH/5I7OO8q/Mx4Oh0/A59bSrv6L7FB9eYZ+Oz39B86D+Qs/P/3JMX/8+yy/d9LyKLZIPj9v+dCz712uWHx6e/+Vx2JavH/4T+ATw1wKfOwAf1+F57x+3DPj2fORr3MYx+W8f8fEP+1iOv/0V+PPy496Xv9z78td7X/6WXv7a9z61L89gbBimxFLvy/NRoH35wlH/tan4t2l/tT6Pw8Px/DLGKnzEcblLOoaXX9K2Pm+w2zEmX+PPb8R2rF++luoGO42fv+qMy/63T/857Og07OQ07Fxp2PXzIc5NDRtOwy5Ow66Vhn1+ePp6OPocdnMadnca9ih16/ky7Pxt2GWo5KCmYXsOO21i2EoOKh22koNKhy3loL78m512MWxce9j9aXfHYTySaX/f2X06Pg6P0+PnsOQ4Po/Pk+Y87z86uy/DxU3fRfR5V7ayDBf3qfb6XNxad9Pnz2nf4K2f2fC4T3N264qPW++2fvnDuEx/Xf5x68sfh3tf/njvy5/uffnzvS8/7n35y70vf7335W/3vvx733XHe991p3vfdad733Wne991p3vfdad733Wne991p3vfdad733Wne991p3vfded733Xne99153vfded733Xne99153vfded733Xne99153vfded733Xj3nfduPddN+59141733Xj3nfduPddN+59141733Xj3nfduPddd7n4XXd/PnCw74O4/IvfdbPLv/hd91i/7KKNf7v+7x+OZX0+NLMcn4+ruOyiLcvFTQhq/pKagZqF1Ly4RUXNX1Lz4o4dNX9JzYsfYFDzl9S8+HkONX9JzYsfb1HzV9RcL37aR81fUvPi4Qdq/pKaZEGV1CQLqqRmoGYhNcmCKqlJFlRJTbKgSmqSBVVSkyyokJobWVAlNcmCKqlJFlRJTbKgSmoGahZSkyyokppkQZXUJAuqpCZZUCU1yYIKqbmTBVVSkyyokppkQZXUJAuqpGagZiE1yYIqqUkWVElNsqBKapIFVVKTLKiQmgdZUCU1yYIqqUkWVElNsqBKagZqFlKTLKiSmmRBldQkC6qkJllQJTXJguqouQ5kQZXUJAuqpCZZUCU1yYIqqRmoWUhNsqBKapIFVVKTLKiSmmRBldQkCyqk5kgWVElNsqBKapIFVVKTLKiSmoGahdQkC6qkJllQJTXJgiqpSRZUSU2yoEJqTmRBldQkC6qkJllQJTXJgiqpGahZSE2yoEpqkgVVUpMsqJKaZEGV1CQLKqTmTBZUSU2yoEpqkgVVUpMsqJKagZqF1CQLqqQmWVAlNcmCKqlJFlRJTbKgQmoGWVAlNcmCKqlJFlRJTbKgSmoGahZSkyyokppkQZXUJAuqpCZZUCU1yYIKqbmQBVVSkyyokppkQZXUJAuqpGagZiE1yYIqqUkWVElNsqBKapIFVVKTLKiQmitZUCU1yYIqqUkWVElNsqBKagZqFlKTLKiS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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_notes_internal",
        "get_collapse_hints",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "pack_returns_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000b3dd3286"
            },
            {
              "kind": "string",
              "value": "ParticipantNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "name",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseEscrow"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "entitlements",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "escrow_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "dkim_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "managed_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participants",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participant_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "dkim_key_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "verifier_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::DKIMKeyHashRegistered"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::set_contract_registered_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::set_contract_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_registry_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_registry_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "usdc",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow_contract_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_bulk_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_bulk_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_class_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_class_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_and_register_participant_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_and_register_participant_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "105": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "107": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "108": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "109": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "110": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "112": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "113": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "114": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "119": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "120": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "122": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\n\npub struct NullifierMembershipWitness {\n    pub index: Field,\n    pub leaf_preimage: NullifierLeafPreimage,\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let serialized_leaf_preimage = array::subarray(fields, 1);\n\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"
    },
    "125": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "126": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "129": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "131": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 bytes.\n//\n// Each 31 byte chunk is converted into a Field as if the chunk was the Field's big endian representation. If the last chunk\n// is less than 31 bytes long, then only the relevant bytes are conisdered.\n// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\npub fn bytes_to_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut dst = [0; (N + 30) / 31];\n\n    for dst_index in 0..((N + 30) / 31) {\n        let mut field_value = 0;\n\n        for i in 0..31 {\n            let byte_index = dst_index * 31 + i;\n            if byte_index < N {\n                // Shift the existing value left by 8 bits and add the new byte\n                field_value = field_value * 256 + input[byte_index] as Field;\n            }\n        }\n\n        dst[dst_index] = field_value;\n    }\n\n    dst\n}\n\n// Converts an input array of fields into bytes. Each field of input has to contain only 31 bytes.\n// TODO(#8618): Optimize for public use.\npub fn fields_to_bytes<let N: u32, let M: u32>(input: [Field; M]) -> [u8; N] {\n    let mut dst = [0; N];\n\n    for src_index in 0..M {\n        let field = input[src_index];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let src: [u8; 31] = field.to_be_bytes();\n\n        // Since some of the bytes might not be occupied (if the source value requiring less than 31 bytes),\n        // we have to compute the start index from which to copy.\n        let remaining_bytes = N - src_index * 31;\n        let src_start_index = if remaining_bytes < 31 {\n            // If the remaining bytes are less than 31, we only copy the remaining bytes\n            31 - remaining_bytes\n        } else {\n            0\n        };\n\n        // Note: I tried combining this check with `assert_max_bit_size` above but `assert_max_bit_size` expects\n        // the argument to be a constant. Using comptime block to derive the number of bits also does not work\n        // because comptime is evaluated before generics.\n        for i in 0..src_start_index {\n            assert(src[i] == 0, \"Field does not fit into remaining bytes\");\n        }\n\n        for i in 0..31 {\n            let byte_index = src_index * 31 + i;\n            if byte_index < N {\n                dst[byte_index] = src[src_start_index + i];\n            }\n        }\n    }\n\n    dst\n}\n\nmod test {\n    use crate::utils::bytes::{bytes_to_fields, fields_to_bytes};\n\n    #[test]\n    fn test_bytes_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_bytes() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_bytes(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_less_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_bytes(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_bytes_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_bytes() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_input_to_fields_and_back(input: [u8; 128]) {\n        let output = bytes_to_fields(input);\n        let input_back: [u8; 128] = fields_to_bytes(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_bytes(input);\n        let input_back = bytes_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"Field does not fit into remaining bytes\")]\n    fn test_too_few_destination_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_bytes(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_bytes_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_bytes(input);\n    }\n\n    #[test]\n    fn test_fields_to_bytes_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_bytes(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "145": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::DEPLOYER_CONTRACT_ADDRESS,\n    hash::compute_siloed_nullifier,\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for BlockHeader {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for BlockHeader {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for BlockHeader {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for BlockHeader {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n"
    },
    "146": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr",
      "source": "use dep::protocol_types::block_header::BlockHeader;\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{\n    context::PrivateContext,\n    note::{note_interface::{NoteInterface, NullifiableNote}, utils::compute_siloed_nullifier},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: BlockHeader, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for BlockHeader {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving nullifier inclusion failed\",\n            );\n\n            // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n            // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n            // care about is showing that the tree contains an entry with the expected nullifier.\n            assert(\n                witness.leaf_preimage.nullifier == nullifier,\n                \"Nullifier does not match value in witness\",\n            );\n        }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(\n        header: BlockHeader,\n        note: Note,\n        context: &mut PrivateContext,\n    )\n    where\n        Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for BlockHeader {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(self, note: Note, context: &mut PrivateContext)\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"
    },
    "148": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "149": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "150": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "153": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "154": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "161": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "197": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr",
      "source": "pub global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable},\n    hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct NullifierLeafPreimage {\n    pub nullifier: Field,\n    pub next_nullifier: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<Field> for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_key: Field, next_index: u32) -> Self {\n        Self { nullifier: self.nullifier, next_nullifier: next_key, next_index }\n    }\n\n    fn update_value(self, _nullifier: Field) -> Self {\n        assert(false, \"Tried to update a nullifier\");\n        Self::empty()\n    }\n\n    fn build_insertion_leaf(nullifier: Field, low_leaf: Self) -> Self {\n        Self { nullifier, next_nullifier: low_leaf.next_nullifier, next_index: low_leaf.next_index }\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value =\n            compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(\n            self.nullifier,\n            siloed_value,\n            \"Value of the nullifier leaf does not match read request\",\n        );\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"
    },
    "205": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "212": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "241": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n"
    },
    "252": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "267": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "268": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "284": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "287": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "289": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "290": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "293": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "294": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "296": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "297": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "301": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "302": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "303": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "304": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "307": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "313": {
      "path": "/Users/ianbrighton/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "321": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_escrow/src/types/entitlement_note.nr",
      "source": "use aztec::{\n    encrypted_logs::encrypted_event_emission::encode_and_encrypt_event,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::{note, note_custom_interface},\n    note::utils::compute_note_hash_for_nullify,\n    oracle::{random::random, notes::check_nullifier_exists, debug_log::debug_log_format},\n    prelude::{NoteHeader, NullifiableNote, NoteInterface, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        traits::{Serialize, Deserialize},\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::{poseidon2_hash_with_separator, poseidon2_hash_bytes},\n        utils::field::field_from_bytes,\n    },\n};\nuse compressed_string::CompressedString;\nuse generators::GENERATORS;\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\nuse crate::{ZERO_DESTINATION, ZImburseEscrow::{SpotReimbursementClaimed, RecurringReimbursementClaimed, EntitlementNullified}};\n\nglobal ENTITLEMENT_NOTE_LENGTH: u32 = 8;\n\n#[note]\npub struct EntitlementNote {\n    // the user that is allowed to use this entitlement\n    recipient: AztecAddress,\n    // the type of receipt verifier that this entitlement can be used for\n    verifier_id: u8,\n    // the maximum value that can be withdrawn from the escrow using this entitlement\n    max_value: U128,\n    // date range that verified emails can be used for\n    date_start: u32,\n    date_end: u32,\n    // destination if used for travel\n    destination: Field,\n    // whether or not the entitlement is a spot entitlement\n    spot: bool,\n    // blinding factor & nullifier secret for the note\n    randomness: Field,\n}\n\n// impl NoteInterface<ENTITLEMENT_NOTE_LENGTH> for EntitlementNote {\n\n//     fn serialize_content(self) -> [Field; ENTITLEMENT_NOTE_LENGTH] {\n\n//         [\n//             self.recipient.to_field(),\n//             self.verifier_id as Field,\n//             self.max_value.to_integer(),\n//             self.date_start as Field,\n//             self.date_end as Field,\n//             self.destination,\n//             self.spot as Field,\n//             self.randomness\n//         ]\n//     }\n\n//     fn deserialize_content(serialized_note: [Field; ENTITLEMENT_NOTE_LENGTH]) -> EntitlementNote {\n//         EntitlementNote {\n//             recipient: AztecAddress::from_field(serialized_note[0]),\n//             verifier_id: serialized_note[1] as u8,\n//             max_value: U128::from_integer(serialized_note[2]),\n//             date_start: serialized_note[3] as u32,\n//             date_end: serialized_note[4] as u32,\n//             destination: serialized_note[5],\n//             spot: serialized_note[6] as bool,\n//             randomness: serialized_note[7],\n//             header: NoteHeader::empty()\n//         }\n//     }\n\n//     fn to_be_bytes(self, storage_slot: Field) -> [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] {\n//         let serialized_note = self.serialize_content();\n//         let mut buffer: [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] = [0; ENTITLEMENT_NOTE_LENGTH * 32 + 64];\n//         let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n//         let note_type_id_bytes: [u8; 32] = EntitlementNote::get_note_type_id().to_be_bytes();\n//         for i in 0..32 {\n//             buffer[i] = storage_slot_bytes[i];\n//             buffer[32 + i] = note_type_id_bytes[i];\n//         }\n//         for i in 0..serialized_note.len() {\n//             let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n//             for j in 0..32 {\n//                 buffer[64 + i * 32 + j] = bytes[j];\n//             }\n//         }\n//         buffer\n//     }\n\n//     fn get_note_type_id() -> Field {\n//         comptime\n//         {\n//             let bytes = \"EntitlementNote\".as_bytes();\n//             let hash = poseidon2_hash_bytes(bytes);\n//             let hash_bytes = hash.to_be_bytes::<4>();\n//             field_from_bytes(hash_bytes, true)\n//         }\n//     }\n\n//     fn get_header(self) -> NoteHeader {\n//         self.header\n//     }\n\n//     fn set_header(&mut self, header: NoteHeader) {\n//         self.header = header;\n//     }\n\n//     fn compute_note_hash(self) -> Field {\n//         let serialized = self.serialize_content();\n//         let generators = [\n//             GENERATORS[0],\n//             GENERATORS[1],\n//             GENERATORS[2],\n//             GENERATORS[3],\n//             GENERATORS[4],\n//             GENERATORS[5],\n//             GENERATORS[6],\n//             GENERATORS[7],\n//             GENERATORS[8]\n//         ];\n//         let data = [\n//             from_field_unsafe(serialized[0]),\n//             from_field_unsafe(serialized[1]),\n//             from_field_unsafe(serialized[2]),\n//             from_field_unsafe(serialized[3]),\n//             from_field_unsafe(serialized[4]),\n//             from_field_unsafe(serialized[5]),\n//             from_field_unsafe(serialized[6]),\n//             from_field_unsafe(serialized[7]),\n//             from_field_unsafe(self.get_header().storage_slot)\n//         ];\n//         std::embedded_curve_ops::multi_scalar_mul(generators, data).x\n//     }\n// }\n\nimpl NullifiableNote for EntitlementNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = self.randomness; // use as nullifier_secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = self.randomness; // use as nullifier secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for EntitlementNote {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient)\n            & (self.date_start == other.date_start)\n            & (self.date_end == other.date_end)\n            & (self.destination == other.destination)\n            & (self.max_value == other.max_value)\n            & (self.randomness == other.randomness)\n            & (self.spot == other.spot)\n            & (self.verifier_id == other.verifier_id)\n    }\n}\n\nimpl EntitlementNote {\n    \n    /**\n     * EntitlementNote constructor\n     *\n     * @param recipient - the address of the recipient of the entitlement (NOT THE OWNER OF THE NOTE)\n     * @param verifier_id - the type of verifier that the entitlement can be used for\n     * @param max_value - the maximum value that can be withdrawn from the escrow using the entitlement\n     * @param date_start - the start of the date range that the entitlement can be used for (0 for recurring)\n     * @param date_end - the end of the date range that the entitlement can be used for (0 for recurring)\n     * @param destination - the destination of the entitlement (ZERO_DESTINATION for recurring)\n     * @param randomness - blinding factor for the note (inputted since must be same between the two notes)\n     */\n    fn new(\n        recipient: AztecAddress,\n        verifier_id: u8,\n        max_value: U128,\n        date_start: u32,\n        date_end: u32,\n        destination: str<31>,\n        spot: bool,\n        randomness: Field\n    ) -> Self {\n        let destination_compressed: CompressedString<1, 31> = CompressedString::from_string(destination);\n\n        // assert destination \n        if spot {\n            assert(date_end == 0, \"Date end must be zero if entitlement is spot.\");\n            assert(date_start == 0, \"Date start must be zero if entitlement is spot.\");\n            assert(destination == ZERO_DESTINATION, \"Destination must be empty if entitlement is spot.\");\n        }\n\n        Self {\n            recipient,\n            verifier_id,\n            max_value,\n            date_start,\n            date_end,\n            destination: destination_compressed.value[0],\n            spot,\n            randomness,\n            header: NoteHeader::empty()\n        }\n    }\n\n    /**\n     * Return the destination of the entitlement\n     *\n     * @return the utf8 bytes of the destination\n     */\n    fn destination(self) -> [u8; 31] {\n        CompressedString::<1, 31> { value: [self.destination] }.to_bytes()\n    } \n\n    /**\n     * Constrain a given timestamp to be within the date range of the entitlement\n     *\n     * @param timestamp - the timestamp to check\n     */\n    fn check_date_range(self, timestamp: u32) {\n        debug_log_format(\"\\n\\n\\n\\nChecking date range:\\nStart: {0}\\nTimestamp:{1}\\nEnd:{2}\", [\n            self.date_start as Field,\n            timestamp as Field,\n            self.date_end as Field\n        ]);\n        assert(\n            (timestamp >= self.date_start) & (timestamp <= self.date_end),\n            \"Receipt is out of entitlement date range\"\n        );\n    }\n\n    /**\n     * Determine the amount to reimburse for a given claimed amount (lesser of the two)\n     *\n     * @param claimed - the amount claimed by the user\n     * @return the amount to reimburse\n     */\n    fn amount_to_reimburse(self, claimed: U128) -> Field {\n        if self.max_value >= claimed {\n            claimed.to_field()\n        } else {\n            self.max_value.to_field()\n        }\n    }\n\n    fn derive_shared_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            self.serialize_content(),\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Derives the nullifier for recurring notes\n     * @dev recurring notes are nullified for a scope (month) without destroying the ntoe\n     *      prove nullifier non-inclusion to use\n     *\n     * @param timestamp - the timestamp (month/ year) from the email receipt verifier\n     * @return - the month nullifier for the note\n     */\n    fn derive_recurring_nullifier(self, timestamp: Field) -> Field {\n        let serialized = self.serialize_content();\n        let mut inputs: [Field; ENTITLEMENT_NOTE_LENGTH + 1] = [0; ENTITLEMENT_NOTE_LENGTH + 1];\n        for i in 0..ENTITLEMENT_NOTE_LENGTH {\n            inputs[i] = serialized[i];\n        }\n        inputs[ENTITLEMENT_NOTE_LENGTH] = timestamp;\n        poseidon2_hash_with_separator(\n            inputs,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Assert that a recurring nullifier has not been used before and emits it\n     * @dev uses oracle check_nullifier_exists which is technically unsafe but will be caught by kernel\n     *\n     * @param context - the private context to use for the oracle call\n     * @param timestamp - the timestamp to check\n     */\n    fn check_and_emit_recurring_nullifier(self, context: &mut PrivateContext, timestamp: Field) {\n        // derive recurring nullifier for the month\n        let recurring_nullifier = self.derive_recurring_nullifier(timestamp);\n        // check the nullifier has not been emitted via oracle call (rely on kernel to actually constrain)\n        let recurring_nullifier_exists = unsafe { check_nullifier_exists(recurring_nullifier) };\n        assert(!recurring_nullifier_exists, \"Entitlement has already been claimed for this month\");\n        // emit the nullifier\n        context.push_nullifier(recurring_nullifier);\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a recurring claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     * @param timestamp - the timestamp of the claim\n     */\n    fn emit_recurring_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field, timestamp: Field) {\n        RecurringReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n            timestamp\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a spot claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     */\n    fn emit_spot_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field) {\n        SpotReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Admin or recipient notifies counterparty that note has been nullified\n     * @dev admin emits event when revoking entitlement, recipient emits when claiming spot\n     * @dev clients must scan for these events to prune notes that are no longer valid\n     *\n     * @param context - the private execution context\n     * @param to - the address of the counterparty to notify\n     * @param from - the address of the notifier who nullified the entitlement note\n     */\n    fn emit_nullified(self, context: &mut PrivateContext, to: AztecAddress, from: AztecAddress) {\n        EntitlementNullified { randomness: self.randomness }.emit(\n            encode_and_encrypt_event(\n                context,\n                to,\n                to\n            )\n        );\n    }\n}\n"
    },
    "364": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "459": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/registry_definition.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\n\nglobal REGISTRY_DEFINITION_LENGTH: u32 = 3;\n\npub struct RegistryDefinition {\n    admin: AztecAddress,\n    usdc: AztecAddress,\n    escrow_contract_id: Field\n}\n\nimpl Serialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn serialize(self: Self) -> [Field; REGISTRY_DEFINITION_LENGTH] {\n        [self.admin.to_field(), self.usdc.to_field(), self.escrow_contract_id]\n    }\n}\n\nimpl Deserialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn deserialize(fields: [Field; REGISTRY_DEFINITION_LENGTH]) -> Self {\n        RegistryDefinition {\n            admin: AztecAddress::from_field(fields[0]),\n            usdc: AztecAddress::from_field(fields[1]),\n            escrow_contract_id: fields[2]\n        }\n    }\n}\n\nimpl RegistryDefinition {\n    /**\n     * Create a new definition for a Z-Imburse escrow registry contract\n     *\n     * @param admin - The address that can add dkim keys to the registry\n     * @param usdc The address of the USDC token\n     * @param escrow_contract_id The ID of the escrow contract\n     * @return The new escrow registry definition\n     */\n    pub fn new(admin: AztecAddress, usdc: AztecAddress, escrow_contract_id: Field) -> Self {\n        RegistryDefinition { admin, usdc, escrow_contract_id }\n    }\n}\n"
    },
    "460": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/participant_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}\n},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n"
    },
    "473": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/library_methods/dkim.nr",
      "source": "use aztec::{context::public_context::PublicContext, unencrypted_logs::unencrypted_event_emission::emit};\nuse crate::{\n    BULK_KEY_LENGTH,\n    ZImburseRegistry::{DKIMKeyHashRegistered, Storage}\n};\n\n/**\n * Register a single DKIM key\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hash - the hash of the DKIM key to add to the registry\n * @param verifier_id - the verifier ID to register the DKIM key to\n*/\n\npub fn register_dkim_key(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hash: Field, verifier_id: Field) {\n    let stored_id = storage.dkim_registry.at(dkim_key_hash).read();\n    assert(stored_id == 0, \"DKIM key has already been registered\");\n    storage.dkim_registry.at(dkim_key_hash).initialize(verifier_id);\n    emit(\n        context,\n        DKIMKeyHashRegistered { dkim_key_hash, verifier_id }\n    );\n}\n\n/**\n * Register multiple DKIM keys\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n * @param verifier_ids - the verifier IDs to register the DKIM keys to\n */\npub fn register_dkim_keys_bulk(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hashes: [Field; BULK_KEY_LENGTH], verifier_ids: [Field; BULK_KEY_LENGTH]) {\n    for i in 0..BULK_KEY_LENGTH {\n        if (verifier_ids[i] != 0) {\n            register_dkim_key(context, storage, dkim_key_hashes[i], verifier_ids[i]);\n        }\n    }\n}"
    },
    "474": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\nmod library_methods;\nmod test;\nmod types;\n\npub global BULK_KEY_LENGTH: u32 = 4;\n\n#[aztec]\ncontract ZImburseRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, PrivateSet, PublicImmutable, Map},\n        macros::{storage::storage, events::event, functions::{private, public, view, initializer, internal}},\n        note::{\n            note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions,\n            note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE\n        },\n        protocol_types::{\n            contract_instance::ContractInstance, address::partial_address::PartialAddress,\n            contract_class_id::ContractClassId, abis::function_selector::FunctionSelector, traits::Serialize\n        },\n        oracle::get_contract_instance::get_contract_instance,\n        keys::getters::get_public_keys, utils::comparison::Comparator,\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt_note_unconstrained, encode_and_encrypt_note},\n        unencrypted_logs::unencrypted_event_emission::emit\n    };\n    use std::{meta::derive, collections::bounded_vec::BoundedVec};\n    use dep::address_note::address_note::AddressNote;\n    use dep::zimburse_verifiers::constants::verifier_ids;\n    use dep::z_imburse_escrow::ZImburseEscrow;\n    use crate::{\n        library_methods::dkim::{register_dkim_key, register_dkim_keys_bulk},\n        types::{registry_definition::RegistryDefinition, participant_note::{ParticipantNote, NAME_LENGTH}},\n        BULK_KEY_LENGTH\n    };\n\n    #[derive(Serialize)]\n    #[event]\n    struct DKIMKeyHashRegistered {\n        dkim_key_hash: Field,\n        verifier_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        definition: PublicImmutable<RegistryDefinition, Context>,\n        escrow_registry: Map<AztecAddress, PublicImmutable<bool, Context>, Context>,\n        dkim_registry: Map<Field, PublicImmutable<Field, Context>, Context>,\n        managed_escrows: PrivateSet<AddressNote, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: PrivateSet<AddressNote, Context>,\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract\n     *\n     * @param usdc - The address of the USDC token\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n     */\n    #[public]\n    #[initializer]\n    fn constructor(\n        usdc: AztecAddress,\n        escrow_contract_id: Field,\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // initialize the registry definition\n        let definition = RegistryDefinition::new(context.msg_sender(), usdc, escrow_contract_id);\n        storage.definition.initialize(definition);\n        // add any DKIM key hashes that were passed in at initialization\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Bulk registration of DKIM keys\n     *\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys\n     */\n    #[public]\n    fn register_dkim_bulk(\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        // bulk insert up to 50 dkim key hashes\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Register a DKIM key hash for email verifiers to anchor trust to\n     *\n     * @param verifier_id - the ID of the verifier\n     * @param dkim_key_hash - the hash of the DKIM key\n     */\n    #[public]\n    fn register_dkim(verifier_id: Field, dkim_key_hash: Field) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not registry admin\");\n        // ensure that the dkim key has not already been registered\n        register_dkim_key(&mut context, storage, dkim_key_hash, verifier_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     * @param escrow_contract - the address of the escrow contract to register\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check the contract class ID by recomputing the contract address\n        let definition = storage.definition.read();\n        let contract_instance: ContractInstance = unsafe {\n            get_contract_instance(escrow_contract)\n        };\n        let computed_escrow_address = AztecAddress::compute(\n            contract_instance.public_keys,\n            PartialAddress::compute(\n                ContractClassId::from_field(definition.escrow_contract_id), // constrained here\n                contract_instance.salt,\n                contract_instance.initialization_hash,\n                contract_instance.deployer\n            )\n        );\n        assert(\n            computed_escrow_address == escrow_contract, \"Escrow contract class ID does not match expected class ID\"\n        );\n        // check that the contract has been deployed\n        // annoying that we can't use this in the deploy tx\n        context.historical_header.prove_contract_initialization(escrow_contract);\n\n        // check that the contract has not already been registered\n        let registration_status = storage.escrow_registry.at(escrow_contract).read();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        let escrow_params = ZImburseEscrow::at(escrow_contract).get_registration_params().view(&mut context);\n        assert(\n            escrow_params[0] == context.this_address(), \"Escrow contract registry does not match this contract\"\n        );\n        assert(escrow_params[1] == definition.usdc, \"Escrow contract USDC does not match registry USDC\");\n        assert(\n            escrow_params[2] == context.msg_sender(), \"Escrow contract admin does not match sender of message\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let admin_keys = get_public_keys(context.msg_sender());\n        let mut escrow_note = AddressNote::new(escrow_contract, admin_keys.npk_m.hash());\n\n        // use unconstrained - why would you lie here\n        storage.managed_escrows.insert(&mut escrow_note).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender()\n            )\n        );\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.escrow_registry.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n    fn check_and_register_participant(participant: AztecAddress, participant_name: str<60>, escrow: AztecAddress) -> bool {\n        // todo: switch to check that the sender is an escrow\n        // check that sender is admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        let is_registered = storage.escrow_registry.at(escrow).read();\n        assert(is_registered, \"Escrow contract is not registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new().select(AddressNote::properties().address, Comparator.EQ, participant).set_limit(1);\n        let participant_exists = storage.participants.at(escrow).get_notes(options).len() == 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        let mut added = false;\n        if participant_exists {\n            added = true;\n            ZImburseRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, escrow).call(&mut context);\n        }\n        added\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant(participant: AztecAddress, participant_name: str<60>, admin: AztecAddress, escrow: AztecAddress) {\n        let admin_keys = get_public_keys(admin);\n        let participant_keys = get_public_keys(participant);\n        // add escrow to the participant's set of escrows\n        let mut escrow_note = AddressNote::new(escrow, participant_keys.npk_m.hash());\n        storage.participant_escrows.insert(&mut escrow_note).emit(\n            encode_and_encrypt_note(\n                &mut context,\n                participant,\n                participant\n            )\n        );\n        // add the participant to the admin set of participants\n        let mut participant_note = ParticipantNote::new(participant, participant_name, admin_keys.npk_m.hash());\n        storage.participants.at(escrow).insert(&mut participant_note).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, admin, admin)\n        );\n    }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the public context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[public]\n    #[view]\n    fn check_dkim_key_hash_public(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the private context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[private]\n    #[view]\n    fn check_dkim_key_hash_private(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /** Get the class ID that all escrow contracts must match */\n    #[public]\n    #[view]\n    fn get_escrow_class_id() -> Field {\n        storage.definition.read().escrow_contract_id\n    }\n\n    /** Get the registration status of an escrow contract */\n    #[public]\n    #[view]\n    fn get_escrow_registry_status(escrow_contract: AztecAddress) -> bool {\n        storage.escrow_registry.at(escrow_contract).read()\n    }\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param page_index - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_managed_escrows(offset: u32) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.managed_escrows.view_notes(options);\n        let mut managed_escrows = BoundedVec::new();\n        for i in 0..notes.len() {\n            managed_escrows.push(notes.get_unchecked(i).address);\n        }\n        (managed_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param admin - the address of the participant\n     * @param page_index - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_participant_escrows(\n        participant: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participant_escrows.view_notes(options);\n        let mut participant_escrows: BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE> = BoundedVec::new();\n        for i in 0..notes.len() {\n            participant_escrows.push(notes.get_unchecked(i).address);\n        }\n        (participant_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param page_index - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<ParticipantNote, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participants.at(escrow).view_notes(options);\n        (notes, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n}\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "63": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/address_note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "69": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "72": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "75": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "76": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "79": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "83": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "90": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "91": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "93": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
