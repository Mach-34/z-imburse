{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "ZImburseRegistry",
  "functions": [
    {
      "name": "get_escrow_class_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAGEHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAAGtHgIAAgkmAgMAAQo4AgMEIwIABAAAAIUkAAABvyYCAgAALAgBBCYCBQQEABABBQEmAwQEAQAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYsCAECAAABAgEsDgQCJgIEBAEmAgUEACYCBgQDLAwFASIAAADhDDgBBgUjAgAFAAABDyIAAADzLA0CASYCAgQCACgBAgQAOAQCBSwNBQMsDAMBJSwNAgUcDAEHAAA4AwcILgwACAAHJgIJBAMMOAEJCiMCAAoAAAE6JAAAAdEtBAAFgAMnAIAEBAAEJAAAAeMtCIAFAAgAKAgCCQA4CQEKLA4HCgA4AQQFDjgBBQcjAgAHAAABdyQAAAJxLA4IAiwMBQEiAAAA4ScAgAQEeAANAAAAgASAAyMAgAMAAAGsKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVSVfKdc0WarDsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAB/iIAAAIJLQCAA4AFIgAAAnAtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAACXC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAACKycBgAUEAAEDAIAGAAKABiIAAAJwJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "1ZrbjuIwDIbfpde9iHOyzausRiMOZVSpKqjASivEu2+KaKdbuqmGYWbiG9SgP/UnJ3ViJ+dsU6xOb69lvd0dssWvc1bt1stjuatD63zJs1VTVlX59jr8O1Ptj+er/rBf1m3zcFw2x2wBnlWeFfUmPKJS4Q3bsiqyhUV7ye/VSrlOrbTr1WBpQm0N0U1tDWOvJjchJjDdqwkcDMUveYb2GfCkO3Wg/0b4p3jeQu95P+d5cKaDB8c2Ds9ad69m7e0InvC58KD+hQ8mWH+5iTBxv8GG+7wNj70Nj25u2hF3M5oY3GjkAuNHea693CO99EO2ND3Sy5jJXmAG37cdjM+0pzUQ3uThAxiEA88TatTgb2rUZmZcPFEXDsKjH4+LIdn8VgvnR9n8Trj/nXD/e+H+9142Pyrh/E44P8vmJyucX/j+gYXHT5a9fmmdfPxh6EjCoxnz2+T3/0zc87O74/+R+aOg53c6zo9surRyUCexjq/4P7P9fB6+bO972d5HkB17kt+7oepLkajsXeyh1PfOqLSK8afvf4Xv/D4uDiVpNH1Zl9XdUs3pfy7RpY6TTzWj/EbJ9r9RyadqcX6wsvl18qWKGf7kU504v0k+1ZzhTz7Vj/MLT9WMFe7/9I8KZviFx5/0jwri/OmX2mf40y91/Z//Elq/l025XFXF7XrP9lSvB7d9jn/2xejiz77ZrYvNqSnaK0Dvt3/acQyn6gDw0t5UCC10Oam20W5xyebkg8Fg9C8=",
      "brillig_names": [
        "get_escrow_class_id"
      ]
    },
    {
      "name": "get_managed_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjuTG0YTfZa91Uaesg1/FMARJlo0FFpIhyT/ww9C7m8OZPqzJ6pxh1zYj2HljSBZrmBFDxpc1M5X9n09///nHf//z+8+//OPX3z/95a//+fTl159++OPzr79M//afP7/79ONvn798+fzP76//70/u5X9CnK///V8//PLyr7//8cNvf3z6i8/Nfffp51/+Pv1jcW76Cv/4/OXnT39JJf353eLq6urbxTXk87V17VIJ8napyOXLeid//u27TyENqEXaqZbqb9eS4unSlOuiFrm/luby28UtuNu1ZHfyJV9ZeKolD6glpVMtUpRa6unrXn/ZUy1ltZYQvD8VE0IUpZpyvrqEi/Ulr1wacj6VE6bKLhfP1VSoahpSNdFBVeOhqglQ1USoahJUNQJVTYaqBiqLI1QWR6gsTlBZnKCyOEFlcYLK4gSVxQkqixNUFieoLE5QWZygsligsligsligsligsligsligsligsligsligsligsjhDZXGGyuIMlcUZKoszVBZnqCzOUFmcobI4Q2VxhsriApXF5dtm8csdwje/Q/zmdxiTg+n0i7CS8z3fM4GqJkNVU6CqqVDVNKRqqoOqxkNVE6CqiVDVQGVxhcriCpXFFSqLK1QWV6gsblBZ3KCyuEFlcYPK4gaVxQ0qixtUFjeoLG5QWdygstg7qDD2DiqNvYOKY++g8tg7qED2DiqRvYOKZO+gMtk7qFD27tum8sstvPv2t/Df/hbvScSUv7rFvC5uXJc2rpON6/LGdWXjurpxXdu2LriN6/zGdRufl7DxeQkbn5ew8XkJG5+XsPF5CRufl7DxeYkbn5e48XmJG5+XuPF5iRufl7jxeYkbn5e48XmJG5+XuPF5SRufl7Txeen+oXHJ53XRBQV5U2d9Oqo1dSYXQPrs166u56/dLr+8C/W1lej+sfF+FSW4igSuogxXUYGrqMJV1NAq6v4h8n4VebiK9shsOX3tcPWVXypaXltDim8X19AuB46jiytXx/NXTlcHgsPqHjS4E80msLXbF0s8FSExXV86WxjNwnstTGbhvRaKWXivhdksvNfCYhbea2E1C++1sJmFd1qYnVl4r4XeLLzXQtud3G2h7U7eY2EuJwuvRlWdLExm4b0W2u7kbgttd/IOC/P52vz1pbOFtju520Lbndxtoe1O7rWw2O7kbgttd3K3hbY7udtC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",
      "brillig_names": [
        "get_managed_escrows"
      ]
    },
    {
      "name": "register_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10966310306735189739": {
            "error_kind": "string",
            "string": "Escrow contract USDC does not match registry USDC"
          },
          "12806906349574299095": {
            "error_kind": "string",
            "string": "Escrow contract has already been registered"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14827131733433028185": {
            "error_kind": "string",
            "string": "Escrow contract registry does not match this contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17408225848945384450": {
            "error_kind": "string",
            "string": "Proving nullifier inclusion failed"
          },
          "17540660350934727925": {
            "error_kind": "string",
            "string": "Nullifier does not match value in witness"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3089479698890196495": {
            "error_kind": "string",
            "string": "Escrow contract admin does not match sender of message"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6337220856976823863": {
            "error_kind": "string",
            "string": "Escrow contract class ID does not match expected class ID"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_contract_instance_internal",
        "get_nullifier_membership_witness",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "unpack_returns",
        "get_public_keys_and_partial_address",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "pack_arguments_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          },
          "5932914842188225196": {
            "error_kind": "string",
            "string": "Function get_escrow_class_id can only be called statically"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7V3bziS3jX6XufaFDqRI5lUWi8BJvMEAhh04zgKLIO++9R+qumda1XKzimpWtW6MGU+xv08fqbNE/fvL3376y7/+/uevv/zPr//88qf/+veXn3/964+/f/31l+lv//7PD1/+8tvXn3/++vc/X//vL+HtP0Xev//nP3785e2v//z9x99+//KnGPMPX3765W/Tn1Kc7P/n688/ffkTEPznv3/4QvywCefHTR5HkcdR5HGUGJLChh63iQqcqMBJUWFTHrfJQWGDD9skeNDmh9tvQ5Dl6xAzLN8zvkNgsIcAewgxhyj2pSj2pSD7UvDjlT3x45UwSVTYbK5QHOjzW860fJv48/fF9PdzAOPff7wTyYrGPSsa96xo3HN6vNHNisY9Z1DYKLSGrLChzTETZYkZuIkZTMa/X2x/vwTj3wfj3xfb3ydj/o8Owh/9fU62bSaT7e8/2s89/Pto/Pu2fSIY94kQjPnHbPz7tu0/pGT8+7btP+Rg/Ptg/Pu27T+AMX+wbf8Bbdt/QNv2H0o0/n00/n3j9nOH8cn93zfmz8btPz8+1wJJCpvH5/AYgsIGFDaPz7UwZoWNAiclhY1Ca8W8FhWLlpgfX4dHUPgUFFqjQmtUaF0UWheF1qTAIYXWio0SVKwDoqKtwu3zo1gkzB9TCLcIaIxQQjBHAHMEtkbYPlNqIpA1QormCMUaIZuXIZvWuMrXSPMUIqLI8nUErnwNmfnz62n2dRlxTRsgtclJxnl0FjFef/xWUgidS1pSmr8uBRslTTnMX6eMl7lVTKH221TK/Nscyzdfv5WV+YllpdQoK5WZB9GF++SxN+pSjkqdQjwu9d7NAIUlgKmEVuVgnr9OAtKoHCkuqxQpcvi+chDmZ5aVtripxONSL4elTr17Dk7LT3Nu9pEMc7gDF77fR7bOFNAOxxaOU1Z5nbLyC/mVX8iv8jp+5ZAOWtZ38uXA5GM8Mnl0TV7CQl7STcwn32OPBvlDK++8F+FwIY/3W9Yi8zyRwtW2bUwf5+yddyH7FbS7R+FS0AKNgmLAORynXbRGQR8k0upZIQ9lVpThoUxdGRwxs6bMiJkVZcqImRVlKL6EMu9FxZcpKofXKSq8aNXOeSGSIV5vZUhtkxKWlWbGcFmWziHXflvC8tsSLzs8aZrlvov+qiPaZ4our9qJPVX0Vx1TPVH06V+H6P1FH5HeX/Q4Iv0Joo9I7y96GpH+BNFpiN5d9JyG6P1FL0P07qJvvzg6RH9c9DF66S/6y246PVX0Een9RS9j9PIE0cc4vb/oL7JJ1lt0wUV0KTeij/V0A9EhLPkhIKTwvegxhNGob1X9Q8cxy9xFx/gap07sdXyNIy2bdcR40RFDozXltPw2J4mtDg/n637wTctb+TSlED+/TSnK9cfv3hxrWGfyJow27kzeHC3tmbw5zq+dyJs7PD8wvOnHm6NunsibL3vz4pzeHOvUJ/Lmi9z9eRVvjhnKmbw5RkEn8iaPUdCZvDn2ME/kTRl7o2fy5thDOY83YxgzlDN5c8xQzuTNMUM5kTcjDG+eyJtjhnIib6YxQzmTN8ceyom8mccM5UzeHDOUE3kTxgWfM3kThjdP5M0xQzmRN8f1+DN5c5wLOpY34eJNTDfeHLlaD+VNSsuTgwThxpv9310a3jT05hgFncebadyyP5U3x0mSE3kzjrWgM3kThjdP5M0xQzmRN9Oom2fy5pihnMib3VNT05INbvImNbyZqMxpzBJLbny9b4q0lGlIsyJN90w2B5KmDGlWpMERNavSjKhZk6aMqFmVBoc0a9LIkGZFGoIhzZo0PKRZkab7hfUDSfMiE4X3wsqLdMcfhX2RYdlbYXMIJyrsIc5V5XSmynQQyc9UpY8heR4NS3fJYUjeW/IzzTiPITmMKO8u+ZlmyMeQHM+0RXcQyccgsbfkZQwSu0s+us/uko/us7fkdKaF64NIfqYF8WNIzmMlsbvkY5DYW3IZg8TuksOQvLfkYyWxs+QQxiCxu+RjkNhb8jhWErtLPgaJvSVPY5DYXfIzHUQ+iORjkNhb8jwGid0lH+vlvSUfe58Gkt9NyAanupFxiHvPQKP77C35qW6QHETyscbSW/JT3Y85iORj9tld8tF9dpYcAwzJe0s+ory35HEMErtL3v35KV6+lli+EfGdUP/XzRqEul9gaxLqPeIR4oWQNHOwFZmJIAW+BNxk+U6/9zM804rX/NMp5NigD4jz19Ni2OXrago5TiEttTbS9ccfRcXeRb2s7oXcaqFiyHN7FgOlW09h6B5odKEPt5GP6IxQyd4IbV4yT4IzoSSFG1/vWl22H9bOl2wdU89ZWmoiLxWgxEsFmHxS+ZpSnHtSSpnuF5UuRChAuf9xDExLGYOEcqMMp6HMijLcWZmyVI9YCn6jzDshyb4IlRC9ESqdCXFaxi+M0ArmUuY+lArnRjBf0qoQRmgFs/Dc/sUYUv4+mEvsXc15GatNQ01pKiOzjkSxoQykWUXIlx8G/IyBWF6lpCm+TElfxqf5ZXyaX8an26elhykpvExJ5VVKivllSsqvUlJy3ss8Mk7Oy7rF9Ee+Gfhuf/guxzzTySm0li1ipmXhP8v1qstHOkTqfXIfFzGRWyuskJkvcdOYbnPMc0l5Wu3/XnnqnYQQlxgrEVsFTXGpICk3lgokp/mXJSPeFnT72mGAZXl1+nO6WYygHbYK2hjQAUPsMaBDOR5dL343ejQxyoeRKIweXe/8MGKF0Q6HZEK49A7Tjgp8LzbvkEG2jQEdMMQeI3YoR+xQjtShHI8+UvRhVBRGjz5s82G0uWqVZTe/XO/C8QwgxgAI1gCKJouLxu2FFEakcTspupZpY19jBBojjeSSNUYKySUkjZGiTksMGiPQGCkkl5Q1RhokTTMqmmZUQCM5oMZIMeoS1DhX04SJpgmTopGcNJJrmjDRNGGiacJE04SJaCRXNGFvJ20sJ84fEGgOYfsO9gcE2EOwOUTK9hBkDpHtgzYXcwiwLwXYVz20r3poX/XQvuqVZA9hH7RkH7RkXwrevktalgPpuYBUINAeQswhdjgG1oQga4i4w9mxJoS5u2MM9hAdSmEetDFlewj7oN3hdM60oTlDUGh9veMZ6In89gM3heBCPt/qA9EeQswhth+9z7Ts1edpPa/VNd7fMk5xhyTMjQ2tCaPYY0jogGG+GZtSsC/H1Cg/vnKQUtAYocZIFEaPbjC/G+3wuntjIyjt8Ux6E6OEDhhoj0EdykEdysEdyqFYaJxqVtIYKRYa8/Yx+N3tuQkAjQG2j79bAIomKyv2a1JW7NdMRhq356gxKgojxX5Nevj1vQ8jRX+UUSM5apyr2K+ZjDSSk0Zy0khOGslZg6RpRrOmGc2aZhRC1BihxkghOcSsMVJIDpomDDRNGNjvNkA2X6cHCPYQYA9hvk4PmO0hzLfIoNgHrf1uA9jvNgDZVz22r3psX/XYvupJsocwD1q0P1KBwb4U22c7MM0U5wXl64zBFwi0hxBziO27DW0IMofYPshpQ9i7G+yDFjqUwj5o0T5o0T5oyw5By0sOuhyg9fWOW2S4ffg0TWfoQr7c6kPRHkLMIbaPbQDiAgGMFQgxh9h+kqINQdYQO2ThaUOgPYS5u0vM9hD27k727k727k727s727s727gZ7d4O9u8He3WjvbrR3d7F3d7F3d7F3N9m7m+zdzfbuZnt32w/Viv1QrdgP1ch+qEb2QzWyH6qR/VCN7IdqZD9UI/uhGtkP1XbIPNKGsC8FKLY/CRTbn4RJY2R/wpNK7IBhf8KTKHTA6FAOVhwheTily5sR7/DARus4He/wokQTY4dHItoYHcqRO5QjdygHaIJRcxqMFbf3E2+/pMhLIj2+SnA+H0Dk7VcUWwBkDKBIgpI0SVCSJglK0iRBSZokKEmTBCVpkqAk0ZxI0yRBSbJ9S5qjLNEDN9Ej2zekWwBiDLB9M7oFQMYA2/uSFoB1CbavorYA0LYVle13+lsAYA1g3FWKdVcp1l2lkHUJtt/jbwDYn6sT+3N1wmIOIdkewvpIaw4h2UMUcwjzVEUTBJpDJPtSJLCHEHOInO0h7KueeaqibJ+qKNunKpogOpSi84O+Ox56y6FAZ/L7JZmfyNs3F2Tf6LF9N8qbWyQqef54WoOXFqGwOC4Gvn6rLda+Xo58Rrl62JXpg7zEI5MvxyW/Q5qmZ5I/svLxyMpvH+4+k7wcmPz2IfozybNr8kuqiGlEdUt++7TimeR9Dw/ukwffTWWDvO9O6j55PLLy6LuTapDv3UnFEi4/Td+Qfye0fRq5NyF2Rmj76v7ehIozQtt3D/Ym5C2o2VtQS/ZGyJlCKTir9ik4q/YpOqv2KTqr9inuG9RMLUIY5hy50zApXxGSD0KJnBHKqTchnjfCJy+lbwhVfjvFeTRHKTfWvOnyti4FaDxOOo0k6XKCUsL3Z4AnZXrHTsElmEvBW1dBdkZo51nMDoRKZ0Kc5i2Zt0f7WsH80PvMUBYiGKEVzMLzXlWMIeWbYC69q7nhy9U7K7M9F1TjOkFOlDtgkD3GDvttbYwO5ZDHjyHnaUNTYZTMMzJPGGKPsccb102MDuWADuWADuVATTCWqDEqCiOyPXWb8/bDBS0AMQbgrNCVNW5XZPSdjBRuhxA0RqgxEoWRIqNv1mT0zZBsT/5nML67kHfIFNwCQGsAMQbY3pe0AKxLgNkawPbkfwbjuwt5h8zADQDrrhKsu0qw7ip3yAjcAmBjAPNswNk+G3C2zwY8QaA9hPnRVzR/YHmCYHOIlOwhzM/7Y7YvRbaveva3FtD+1sIO2YCbEOZPHmRE+6At9kFb7Eth++TB7deFYF73K4StGxIsy/UOifif71ZYkOwrNdtXaravcbK9swuEyz5KIE7N7/c7O4vCR6ZfQj42/WOrH4+tfjy2+nvknHom/XJo+ju8JfZU+uic/t1zzGWHN9CeSh+OTd97w3mfPnrvthr0j61+8d5tNej377YaxzwLRX+U0B8lcUeJsz9K5I6S+AtvcRfeFII/Sg5VctcIUHTXCFB01wjskBR/f0o7hzeHm4fxMuXQAwR6gHAHEEg9QEoHEOzheOwRwqVHSUqPEC6Kw3BEWWOkQdKcqSTNmUrSnKkkRU7qzCFpjBSnNzlGjZHi9CanoDFSISnOiXK2v67B2f7aCUPqgGF/XYOxQzmKoulg0tRNMU/dyDtsyTYhzDeWJWR7CPNDEBKTPYT5UQWxT5Iryfz8kWT7UmSwh7CvemBf9cC+6mG0h7AP2mIftKVDKTqn+t3zLJjYp7IVsq/UbF/jdjjnHvPVhW0IWAEhcxAIO5x1/wMg2ANEOoDssIb7B0B6OD6lHiA9SpJ7hHDuEcK5RwgrniGdjFhhhBok1CCVpDEihRFpkEiDxFFjVBRGEjRGjy9TQVRcnJ6MQGNkvu4EMeYOGGSPkVIHjA7lyIqmIyoeWIZYzNOdTBhij7HDgL+N0aEc3KEc3KEcip0TSIrXPCEpdk5gh0SMd+8Pww6JFVsAYgyQFGOeh7MlvhvlpDHSuB2Cxgg1RqIw0gwzk2aYuUN2ubt5JCYAMgagaA2A1gBiDLBDFoYGgHUJJFsD2KY7gRySNUAxBrDuKrN1V5mtu8qcrEuQ2BjAPOfCBFHMIcxzLkwQaA8h5hDbn8BuQ7A5RLEPWvOcC5DJvhRkX/XYvuqxfdVj+6pn/hz221Oj1hBg/hz2BGFfinjcdCcTefNKDSnaQ5jXONjhgE8sl0cZYsktP+947X2iz4emv8PBpKfSP7b6eGz18djq7zBAfSr9cmj6O9wxfyp9dE7/XtKBqd0Mx6YPx6bvveG8T1+8d1sN+odWH4P3bqtBv3+3df/eNWCM/iihP0rijlLK/iiRO0rZX3hnf+ENwR8lhyr5awTQXyOA/hqB4q8RKHuHN7YysKS4PJaakuPHUgF3nx3vrs1yRpbS1W+vaHOl42VEKOGzrOV1yqo5bI+aw/YoGiTFK2VQNIfti+KVMihRgxRVSIoDguXRgyYfRooDgiVnjZEGCZLGaId8Ro1D+GWHy8htDLTH2COZUROjQzlI03RomsOiaQ6LpjksmuaQNMfkSXNMnqIGKWqQkgYpaZCyBklz2pw0p81Jc9r84cxrH0YapKJBejTT2YeRojPRZC6bjBSXFoiTxkgTRpqGhTSXGlkzzuIAGiPF6IcVr8FORoow4pQ0RoowYk1rxJrWiDWtEWtaI9bcfWHUhJHm7osmcdhkpHGu5oo1a4Y5rBnmMGucq7li/XB6sw8jRRjtkIKM5lN3dFmQmebkH7/Olr++/UTfvV/ffpjv7q+j5a9vTwN299dtuYvlr2/PtHj318ny14sp92LKnUzbGTKNGTaNdzGtq2LIHUMIpr8Opr8ulr++/ZJeJplzVWcmbHz9lvFn/mlI1ztB+ZOQOCOUvCm0/U7f3oTIGSHwphB4U2j7GvgWQnhLqHSv9kQLIakQIvBGyJtCTM4ISfJGyJlCMThTKG4/0/kooeWmXsSYbwnF6I0QeiMkzghtP8u5NyFyRih7C+rsLaizt6AGb0EN3oIavQU1egtq9BbUxVtQF29BTd6CmrwFNXkLavYW1OwtqMVbUIu3oBZnQZ2Cs6BOwVlQJ28TxeRtopi8TRSTt4li8jZRTN4misnbRDF5mygmbxPF5G2imLxNFBM6W/RMxZtCFLwR8tYOsTeFtmcm2ZfQDhma87RwOhNKgZuE7u+55h2GsPsSit4U2v626d6E0Bmh7E2h7E4heSah2y3OjN2r/f091x3SK+9NyJtChM4IcfBGyJtC4k2h7S+/P0qoMR4S8UUIdlhj3JkQOSO0wxrjzoTQGyFvQZ28BXXyFtTZW1Bnb0GdvQU1eAtq8BbU6C2o0VtQo7egLt6CungLavIW1OQtqMlbULO3oGZvQS3eglq8BbW3iSJ6myiit4kiepsooreJInqbKKK3iSJ6myiit4kiepsooreJ4jQx80bIm0LbXz7amZC3aRAWbwptzzK8M6Ed9jouOadzyKVFiGX5aYmyfL2S9LiUmT4VvtCvJz2G5TFEwvBNhuSPouKJirrsGNWKWsKJvIpLUm26juClqCfyaqOo8XW8GvllirrD4P0wRX0dr+bX8eoOKXv89KslX4oK9z+OQXgecMQY0q0ycKIgWFfmo6gnqtqNouLreHWHw/xHKeoOr2E+9M57JFnOenK5epgIuPJ1orK8FTNp1PiacaHN0wrz8vXkgdrXCZavk8TG13l5WPH6yOzbUwy3pPNCI+Ur+aaP3yXf4QXPIfmDko8o7yw57fDU6JD8Mcl3eEp1SP6g5CPKe0ueRpR3lxyH5HtLnkQWya9eQZwl335LbUj+qOQwJO8t+RiX95Z8e2LvIfmjko9BYm/JcXSf3SUf3Wd3yWVI3lnyMqK8t+Q01su7Sz7G5b0l5xHlvSWXsZLYWXKOvRsWXgo6SQ4NETHgzB4DXzKS1M/BPEQk54VIhhiuiMhh14U55eHNE3lz1M0TeTOX4c3zeBPi8OaJvDnq5om8iaNunsmbOLx5IG825pslDG+eyJswvHkib4755om8SWl480TeHDOUE3mTxyjoTN6E4c0TeVOGN8/jTRl18zzelDD2N8/kzTHfPJE346ibJ/JmGnsoJ/JmHnsof8ibl9wsjIFa/pHl9OD0x3IlOn+qPmYS+6sOIc5ZwKY/yq3q2/P1DtUVqo9Yf4Lq29/hHKo/rnoZOysWqqe8qJ5TRfUR609QfewiPkP1sT/0FNXHLOkJqsuI9WeoPmL9GaqPWZKF6ktq38kB4XvVSwgwVH+C6iPWn6B6HLOkJ6iexizpGaqP/eMnqD72kp6hOoxZ0jNUH6eun6D6uL/5FNVHrD9B9XEf8gmqx/rL2bg8o4VXr/gkhg+jenKdllF1PlbirFS5eotoMcpJY6RBAlQY1XO5tow0SEWDVL+UOi3vz0ZX8XMxYoVRPRFiy0iDxBok1iBJ0hhV+46yHGArlG6MUogaIw1S1CDV24iGUQKNESuMsOqnBHFujhJcJ1OQ8GlGKrOiQysqtFw/OMdx7os4wzeCVDounI/mId42Ebl+RmxPADYGqD/+tyeAdQmKdQmKdQnqZyP2BCjGABytAdAYoL57vCeAdVMhxo0dhGwNQMYA0biiAWyPorvTANihNb07AoOSrAE2t0X3BzRA0RrAugQM1gBiDCDZGoBsAbA+qeBlPYAzVYyKwigGjRFojERhlDRI9ZlIw6i+WtEy0kgOGueicduOCNYAbAywvfOYJubLkgxWAMgYgKxLwMEaYPNI+f6yGG4fKbcAjEtQtg9kWwBsDBCtSxCtS5CMx5klkTFAti7BDpOJBgAaA2C0BjCeDpUdFpcaAGIMQGANYF0CtvYBW0eRGJeAQrQGKMYA9WkG5nm3Fq8ByqeNPG6Ts8KGH7cBBQ4ocFCBU9+7uW9TosKmPG5DQWGDCpt67CwvM+G0xf+9zcrm6X0bftymvnVaQpwr0DeXiT9tysM2vLJxet9GgRMVOFGBk4LCBhQ28rhNvd1p2PDjNpAUNvS4Tf2JtURpXlVLBOHWqn7md+pfPq3i1Bl/byUhqKxUWCvZp1pWrLFaOe0/tTOzFYd0a0UaqxxVVqiyEo1VvcdsWqnUQJXyqMIqKuWLSvmiUp5UypNKDVapwSo1Vm4Et6yqPUKUZawbJVes5HErWrtR2LJSYZHt7ioFTtYAxRhAojWAcQliiNYA1iWIwRoArAHEGCBlawA2BsjJGsC4sYtgXdEAjQHQuqKR7XYjRbFdlKIUgjXA5rbo7jGGCUCMAaJ1CbZvFLUAyBggR2sAtAZ4/ODItKALGiNWGGHSGJHCqGiQSlEYUdAYaSQnjXPZuG1PkqwBii1ADrYnPSYANAaI1iXY4ZTBfYBke05iAmBjgGxdgu0D2RZAMQZA6xKgdQmK8TgzFzQGIOsSEBsDGJ8ymADEGMB6OgTGpwxojwsg9wFisgawLkGy9kGyjqJsXYJsXNFgh1uf9wFWEoOHMK+3xJAuo516ygXIPGNMilxAqikXOOb5pzlivP74g1B9rycsI+Bp2Tb1JLSSTjpAXBQqLYUi5plQRIH7hKbN2vmnJRW4IbSSafmKUAzfEvowQ5VZ/UBZywzry00p8jzXmwp55cZSy6AxLfnMawXTwkDDjdOu9+zG6Y/le9Wwvjz1REL17f9nEmJnhJI3hZI3hbI3heqbIU8kVJ9zPpNQcUaovjnzTELojZC3rqN4q/bFW8Mo3WuZLAli3k72fU+oxO7jIWFZCAneEtrFZcvBzbetkRah+YkiChd9AOWDzz6d/Y58nOlTP8dgyGca+s/fIlf4kC8+4Eyfffr5R/jIkm7waoK88MHojI8zfYozfYid9WCcOhOamkFcWkS47cGYuhNatgCrhKS/QsvW+USo3P94WkKj5TRykFBu+bOvMQqF7I2QN4VicUYoRW+EyBmhDN4IiTNCgM4I9V8iaRFyp5C3GCrealnxphB5axi7DzAbhDganzzkHTLTNACMjxNxjtYA1iXYvsPeAhBjALQuAVqXwDj1zQRgfFaGd8ir3ACwLgFbl4CtSyDRGsD48oPscI67AWBdgmhdgh3Ocd8HSNkawPgS0Er+hfu3LESR3JQEgsYINEaKyzqy8uBAw0iDpLmss5IzoCyBUOBqG4hydUkvX47pXb11FEusfc1z2ES5yhDC9EkHfNERR3R4JX3C8+j4Uif6UqfeSTyNTn2a9zw65IpOvbsypLP0nuk6JctCp7iiA8EXHfBFR1zRQV/qILuiU7Y3g7EsWc5SpG/ofECQOQRFewi0hxBziPott30h7N0t9u6WYg2xkqtpXwi0hzAP2hizPYR50MbUcnf5FuLDqCiMctAYgcaIFUaQNEYaIVAjOWqQikby+nZooWW9U1LFSBRGpEGqLz63jKoVifJyLLP0nMfEek/xPDrFE52V/FaGdO6ORVO9t3oeHXFFp94LPo8Ou6KTfKmTyBWdvL0ZbAxvUi7mEBDsIcAegs0h6gnR9oWwd3exd3dBcwiyLwXZBy3ZBy3bBy3bB6203M3SgsAw3zmLiPkKQj4hxBoiB9gOsZwQnLTxe8GCV7LcPVTWgpd3Hq7TjsxyRjSHaI5/doDgzRBTFZwhGKEVFKUsF7fK1UHKlYt/ZXYzYYRWUMg3mWvyTVBkfJ2yQtxe1uXa3NsrBJ7LupL1dXYVXyUmqpc1L41PDpcp9TRa/wBYSUa4I0AxBijWJSjWJSDrEtT3gvYEEGOAlSfmdwRgY4CVNxV3BNjcVGCaR1mIcgMAoRgDrL0svx8AGgMk6xIk6xJk6xJksAZgYwDI1gDWNXktAf1+ANubiiX5YonlG4Dbb5ni8ruN6VWmJS1inkaMy8fTPPiDeQmHZY6HZS5HZU75sMz5oMwxuG1bpm2UmTlfzeUW5gm8MpdlOWsap9aYPylaJHx/oZZX0lU+iYsjXcCRLuBIlx0GO/txIT9ciiNdiiNdtq/G7Mil+OHCwREX9MNFHOkifnQpwU89KsFP+1Kin356JX+rGZdlw06uFjCrI1KBJUueAN5sgq4kej0CcToo8ZyOSvyoioPb6SLjMkXnq7S183SxgNsFnRZzPKzmzxrO78CcjsqcDqs5HVZzjm6Zy7KIdk3iwtztAn1j+a+I202RJvOjar6StvgQzN1uLbSYR7e9f4t5ctsqNpm73c5pMc9ue/8mc7e9f4s5HFZzOGyc42HbFr/HUFrMy2F7Ir+HOVrM61fB7yZHZqpf2G4ZraS5uJPfljkEjZEGaS1/xX0jVhglDVLSINU767u5Wnklb3TDqH49oWWkQUINEmqQ6qfiWkbVNuxu3tHJSBRGpEEiDdJKsqD7RvUnfVpG5XEjWTmnk2B5JSrJ5XHqXG1S8wIxrU9fIErl03R5qiqlq3s008fvdFbWgZ9FZ2Vx92l0fDlrZQH5aXTIFR3ypc7KwZBn0Vk5G/I0Or4qOvuq6OIrlMVTKEtYObbyNDroi46nHl1WUkY/j46nii4rKaOfR8dTjy4rKaOfR8dXRQdPPbqspIx+Hh1fFX3ljYqn0fFV0Yuvil58jXekd82CC52r160/6cTYuc+a9h9nOgThlg65opOiLzroi464opOzLzq+Qhl8VXTwpQ76quilc83Kcf7hlFO8oUPgi44vdZhc0em93NSi40qdFFypk0LvwanIQifejAZTjL7ooC864opOyr7okCs62VcoZ1+h3H25qUHHlzrdN64bdHy1O8WXOt13iu/SyfX9rEjLqlCkeKEDVHsrWGA+zib4bbbUD4hiDbGS9+4xiBh4+TpcPS8ymX6A1HPf7Q3CHUDqVWJvEOkAUr+oti/ISmKmvUE6yIW5h1wM1vUdWcwhhKwhVm5w7wthLlRBc6GoPnVIccnJP21d+M3JL1y/lBrDsqoWA+H3XTPXL4Q2reoej7Bkw4/X92Y/rerbPE0rDZbUs620rOo7P02r+tgj0iWvutxoKPV9lJbVSnWGJZSmP94yrO8Vt6zqWcuaVkVjVT/dHTEvyiPSrRVqrEiFVc9W2bKqPx7btBKNVf0U232rGFZOm7XNSGW2UsWaZjq0pCtb0imZdWhZVGYrTQGSLGYiFTNWma00Bk2zojJbqdh5eRx02tnkW7OVmt00A50Zq8zqjza1zYrKTHSSiMoBMQSdGejMVA5YOd/RNltxAC7vQuVyW01Xzku0zUhllkFnJiozQJUZBp2ZEk0eH5BMZiXrzEhlVs/42TJbeV8KponRsnZ3NS96u2Z6O7W4e59rwqhfW9wZg+wx6pci72F82qHOrh7lf8AOlHass6sH+h+wI50dKf1Qv2/UtmMlXn1qDAku6+IFKnb1HvcP2IHSTlR2EEBpp8SLSrz6jYa2Xf3qwR+wI51dffT/B+yKzg6C0g6Vdit+J1jshBtt9L2vP1Dq58h3R+EeKCV1QSk9UFZa7Z1RZIcYe3PvsngJ5XYkgJH2QCmXHQoKFZSUepQllT1QrtaWr16ufEO5/ZqXeRJnaHx7NwnJxD6HQ7MHz+zvZiN5Yy9HZg+H1h7TodnTkdmXQ2tfDq39HqMIw/b+XjKhN/Z4ZPbsu69tsT+09nJo7eXY2rse5zTYl5Bdt/f311xL4COzj4fWPrnua5vsXc9rW+x9z2ub7KE7+2Wfi3OtFXzCXLXBCLI7RuSNEUZ3jIo3RsWdRgXdMZIO67WFoAtKl7JwjxXuIqkLCndAoYA9UGLoglJ6oOwzvmyidClL7uKX3CXGoEtZoEutxNwDpb6+QcuGOOH36Uje7idVqQnMw3ApqWJECqN6RWsZocaoflTu7m2QyWzl0GHTjFVm9ZF320yHhjo01KEVHVrRoZHOb6RDY13Z6kOZpplEnRnqzFQVRwI83vBIfU1N4vLIcq4Y1bvRhlG9V2wZgcZIU6Z6+q77TZyAogVeuQnVMKpfaWoZKZrtlQtNLSMVUjXOpcwBO31wa1S/q9sy0iDV79PeNXq77aMx0iBFDVJ9MH/lp5qRYsgQV249NYyyBqm+nNcwqp/4aBhh0BiRwqgkjRErjChrjDRIrCkTa8JINH4SRUTEkDVGCvVi1CA9WnP/M/3tf3/87euPf/n5p39OFm//+K9f/vr7119/+fzr7//3j/lf/vLb159//vr3P//jt1//+tPf/vXbT3/++de/vv3bl/D5n/9KMcEPKQJOdN74p6ne/ZACwnsLO/2PmDj+MP2nvPN9/wLx7QuauEx8/h8=",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_participants",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "name",
                            "type": {
                              "kind": "array",
                              "length": 2,
                              "type": {
                                "kind": "field"
                              }
                            }
                          },
                          {
                            "name": "npk_m_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "randomness",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "header",
                            "type": {
                              "fields": [
                                {
                                  "name": "contract_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "nonce",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "storage_slot",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "note_hash_counter",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::note::note_header::NoteHeader"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::participant_note::ParticipantNote"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dXWwk2VWutt1td/fY3fHv7Mx4xp6/zSaEdPWPPQ4kzCYbQvjZhCQkLGwkPLYnidjsRjsbVmhfDCKgPKwIEg8RIC0IKQ88ICGEEAKkfUHkZfMUEbQEHhcp8AAPQYCQoGq2j/vz11/drp7u23ZTVdJVV9c9dc6555z7U9+9VbcQvH18NkqF7vlc93cm6D+M5m73tzHaEY6RV8OnnoUx6jkLOv4c2Hq2a/tilEpRmo/SQpTKUapEqRqlC1FajNJSlGpRqkfpHVFajtJKlFajtBal9ShtROlilB6L0qUoXY7SlShtRulqlK5FaStK21G6HqUbUboZpVtRuh2lx6P0zig9EaV3RendUfqBKL0nSj8YpffGtohS7MRmlFpRakepE6WdKO1G6U6U9qL0vij9UJR+OErvj9IHovQjXZs+GaUPRulDUXoqSh+O0o9G6SNR+rEofTRKPx6ln4jST0bpp6L0dJQ+FqWPR+mno/SJKH0ySp+K0s9E6dNR+kyUfjZKz3Tt/PNdWz/b/f2sOUEFfAHOn4X83En+nfSsOYd88ZHK279l8Iflzwbjq+xlkjtO/nca+yf8Az/6t8rA0wP/pvGf88O/Md/l86Hj0/wDkmvXnjru2fIpumexe4712fhaHtZ7uz+u0zdmerxQrslmvsbH7FMMxm+fO412x/jPe+AfH8Z/wRN/s1tZ2BNjyspX6/4vQR7W0SReaH8rS13cXyK/ebJr6NmuodmiEgxnV7RFheyqeKGtZ4i+KuiVH8wWF/zYorloOhz3l83y5iCvSnlFyDMdY93/unxaf0+x0vQcK62M1sGWZ7u2M2rXtme7djJq145nu+5k1K47nu26m1G77nq2652M2vWOZ7vuZdSue57tum+2yMfkUz8m3/ccKwcZrYP3PNv1MKN2PfBs16OM2vXQs13vZ9SuR37tGmYVd7zv2a5hNu0aesbJw2ZG7eoZJw9brnF0PiafpjF56BknDzOKO4aecfIwo7hj6BknDzOKO4aecfIwo7hj6BknDzOKO4aecfJwP6N29YyTh/cyalfPOHl44BpH52PyqRqTe8bJw4zijqFnnDzMKO4YesbJmxnFHUPPOHkzq7ijZ5y8mVXc0TNO3szomsumZ5y8mdE1l03POHmz4xpH52PyaRqTNz3j5M2M4o5Nzzh5M6O4Y9MzTt7MKO7Y9IyTNzOKOzY94+TNjOKOTc84eTOjay6bnnHyZkbXXDY94+TNI9c4Oh+TT9WY3DNO3soo7tj0jJO3Moo7Nj3j5K2M4o5Nzzh5K6u4o2ecvJVV3NEzTt7K6JrLlmecvJXRNZctzzh5a9c1js7H5NM0Jm95xslbGcUdW55x8lZGcceWZ5y8lVHcseUZJ29lFHdsecbJWxnFHVuecfJWRtdctjzj5K2MrrlsecbJ2w3XODofk0/VmNwzTt7OKO7Y8oyTtzOKO7Y84+TtjOKOLc84eTuruKNnnLydVdzRM07ezuiay7ZnnLyd0TWXbc84eXvPNY7Ox+TTNCZve8bJ2xnFHduecfJ2RnHHtmecvJ1R3LHtGSdvZxR3bHvGydsZxR3bnnHyTkbXXLY94+SdjK65bHvGyTtN1zg6H5NP1ZjcM07eySju2PaMk3cyiju2PePknYzijm3POHknq7ijZ5y8k1Xc0TNO3jm3ay5t3PDacS9vhvJ+//i0TYKg5w8f+6/i/qI+9i+N/HGwIvQ3WbHdvtk1VjyGWupe/9zRSx987oWDX3z6y1+8d/RiIegdzCkgrfmIuS73uH7ohedfenH/4KUnDw9fPHrwgDkUBecggWsFuH5+/wvPf/SQuZUejdunj1588IUXnmdu8ym5qfoVH3e7v40RD+OPdWLcvPkZY1z8bQ/gKtkW7ebneePt7+2hvCDoRSzmmfwK6TpefXr7x14gfdg+2EYVgl5bhffWRR7GH+ahnEUhR/Gq5LyG4lUeI6/cj7kfcz/mfsx55X78/+ZHe/bDMV+V5Kjx0QWHHLzf6BbFfYXub1noN8Zx536B5Fk58BrKrwib+Bh3Lqa0q9luSehaF3lcr5aEnCUhR/Gq5LyG4pXbPrd9bvvcXpPkldv+0XjZ2EfhOQXKQzmuMRbev+iQUx1RTlXIWRT3FRJ+TQ5fc40ZqySnOgY5NvZD/4xxrNVQ9jJZ5pca5LH/a1QOvubyv9EtivtG9YvS2TXGflQ5WJ4lklMfgxzz/zuAZoz+36+TrijLyrE8hnLUiVch6B+/z4xBjtlrBWjidLf7vzHaEdZJV5RlsldBrzHJ3TUbrQkbmdx1uD7GGGml8QHKr5CuY9bn5PlwnfRh+3B8bQhd6yJvFc4xD+VsCDmKV4F0QBuy/1b92Kud1n8mv0K6+vLfqrCrqtNmu3Wha13kMQan4mRdyJkUr1qg4wzPlW1WHXKUH8fYHjX5AvskCPrjGevBGOOnkzaeTX4l8No+hq52QsWG2e6i0LUu8jgGLwo5F4WcaeJlMTqpurEo7isk/JocvsZylM41ocM60bGcwgA560KOq3951PIonV31/lHlYHl4DL0xRjnYHvEacozFMbYNJ+9FPuaH/8n7gZf88A8XgSf7KF69NDfbux4nW3lVDHqxjPdehHyk/3K5x3O+e0ONaNiHhaC3Hgtp8HyB5Bn9ha4Ms1/Jj/0a+LwTkCyf6/bi/UHNd5eD/sPyroBsbhs3g9O2xryrkMdtwzXIQ3/xMUv/0Rax375V7vFlOjtUjHBfUhTlUGs6+ZlgVeil2sYi5WF7xr7mtutu97cx2hG6nj0KpEt88BrV+Jgh+nlBj/ZinEitnWUbFQVtOUFPtR5U1Wmjv9kNqDj/scpp3fB+xh2xTFXKwzWVNcpT87hqvrhOeYgZLlMe4lY+8BGFX1RIjsKtyqTvmNvJnTTlQPkV0nXc/V6B5Jk+bB/20arQVbUnjNcPO6bNKi/fmGSd5Ljqgie8JnVdYLzGd11Q/nPVhTWha13kcZysCTkK18s6L9/PsMPUBU9Yb+q6YPInVReU/1x1YV3oqsaLHCej4I1Z4uWaH3nUuoAxPUxd8IQzpq4LPA/juy4o/7nqQtp5GH4uGGUeJku8fGN0w9QFT3MAqesCzwH4rgvKf666cFnoWhd53GZeFnIuCzlZ5+UbRzbflgOv8XXyvbLLfvifvON7xQ//nUE48quEIxv2mIQjlyAf6b+70OP5te4NJhuxLm6nPOG/qdspk18hXX21U2mxQLPditC1LvK4Dq8IOStCTtZ5mZ3RL6O2UxjTRZLjqguo31nUBZM/qbqg/OeqC5tC17rI4zjZFHI2hZys8+I2x/LVr8nha646N0xdQP3Ooi6Y/EnVBeU/V124KnStizyOk6tCzlUhJ+u8uM2xfPVrcviaq84NUxdQv7OoCyZ/UnVB+c9VF64JXesij+PkmpBzTcjJOq9F+m/56tfk8DWWg3pyXUh6VnmTnlVwbls9q1QhH+nvwbPKP9KaF4xt07lG/+Nznj/G+WpeB4Hz1WuUh3Ng65SHcwIblIcYaYnycPy5QnnYH29SnsJ3a0G/v9AOHBez4lqaOXAlZ35EOfMp5VRHlFNNKWd5RDnLKeWsjihnNaWctRHlrKWUUxpRTimlnJUR5ayklLM+opy8nub1NK+n01lPXWMpz3M3qd8n47mbih99nHM3yq4KB+K5G8zjOb5RMBJ+hwh9xGPuYecSK6I8uZxcTi4nl5PLyeXkcnI5uZxcTi5nfHJc65P8zkF27hVInpUDr6H8irDJpOYglV2HnYPk74CNMj9XHiOvyjnVK+c1HK+lMfLKYzXnlcdqHqs5rzxW85jIYzWP1ZxXHqt5rOaxmsfqpPXKeeWxmsdqHquDeOWxmvPKYzWP1ZxX/3ds1ftbft+rOkz9nWyTXyFdx6uP+70qtf7R7HPNj33aBeKP+qh3ucyXWyLPeG13/+O7QEh/DcqI9Hhu9+O1p7ovBNUFT47braC/PHjN7Buvc/5Al29NlGeD+A5bH/B+tiHeV0j4NTl8zVXvTKbfNczhfX7nLxDlCUQ5AqFr3Bdd6Tb8ab51i2Xib/QOuyZBrWH2azt3vZsRurriet5Bvy3oqw7664J+2UF/Q9CvOuhvCvo1B/0tQV9y0N8W9CsO+scF/bqD/p2CXrXbVjeegDzu894F18+izzP5FdLVV5/3rqDfdk8I28XfDbax6eeOXnr6hZeOHqDeyOvbcB3z8TCaOlyLaeboP38j2+omX99KuL6dcP16wvUbCddvJly/lXD9dsL1x+m65fHeX7wXHO9Bxn2g1QFl14Bo2R/2X32PfBz5gUfe4863a7MJ5wW67opt9V70E8QL+xVXX1MX9884yuCqy0bv+tZSfL7kKEeJ7isl6DWbwFvJxvv4GwounV1lHPSt+EtURpRr93r+FtdumeSNmf/eoO8GPCiethl+F2BW3PsOyEf6Z+Z7PH+Jxu94/1WyOe8zgbpgfzArrnH9wPvnHHIqI8qp5HJyObmcXM45kLMo7it0f61v8fNNok5YIHlWDryG8iuBbvPvjkWf3nNNMaVdzXYLQte6yGNMa0HIWRByFK/KGHmNU6+c13C8ls6pXnl85fGVx1fOaxCvPL5yXnl85X6cVl55fOW88vjK/TitvPL4ynnl8ZX7cVp55fGV85pEfKk5+jmSo3D/okOO2svdtecE/5ocvsZylM6ueZtHlYPlMbvZHBDadIxzLnd4H3iUHa8F+Fipdx1jA9cX4L28vsDonyn1eH6ie14Dvna/2VqtW+G5OV5vgOeWFwT96yCCoN/2eP9sAq+5AWWuBv12mkm4h9enVEn+3e7/xoiH6VMRZagKfYpEv0/+t7VtuDaoLPgY/QUhdxFoZkjuBZIbx/21yiRs1dlnnYsJZawm6HwEOl+vnLYDrhF2xSPrgPRYbtNHfdv7QjBYNpbnUoLs0pDlfw7Kf4t8hj734bMl0EnZa5F0NvovOXy2KOzm8tmSoF8UdqsF/X7icdggn10MtK5pfWb0Lzt8hjr58FkNdFI+WyKdjf4Vh8+UD1w+qwn6JWG3WtDvzxrlqXhz+VO9N1APkuMmbWw8RvTYn6eJDaP/iiM2anC/j9hYBp1UbNRIZ6P/qiM2lK9dsbEs6GvCbrWgP254n41BPqsHWte0PjP6rzl8hjr58NkK6KR8tkw6G/1vO3ymfODymdp3c1nYrRb0+5P33hjks8uB1jWtz4z+dx0+87Nvas9nq6CT8tkK6Wz0rzl8pnzg8tmqoF8RdlP7ivE+M4N8diXQuqb1mdF/w+Ez1MmHz9ZAJ+WzVdLZ6P/I4TPlA5fP1gT9qrCb2puN9+wZ5DPee8fkpPWZ0f+Jw2eokw+frYNOymdrpLPR/5nDZ8oHLp+tC/o1YTe1Rx/vFzTIZwuB1jWtz4z+r6bQZ6+foc/Qpuuknz0j/g1gMZ+cP30/PkfyGLYidKkI3dUYthIky2HMB23MGOGgto/xJ6N/A3zyzsppeWuOMit/raUs81oCr5kE3a3O+H1XuocJWXwgNrMh9OH4/nvChK6CfVSMcluwKeTi+/bcFmySXIUJ+bFVp8E6FxPKuJGg83dFW3CCoR337rf6YPV37thLecJYj3eDHtzGFEEulisIeuV2vc/t+s4+2kx9K4BxK9XeoM3T4FZqfz/Grf558n1Mg+2LcVUR9ioS/b+kjCvz1VnEFWKYHFeqXUV6jisVh8q36jsh3KYrXA9tznGlxi6qn+Q+5z/OMK7U2EX1Tdy2/3fKuDJfnUVcYbuQJq7UGIXthPRqPFAn+vicMVuF2aPNOa4ULof0OA+B9MXumG2CmG2D7YtxpXBsrgtl0Pm89oPYLnBcubD9+EjzfIy+MZvVg/6YqxEv1Q+izdPEFdJzP2j0q2cYV2ouANvYpLmAiynjyq6dt35QxZWrHxw0X8H9IMYSY9LD9oMqrlz9oNHfOGdxhW1sUlw9njKuzms/qOLK1Q8OiivuB124+aT6weY5iytXP2j0OxnrBwfFFfeDGFdp9pD30Q8+OYX94IfzfjB1P8jrG8uCF+JyHFfGu5RAj2vkkP7jIq7UGkOuE3OCN2K3rnLMDFmOmRTl+Iwox6LjfrWOcNB3inhdmNE/C98penZB85xJ4GnzSH7XJPXw1UFr30pURqM/JL/auA3x1argw3UD5fLcP8qtkVzEV7ksAfDENUi8RkWtR0J67tON/vOOttePv3rfDh3Upy8m2O050fayHdBuT8C1NO2aGgupuRJ+blSyXf2lWnOSpvwPHD7zs+ak5zO15gTtlbTm5GWHz9SaE5fPBq05MX1ca07UfbzGylU+5FETsguQnyY2eH2hWtviig2j/xURG642BfVNs77G9Zxg9F9x6KDWmW0InqpND4J+n/GcmdF/FXR4ckrqyKtnWEfQ7vx8qWRfErxYdimBPnFdmqNd87PGp+czhbOqdU+Ms37d4TO1xsfls0FrfEyfNGt8lM+wjWGfqTU+F4XsvnVpDp/5mXPp+UzNuSwLm/Ccyx86fKZ84PLZoPkM9plrjY/yGa4tTlorUUqgZ5+drEtz+Ax18uEzNa+/LGzC8/p/7PCZ8oHLZ2rOfF3YTa1X4W/1K5/h2mL2mckpJdCzz07WpU2hz/7iDH2Gdrd7F4N+nxW6v35t2WgVSJ6VA6+h/ErQb+cx6hO6/KD2S+A9cPBetbaExxDKf2rfAcXL2kzV7/Ecixr3rDjkLAudlRz+DvOqQwfV76+m1GF1wnKYVxKWw+9PetpfyLlWblPow+3kdwjL2QL7qDEVvz95TcjdorKi3GskV62V82Or3rpZ3OdBlXEzQed/SIlhWz3wjGHfG3atnKtPiA/uQ9ReNaqdqRO93Y/nqp1BmzPWY3JKCfT83ofRv+Xo988irrBNTIqr76WMqwmtlZNxhe1kmrhy7Qk0KK7MZiqukvAO5IU257hS48kVwZ/bye9PfDzZiys1nkQ7JI0n/ytlXJmvziKusF3guFJjLdfeToPGvDxvhTHHYwX1nOLCphUecEHwZzxgrgvIncV7WoPwAMZwjH4BdD6v/aBrLleNA11zuSoO1ThTrcFknGkQzpgmrtQYnONq5QzjSmGD2MYmYYMbKeNqQmuaZFxhu5Amrlx76Q3CL7kfdL0HNGw/qOY/Xf2g0V93xNVZvAuscHiuC7dTxpX56iziyrWmSbUZrjVNg95X5n4QY65IvIbtB9VchqsfNPrwnMVVmja2kzKuJrSmaeh+UMWVqx8cFFfcD6r3rQv0H3m5+kHVXqnvJnB7ddcRV+f1exNPTUE/6GqvVJvhaq/SfhOjHvTHHL9/O+i7VBxXas4e6ZPm7D92zuIqTRv7ySlor7BdSBNXrr2NB8UV94MYVzXKU+//utb4oUzEhdO8EzorZPF6jV8Q8bfouB/3YjRe1tcfAq+naN7JaJJwblsDY7HvZ9/6Hs5tfkC8+ZrQp0j0z5GftrvXEecuCj5GvyXkblNZUe4WyVU4tx9bhXusczGhjNcSdP6SaCcKdE8APF37kW8Jeiw3f1sB69lWMFg2ludSguxSMFz5X3a07ezzu93/jZGOns+ug07KXtuks9G/4vCZ3YN2c/nsuqDfFnarBf1+uk68BvmM1/GZnLQ+M/pfdfgMdfLhsxugk/LZddLZ6H/d4TPlA5fPbgj668JutaDfnzeI1yCf8ff7TE5anxn9qw6foU4+fHYTdFI+u0E6G/1vOXymfODy2U1Bf0PYrRb0+/Mm8RrkM/5+n8lJ6zOj//oU+uz3ztBnaNObpJ/1dX/Q1S/2xd8tnL4f+0N+P8SPvRsdl71x7Jdk72+kfM64CuWJj7ljL+XZUc8ZWF+KIDcpJpB+2Jgwm9WD/rq7RXn4rgzHEsYCzq0gH1+xoPq4WVEObi/+dMpjYQvy0sSCip2t4HRZ4qMe9MfJNuXh86grFmwec1KxYHqmjQWjfz1jsbAt6LeC02WJjzrRY1+v5qpdsYDvZZ/nWHgjj4XUsVCkPHzf2mTi2KFA96FMFxZ1FXgpeuPH45c3U2JRReD/5uxpXhbf/+TAoowmCYuyb+eeFyzqSoK93kqBRW0KPhx7w2JRb00eizpinYsJZUzCYr43JBaFMT8sFmX6PCoWheVJg0WlKf+/Tx6LOvHZo2JR3x8Si3L5zDcWhT5Ig0W5fGb0/zN5LOrEZzdAp2GwKOtg02JRLp/5xqLQB2mwKJfPjH4eyj8hXOPEZ4+Ka1QdPlM+cPnMNxaFPkiDRbl8ZvTLDp+hTj58dgt0Uj5jrMfo1x0+Uz5w+eyWoL8p7FYL+v15i3gN8hnPh5mctD4z+s0p9Nn2GfoMbXqL9LPxye2ufrEvXiifvh/HMPzOH5Z9JoVO5hfz1226frf7vzHacfJs+TiUV+l1m+xh9O8R/jpvz5YYB0WQi+UKgl65kZ5j6nFBj74xm9WJPj7fojxcH2EyVSzhOwPcnviIBfS1igWuG0b/vimIha2gd3AsqPYC6TkWXLGjYgHjZJvycP3eVvdcxcLJN3SJj69YUO34TVEObsc/MuWxsA15aWJBxQ76hmMB44TxR1x7vtU9V7GA76hNIhbUM6orFoz+UxmLhUHP0RwLOL7fpDx8v2Wre67GK/adorPEotVcGz+v76eMBZxniY+5Yy/lkbFgcfhQf5DLfp8V9MNi0RwLGCc3KA+/RXWV5OD7eHYNx5L8zQPEnxU9vz9r9F8UzxSm34y4H8fJStdxYOVJuj4Qui467o/5v0pYua15fhnG/X/ePbe6husOxhibTSs/fhsyzVyB0b/ieJZS8xVqLyPWAem53PFRI7vhvWqdxjrl4Zz8Bulga0UU70LQ/701o/818tdl0vtu939jxAPH84GQhfrOJdjxMSqD0b8G8fcb5WR78jc6+HugmIffl2A/oN7ct3j6vkaL6zvGO+qaVN9/M2XfUoTyxMfcsZfytFXfYvNLD/UHuUntItJznbwq6NV3SNS6en6XY07wQptzm4zzi4re+PH6999x9B/4DHSFdMc6VaK8dSFX9ZmXQefJtOHhvUWSjQfHBNpAfdOoQHnqWYDn09kGfMzSf7RF7KNvlXt8mc6OcbZDG8Fpeeel3qL/uN5iHZ0V9Gm+nYAxYN8uV+tROL6xzlymvLR15hLlYbyYb7DOuNoM1zhOtRmzomzcZvxlynHcHPCfm+1dj4/54+CUrg9/4Zr51OJuAekprwx5c8en5VS6/61/Z16mR5Ho/xb69IdlgHvs/rqQXyL5p/QW1zAWmdesuGb0sU1f7+oYv+fksw7u3nl73cdDnbr8i0F/W4Xyi0T/RldBXL9jv3Mj6Hl/dz+839q/v9/ZPzxsH+zzmA9tFtspjtlvUl+DbeE4x5/Gf94P/9D4L/jh37I6jf2I2Sr+/Ta1P+q5CO/l5wGj/1cYS3/HMZbmfgr9NkN5bHPMQ3tZG2W2LPuxZVvtC1Qg2VU/sjsFkhcEp9vpgORXSNdxx22B5Jk+6NP4mCH7XPDkG9PHtecW6hPvY7wU9PtMfXNd7Q+i4hdtzXZw2Uati+SxBfqY11POCB0sD2OEn12wXFafqgllm6Wy4d4lqp3gvTeM/t+gnVjpKptmPIt1mtsJjnHMU3tde96f5CQWlwbYKGk/t/90YEwqvstwjcfFrv2kUB/1XfglspefvZl6GEVtgL2S9mb6X4e9VPlLDnsN2veI7YW2xHtZdlLbMqlYHGTbpL1H5rv2HIT/lKE88TF37KU8nWG/EePahyM+0vhf1Re17xU/Y2Kbze05yuXvOGBby+05ttn4bYQVivtB2DJ/B7cMvIZpzzcgPvg5ctCYc9zPEY3m4cHOUTN61NndCZt7h8M8R1yAMj345ecPnn7hpaMHwYCj6qEQO+2d8M6d/TsHOwf399oH9wYVYtzyj+7sHTb27h/th2HYPGwcTVp+u7O/e7C/G4Z77fCoHXYmLj96Gt25v9voNA/bR83DgQ+jClzAhjE+DKBAAAPpjV+R6N/bLVxcaUJqfItCXkx310FXSPh9yENcmzs+fU0BGwj4GL3Jrhz362h5VcjDRjs+LnT/o72Ql+lRJPr3w4AyPhCksfvrQv4CyT+lt7jGgE9V0FcFfeyfna6OFrdY9nE/oD2USfzxGutmseOjXt1vN4+OOnfa9+5FZ+FhOPF27V57b/fe3kGnETVv4V5rkPz/A5dTq+dWvwEA",
      "debug_symbols": "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",
      "brillig_names": [
        "get_participants"
      ]
    },
    {
      "name": "register_dkim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12973622348172053284": {
            "error_kind": "string",
            "string": "Sender is not registry admin"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim"
      ]
    },
    {
      "name": "register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7921989071249124615": {
            "error_kind": "string",
            "string": "Function register_participant can only be called internally"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "directive_integer_quotient",
        "directive_invert"
      ]
    },
    {
      "name": "get_escrow_registry_status",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5402066124729458757": {
            "error_kind": "string",
            "string": "Function get_escrow_registry_status can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_escrow_registry_status"
      ]
    },
    {
      "name": "get_participant_escrows",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "offset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 10,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec"
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_participant_escrows"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "usdc",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow_contract_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "register_dkim_bulk",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6785921275376807115": {
            "error_kind": "string",
            "string": "DKIM key has already been registered"
          }
        },
        "parameters": [
          {
            "name": "verifier_ids",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBLJgAABAMmAgMECCYCBAQAHxgABAADgEMnAgABBIBDJgIEBAQsCAEDJgIFBAUAEAEFASYDAwQBACgDAgUtBAABgAMtBAAFgAQtBAAEgAUkAAAAuCwMAwEnAgACBIBHJgIEBAQsCAEDJgIFBAUAEAEFASYDAwQBACgDAgUtBAACgAMtBAAFgAQtBAAEgAUkAAAAuCwMAwIkAAAA/icCAAEEgEsmAgIEADoNAAEAAgEAgAOABYAHLQCAA4AILQCABIAJCwCACIAHgAojAIAKAAAA/S0BgAiABi0CgAaACQEAgAgAAoAIAQCACQACgAkiAAAAzCUkAAAFhywIAQQAAAECASYCBQEALA4FBCwIAQUAAAECASYCBgAALA4GBSwIAQcAAAECASYCCAACLA4IBx4CAAgAHgIACQAyOAAIAAkACiYCCAEBIwIACgAAAV0kAAAFsCwIAQgmAgkEBAAQAQkBJgMIBAEAKAgCCSwMCQosDgYKACgKAgosDgYKACgKAgosDgYKLAgBCQAAAQIBLA4ICSYCCAABJgIKBAAmAgsEASYCDAQDLAwKAyIAAAG5DDgDDA0jAgANAAAFEiIAAAHLLA0JCAAoCAINADgNCg4sDQ4JHgIACAEKOAkIDSMCAA0AAAH0JAAABcImAggABSYCCQQEKAIADQBUqmZoJgIOADAoAgAPADuaygAnAgAQAN6tLAwKAyIAAAIlDDgDCREjAgARAAACOCIAAAI3JSYCEgQEDDgDEhMjAgATAAACTyQAAAXUACgBAhIAOBIDEywNExEKOBEGEiMCABIAAATyIgAAAm8mAhQEBAw4AxQVIwIAFQAAAoYkAAAF1AAoAgIUADgUAxUsDRUTJgIYBBksCAAZLAwEGiwMBRssDAccLAwIHSwMDh4sDBMfABAAGAAkAAAF5iwEAAAsDBoULAwbFSwMHBYsDB0XLgwAFwAYCjgYBhcjAgAXAAAC6yQAAAqSJgIbBBwsCAAcLAwEHSwMBR4sDAcfLAwIICwMDiEsDBMiABAAGwAkAAAF5iwEAAAsDB0XLAweGCwMHxksDCAaADgPGhsuDAAbABwKOBwGHSMCAB0AAANHJAAACqQvDAAQABsvDAARABosCAEaJgIbBAQAEAEbASYDGgQBACgaAhssDBscLA4GHAAoHAIcLA4GHAAoHAIcLA4GHCwIARsmAhwEBAAQARwBJgMbBAEAKBsCHCwMHB0sDhMdACgdAh0sDhEdACgdAh0sDg0dLA0aEQAoEQIRLA4RGiwIAREAAAECASwOGhEsDAoSIgAAA9oMOBIMEyMCABMAAARoIgAAA+wsDRESJgIUBAMGKBQCESYCFgQDADgUFhUsCAETABABFQEmAxMEAQAoEwIVLA4UFQAoFQIVLA4UFSYCFgQDADgTFhUAKBICFi0EABaAAy0EABWABC0EABSABSQAAAC4ACgTAhUsDRUUJgIWBAIAOBUWEjYNABIAFCIAAATyJgIUBAMMOBIUFSMCABUAAAR/JAAABdQAKBsCFAA4FBIVLA0VEywNERQmAhYEAww4EhYXIwIAFwAABKgkAAAF1C0EABSAAycAgAQEAAQkAAAKti0IgAUAFQAoFQIWADgWEhcsDhMXADgSCxMOOBITFCMCABQAAATlJAAAC0QsDhURLAwTEiIAAAPaADgDCxEOOAMREiMCABIAAAUJJAAAC0QsDBEDIgAAAiUsDQkNHAwDDgAAOAgODy4MAA8ADiYCEAQDDDgDEBEjAgARAAAFPSQAAAXULQQADYADJwCABAQABCQAAAq2LQiABQAPACgPAhAAOBADESwODhEAOAMLDQ44Aw0OIwIADgAABXokAAALRCwODwksDA0DIgAAAbknAIAEBHgADQAAAIAEgAMjAIADAAAFrykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEF8E0P+B39nfc7AQECJSkBAAEF6J0J/qERLQ47AQECJSQAAAWHLAgBCCYCCQQDABABCQEmAwgEAQAoCAIJLAwJCiwOBAoAKAoCCiwOBgomAgQAACwIAQYmAgkEBAAQAQkBJgMGBAEAKAYCCSwMCQosDgQKACgKAgosDgQKACgKAgosDgQKLA0GCQAoCQIJLA4JBioCAAkAAAAAAAAAAAIAAAAAAAAAACwIAQomAgsEBQAQAQsBJgMKBAEAKAoCCywMCwwsDgQMACgMAgwsDgQMACgMAgwsDgQMACgMAgwsDgkMLA0GCQAoCQIJLA4JBiwIAQkAAAECASwOBgksDQoGACgGAgYsDgYKLAgBBgAAAQIBLA4KBiwIAQoAAAECASYCCwQALA4LCiwIAQwAAAECASYCDQEALA4NDCYCDgQCJgIPBAEmAhAEAywMCwciAAAHGAw4Bw4RIwIAEQAACSkiAAAHKiwNDBAKOBANESMCABEAAAdEJgISBAA7CQESJgIQBBEsCAARLAwJEiwMBhMsDAoULAwMFQAQABAAJAAAC1YsBAAALA0JECwNBhEsDQoSLA4QCSwOEQYsDhIKJgIGAQEsDgYMACgRAgkAOAkLCiwNCgYmAgkALgo4BQkKCjgGBAkjAgAKAAAI8SIAAAe2JgIQADAKOAUQESMCABEAAAi1IgAAB80mAhQAMgo4BRQVIwIAFQAACHkiAAAH5CYCGAA0CjgFGBkjAgAZAAAIPSIAAAf7JgIYADUKOAUYGSMCABkAAAgWJgIaBAA7CQEaCjgJDQUjAgAFAAAIKCQAAAzHLAwBFCwMAhUsDAMWLAwGFyIAAAhkCjgJDQUjAgAFAAAITyQAAAzHLAwBFCwMAhUsDAMWLAwGFyIAAAhkLAwUECwMFREsDBYSLAwXEyIAAAigCjgJDQUjAgAFAAAIiyQAAAzHLAwBECwMAhEsDAMSLAwGEyIAAAigLAwQBCwMEQosDBILLAwTDCIAAAjcCjgJDQUjAgAFAAAIxyQAAAzHLAwBBCwMAgosDAMLLAwGDCIAAAjcLAwEBywMCggsDAsOLAwMDyIAAAkYCjgJDQQjAgAEAAAJAyQAAAzHLAwBBywMAggsDAMOLAwGDyIAAAkYLAwHASwMCAIsDA8ELAwOAyUjAgARAAAJNiIAAApyJgISBAIMOAcSEyMCABMAAAlNJAAABdQAKAgCEgA4EgcTLA0TESwNChIsDQwTCjgTDRQjAgAUAAAJeSYCFQQAOwkBFQo4EhATIwIAEwAACgQiAAAJiywNCRIsDQYTLA0KFCwNDBUmAhcEAww4FBcYIwIAGAAACbIkAAAF1C0EABKAAycAgAQEAAQkAAAKti0IgAUAFgAoFgIXADgXFBgsDhEYADgUDxEOOBQREiMCABIAAAnvJAAAC0QsDhYJLA4TBiwOEQosDhUMIgAACnImAhIEEywIABMsDAkULAwGFSwMChYsDAwXABAAEgAkAAALViwEAAAsDQkSLA0GEywNDBQtBAASgAMnAIAEBAAEJAAACrYtCIAFABUAKBUCFgA4FgsXLA4RFywOFQksDhMGLA4PCiwOFAwiAAAKcgA4Bw8RDjgHERIjAgASAAAKiSQAAAtELAwRByIAAAcYKQEAAQVeLG9yVJmsyzsBAQIlKQEAAQUfCi0n3IKHojsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAK0SIAAArcLQCAA4AFIgAAC0MtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAALLy0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAK/icBgAUEAAEDAIAGAAKABiIAAAtDJSkBAAEFRafKcRlB5BU7AQECJSQAAAWHJgIGBAAmAgcEASYCCAQDLAwGBSIAAAtzDDgFCAYjAgAGAAAL4CIAAAuFLA0BBSwNAgYsDQMHLA0ECCYCCQQELAgBCiYCCwQFABABCwEmAwoEAQAoBgILJgIMBAQAKAoCDT4PAAsADSwNCgYAKAYCBiwOBgosDgUBLA4KAiwOBwMsDggEJSwNAwYMOAUGCSMCAAkAAAv2IgAADKcsDQEGLA0CCSwNAwosDQQLJgINBAQMOAUNDiMCAA4AAAwdJAAABdQAKAkCDQA4DQUOLA0ODCYCDgQDDDgFDg8jAgAPAAAMQiQAAAXUACgGAg4AOA4FDywNDw0AOAwNDiYCDQQEDDgFDQ8jAgAPAAAMbCQAAAXULQQACYADJwCABAQABSQAAAq2LQiABQAMACgMAg0AOA0FDywODg8sDgYBLA4MAiwOCgMsDgsEIgAADKcAOAUHBg44BQYJIwIACQAADL4kAAALRCwMBgUiAAALcykBAAEFAtxuJ4B2Ep07AQECJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "register_dkim_bulk"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 20,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "check_dkim_key_hash_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5886526716701834683": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_private can only be called statically"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_returns_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ]
    },
    {
      "name": "check_and_register_participant",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12235207718074526931": {
            "error_kind": "string",
            "string": "Escrow contract is not registered"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17315513700638891511": {
            "error_kind": "string",
            "string": "Sender is not the registry admin"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "participant_name",
            "type": {
              "kind": "string",
              "length": 60
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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Sj5X8oWSL5V8peRrJd8o+VbJd0q+V/KDkh+V/KTkZyW/KPlVyW9Kflfyh5I/lfyl5G8l/s6nREmpkjIl5UoqlFQq6aekSkm1kholtUr6K6lTMkBJvZIGJQOVDFIyWMkQJUOVDFMyXMkIJXMpmVvJPEpGKhmlZLSSMUrGKmlUMk7JvErmUzK/kvFKFlCyoJKFlCysZBEliypZTMniSpZQElfiKUkoSSpJKUkrySjJKskpaVKypJKllCytZBklyypZTskEJcsrWUHJikpWUjJRycpKVlGyqpLVlKyuZA0laypZS8naStZRsq6S9ZSsr2QDJRsq2UjJxko2UbKpks2UbK7kX0q2ULKlkq2UbK1kGyXNSiYpmaxkipIWJa1KtlWynZLtleygZEclOynZWclUJdOU7KJkVyXTleymZIaS3ZXsoWRPJXsp2VvJPkr2VbKfkplK9ldygJI2JQcqOUjJwUoOUXKoksOUHK7kCCVHKjlKydFKjlFyrJLjlByv5AQlJyo5ScnJSk5RcqqS05ScruQMJWcqOUvJ2UrOUXKukvOUnK/kAiUXKrlIycVKLlFyqZLLlFyu5AolVyq5SsnVSq5Rcq2S65Rcr+QGJTcquUnJzUr899P7737336vuv7Pcfx+4/65t/z3W/jui/fcv++829t8b7L+T9z4l/rtk/fe0+u9A9d8v6r+7038vpv/OSf99jv67Ev33EPrv+PPfn+e/m85/75v/TjX/fWX+u8D892z577Dy3w/lv3vJf6+R/84g/308/rtu/PfI+O9o8d9/4r9bxH9vh/9OjHeU+O9y8N+T4K8B/ef7+8/O959L7z/z3X+euv+scv854P4ztv3nV/vPhvafu+w/09h/XrD/LF7/Obf+M2T957P6zz79SYn/zE7/eZj+syb95zj6z0j0nz/oP9vPf26e/0w6/yDSf5aa/5wy/xlg/vO1/GdX+c+F8p+55D/PyH9WkP8cHv8ZN/7zY/xns/jPPfGfKeI/r8N/Fob/nAn/GQ7+8xH8Zw/49/X798z796P793r791H79yj79//699b6963694T691v69zL69wn69+D597f592j59wT599v492T49xP418L713H71yD71/f614D611f6C2j/+jb/Gij/+iL/GhT/+gn/3L9/3to/J+yfN/TPefnna/xzDX6d3K/xzq5PKvHrVn7t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",
      "debug_symbols": "7P3bkizZslyJ/ct+xoNfzG/9KxQKBWSjKRBpASgE+ATpf2fsqsrILKROt1rIuSLcTcfbQXecOm5DY6Xr1HBz/R//+t//0//z//f//n/85//yf/zX//av/+3/9j/+9X/+1//Xf/zv//m//pfH/+t//Gub//j/9t/+P//xv/z7//nf/vt//P/+93/9b+N6DP/hX//pv/zvj/9xG4b/6z/86//4z//nf/rX/xZb/F//4dunp33e//r0tK+fnx7jEJ+el/H469PzckzJp/fj+d/ej2V8fnoeZvHpcX7+t8d53p+fnlb14WFaPz48bMvXD//f/8O/tgCMBrMARoNZAaPBbIDRYHbAaDAHYCSYfQCMBjMCRoOZAKPB4HwbYAIwGgzOtwEG59sAg/NtgMH5NsDgfDWYA+fbAIPzbYDB+TbA4HwbYAIwGgzOtwEG59sAg/NtgMH5NsDgfDWYccD6tsjgfVtkML8tMrjfFpmATIMM/rdFBgPcIoMDbpHBArfI4IEbZEY8cIsMHrhFBg/cIoMHbpEJyDTI4IFbZPDALTJ44BYZPHCLDB64QWbCA7fI4IFbZPDALTJ44BaZgEyDDB64RQYP3CKDB26RwQO3yOCBG2RmPHCLDB64RQYP3CKDB26RCcg0yOCBW2TwwC0yeOAWGTxwiwweuEEm8MAtMnjgFhk8cIsMHrhFJiDTIIMHbpHBA7fI4IFbZPDALTJ44AaZBQ/cIoMHbpG5vAfelieZ/cjIbPv8cd37MP2MzOU98NvIBGQaZC7vgd9GpoMHjmH5uPoYjs+/kvtf/ye23/9/ooMre/xcG59/vY8viu3i08fjdvDXp49j3b9ekPjqTPP+8d+ephjnb9d/3Pv6V+lwtmP9+L+xHXuk/772D4mnY/ryL2aV/2KW7fmtHr7+85rlh8ePfzD7sgzJP699iuenpyO76c/Lxz+vmIbzf4rT9vynOG2RfLjnP/J1RJ4ryzMhz5XlmZHnyvLEq+UZHyf6jwsavzD8tz5/XNFyuStaL3dF2+WuaL/cFR1Xu6JtuNwVjZe7oulyVzRf7ore8Dd7eGZzU6zfr2i53BW9/m/2ti7P8+b/pNr3T3/ewh/X9MVHbOo6Hr/PflzH47D+t0//MetmNOtuNOtRadZ1fs66fZ91H4xmHY1mnSrN+vzwNH05dz1nnY1mDaNZl1L3nC+zzt9nreSbpmF7zjpt32et5JuyWSv5pmzWUr7py7/X6fv99bi4b9qfFnccxiMZ9vfFq9PxcVqc5jFLTDs+iHJc3Oq5y3Nxd3oRed7148RxcUPtLk+YyPPHsG84BMT0lGqaM1MRH55o+/JAyrRMf179euur32599futr/648dVPw3Drqx9vffXTra9+vvXVx62v/s732mm48712Gu58r52GO99rp+HW99rx1vfa8db32vHW99rx1vfa8db32vHW99rx1vfa8db32vHW99rx1vfa6db32unW99rp1vfa6db32unW99rp1vfa6db32unW99rp1vfa6db32vnW99r51vfa+db32vnW99r51vfa+db32vnW99r54vfa/fkUwb4P36/+4vfa5Oovfq891i/b2ePfLv/7h2NZn4/BLMfnAygm29lTXNx6IOaviHlxJ4aYvyLmxY0pYv6KmBf36Yj5K2IGYtYR8+KnOMT8FTEvfqhFzF8R8+JnfMT8FTEvHnkg5q+ISQJUR8yFBKiQmCRAhcQkASokJglQITEDMeuISQJUSEwSoEJikgAVEpMEqJCYJEB1xFxJgAqJSQJUSEwSoEJikgAVEjMQs46YJECFxCQBKiQmCVAhMUmAColJAlRHzI0EqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXE3EmAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEfMgwSokJgkQIXEJAEqJCYJUCExAzHriEkCVEhMEqBCYpIAFRKTBKiQmCRAZcScBxKgQmKSABUSkwSokJgkQIXEDMSsIyYJUCExSYAKiUkCVEhMEqBCYpIA1RFzJAEqJCYJUCExSYAKiUkCVEjMQMw6YpIAFRKTBKiQmCRAhcQkASokJglQHTEnEqBCYpIAFRKTBKiQmCRAhcQMxKwjJglQITFJgAqJSQJUSEwSoEJikgDVEXMmASokJglQITFJgAqJSQJUSMxAzDpikgAVEpMEqJCYJECFxCQBKiQmCVAdMYMEqJCYJECFxCQBKiQmCVAhMQMx64hJAlRITBKgQmKSABUSkwSokJgkQHXEXEiAColJAlRITBKgQmKSABUSMxCzjpgkQIXEJAEqJCYJUCExSYAKiUkCVEfMlQSokJgkQIXEJAEqJCYJUCExAzHriEkCVEhM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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_notes_internal",
        "get_collapse_hints",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "pack_arguments_oracle_wrapper",
        "pack_returns_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ]
    },
    {
      "name": "check_dkim_key_hash_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17116176681845328521": {
            "error_kind": "string",
            "string": "Function check_dkim_key_hash_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "dkim_key_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "check_dkim_key_hash_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "ndLNCoQgFAXgd7nrFl2131eJIawsBLEwGxiidx+LZmiGNrq5eMTvujkrdKJZhlrqfpyhrFZQY8utHLVL6xZBY6RScqiv1xDvA/F4P09c73G23FgoEWkEQnfuRND5XioBJcvY9ogAiT+h/oT5k8SbkNtfClqkpykYoV+EGB8oCUFpCMpCUB6A6G0PCpYnH5TE7BdtLj65kbxR4uxZv+j2Ujv7msRfAycztqJbjNi7eKmhmxVmESFurVv9Bg==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "set_contract_registered",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14241992704497173765": {
            "error_kind": "string",
            "string": "Function set_contract_registered can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "escrow_contract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_contract_registered"
      ]
    },
    {
      "name": "register_participant_escrow",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "internal"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2564696720034330091": {
            "error_kind": "string",
            "string": "Function register_participant_escrow can only be called internally"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "participant",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "escrow",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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N/nSlzf50pc3+dI1z08Gb1fe5Etf3uRLX97kS9/zJfnSlzf50pX3TL705U2+9OVNvvTlTb705W3wduVNvvTlTb705U2+dM3zM/nSlzf50pX3Qr705U2+dD1fLuRLX97kS1/eBm9X3uRLX97kS1/e5Etf3uRLX97kS1feK/nSlzf50jXPr+RLX97kS1/eBm9X3uRL3/Ml+dKXN/nSlzf50pc3+dKTd+rIl768yZe+vMmXvrzJl768Dd6uvMmXnnk+deRLX97kS1/e5Etf3uRL1/NlT7705U2+9OVNvvTlTb705W3wduVNvvTlTb705U2+9OVNvvTlTb50zfOJfOnLm3zpy5t86cubfOl6vkwGb1fe5Etf3uRLX97kS1/e5Etf3uRLV94D+dKXN/nSlzf50pc3+dI1zw8Gb1fe5Etf3uRLX97kS9/zJfnSlzf50pW3kS99eZMvfXmTL315ky99eRu8XXmTL315ky99eZMvXfO8kS99eZMvXXmP5Etf3uRL1/PlSL705U2+9OVt8HblTb705U2+9OVNvvTlTb705U2+dOU9kS99eZMvXfP8RL705U2+9OVt8HblTb70PV+SL315ky99eZMvfXmTL115z+RLX97kS1/e5Etf3uRLX94Gb1fe5EvXPD+TL315ky99eZMvfXmTL13Plwv50pc3+dKXN/nSlzf50pe3wduVN/nSlzf50pc3+dKXN/nSlzf50jXPr+RLX97kS1/e5Etf3uRL1/PlavB25U2+9OVNvvTlTb705U2+9OVNvvTkPXTkS1/e5Etf3uRLX97kS888P3QGb1fe5Etf3uRLX97kS9/zJfnSlzf50pV3T7705U2+9OVNvvTlTb705W3wduVNvvTlTb705U2+dM3zPfnSlzf50pV3Il/68iZfup4vE/nSlzf50pe3wduVN/nSlzf50pc3+dKXN/nSlzf50pX3QL705U2+dM3zA/nSlzf50pe3wduVN/nS93xJvvTlTb705U2+9OVNvnTlbeRLX97kS1/e5Etf3uRLX94Gb1fe5EvXPG/kS1/e5Etf3uRLX97kS9fz5Ui+9OVNvvTlTb705U2+9OVt8HblTb705U2+9OVNvvTlTb705U2+dM3zE/nSlzf50pc3+dKXN/nS9Xw5GbxdeZMvfXmTL315ky99eZMvfXmTL115z+RLX97kS1/e5Etf3uRL1zw/G7xdeZMvfXmTL315ky99z5fkS1/e5EtX3gv50pc3+dKXN/nSlzf50pe3wduVN/nSlzf50pc3+dI1zy/kS1/e5EtX3iv50pc3+dL1fLmSL315ky99eRu8XXmTL315ky99eZMvfXmTL315ky89eVtHvvTlTb70zPPWkS99eZMvfXkbvF15ky99z5fkS1/e5Etf3uRLX97kS1fePfnSlzf50pc3+dKXN/nSl7fB25U3+dI1z/fkS1/e5Etf3uRLX97kS9fzZSJf+vImX/ryJl/68iZf+vI2eLvyJl/68iZf+vImX/ryJl/68iZfuub5gXzpy5t86cubfOnLm3zper4cDN6uvMmXvrzJl768yZe+vMmXvrzJl668jXzpy5t86cubfOnLm3zpmufN4O3Km3zpy5t86cubfOl7viRf+vImX7ryHsmXvrzJl768yZe+vMmXvrwN3q68yZe+vMmXvrzJl655fiRf+vImX7rynsiXvrzJl67ny4l86cubfOnL2+Dtypt86cubfOnLm3zpy5t86cubfOnKeyZf+vImX7rm+Zl86cubfOnL2+Dtypt86Xu+JF/68iZf+vImX/ryJl+68l7Il768yZe+vMmXvrzJl768Dd6uvMmXrnl+IV/68iZf+vImX/ryJl+6ni9X8qUvb/KlL2/ypS9v8qUvb4O3K2/ypS9v8qUvb/KlL2/ypS9v8qVnnh878qUvb/KlL2/ypS9v8qXn+XLsDN6uvMmXvrzJl768yZe+vMmXvrzJl668e/KlL2/ypS9v8qUvb/Kla57vDd6uvMmXvrzJl768yZe+50vypS9v8qUr70S+9OVNvvTlTb705U2+9OVt8HblTb705U2+9OVNvnTN84l86cubfOnKeyBfuh6/B/Kl73yTL315ky99eRu8XY/f5Evf+SZf+vImX/ryJl/68iZfup4vjXzpy5t86cubfOnLm3zpy9vg7cqbfOnLm3zpy5t8eS7vebmCu/xzyHmTL8u8l+H62GWa73l/R9hqZBymDeGwFB6cLle2rn/5UpJuD06rgjGN3fLj0dNl4f3UCnIpXQ8pQxruRnxRr2Ndr/l/6Prx/sHfxBxbzaMhxWw17H5GMYduuIlpa0H528tI432Npx7cL9v5sl+7IR+TVjM6Y/IT6HWzpv16B1o++GJer7ZqzV3V2GoLwUR91EQZE8VEnTpR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",
      "brillig_names": [
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000f518d98e"
            },
            {
              "kind": "string",
              "value": "EntitlementNote"
            },
            {
              "fields": [
                {
                  "name": "recipient",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "verifier_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "max_value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_start",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "date_end",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000005"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "destination",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000006"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "spot",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000007"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000008"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000b3dd3286"
            },
            {
              "kind": "string",
              "value": "ParticipantNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "name",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseEscrow"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "entitlements",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ZImburseRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "definition",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "escrow_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "dkim_registry",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "managed_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participants",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "participant_escrows",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "dkim_key_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "verifier_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::DKIMKeyHashRegistered"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "usdc",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow_contract_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_dkim_key_hash_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_dkim_key_hash_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::set_contract_registered_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::set_contract_registered_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_ids",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "dkim_key_hashes",
                    "type": {
                      "kind": "array",
                      "length": 4,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_bulk_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_bulk_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_class_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_class_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::get_escrow_registry_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::get_escrow_registry_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verifier_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dkim_key_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_dkim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_dkim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_participant_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_participant_escrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "participant",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "participant_name",
                    "type": {
                      "kind": "string",
                      "length": 60
                    }
                  },
                  {
                    "name": "escrow",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::check_and_register_participant_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::check_and_register_participant_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "escrow_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ZImburseRegistry::register_escrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ZImburseRegistry::register_escrow_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "105": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "107": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "108": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "109": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "110": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "112": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "113": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "114": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "119": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "120": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "122": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{\n    abis::nullifier_leaf_preimage::NullifierLeafPreimage, constants::NULLIFIER_TREE_HEIGHT,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 44;\n\npub struct NullifierMembershipWitness {\n    pub index: Field,\n    pub leaf_preimage: NullifierLeafPreimage,\n    pub path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let serialized_leaf_preimage = array::subarray(fields, 1);\n\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(serialized_leaf_preimage),\n            path: array::subarray(fields, 1 + serialized_leaf_preimage.len()),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"
    },
    "125": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "126": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "129": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "131": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 bytes.\n//\n// Each 31 byte chunk is converted into a Field as if the chunk was the Field's big endian representation. If the last chunk\n// is less than 31 bytes long, then only the relevant bytes are conisdered.\n// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\npub fn bytes_to_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut dst = [0; (N + 30) / 31];\n\n    for dst_index in 0..((N + 30) / 31) {\n        let mut field_value = 0;\n\n        for i in 0..31 {\n            let byte_index = dst_index * 31 + i;\n            if byte_index < N {\n                // Shift the existing value left by 8 bits and add the new byte\n                field_value = field_value * 256 + input[byte_index] as Field;\n            }\n        }\n\n        dst[dst_index] = field_value;\n    }\n\n    dst\n}\n\n// Converts an input array of fields into bytes. Each field of input has to contain only 31 bytes.\n// TODO(#8618): Optimize for public use.\npub fn fields_to_bytes<let N: u32, let M: u32>(input: [Field; M]) -> [u8; N] {\n    let mut dst = [0; N];\n\n    for src_index in 0..M {\n        let field = input[src_index];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let src: [u8; 31] = field.to_be_bytes();\n\n        // Since some of the bytes might not be occupied (if the source value requiring less than 31 bytes),\n        // we have to compute the start index from which to copy.\n        let remaining_bytes = N - src_index * 31;\n        let src_start_index = if remaining_bytes < 31 {\n            // If the remaining bytes are less than 31, we only copy the remaining bytes\n            31 - remaining_bytes\n        } else {\n            0\n        };\n\n        // Note: I tried combining this check with `assert_max_bit_size` above but `assert_max_bit_size` expects\n        // the argument to be a constant. Using comptime block to derive the number of bits also does not work\n        // because comptime is evaluated before generics.\n        for i in 0..src_start_index {\n            assert(src[i] == 0, \"Field does not fit into remaining bytes\");\n        }\n\n        for i in 0..31 {\n            let byte_index = src_index * 31 + i;\n            if byte_index < N {\n                dst[byte_index] = src[src_start_index + i];\n            }\n        }\n    }\n\n    dst\n}\n\nmod test {\n    use crate::utils::bytes::{bytes_to_fields, fields_to_bytes};\n\n    #[test]\n    fn test_bytes_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_bytes() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_bytes(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_less_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_bytes(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_bytes_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_bytes() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_input_to_fields_and_back(input: [u8; 128]) {\n        let output = bytes_to_fields(input);\n        let input_back: [u8; 128] = fields_to_bytes(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_bytes(input);\n        let input_back = bytes_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"Field does not fit into remaining bytes\")]\n    fn test_too_few_destination_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_bytes(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_bytes_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_bytes(input);\n    }\n\n    #[test]\n    fn test_fields_to_bytes_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_bytes(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "145": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/contract_inclusion.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::DEPLOYER_CONTRACT_ADDRESS,\n    hash::compute_siloed_nullifier,\n};\n\ntrait ProveContractDeployment {\n    fn prove_contract_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractDeployment for BlockHeader {\n    fn prove_contract_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonDeployment {\n    fn prove_contract_non_deployment(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonDeployment for BlockHeader {\n    fn prove_contract_non_deployment(self, contract_address: AztecAddress) {\n        // Compute deployment nullifier\n        let nullifier =\n            compute_siloed_nullifier(DEPLOYER_CONTRACT_ADDRESS, contract_address.to_field());\n\n        // docs:start:prove_nullifier_non_inclusion\n        self.prove_nullifier_non_inclusion(nullifier);\n        // docs:end:prove_nullifier_non_inclusion\n    }\n}\n\ntrait ProveContractInitialization {\n    fn prove_contract_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractInitialization for BlockHeader {\n    fn prove_contract_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n\ntrait ProveContractNonInitialization {\n    fn prove_contract_non_initialization(header: BlockHeader, contract_address: AztecAddress);\n}\n\nimpl ProveContractNonInitialization for BlockHeader {\n    fn prove_contract_non_initialization(self, contract_address: AztecAddress) {\n        // Compute initialization nullifier\n        let nullifier = compute_siloed_nullifier(contract_address, contract_address.to_field());\n\n        self.prove_nullifier_non_inclusion(nullifier);\n    }\n}\n"
    },
    "146": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr",
      "source": "use dep::protocol_types::block_header::BlockHeader;\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{\n    context::PrivateContext,\n    note::{note_interface::{NoteInterface, NullifiableNote}, utils::compute_siloed_nullifier},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: BlockHeader, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for BlockHeader {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = unsafe {\n            get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier)\n        };\n\n        // 2) First we prove that the tree leaf in the witness is present in the nullifier tree. This is expected to be\n        // the leaf that contains the nullifier we're proving inclusion for.\n        assert(\n            self.state.partial.nullifier_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving nullifier inclusion failed\",\n            );\n\n            // 3) Then we simply check that the value in the leaf is the expected one. Note that we don't need to perform\n            // any checks on the rest of the values in the leaf preimage (the next index or next nullifier), since all we\n            // care about is showing that the tree contains an entry with the expected nullifier.\n            assert(\n                witness.leaf_preimage.nullifier == nullifier,\n                \"Nullifier does not match value in witness\",\n            );\n        }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, let N: u32>(\n        header: BlockHeader,\n        note: Note,\n        context: &mut PrivateContext,\n    )\n    where\n        Note: NoteInterface<N> + NullifiableNote;\n}\n\nimpl ProveNoteIsNullified for BlockHeader {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, let N: u32>(self, note: Note, context: &mut PrivateContext)\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"
    },
    "148": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "149": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "150": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "153": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "154": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "161": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "197": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr",
      "source": "pub global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable},\n    hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct NullifierLeafPreimage {\n    pub nullifier: Field,\n    pub next_nullifier: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<Field> for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_key: Field, next_index: u32) -> Self {\n        Self { nullifier: self.nullifier, next_nullifier: next_key, next_index }\n    }\n\n    fn update_value(self, _nullifier: Field) -> Self {\n        assert(false, \"Tried to update a nullifier\");\n        Self::empty()\n    }\n\n    fn build_insertion_leaf(nullifier: Field, low_leaf: Self) -> Self {\n        Self { nullifier, next_nullifier: low_leaf.next_nullifier, next_index: low_leaf.next_index }\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value =\n            compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(\n            self.nullifier,\n            siloed_value,\n            \"Value of the nullifier leaf does not match read request\",\n        );\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"
    },
    "205": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "212": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "241": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n"
    },
    "252": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "267": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "268": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "284": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "287": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "289": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "290": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "293": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
    },
    "294": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "296": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "297": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "301": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "302": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "303": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "304": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "307": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "313": {
      "path": "/Users/ianbrighton/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "321": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_escrow/src/types/entitlement_note.nr",
      "source": "use aztec::{\n    encrypted_logs::encrypted_event_emission::encode_and_encrypt_event,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::{note, note_custom_interface},\n    note::utils::compute_note_hash_for_nullify,\n    oracle::{random::random, notes::check_nullifier_exists, debug_log::debug_log_format},\n    prelude::{NoteHeader, NullifiableNote, NoteInterface, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        traits::{Serialize, Deserialize},\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::{poseidon2_hash_with_separator, poseidon2_hash_bytes},\n        utils::field::field_from_bytes,\n    },\n};\nuse compressed_string::CompressedString;\nuse generators::GENERATORS;\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\nuse crate::{ZERO_DESTINATION, ZImburseEscrow::{SpotReimbursementClaimed, RecurringReimbursementClaimed, EntitlementNullified}};\n\nglobal ENTITLEMENT_NOTE_LENGTH: u32 = 8;\n\n#[note_custom_interface]\npub struct EntitlementNote {\n    // the user that is allowed to use this entitlement\n    recipient: AztecAddress,\n    // the type of receipt verifier that this entitlement can be used for\n    verifier_id: u8,\n    // the maximum value that can be withdrawn from the escrow using this entitlement\n    max_value: U128,\n    // date range that verified emails can be used for\n    date_start: u32,\n    date_end: u32,\n    // destination if used for travel\n    destination: Field,\n    // whether or not the entitlement is a spot entitlement\n    spot: bool,\n    // blinding factor & nullifier secret for the note\n    randomness: Field,\n}\n\nimpl NoteInterface<ENTITLEMENT_NOTE_LENGTH> for EntitlementNote {\n\n    fn serialize_content(self) -> [Field; ENTITLEMENT_NOTE_LENGTH] {\n\n        [\n            self.recipient.to_field(),\n            self.verifier_id as Field,\n            self.max_value.to_integer(),\n            self.date_start as Field,\n            self.date_end as Field,\n            self.destination,\n            self.spot as Field,\n            self.randomness\n        ]\n    }\n\n    fn deserialize_content(serialized_note: [Field; ENTITLEMENT_NOTE_LENGTH]) -> EntitlementNote {\n        EntitlementNote {\n            recipient: AztecAddress::from_field(serialized_note[0]),\n            verifier_id: serialized_note[1] as u8,\n            max_value: U128::from_integer(serialized_note[2]),\n            date_start: serialized_note[3] as u32,\n            date_end: serialized_note[4] as u32,\n            destination: serialized_note[5],\n            spot: serialized_note[6] as bool,\n            randomness: serialized_note[7],\n            header: NoteHeader::empty()\n        }\n    }\n\n    fn to_be_bytes(self, storage_slot: Field) -> [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] {\n        let serialized_note = self.serialize_content();\n        let mut buffer: [u8; ENTITLEMENT_NOTE_LENGTH * 32 + 64] = [0; ENTITLEMENT_NOTE_LENGTH * 32 + 64];\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = EntitlementNote::get_note_type_id().to_be_bytes();\n        for i in 0..32 {\n            buffer[i] = storage_slot_bytes[i];\n            buffer[32 + i] = note_type_id_bytes[i];\n        }\n        for i in 0..serialized_note.len() {\n            let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n            for j in 0..32 {\n                buffer[64 + i * 32 + j] = bytes[j];\n            }\n        }\n        buffer\n    }\n\n    fn get_note_type_id() -> Field {\n        comptime\n        {\n            let bytes = \"EntitlementNote\".as_bytes();\n            let hash = poseidon2_hash_bytes(bytes);\n            let hash_bytes = hash.to_be_bytes::<4>();\n            field_from_bytes(hash_bytes, true)\n        }\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn compute_note_hash(self) -> Field {\n        let serialized = self.serialize_content();\n        let generators = [\n            GENERATORS[0],\n            GENERATORS[1],\n            GENERATORS[2],\n            GENERATORS[3],\n            GENERATORS[4],\n            GENERATORS[5],\n            GENERATORS[6],\n            GENERATORS[7],\n            GENERATORS[8]\n        ];\n        let data = [\n            from_field_unsafe(serialized[0]),\n            from_field_unsafe(serialized[1]),\n            from_field_unsafe(serialized[2]),\n            from_field_unsafe(serialized[3]),\n            from_field_unsafe(serialized[4]),\n            from_field_unsafe(serialized[5]),\n            from_field_unsafe(serialized[6]),\n            from_field_unsafe(serialized[7]),\n            from_field_unsafe(self.get_header().storage_slot)\n        ];\n        std::embedded_curve_ops::multi_scalar_mul(generators, data).x\n    }\n}\n\nimpl NullifiableNote for EntitlementNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = self.randomness; // use as nullifier_secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = self.randomness; // use as nullifier secret so that admin and recipient can nullify\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for EntitlementNote {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient)\n            & (self.date_start == other.date_start)\n            & (self.date_end == other.date_end)\n            & (self.destination == other.destination)\n            & (self.max_value == other.max_value)\n            & (self.randomness == other.randomness)\n            & (self.spot == other.spot)\n            & (self.verifier_id == other.verifier_id)\n    }\n}\n\nimpl EntitlementNote {\n    \n    /**\n     * EntitlementNote constructor\n     *\n     * @param recipient - the address of the recipient of the entitlement (NOT THE OWNER OF THE NOTE)\n     * @param verifier_id - the type of verifier that the entitlement can be used for\n     * @param max_value - the maximum value that can be withdrawn from the escrow using the entitlement\n     * @param date_start - the start of the date range that the entitlement can be used for (0 for recurring)\n     * @param date_end - the end of the date range that the entitlement can be used for (0 for recurring)\n     * @param destination - the destination of the entitlement (ZERO_DESTINATION for recurring)\n     * @param randomness - blinding factor for the note (inputted since must be same between the two notes)\n     */\n    fn new(\n        recipient: AztecAddress,\n        verifier_id: u8,\n        max_value: U128,\n        date_start: u32,\n        date_end: u32,\n        destination: str<31>,\n        spot: bool,\n        randomness: Field\n    ) -> Self {\n        let destination_compressed: CompressedString<1, 31> = CompressedString::from_string(destination);\n\n        // assert destination \n        if spot == false {\n            assert(date_end == 0, \"Date end must be zero if entitlement is recurring.\");\n            assert(date_start == 0, \"Date start must be zero if entitlement is recurring.\");\n            assert(destination == ZERO_DESTINATION, \"Destination must be empty if entitlement is recurring.\");\n        }\n\n        Self {\n            recipient,\n            verifier_id,\n            max_value,\n            date_start,\n            date_end,\n            destination: destination_compressed.value[0],\n            spot,\n            randomness,\n            header: NoteHeader::empty()\n        }\n    }\n\n    /**\n     * Return the destination of the entitlement\n     *\n     * @return the utf8 bytes of the destination\n     */\n    fn destination(self) -> [u8; 31] {\n        CompressedString::<1, 31> { value: [self.destination] }.to_bytes()\n    } \n\n    /**\n     * Constrain a given timestamp to be within the date range of the entitlement\n     *\n     * @param timestamp - the timestamp to check\n     */\n    fn check_date_range(self, timestamp: u32) {\n        debug_log_format(\"\\n\\n\\n\\nChecking date range:\\nStart: {0}\\nTimestamp:{1}\\nEnd:{2}\", [\n            self.date_start as Field,\n            timestamp as Field,\n            self.date_end as Field\n        ]);\n        assert(\n            (timestamp >= self.date_start) & (timestamp <= self.date_end),\n            \"Receipt is out of entitlement date range\"\n        );\n    }\n\n    /**\n     * Determine the amount to reimburse for a given claimed amount (lesser of the two)\n     *\n     * @param claimed - the amount claimed by the user\n     * @return the amount to reimburse\n     */\n    fn amount_to_reimburse(self, claimed: U128) -> Field {\n        if self.max_value >= claimed {\n            claimed.to_field()\n        } else {\n            self.max_value.to_field()\n        }\n    }\n\n    fn derive_shared_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            self.serialize_content(),\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Derives the nullifier for recurring notes\n     * @dev recurring notes are nullified for a scope (month) without destroying the ntoe\n     *      prove nullifier non-inclusion to use\n     *\n     * @param timestamp - the timestamp (month/ year) from the email receipt verifier\n     * @return - the month nullifier for the note\n     */\n    fn derive_recurring_nullifier(self, timestamp: Field) -> Field {\n        let serialized = self.serialize_content();\n        let mut inputs: [Field; ENTITLEMENT_NOTE_LENGTH + 1] = [0; ENTITLEMENT_NOTE_LENGTH + 1];\n        for i in 0..ENTITLEMENT_NOTE_LENGTH {\n            inputs[i] = serialized[i];\n        }\n        inputs[ENTITLEMENT_NOTE_LENGTH] = timestamp;\n        poseidon2_hash_with_separator(\n            inputs,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Assert that a recurring nullifier has not been used before and emits it\n     * @dev uses oracle check_nullifier_exists which is technically unsafe but will be caught by kernel\n     *\n     * @param context - the private context to use for the oracle call\n     * @param timestamp - the timestamp to check\n     */\n    fn check_and_emit_recurring_nullifier(self, context: &mut PrivateContext, timestamp: Field) {\n        // derive recurring nullifier for the month\n        let recurring_nullifier = self.derive_recurring_nullifier(timestamp);\n        // check the nullifier has not been emitted via oracle call (rely on kernel to actually constrain)\n        let recurring_nullifier_exists = unsafe { check_nullifier_exists(recurring_nullifier) };\n        assert(!recurring_nullifier_exists, \"Entitlement has already been claimed for this month\");\n        // emit the nullifier\n        context.push_nullifier(recurring_nullifier);\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a recurring claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     * @param timestamp - the timestamp of the claim\n     */\n    fn emit_recurring_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field, timestamp: Field) {\n        RecurringReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n            timestamp\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Emit an event to the admin notifying them of a spot claim\n     *\n     * @param context - the private execution context\n     * @param admin - the address of the admin of the escrow to notify\n     * @param amount - the amount claimed\n     */\n    fn emit_spot_claim(self, context: &mut PrivateContext, admin: AztecAddress, amount: Field) {\n        SpotReimbursementClaimed {\n            claimant: self.recipient,\n            amount,\n            verifier_id: self.verifier_id,\n        }.emit(\n            encode_and_encrypt_event(\n                context,\n                admin,\n                admin\n            )\n        );\n    }\n\n    /**\n     * Admin or recipient notifies counterparty that note has been nullified\n     * @dev admin emits event when revoking entitlement, recipient emits when claiming spot\n     * @dev clients must scan for these events to prune notes that are no longer valid\n     *\n     * @param context - the private execution context\n     * @param to - the address of the counterparty to notify\n     * @param from - the address of the notifier who nullified the entitlement note\n     */\n    fn emit_nullified(self, context: &mut PrivateContext, to: AztecAddress, from: AztecAddress) {\n        EntitlementNullified { randomness: self.randomness }.emit(\n            encode_and_encrypt_event(\n                context,\n                to,\n                to\n            )\n        );\n    }\n}\n"
    },
    "364": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "459": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/registry_definition.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\n\nglobal REGISTRY_DEFINITION_LENGTH: u32 = 3;\n\npub struct RegistryDefinition {\n    admin: AztecAddress,\n    usdc: AztecAddress,\n    escrow_contract_id: Field\n}\n\nimpl Serialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn serialize(self: Self) -> [Field; REGISTRY_DEFINITION_LENGTH] {\n        [self.admin.to_field(), self.usdc.to_field(), self.escrow_contract_id]\n    }\n}\n\nimpl Deserialize<REGISTRY_DEFINITION_LENGTH> for RegistryDefinition {\n    fn deserialize(fields: [Field; REGISTRY_DEFINITION_LENGTH]) -> Self {\n        RegistryDefinition {\n            admin: AztecAddress::from_field(fields[0]),\n            usdc: AztecAddress::from_field(fields[1]),\n            escrow_contract_id: fields[2]\n        }\n    }\n}\n\nimpl RegistryDefinition {\n    /**\n     * Create a new definition for a Z-Imburse escrow registry contract\n     *\n     * @param admin - The address that can add dkim keys to the registry\n     * @param usdc The address of the USDC token\n     * @param escrow_contract_id The ID of the escrow contract\n     * @return The new escrow registry definition\n     */\n    pub fn new(admin: AztecAddress, usdc: AztecAddress, escrow_contract_id: Field) -> Self {\n        RegistryDefinition { admin, usdc, escrow_contract_id }\n    }\n}\n"
    },
    "460": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/types/participant_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, traits::{Serialize, Deserialize}\n},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\nuse dep::compressed_string::CompressedString;\n\nglobal NAME_LENGTH: u32 = 60;\nglobal NAME_SERIALIZED_LENGTH: u32 = 2;\n\n#[note]\npub struct ParticipantNote {\n    address: AztecAddress,\n    name: [Field; 2],\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NullifiableNote for ParticipantNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for ParticipantNote {\n    // does not check for participant name\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl ParticipantNote {\n    pub fn new(address: AztecAddress, name: str<NAME_LENGTH>, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let name_serialized: CompressedString<NAME_SERIALIZED_LENGTH, NAME_LENGTH> = CompressedString::from_string(name);\n        ParticipantNote { address, name: name_serialized.value, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_name(self) -> [u8; NAME_LENGTH] {\n        CompressedString::<NAME_SERIALIZED_LENGTH, NAME_LENGTH> { value: self.name }.to_bytes()\n    }\n}\n"
    },
    "473": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/library_methods/dkim.nr",
      "source": "use aztec::{context::public_context::PublicContext, unencrypted_logs::unencrypted_event_emission::emit};\nuse crate::{\n    BULK_KEY_LENGTH,\n    ZImburseRegistry::{DKIMKeyHashRegistered, Storage}\n};\n\n/**\n * Register a single DKIM key\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hash - the hash of the DKIM key to add to the registry\n * @param verifier_id - the verifier ID to register the DKIM key to\n*/\n\npub fn register_dkim_key(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hash: Field, verifier_id: Field) {\n    let stored_id = storage.dkim_registry.at(dkim_key_hash).read();\n    assert(stored_id == 0, \"DKIM key has already been registered\");\n    storage.dkim_registry.at(dkim_key_hash).initialize(verifier_id);\n    emit(\n        context,\n        DKIMKeyHashRegistered { dkim_key_hash, verifier_id }\n    );\n}\n\n/**\n * Register multiple DKIM keys\n *\n * @param context - the contract context\n * @param storage - the contract storage\n * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n * @param verifier_ids - the verifier IDs to register the DKIM keys to\n */\npub fn register_dkim_keys_bulk(context: &mut PublicContext, storage: Storage<&mut PublicContext>, dkim_key_hashes: [Field; BULK_KEY_LENGTH], verifier_ids: [Field; BULK_KEY_LENGTH]) {\n    for i in 0..BULK_KEY_LENGTH {\n        if (verifier_ids[i] != 0) {\n            register_dkim_key(context, storage, dkim_key_hashes[i], verifier_ids[i]);\n        }\n    }\n}"
    },
    "474": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/z_imburse_registry/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\nmod library_methods;\nmod test;\nmod types;\n\npub global BULK_KEY_LENGTH: u32 = 4;\n\n#[aztec]\ncontract ZImburseRegistry {\n    use dep::aztec::{\n        prelude::{AztecAddress, PrivateSet, PublicImmutable, Map},\n        macros::{storage::storage, events::event, functions::{private, public, view, initializer, internal}},\n        note::{\n            note_viewer_options::NoteViewerOptions, note_getter_options::NoteGetterOptions,\n            note_getter::{get_notes, view_notes}, constants::MAX_NOTES_PER_PAGE\n        },\n        protocol_types::{\n            contract_instance::ContractInstance, address::partial_address::PartialAddress,\n            contract_class_id::ContractClassId, abis::function_selector::FunctionSelector, traits::Serialize\n        },\n        oracle::get_contract_instance::get_contract_instance,\n        keys::getters::get_public_keys, utils::comparison::Comparator,\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt_note_unconstrained, encode_and_encrypt_note},\n        unencrypted_logs::unencrypted_event_emission::emit\n    };\n    use std::{meta::derive, collections::bounded_vec::BoundedVec};\n    use dep::address_note::address_note::AddressNote;\n    use dep::zimburse_verifiers::constants::verifier_ids;\n    use dep::z_imburse_escrow::ZImburseEscrow;\n    use crate::{\n        library_methods::dkim::{register_dkim_key, register_dkim_keys_bulk},\n        types::{registry_definition::RegistryDefinition, participant_note::{ParticipantNote, NAME_LENGTH}},\n        BULK_KEY_LENGTH\n    };\n\n    #[derive(Serialize)]\n    #[event]\n    struct DKIMKeyHashRegistered {\n        dkim_key_hash: Field,\n        verifier_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        definition: PublicImmutable<RegistryDefinition, Context>,\n        escrow_registry: Map<AztecAddress, PublicImmutable<bool, Context>, Context>,\n        dkim_registry: Map<Field, PublicImmutable<Field, Context>, Context>,\n        managed_escrows: Map<AztecAddress, PrivateSet<AddressNote, Context>, Context>,\n        participants: Map<AztecAddress, PrivateSet<ParticipantNote, Context>, Context>,\n        participant_escrows: Map<AztecAddress, PrivateSet<AddressNote, Context>, Context>,\n    }\n\n    /**\n     * Initialize the Z-Imburse registry contract\n     *\n     * @param usdc - The address of the USDC token\n     * @param contract_class_id - The class ID of the escrow contract that all escrows must be instances of\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys to add to the registry\n     */\n    #[public]\n    #[initializer]\n    fn constructor(\n        usdc: AztecAddress,\n        escrow_contract_id: Field,\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // initialize the registry definition\n        let definition = RegistryDefinition::new(context.msg_sender(), usdc, escrow_contract_id);\n        storage.definition.initialize(definition);\n        // add any DKIM key hashes that were passed in at initialization\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Bulk registration of DKIM keys\n     *\n     * @param verifier_ids - the verifier IDs to register the DKIM keys to\n     * @param dkim_key_hashes - the hashes of the DKIM keys\n     */\n    #[public]\n    fn register_dkim_bulk(\n        verifier_ids: [Field; BULK_KEY_LENGTH],\n        dkim_key_hashes: [Field; BULK_KEY_LENGTH]\n    ) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        // bulk insert up to 50 dkim key hashes\n        register_dkim_keys_bulk(&mut context, storage, dkim_key_hashes, verifier_ids);\n    }\n\n    /**\n     * Register a DKIM key hash for email verifiers to anchor trust to\n     *\n     * @param verifier_id - the ID of the verifier\n     * @param dkim_key_hash - the hash of the DKIM key\n     */\n    #[public]\n    fn register_dkim(verifier_id: Field, dkim_key_hash: Field) {\n        // check that the sender is the admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not registry admin\");\n        // ensure that the dkim key has not already been registered\n        register_dkim_key(&mut context, storage, dkim_key_hash, verifier_id);\n    }\n\n    /**\n     * Check the authenticity and deployment status of an escrow contract and register it in the Z-Imburse registry\n     * @dev the header will not include the contract address and the contract \n     *\n     * @param escrow_contract - the address of the escrow contract to register\n     */\n    #[private]\n    fn register_escrow(escrow_contract: AztecAddress) {\n        // check the contract class ID by recomputing the contract address\n        let definition = storage.definition.read();\n        let contract_instance: ContractInstance = unsafe {\n            get_contract_instance(escrow_contract)\n        };\n        let computed_escrow_address = AztecAddress::compute(\n            contract_instance.public_keys,\n            PartialAddress::compute(\n                ContractClassId::from_field(definition.escrow_contract_id), // constrained here\n                contract_instance.salt,\n                contract_instance.initialization_hash,\n                contract_instance.deployer\n            )\n        );\n        assert(\n            computed_escrow_address == escrow_contract, \"Escrow contract class ID does not match expected class ID\"\n        );\n        // check that the contract has been deployed\n        // annoying that we can't use this in the deploy tx\n        context.historical_header.prove_contract_initialization(escrow_contract);\n\n        // check that the contract has not already been registered\n        let registration_status = storage.escrow_registry.at(escrow_contract).read();\n        assert(!registration_status, \"Escrow contract has already been registered\");\n\n        let escrow_params = ZImburseEscrow::at(escrow_contract).get_registration_params().view(&mut context);\n        assert(\n            escrow_params[0] == context.this_address(), \"Escrow contract registry does not match this contract\"\n        );\n        assert(escrow_params[1] == definition.usdc, \"Escrow contract USDC does not match registry USDC\");\n        assert(\n            escrow_params[2] == context.msg_sender(), \"Escrow contract admin does not match sender of message\"\n        );\n\n        // privately add the escrow contract to the list of managed escrows\n        let admin_keys = get_public_keys(context.msg_sender());\n        let mut escrow_note = AddressNote::new(escrow_contract, admin_keys.npk_m.hash());\n\n        // use unconstrained - why would you lie here\n        storage.managed_escrows.at(context.msg_sender()).insert(&mut escrow_note).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender()\n            )\n        );\n\n        // publicly add the escrow contract to the list of participant escrows\n        ZImburseRegistry::at(context.this_address()).set_contract_registered(escrow_contract).enqueue(&mut context);\n    }\n\n    /**\n     * Publicly set the contract registration status\n     *\n     * @param escrow_contract - the address of the escrow contract that has privately been constrained to be valid\n     */\n    #[public]\n    #[internal]\n    fn set_contract_registered(escrow_contract: AztecAddress) {\n        storage.escrow_registry.at(escrow_contract).initialize(true);\n    }\n\n    #[private]\n    fn check_and_register_participant(participant: AztecAddress, participant_name: str<60>, escrow: AztecAddress) -> bool {\n        // todo: switch to check that the sender is an escrow\n        // check that sender is admin\n        let admin = storage.definition.read().admin;\n        assert(admin == context.msg_sender(), \"Sender is not the registry admin\");\n        let is_registered = storage.escrow_registry.at(escrow).read();\n        assert(is_registered, \"Escrow contract is not registered\");\n        // check if the participant has already been registered\n        let options = NoteGetterOptions::new().select(AddressNote::properties().address, Comparator.EQ, participant).set_limit(1);\n        let participant_registered = storage.participants.at(escrow).get_notes(options).len() != 0;\n        // if the participant has not been registered, enqueue a private call to register the participant\n        // do this instead of if statement here to make adding first time expensive but cheap if already registered\n        if !participant_registered {\n            ZImburseRegistry::at(context.this_address()).register_participant(participant, participant_name, admin, escrow).call(&mut context);\n        }\n        // add escrow to participants private set\n        ZImburseRegistry::at(context.this_address()).register_participant_escrow(participant, escrow).call(&mut context);\n        participant_registered\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant(participant: AztecAddress, participant_name: str<60>, admin: AztecAddress, escrow: AztecAddress) {\n        let admin_keys = get_public_keys(admin);\n        // add the participant to the admin set of participants\n        let mut participant_note = ParticipantNote::new(participant, participant_name, admin_keys.npk_m.hash());\n        storage.participants.at(escrow).insert(&mut participant_note).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, admin, admin)\n        );\n    }\n\n    #[private]\n    #[internal]\n    fn register_participant_escrow(participant: AztecAddress, escrow: AztecAddress) {\n        let participant_keys = get_public_keys(participant);\n        // add escrow to the participant's set of escrows\n        let mut escrow_note = AddressNote::new(escrow, participant_keys.npk_m.hash());\n        storage.participant_escrows.at(participant).insert(&mut escrow_note).emit(\n            encode_and_encrypt_note(\n                &mut context,\n                participant,\n                participant\n            )\n        );\n    }\n\n    // todo: add ability to remove participant\n    // todo: add ability to remove participant escrows by looking up nullifications\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the public context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[public]\n    #[view]\n    fn check_dkim_key_hash_public(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /**\n     * Check which verifier type a DKIM key maps to using the DKIM key hash\n     * @dev constrained in the private context\n     * \n     * @param dkim_key_hash - the hash of the DKIM key\n     * @return verifier_id - the ID of the verifier (returns 0 if none)\n     */\n    #[private]\n    #[view]\n    fn check_dkim_key_hash_private(dkim_key_hash: Field) -> Field {\n        storage.dkim_registry.at(dkim_key_hash).read()\n    }\n\n    /** Get the class ID that all escrow contracts must match */\n    #[public]\n    #[view]\n    fn get_escrow_class_id() -> Field {\n        storage.definition.read().escrow_contract_id\n    }\n\n    /** Get the registration status of an escrow contract */\n    #[public]\n    #[view]\n    fn get_escrow_registry_status(escrow_contract: AztecAddress) -> bool {\n        storage.escrow_registry.at(escrow_contract).read()\n    }\n\n    /**\n     * Get a page of the list of escrows administrated by a given address (private)\n     *\n     * @param admin - the address of the admin\n     * @param offset - the index of the page to retrieve\n     * @return managed_escrows - the list of managed escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_managed_escrows(admin: AztecAddress, offset: u32) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.managed_escrows.at(admin).view_notes(options);\n        let mut managed_escrows = BoundedVec::new();\n        for i in 0..notes.len() {\n            managed_escrows.push(notes.get_unchecked(i).address);\n        }\n        (managed_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of escrows participated in by a given address (private)\n     *\n     * @param participant - the address of the participant\n     * @param offset - the index of the page to retrieve\n     * @return participant_escrows - the list of enrolled escrows\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained pub fn get_participant_escrows(\n        participant: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participant_escrows.at(participant).view_notes(options);\n        let mut participant_escrows: BoundedVec<AztecAddress, MAX_NOTES_PER_PAGE> = BoundedVec::new();\n        for i in 0..notes.len() {\n            participant_escrows.push(notes.get_unchecked(i).address);\n        }\n        (participant_escrows, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n\n    /**\n     * Get a page of the list of of participants in an escrow (private)\n     *\n     * @param admin - the address of the escrow\n     * @param offset - the index of the page to retrieve\n     * @return participants - the list of participating addresses\n     * @return page_limit_reached - whether the page limit has been reached (keep calling until this is true)\n     */\n    unconstrained fn get_participants(\n        escrow: AztecAddress,\n        offset: u32\n    ) -> pub (BoundedVec<ParticipantNote, MAX_NOTES_PER_PAGE>, bool) {\n        let mut options = NoteViewerOptions::new().set_offset(offset);\n        let notes = storage.participants.at(escrow).view_notes(options);\n        (notes, notes.len() == MAX_NOTES_PER_PAGE)\n    }\n}\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "60": {
      "path": "std/uint128.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"
    },
    "63": {
      "path": "/Users/ianbrighton/Documents/Mach34/zimburse/z-imburse/contracts/address_note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl Eq for AddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "69": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "72": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "75": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "76": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "79": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "83": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "85": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "90": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "91": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "93": {
      "path": "/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
